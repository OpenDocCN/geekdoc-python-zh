# Django 的多种环境设置

> 原文：<https://overiq.com/django-1-11/settings-for-multiple-environments-in-django/>

最后更新于 2020 年 7 月 27 日

* * *

## 多个设置文件

到目前为止，单个`settings.py`文件已经很好地为我们服务了。现在我们正在转移到生产环境，因此`settings.py`文件中的一些设置需要更改。最值得注意的是，我们将把`DEBUG`改为`False`，把`ALLOWED_HOSTS`改为生产服务器的 IP 或域名。

为了在不同的环境中高效地运行我们的 Django 项目，我们将把我们的单个`settings.py`分割成多个文件，每个文件代表一个特定环境的设置。

让我们首先将`settings.py`重命名为`old.settings.py`，并在 Django 配置目录(`djangobin/django_project/django_project`)中创建一个名为`settings`的目录。在`settings`目录内创建以下四个文件:

1.  `__init__.py`
2.  `base.py`
3.  `dev.py`
4.  `prod.py`。

`__init__.py`文件告诉 Python`settings`目录是一个包。`base.py`包含开发和生产环境通用的设置。`dev.py`和`prod.py`分别包含特定于开发和生产的设置。

此时，Django 配置目录应该如下所示:

```py
django_project/
├── celery.py
├── __init__.py
├── old.settings.py
├── settings
│   ├── __init__.py
│   ├── base.py
│   ├── dev.py
│   └── prod.py
├── urls.py
└── wsgi.py

1 directory, 9 files

```

`base.py`完整代码如下(变化突出显示):

**djangobin/django _ project/django _ project/settings/base . py**

```py
"""
Django settings for django_project project.

Generated by 'django-admin startproject' using Django 1.11.

For more information on this file, see
https://docs.djangoproject.com/en/1.11/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/1.11/ref/settings/
"""

import os, json
from django.core.exceptions import ImproperlyConfigured

with open(os.path.abspath("djangobin-secrets.json")) as f:
    secrets = json.loads(f.read())

def get_secret_setting(setting, secrets=secrets):
    try:
        return secrets[setting]
    except KeyError:
        raise ImproperlyConfigured("Set the {} setting".format(setting))

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/1.11/howto/deployment/checklist/

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.humanize',
    'django.contrib.flatpages',
    'django.contrib.sites',
    'django.contrib.sitemaps',
    'djangobin',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'django.middleware.common.BrokenLinkEmailsMiddleware',
]

ROOT_URLCONF = 'django_project.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            os.path.join(BASE_DIR, 'templates'),
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'djangobin.context_processors.recent_snippets',
            ],
        },
    },
]

WSGI_APPLICATION = 'django_project.wsgi.application'

# Password validation
# https://docs.djangoproject.com/en/1.11/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
# https://docs.djangoproject.com/en/1.11/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/1.11/howto/static-files/

STATIC_URL = '/static/'

STATIC_ROOT = os.path.join(BASE_DIR, 'staticfies')

MEDIA_ROOT  = os.path.join(BASE_DIR, 'media')

MEDIA_URL = '/media/'

LOGIN_REDIRECT_URL = 'djangobin:index'

LOGIN_URL = 'djangobin:login'

SITE_ID = 1

```

这里有几件事需要注意:

*   出于安全原因，您绝不能在代码中硬编码敏感配置，如 SECRET_KEY、数据库凭据或 API 密钥。此外，这些配置也会随着部署的不同而变化。如果您将这些配置放在代码中，那么每次迁移到新环境时，您都必须不断更新代码。

    在我们的例子中，我们已经将所有敏感配置存储在名为`djangobin-secrets.json`的 JSON 文件中，该文件位于项目根目录(`djangobin/django_project`)中。`djangobin-secrets.json`的内容是这样的:

    **决哥/决哥 _ 项目/决哥的秘密。json】**

    ```py
    {
      "SECRET_KEY": "rj3vhyKiDRNmth75sxJemvOuTy1Hy0ogeKgS9JP8Gp7dGDctfSMUuOt5QbSpsS9xAlvBMTXW3Z6VTODvvFcV3TmtrZUbGkHBcs8I",
      "DATABASE_NAME": "djangobin",
      "DATABASE_USER": "postgres",
      "DATABASE_PASSWORD": "pass",
      "DATABASE_HOST": "127.0.0.1",
      "DATABASE_PORT": "5432",
      "EMAIL_HOST_USER": "apikey",
      "EMAIL_HOST": "smtp.sendgrid.net",
      "EMAIL_HOST_PASSWORD": "IK.qQecgqph1Sa9TkOOljo8pA.5Xrj1oyJKuOGBbHnWFmdDe32G8XXojH45W1loxIsktqY3Nc",
      "EMAIL_PORT": "587",
      "EMAIL_USE_TLS": "True"
    }

    ```

    该文件包含 SECRET_KEY、数据库凭据和电子邮件凭据。如果您正在使用版本控制系统(您应该这样做)，请将此文件添加到`.gitignore`。

    要生成密钥，我们使用`django.utils.crypto`模块的`get_random_string()`功能:

    ```py
    >>>
    >>> from django.utils.crypto import get_random_string
    >>>
    >>> get_random_string(80)
    'ZEjwrGbwF9fjFAfTXTvz7LxXnCGUPOJyfPszrk2WHtbrbH3mgBeag2NWUueGYYiA7fTw36F50T2R3F5L'
    >>>

    ```

    在生产中，我们将使用 PostgreSQL 作为我们的数据库，并使用 SendGrid 发送电子邮件。

    如果您已经知道如何安装和配置 PostgreSQL，请继续填充数据库凭据，否则，请等到下一课，我们将了解如何安装和配置 PostgreSQL。

    要获取电子邮件凭据，请在发送网格上注册一个免费帐户。截至本文撰写之时，SendGrid 免费计划允许您每天发送 100 封电子邮件。

    回到`base.py`文件。

    在第 16-17 行，我们读取`djangobin-secrets.json`文件的内容，并将其作为字典存储在`secrets`变量中。

    如果你试图访问一个不存在于`secrets`目录中的配置，你会得到一个`KeyError`异常。可悲的是，这没有太大帮助。为了使调试更容易，我们定义了`get_secret_setting()`函数。如果在`secrets`目录中找不到该设置，则该方法返回调用它的设置值或一个`ImproperlyConfigured`异常。

*   我们的设置文件现在位于 Django 配置目录的一级深处。换句话说，`BASE_DIR`设置不再指向项目根目录(`djangobin/django_project/`)，而是指向 Django 配置目录(`djangobin/django_project/django_project`)。这有效地中断了模板、静态文件和媒体文件的路径。为此，在第 27 行中，我们为`os.path.dirname()`添加了一个额外的呼叫。这将确保`BASE_DIR`设置指向正确的基本目录。

*   在第 23 行，我们已经将`'django.middleware.common.BrokenLinkEmailsMiddleware'`添加到了`MIDDLEWARE`列表中。每当发生 HTTP 404 错误时，这将通过电子邮件发送给`MANAGERS`。

`dev.py`的代码如下:

**djangobin/django _ project/django _ project/settings/dev . py**

```py
from .base import *

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = '_5=#=+cl&lp@&ayps6ia0viff)^v$_wvutyyxca!xu0w6d2z3$'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}

EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

SERVER_EMAIL = 'infooveriq@gmail.com'
DEFAULT_FROM_EMAIL = SERVER_EMAIL

ADMINS = (
    ('OverIQ', 'admin@overiq.com'),
)

MANAGERS = (
    ('OverIQ', 'manager@overiq.com'),
)

```

这里没什么花哨的，这个`dev.py`只是包含开发的具体设置。要从`base.py`导入常用设置，我们使用`from .base import *`语句(第 1 行)。请注意，我们特意对一些敏感的配置进行了硬编码，因为这样可以简化开发过程。然而`prod.py`文件却不是这样。

**djangobin/django _ project/django _ project/settings/prod . py**

```py
import os
from .base import *

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = get_secret_setting('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = False

ALLOWED_HOSTS = ["*"]

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': get_secret_setting('DATABASE_NAME'),
        'USER': get_secret_setting('DATABASE_USER'),
        'PASSWORD': get_secret_setting('DATABASE_PASSWORD'),
        'HOST': get_secret_setting('DATABASE_HOST'),
        'PORT': get_secret_setting('DATABASE_PORT'),
    }
}

STATIC_ROOT = 'static'

EMAIL_HOST_USER = get_secret_setting('EMAIL_HOST_USER')
EMAIL_HOST = get_secret_setting('EMAIL_HOST')
EMAIL_HOST_PASSWORD = get_secret_setting('EMAIL_HOST_PASSWORD')
EMAIL_PORT = get_secret_setting('EMAIL_PORT')
EMAIL_USE_TLS = True
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'

DEFAULT_FROM_EMAIL = 'support@overiq.com'
SERVER_EMAIL = 'no-reply@overiq.com'

ADMINS = (
    ('OverIQ', 'infooveriq@gmail.com'),
)

MANAGERS = (
    ('OverIQ', 'manager@overiq.com'),
)

```

`prod.py`几乎与`dev.py`相似，但它定义了特定于生产环境的设置。

这里有几件事需要注意:

1.  与`dev.py`不同，在`prod.py`中，我们通过`base.py`文件中定义的`get_secret_setting()`函数加载敏感配置。

2.  在第 10 行，我们将`ALLOWED_HOSTS`设置为`[*]`。`ALLOWED_HOSTS`设置是一项安全功能，用于验证请求是否来自允许的域。它指定了一个代表这个 Django 项目可以服务的主机/域名的字符串列表。默认情况下，它被设置为空列表。一旦你进入生产，你需要设置它，否则你将得到 500 内部服务器错误。

    如果您拥有`example.com`并希望允许来自`example.com`或`www.example.com`的请求，那么您需要将`ALLOWED_HOSTS`设置为:

    ```py
    ALLOWED_HOSTS =  ['example.com', 'www.example.com']

    ```

    如果您想允许来自`example.com`及其所有子域的请求，那么使用句点作为子域通配符。例如:

    ```py
    ALLOWED_HOSTS =  ['.example.com']

    ```

    要允许 Django 接受来自任何域的请求，请将`ALLOWED_HOSTS`设置为“*”。

    ```py
    ALLOWED_HOSTS =  ['*']

    ```

    但是，在实际部署中，您应该将此设置仅限于您希望允许的主机/域。

3.  在第 15-19 行，我们定义了连接到 PostgreSQL 数据库的配置。

4.  在第 25-28 行，我们定义了通过发送网格发送电子邮件所需的设置。

## 运行项目

我们已经重构了很多代码。现在让我们看看如何使用这个新设置与我们的 Django 项目进行交互。

在终端执行`./manage.py`文件，会得到如下错误:

```py
$ ./manage.py
...
Note that only Django core commands are listed as settings are not properly configured (error: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.).

```

如果您尝试运行`runserver`或`shell`命令，您将会得到相同的错误(只是措辞不同)。

```py
$ ./manage.py runserver
...  
django.core.exceptions.ImproperlyConfigured: Requested setting DEBUG, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.

```

问题是 Django 不知道我们的设置文件在哪里。我们可以使用`--setting`选项从命令行指定设置文件的位置。

```py
$  ./manage.py runserver --settings=django_project.settings.dev
Performing system checks...

System check identified no issues (0 silenced).
June 04, 2018 - 06:37:16
Django version 1.11, using settings 'django_project.settings.dev'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.

```

请注意，每次执行`manage.py`脚本时，您都需要指定`--settings`选项。例如:

```py
$ ./manage.py shell --settings=django_project.settings.dev

```

```py
$ ./manage.py makemigrations --settings=django_project.settings.dev

```

每次执行`./manage.py`文件时指定`--settings`选项会很快变得乏味。或者，您可以将`DJANGO_SETTINGS_MODULE`环境变量设置为所需的设置文件，如下所示:

```py
$ export DJANGO_SETTINGS_MODULE=django_project.settings.dev

```

您现在可以像往常一样执行`./manage.py`，而无需指定设置文件的路径。

```py
$ ./manage.py runserver

```

`DJANGO_SETTINGS_MODULE`变量将一直存在，直到 shell 会话处于活动状态。不幸的是，如果你开始一个新的 Shell，你将不得不再次设置`DJANGO_SETTINGS_MODULE`。

更好的方法是修改 virtualenv 的`activate`脚本，并在激活 virtualenv 时设置`DJANGO_SETTINGS_MODULE`环境变量，在禁用 virtualenv 时取消设置。

打开`activate`脚本，修改如下:

**djangobin/env/bin/激活**

```py
# This file must be used with "source bin/activate" *from bash*
# you cannot run it directly

deactivate () {
    unset -f pydoc >/dev/null 2>&1

    # reset old environment variables
    # ! [ -z ${VAR+_} ] returns true if VAR is declared at all
    if ! [ -z "${_OLD_VIRTUAL_PATH+_}" ] ; then
        PATH="$_OLD_VIRTUAL_PATH"
        export PATH
        unset _OLD_VIRTUAL_PATH
    fi
    if ! [ -z "${_OLD_VIRTUAL_PYTHONHOME+_}" ] ; then
        PYTHONHOME="$_OLD_VIRTUAL_PYTHONHOME"
        export PYTHONHOME
        unset _OLD_VIRTUAL_PYTHONHOME
    fi

    # This should detect bash and zsh, which have a hash command that must
    # be called to get it to forget past commands.  Without forgetting
    # past commands the $PATH changes we made may not be respected
    if [ -n "${BASH-}" ] || [ -n "${ZSH_VERSION-}" ] ; then
        hash -r 2>/dev/null
    fi

    if ! [ -z "${_OLD_VIRTUAL_PS1+_}" ] ; then
        PS1="$_OLD_VIRTUAL_PS1"
        export PS1
        unset _OLD_VIRTUAL_PS1
    fi

    unset VIRTUAL_ENV
    if [ ! "${1-}" = "nondestructive" ] ; then
    # Self destruct!
        unset -f deactivate
    fi

    unset DJANGO_SETTINGS_MODULE
}

# unset irrelevant variables
deactivate nondestructive

VIRTUAL_ENV="/home/pp/django-1.11/djangobin/env"
export VIRTUAL_ENV

_OLD_VIRTUAL_PATH="$PATH"
PATH="$VIRTUAL_ENV/bin:$PATH"
export PATH

# unset PYTHONHOME if set
if ! [ -z "${PYTHONHOME+_}" ] ; then
    _OLD_VIRTUAL_PYTHONHOME="$PYTHONHOME"
    unset PYTHONHOME
fi

if [ -z "${VIRTUAL_ENV_DISABLE_PROMPT-}" ] ; then
    _OLD_VIRTUAL_PS1="$PS1"
    if [ "x" != x ] ; then
        PS1="$PS1"
    else
        PS1="(`basename \"$VIRTUAL_ENV\"`) $PS1"
    fi
    export PS1
fi

# Make sure to unalias pydoc if it's already there
alias pydoc 2>/dev/null >/dev/null && unalias pydoc

pydoc () {
    python -m pydoc "$@"
}

# This should detect bash and zsh, which have a hash command that must
# be called to get it to forget past commands.  Without forgetting
# past commands the $PATH changes we made may not be respected
if [ -n "${BASH-}" ] || [ -n "${ZSH_VERSION-}" ] ; then
    hash -r 2>/dev/null
fi

export DJANGO_SETTINGS_MODULE=django_project.settings.dev

```

启动新 Shell，激活虚拟环境，使用`echo`命令检查`DJANGO_SETTINGS_MODULE`环境变量的存在:

```py
$ echo $DJANGO_SETTINGS_MODULE 
django_project.settings.dev

```

不出所料，`DJANGO_SETTINGS_MODULE`环境变量可用。

现在，您可以运行`./manage.py`文件，而无需设置任何环境变量或指定`--settings`选项

启动 Django 开发服务器，确保一切都按预期运行。

```py
$ ./manage.py runserver

```

输出应该如下所示:

```py
Performing system checks...

System check identified no issues (0 silenced).
May 17, 2018 - 14:51:37
Django version 1.11, using settings 'django_project.settings.dev'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.

```

`DJANGO_SETTINGS_MODULE`变量将在停用虚拟环境时自动移除。

## 创建需求文件

需求文件是一个包含项目依赖关系的简单文本文件。我们使用需求文件来安装项目依赖项。

要创建需求文件，请执行以下命令:

```py
$ pip freeze > requirements.txt

```

我们的 DjangoBin 项目现在已经完成。在下一课中，我们将学习如何将其部署到 DigitalOcean 服务器。

* * *

* * *