# 第二章 - 清洁架构的组成部分

> [`www.thedigitalcatbooks.com/pycabook-chapter-02/`](https://www.thedigitalcatbooks.com/pycabook-chapter-02/)

## 清洁架构的组成部分

> 等一下，等一下，医生，你是说您用一辆德洛瑞安车造了一台时光机吗？
> 
> 《回到未来》，1985 年

在本章中，我将分析一组被称为“清洁架构”的软件设计原则。虽然这个特定的名称是由罗伯特·马丁提出的，但它所推动的概念是软件工程的一部分，并且几十年来已经成功应用。

在我们深入探讨它们的可能实现之前，这是本书的核心，我们需要更深入地分析清洁架构的结构以及遵循该架构设计的系统中可以找到的组件。

### 分而治之

一个设计良好的系统的主要目标之一是达到控制。从这个角度来看，软件系统与一个人类工作社区，如办公室或工厂，没有区别。在这样的环境中，有工人交换数据或物理对象以创造和交付最终产品，无论是物体还是服务。工人需要信息和资源来完成自己的工作，但最重要的是，他们需要对自己的责任有一个清晰的了解。

虽然在人类社会我们重视主动性和创造力，然而，在一个软件系统这样的机器中，组件不应该能够做在设计系统时没有明确说明的事情。软件不是活物，尽管人工智能在近年来的成就令人印象深刻，但我仍然相信人类身上有一种火花是代码无法单独复制的。

无论我们对人工智能的看法如何，我认为我们都会同意，如果责任明确，系统的工作效果会更好。无论是处理软件还是人类社区，对组件可以或应该做什么不清楚总是危险的，因为影响和控制区域自然会重叠。这可能导致各种问题，从简单的低效到完全的僵局。

在系统中增加秩序和控制的一个好方法是将其拆分为子系统，在它们之间建立清晰和刚性的边界，以规范数据交换。这是政治概念（分而治之）的扩展，该概念指出，统治一组相互连接的小系统比统治一个单一的复杂系统要简单。

在我们上一章设计的系统中，组件在被调用时期望接收的内容总是清晰的，而且以破坏系统结构的方式交换数据是不可能的（或者至少是被禁止的）。

你必须记住，软件系统并不完全像工厂或办公室。每当讨论机器时，我们必须考虑它们的工作方式（运行时）以及它们被构建或将要修改的方式（开发时）。原则上，计算机并不关心数据从哪里来以及到哪里去。另一方面，人类需要构建和维护系统，需要清晰地了解数据流，以避免引入错误或降低性能。

### 数据类型

在系统中，数据类型扮演着重要的角色，即我们封装和传输信息的方式。特别是，当我们讨论软件系统时，我们需要确保不同系统之间共享的类型为所有系统所知。数据类型和格式的知识实际上是一种耦合。想想人类语言：如果你必须与听众交谈，你必须使用他们理解的语言，这使你与听众耦合。这本书（暂定）是用英语写的，这意味着我与英语读者耦合。如果世界上所有的英语使用者突然决定忘记这种语言，并用意大利语来代替，我应该从头开始写这本书（但肯定要少费劲）。

因此，当我们考虑软件系统时，我们需要了解哪个部分定义了类型和数据格式（“语言”），并确保产生的依赖关系不会妨碍实施者。在前一章中，我们发现系统中有一些组件应该被视为最重要的，并代表系统的核心（用例），而其他组件则不那么中心，通常被认为是实现细节。再次提醒，称它们为“细节”并不意味着它们不重要，或者它们是容易实现的，而是用不同的实现来替换它们不会影响系统的核心（业务逻辑）。

因此，存在一个由它们之间的依赖关系产生的组件层次结构。一些组件在设计初期就定义了，并且不依赖于任何其他组件，而其他组件则会在之后出现并依赖于它们。当涉及到数据类型时，产生的依赖关系不能打破这个层次结构，因为这会重新引入我们想要避免的组件之间的耦合。

让我们回到最初的例子，一个从批发商那里购买商品，将它们陈列在货架上，然后卖给顾客的商店。这里有两个组件之间存在明显的依赖关系：称为“商店”的组件依赖于称为“批发商”的组件，因为数据（“商品”）从后者流向前者。反过来，商店货架的大小取决于商品的大小（类型），这是由批发商定义的，这遵循我们已建立的依赖关系。

如果物品的大小由商店定义，那么突然之间就会出现另一个与我们已建立的依赖相反的依赖，使得批发依赖于商店。请注意，当涉及到软件系统时，这并不是一个循环依赖，因为第一个是概念依赖，而第二个是在编译时在语言级别发生的。无论如何，有两个相反的依赖肯定很令人困惑，并且使得替换“外围”组件，如商店变得困难。

### 主要的四层

整洁架构试图通过分层方法同时捕捉组件的*概念层次结构*和*类型层次结构*。在整洁架构中，系统的组件被分类并属于特定的层，具有关于属于同一层或不同层的组件之间通信的规则。特别是，整洁架构是一个球形结构，内部（低级）层完全被外部（高级）层包围，前者对后者的存在一无所知。

![width=60%](img/49e9c9db3a93c2df1483766a867e48f1.png)整洁架构的基本层

记住，在计算机科学中，“低级”和“高级”这两个词几乎总是指抽象级别，而不是系统组件的重要性。系统的每个部分都很重要，否则它就不会存在。

让我们看看图中展示的主要层，同时记住，特定的实现可能需要创建新的层或将其中一些层拆分为多个层。

#### 实体

这个整洁架构的层包含了对领域模型的表示，即系统需要与之交互的任何东西，并且足够复杂，需要特定的表示。例如，Python 中的字符串是复杂且功能强大的对象。它们提供了许多内置方法，所以通常，为它们创建领域模型是无用的。然而，如果你的项目是一个分析中世纪手稿的工具，那么你可能需要隔离句子及其特征，在这种情况下，定义一个特定的实体可能是合理的。

![width=60%](img/2ccf8c8658b7ed391c5abc9d583d25d8.png)实体

由于我们使用 Python，这个层可能包含类，其中包含简化与它们交互的方法。然而，理解这个层中的模型与 Django 等框架的常规模型不同非常重要。这些模型与存储系统没有连接，因此不能直接使用它们自己的方法保存或查询，它们不包含将自身导出到 JSON 字符串的方法，它们与任何表示层都没有连接。它们是所谓的轻量级模型。

这是最内层。实体由于生活在同一层，因此它们相互了解，因此架构允许它们直接交互。这意味着代表实体的 Python 类之一可以直接使用另一个，实例化它并调用其方法。尽管如此，实体对生活在外层的任何事物一无所知。它们不能调用数据库，访问由表示框架提供的访问方法，或实例化用例。

实体层为外层提供了一个坚实的类型基础，外层可以使用它来交换数据，它们可以被认为是您业务的词汇表。

#### 用例

正如我们之前所说的，一个干净系统的最重要部分是使用用例，因为它们实现了业务规则，这是系统本身存在的核心原因。用例是在您的应用程序中发生的流程，您使用领域模型来处理真实数据。例子可以是用户登录，执行具有特定过滤器的搜索，或者当用户想要购买购物车中的内容时发生的银行交易。

![width=60%](img/1fc8a1768485caa478e1c21f3ecf06b1.png)用例

用例应该尽可能小。将小动作隔离到单独的用例中非常重要，因为这使得整个系统更容易测试、理解和维护。用例可以完全访问实体层，因此它们可以直接实例化和使用它们。它们也可以相互调用，并且创建由简单用例组成的复杂用例是常见的。

#### 网关

这一层包含定义外部系统接口的组件，即对不实现业务规则的服务的通用访问模型。经典的例子是数据存储，其内部细节在不同的实现中可能非常不同。这些实现共享一个公共接口，否则它们就不会是同一概念的实施，网关的任务就是暴露它。

![width=60%](img/30c518a668581fa350b5612b9aedb163.png)网关

如果您回想起我一开始给出的简单例子，这就是数据库接口所在的位置。网关可以访问实体，因此接口可以自由接收和返回在该层定义的类型对象，就像它们可以自由访问用例一样。然而，网关用于屏蔽外部系统的实现，因此网关很少调用用例，因为这可以通过外部系统本身完成。网关层与外部系统层紧密相连，这就是为什么两者之间用虚线分开的原因。

#### 外部系统

架构的这一部分由实现上一层定义的接口的组件组成。同一个接口可能由一个或多个具体组件实现，因为您的系统可能需要同时支持该接口的多个实现。例如，您可能希望通过 HTTP API 和命令行界面公开一些用例，或者根据某些配置值提供对不同类型存储的支持。

![宽度=60%](img/86c76130c19d591cc7f3afa3af33a4cf.png)外部系统

请记住，“外部”这个形容词并不总是意味着系统是由他人开发的，或者它是一个像 Web 框架或数据库这样的复杂系统。这个词具有拓扑意义，表明我们正在讨论的系统是架构核心的边缘，也就是说它不实现业务逻辑。因此，我们可能希望使用内部开发的短信系统向某个服务的客户发送通知，但这又仅仅是一个表示层，除非我们的业务专门围绕创建通知系统展开。

外部系统可以完全访问网关、用例和实体。虽然理解与网关的关系比较容易，因为网关是为了包装特定的系统而创建的，但对于外部系统应该对用例和实体做什么可能不太清楚。至于用例，外部系统通常是触发它们的系统的一部分，是用户运行业务逻辑的方式。用户点击按钮、访问 URL 或运行命令，都是与直接运行用例的外部系统交互的典型例子。至于实体，外部系统可以直接处理它们，例如在 JSON 有效负载中返回它们，或将输入数据映射到领域模型中。

我想指出用例使用的外部系统和想要调用用例的外部系统之间的区别。在前一种情况下，通信的方向是外向的，我们知道在干净的架构中，没有接口我们不能向外传递。因此，当我们从用例访问外部系统时，我们总是需要一个接口。相反，当外部系统想要调用用例时，通信的方向是内向的，这是直接允许的，因为外部层可以完全访问内部层。

实际上，这转化为两种极端情况，数据库和 Web 框架得到了很好的体现。当用例访问存储系统时，两者之间应该有松散的耦合，这就是为什么我们用接口包装存储并在用例中假设。相反，当 Web 框架调用用例时，端点的代码不需要任何接口来访问它。

### 层之间的通信

在这个架构中，层越深，内容就越抽象。内层包含业务概念的表示，而外层包含关于现实生活实现的特定细节。同一层中存在的元素之间的通信是不受限制的，但当你想要与分配给其他层的元素通信时，你必须遵循一个简单的规则。这个规则是清洁架构中最重要的东西，可能是清洁架构本身的核心理念。

**黄金法则：内部使用简单结构进行交流，外部通过接口进行交流。**

你的元素应该向内部交流，也就是说，通过基本结构（即实体和编程语言提供的所有内容）将数据传递给更抽象的元素。

![宽度=60%](img/4a280b20aebe60dc2f41880546b9f700.png)清洁架构的黄金法则

你的元素应该使用接口向外交流，也就是说，只使用组件的预期 API，而不引用特定的实现。当创建外部层时，那里的元素将自动连接到这些接口并提供实际实现。

### API 和灰色地带

在清洁架构中，API 这个词至关重要。内层的每个元素都可以通过 API 访问，即一个固定的^([1])入口点集合（方法或对象）。

层之间的分离以及每一层的具体内容并不总是固定不变的。一个设计良好的系统还应该应对实际世界的问题，例如性能或其他特定需求。在设计架构时，了解“什么在哪里以及为什么”非常重要，当你“弯曲”规则时，这一点尤为重要。许多问题没有黑白分明的答案，许多决策都是“灰色地带”，也就是说，你必须证明为什么将某物放在特定的位置。

然而，记住，你不应该打破清洁架构的*结构*，并且对数据流要特别严格。如果你打破了数据流，你基本上就使整个结构无效。你应该尽可能地不引入基于数据流中断的解决方案，但现实地说，如果这样做能节省金钱，那就做吧。

如果你这样做，你的代码和文档中应该有一个巨大的警告，解释你为什么这样做。如果你访问了打破接口范式的外部层，通常是因为一些性能问题，因为分层结构可能会在元素之间的通信中增加一些开销。你应该清楚地告诉其他程序员这种情况发生了，因为如果有人想用不同的东西替换外部层，他们应该知道存在直接访问，这是特定于实现的。

为了举例，假设一个用例是通过接口访问存储层，但结果发现这太慢了。然后你决定直接访问你正在使用的特定数据库的 API，但这样做打破了数据流，因为现在内部层（用例）正在访问外部层（外部接口）。如果将来有人想用不同的数据库替换你正在使用的数据库，他们必须意识到这一点，因为新的数据库可能不会提供相同的 API 入口点以及相同的数据。

如果你一直打破数据流，可能你应该考虑移除一层抽象，合并你正在链接的两个层。

1

在这里，“固定”意味着“在每种实现中都是相同的”。显然，API 可能会随时间而改变。
