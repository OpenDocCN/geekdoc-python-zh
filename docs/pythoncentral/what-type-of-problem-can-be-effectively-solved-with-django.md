# 用 Django 可以有效地解决什么类型的问题？

> 原文：<https://www.pythoncentral.io/what-type-of-problem-can-be-effectively-solved-with-django/>

[![django](img/9bfab033e5edde8cd5eb7647fcb35f84.png)](https://www.pythoncentral.io/wp-content/uploads/2022/11/faisal-g0RtZc1IBtU-unsplash.jpg)

Django 是编写 web 应用程序时使用的框架工具。开始时，你会注意到它的简单，这有助于事情进展得更快。

随着您添加现实世界的约束，数据模型变得更加复杂。你会发现你最初的策略不再有效。

随着您对问题了解的越来越多，请调整您的代码。Django 可能很快，但有时你最终会写出很慢的代码。

可能很难知道从哪里开始，尤其是当你的专业项目非常广泛的时候。在这种情况下，这是与 Django 发展公司合作的最佳时机，以获得你所要求的最好的专业结果。

请继续阅读本文，了解通过坚持不懈的努力、关注和一些调整，可以解决哪些常见的 Django 问题。学习阅读代码错误并找到它们的解决方案需要时间和练习。

## Django 安装和使用中的常见问题

处理数据时，从数据位置开始调试，然后转到数据存储的界面，最后是视图和报告。

大多数性能问题都是由于试图访问数据库造成的。幸运的是，Django 详细总结了如何优化数据库。您只需从一开始就应用一个好的策略来高效地构建您的代码。

在寻求优化时，您的代码可能会变得不清晰。当面临清晰代码和性能提升之间的选择时，你能理解的代码应该放在第一位。你需要[练习](https://www.pythoncentral.io/how-long-does-it-take-to-learn-python/)才能明白要改变什么。

### 工具

要解决问题，首先要识别它。有几件事你可以做。首先，理解 *Django.db.connection，*在当前连接中您有哪些查询。进入 shell 并使用命令 *shell_plus* 和标志*–print-SQL*on。

您的调试环境应该在后台运行中间件。它记录查询并引起对重复的注意。你可以在 Django-debug-toolbar 上找到这些信息。

### 意外查询

例如，在检查作者的 id 时，您本能地想要使用 author 字段。如果不需要 author 对象，可能就白做了一次额外的查询。万一以后用了作者值，也没关系。

通过使用列*名称属性*，使事情变得简单明了。

### 大小和存在命令

理解何时使用*存在*和 c *计数*需要时间。当使用 Django 的 queryset 中的数据时，使用 Python 操作。当不使用数据时，请改用 queryset 方法。

在寻找 queryset 的大小时，做同样的事情。当你需要尺寸时使用*计数*，当你使用查询设置时使用*长度*。

## 如何得到你需要的东西

Django 固有地请求表中的所有列，并在 Python 项目中填充这些列。当您只需要表中列的子集时，使用*值*或*值列表*。通过这样做，您不必创建复杂的 python 对象。相反，您可以使用字典、值或元组。

## 如何处理多行

Django 捕捉在计算 querysets 时获得的值。如果您多次重复 queryset，它就可以工作，但是如果您只循环一次，它就不能很好地运行。

Django 将书籍加载到内存中，并遍历每一本书。您希望它保持一个 SQL 连接打开并读取每一行，然后在转到下一行之前调用 *do_stuff* 。在这种情况下，迭代器可以帮助您。迭代器允许你写线性数据。它很棒，因为当与*值*和*值列表*结合使用时，它在内存中保留的信息量最少。

迭代器在迁移信息并且必须改变表中的行时也很有帮助。它节省时间，避免了停机时间。

### 关系问题

Django 让您可以自然地与关系数据库交互。您可以随意使用精确且语义清晰的代码。因为 Django 使用延迟加载，所以它只在您需要时才加载作者。虽然这是一个积极的方面，但它可能会导致大量的查询。

Django 认识到了这个问题。它提供了两种解决方案:*预取 _ 相关*和*选择 _ 相关*。当用 Django 编写应用程序时，了解和使用它们是必不可少的。

### 当不使用*时选择 _ 相关*

一直使用 *select_related* 很有诱惑力，但有时并不合适。这可能意味着更多的工作不值得做。该命令为查询的每一行创建新的实例，这会消耗内存。当您查询 *select_related* 的相同值时，使用 querysets。另一种方法是翻转您的查询，使用*预取相关的*。

请记住，使用查询集时，您的更改会传播到查询集中的其他行。而 *select_related* 就不是这样了。

## 结论

Django 中出现的每个问题都至少有一个解决方案。您应该关注的是清晰的代码，以便以后进行优化。当你继续开发你的应用程序时，保持良好的卫生习惯，使用干净清晰的代码。

在 Python 文件中使用 Django 时，通过尝试遵循文档来避免错误。从养成使用资源的好习惯开始你的旅程，因为你以后会享受到好处。