# 想要获得高薪工作，你应该知道的几个面试问题

> 原文：<https://www.pythoncentral.io/top-python-interview-questions-you-should-know-the-answer-to-for-a-well-paying-job/>

在 Indeed.com 有超过 [38，000 个招聘信息](https://www.indeed.com/q-python-programmer-l-United-States-jobs.html?vjk=cc10e115d1ed386e) 对于 Python 开发者来说，很明显这些知识渊博的编程专业人士需求量很大。此外，根据 PYPL 流行指数，Python 仍然高居榜首，占据了[28.52%](https://pypl.github.io/PYPL.html)的市场份额。

Python 被用在许多不同的编程场景中，并被世界上最大的公司所利用，它将继续存在，一些业内人士甚至认为它是编程语言的未来。

尽管如此，不管你有多有经验或知识多渊博，面试一个开发人员的角色都是令人紧张的。

面试官希望应聘者对编程概念有深刻的理解，并表现出解决复杂问题的能力。虽然对 Python 开发人员的需求很高，但是被雇佣也不是件容易的事。

如果你很快就要参加 Python 面试，这份顶级 Python 面试问题列表将有助于确保你在开始面试前已经覆盖了所有的基础。

在这篇文章中，我们涵盖了从面向新生的 Python 面试问题到高级 Python 编程面试问题的所有内容。

## **Python 新鲜人面试问题**

### **#1 什么是 Python？它有什么好处？**

Python 是一种解释型通用编程语言，以其高级语法而闻名。在合适的库的帮助下，它可以用来构建许多不同种类的应用程序。此外，Python 允许面向对象编程，并拥有自动内存管理等特性。

这些品质使这种语言成为构建解决现实世界问题的应用程序的理想语言。

Python 提供了两个主要的好处:

1.  Python 有一个易读易懂的语法，便于学习和调试。这种简单性有助于降低企业的程序维护成本。此外，开发人员可以使用 Python 编写脚本，第三方包支持为开发人员提供了重用代码的灵活性。
2.  Python 是动态类型的，加上高级数据结构，使其成为快速应用开发的首选语言。

### **#2“动态类型化”是什么意思？**

在编程中，“键入”指的是类型检查。类型检查是确保开发人员想要执行的操作的数据类型相互兼容的过程。

Python 是一种强类型语言，这意味着代码如:

```py
"1"+2
```

会抛出一个类型错误。代码中的 1 是一个字符串，而 2 是一个数字，Python 不隐式转换数据类型。换句话说，强类型语言不允许类型强制。

相比之下，使用弱类型语言(如 JavaScript)运行相同的代码将输出字符串“12”

类型检查分两个阶段进行:

*   **静态:** 程序执行前检查数据类型。
*   **动态:** 程序执行过程中检查数据类型。

由于 Python 是一种解释型语言，程序语句是一行一行地动态执行的。这使得 Python 成为一种动态类型语言。

### **#3 什么是解释语言？**

解释编程语言是按顺序一行接一行地执行语句的语言。运行程序不需要编译。除了 Python，JavaScript、PHP 和 Ruby 等语言也是解释型语言。

### **#4 人教版 8 是什么意思，是什么让它变得重要？**

Python 增强提案(PEP)是由该语言的开发者向社区提供的设计文档。除了提供设计信息，这些文档还描述了该语言的新特性及其内部流程。

PEP 8 是一个特定的 PEP 文档，概述了 Python 的风格指南。开源社区的开发者需要在他们的项目中遵循这些指南，使得 PEP 8 成为每个开发者的主要指南之一。

### **# 5 Python 中的“作用域”是什么意思？**

对象的作用域是对象保持相关的代码块。每个 Python 对象都有一个作用域，Python 的名称空间唯一地标识了程序中的所有对象。

除了对象，名称空间还有一个作用域，程序员可以在其作用域内使用名称空间中的对象，而无需添加前缀。在代码执行期间，范围是在不同的级别上定义的。不同的范围是:

*   局部作用域，指函数中可访问的局部对象。
*   全局范围，指的是在整个执行过程中可访问的对象。
*   模块级作用域，指当前模块中可访问的对象。
*   最外层的作用域，指程序中可以使用的所有内置对象。Python 最后搜索最外层范围内的对象，这样它就可以找到引用的名称。

需要注意的是，使用内置关键字，如 **全局** ，可以将局部范围对象视为全局范围对象。

### **#6 什么是元组和列表？它们有什么不同？**

在 Python 中，列表和元组都是序列数据类型，这意味着它们存储对象的集合。程序员可以在列表和元组中存储不同的数据类型。

程序员在定义列表时，会使用方括号:

```py
mylist = ["John", 7, 0.38]
```

另一方面，程序员在定义元组时使用括号:

```py
mytuple = ("Andy", 3, 0.29)
```

列表和元组的主要区别在于列表是可变对象，而元组是不可变对象。

换句话说，程序员可以通过添加或删除数据来修改列表。然而，一旦元组被声明，程序员就不能以任何方式修改它。

### **# 7 Python 内置的数据类型有哪些？**

Python 包括几种数据类型；然而，当声明任何类型的变量时，不需要定义数据类型。也就是说，理解 Python 中的数据类型是至关重要的，因为忽略数据类型之间的兼容性会导致程序执行过程中的类型错误。

使用 type()和 isInstance()之类的函数，可以检查变量中存储了什么类型的数据。

Python 中有许多不同类别的对象:

#### **无类型**

none 数据类型在 Python 中定义了空值。它被设计用作布尔等式运算。它使用“None”关键字定义。

#### **数字类型**

整数、浮点数和复数是 Python 中可用的三种数字数据类型。布尔数据类型被认为是整数子类型。

| **类名** | **使用** |
| int | 将整数文字存储为整数 |
| 浮动 | 存储带小数或指数的文字和浮点数 |
| 复杂 | 以 A + Bi 形式存储复数；属性包括 real 和 imag |
| bool | 存储真值或假值 |

可以使用标准库中的“分数”和“小数”类分别存储有理数和小数。

#### **序列类型**

官方 Python 文档指出有三种序列数据类型:列表、元组和范围对象。

| **类名** | **使用** |
| 列表 | 它是一个可变序列，用于存储元素的集合 |
| 元组 | 它是一个不可变的序列，用于存储元素的集合 |
| 范围 | 表示执行过程中产生的不可变序列 |
| str | 它是一个不可变的 Unicode 码位序列，用于存储文本 |

标准的 Python 库也包含了 bytearray 之类的类来存储二进制数据。

程序员可以用 中的 **和** **而不是** 运算符遍历存储在序列数据类型中的元素。这些运算符与值比较运算符具有相同的优先级。

#### **映射类型**

映射对象使程序员能够将散列值映射到随机对象。截至 2021 年，映射类型只有一种: **字典** 。dictionary 数据类型是可变的，它存储一个逗号分隔的键和值对列表。

一个程序员会实现这样一个字典:

```py
a = dict(name = "Kate", age = 16, country = "Finland")
```

#### **设定类型**

集合数据类型存储可散列对象的无序集合。Python 目前只内置了两种 set 类型: **set** 和 **frozenset** 。

**set**类型是可变的，程序员可以对其使用 add()和 remove()等方法。另一方面，顾名思义， **frozenset** 数据类型是不可变的，声明后不能修改。

| **类名** | **使用** |
| 设置 | 不同散列对象的可变无序集合 |
| frozenset | 不同可散列对象的不可变集合 |

需要注意的是，由于 frozenset 是不可变的，所以它是可散列的，这使得程序员可以将它用作字典键。Frozensets 也可以用作集合的元素。

设置的数据类型是不可变的，不能作为字典键使用。

#### **模块**

模块是内置的数据类型，支持属性访问，这是一种特殊的操作。属性访问定义了 **mymod** 。 **myobj** ，其中 **mymod** 为模块， **myobj** 为符号表中的名称。

模块的符号表存储在 _dict_ module 的特殊属性中。但是不可能直接分配给这个模块。

#### **可调用类型**

这些数据类型是应用函数调用的类型。因此，这些数据类型包括用户定义的函数、生成器函数、实例方法和一些精选的内置函数、方法和类。

要更详细地了解可调用类型，请参考[](http://docs.python.org)。

### **#8 什么是 pass 关键字？**

**pass**关键字用于填充可能在程序运行时执行的空代码块。换句话说，该关键字表示对程序中尚未编写的代码块的空操作。

### **# 9 Python 语言中的模块和包是什么？他们提供什么好处？**

模块是任何扩展名为. py 的 Python 文件。它可以包含已定义的类、函数或变量。这些文件可以使用 **导入** 关键字导入并初始化到程序中。如果不需要使用整个模块，程序员也可以使用 中的 **和** **import** 关键字导入模块的部分内容。

模块的概念是它们有助于避免不同程序中全局变量之间的冲突。

同样，包有助于避免不同模块名称之间的冲突。包只是支持模块名称空间的层次结构的工具。

用 Python 创建一个包很简单，因为使用了系统固有的文件结构。要创建一个包，程序员必须简单地将模块放入一个文件夹中。文件夹名用作包名。

要从一个包中导入一个模块，程序员必须在包名后面加上模块名，并在它们之间加一个点。

也可以导入整个包。但是，这样做并不会将模块导入到本地名称空间，因此这个操作没有用。

#### **模块化的好处**

模块和包是 Python 机制，支持 Python 中的模块化编程。模块化提供了几个优势:

*   简单: 当开发人员在一个模块上工作时，他们可以把全部精力放在解决问题的一小部分上。有了模块化，开发更容易，错误更少。
*   可维护性: 使用模块的想法是为了加强问题不同领域之间的逻辑界限。当模块以相互依赖最小的方式编写时，以后对一个模块的修改破坏其他模块的可能性就最小化了。
*   **可重用性:** 一个模块中的功能可以在应用程序的其他部分重用，没有任何麻烦。
*   **作用域:** 模块有自己的名称空间，这有助于避免程序不同部分中相似标识符的混淆。

### 什么是全局、私有和受保护的属性？

全局变量是用 Global 关键字声明的公共变量，赋予它们一个全局范围。

受保护的属性是可以从定义它的类外部访问和修改的属性。然而，一个负责任的开发者应该避免这些行为。受保护的属性有一个下划线作为标识符的前缀(例如，“_john”是受保护的属性)。

私有属性在标识符后面有一个双下划线，不能从类外部访问或修改。尝试访问或修改这些标识符会导致 AttributeError。

### **# 11 Python 中的“自我”是什么？**

程序员用 **self** 来表示类的一个实例，访问类的属性和方法。需要注意的是，与 C++中不同的是， **self** 在 Python 中并不是一个关键字。然而， **self** 将属性与开发者的参数绑定在一起，因此像关键字一样使用。

### **# 12 _ _ init _ _ 代表什么？**

__init__ 是一个构造函数方法，在创建新的对象或实例时会自动调用。它的功能是为对象或方法分配内存。每个类都有一个与之关联的 __init__ 方法，这有助于将类的属性和方法与存在的局部变量区分开来。

### **# 13 Python 中的 break 和 continue 是做什么的？**

将 break 语句添加到循环的末尾会终止循环，并将控件放在循环体的末尾。

与 break 语句一样，continue 也是一个跳转语句。但是，continue 语句不是终止循环，而是跳过循环的当前迭代。控制流向循环的下一次迭代。

### **#14 什么是单元测试？**

单元测试包括单独测试程序的不同部分。应用程序通常包含几个协同工作的不同组件。

然而，如果应用程序不能正常运行，查明应用程序的哪个部分导致了问题就变得很困难。也有可能是应用程序的多个组件运行不正常。

单元测试是用来单独测试应用程序的每个组件的框架。它有助于确定应用程序的哪些部分可能对其失败负责。

### **# 15 docstring 的作用是什么？**

文档字符串是一个多行字符串，帮助开发人员记录一段代码。docstring 描述了一个方法是如何工作的。

### **#16 什么是切片？**

切片的意思是拿走某物的一部分。切片用于删除列表的一部分。切片的语法是[start : stop : step]。“开始”定义了列表必须被切片的起点。“stop”是要切片的最后一个元素的索引。“步长”值定义了要跳跃的步数。

Python 允许对列表、字符串、数组和元组进行切片。

### Python 中的数组和列表有什么不同？

数组是相同类型数据的集合，比列表消耗更少的内存。

列表是不同类型数据的集合。这些数据类型消耗大量内存。

## **面向经验丰富的开发人员的 Python 面试问题**

### **# 18 Python 如何管理内存？**

Python 内存管理器处理 Python 中的内存管理。该组件以仅为 Python 保留的私有堆空间的形式分配内存。

换句话说，所有的对象都存储在这个私有堆中。虽然数据是不可访问的，但是程序员可以使用一些 API 函数来处理私有堆空间。

除了 PMM，Python 还有内置的垃圾收集特性来为私有堆空间释放内存。

### 什么是名称空间，为什么要使用它们？

名称空间是将“名称作为键”映射到“对象作为值”的字典，有助于确保程序中的对象名称被识别为唯一的。名称空间是允许 Python 开发人员在没有任何冲突的情况下使用对象的组件。

由于名称空间本质上是字典，多个名称空间可以将相同的名称映射到不同的对象。名称空间可以分为三种类型:

*   **本地命名空间:** 为函数调用临时创建，当函数返回输出时被 Python 清除。顾名思义，它包括函数内部的本地名称。
*   **全局命名空间:** 当一个程序导入一个包，并且这个包一直使用到执行结束时，就创建了全局命名空间。它包含给定项目中使用的包或模块的名称。
*   **内置名称空间:** 这个名称空间包括 Python 内置的函数名。它还包括各种异常的名称。

名称空间的生命周期取决于它们所关联的对象的范围。当一个对象的范围结束时，相应的名称空间的生命周期也结束了。

由于这个原因，从外部名称空间访问内部名称空间对象在 Python 中是不可能的。

### 什么是范围解析？

一个程序可能有两个不同的对象，它们具有相同的名称和作用域，但功能不同。范围解析是确定检查命名空间的顺序的过程。这个过程使 Python 能够很容易地区分看似相似的对象。

Python 使用范围解析的一个很好的例子是，它必须区分“math”和“cmath”模块中两个名称相似的函数。

### **#21 装饰器在 Python 中有什么用？**

装饰函数是一种 Python 函数，它在不改变函数结构的情况下向程序中的现有函数添加功能。这些函数是以自底向上的方式调用的。

装饰函数之所以如此有用，是因为除了让函数更有用之外，它们还可以接受函数的参数，并在将参数传递给函数之前对其进行修改。

这是通过使用内部嵌套函数来封装数据并确保装饰函数不会全局出现来实现的。

### **#22 什么是 lambda，它有什么用？**

在 Python 中，lambda 是一个匿名函数，可以接受无限数量的参数。但是，这个函数只能有一个表达式。

开发人员在短时间内需要匿名函数的情况下使用 lambda 函数。这些函数既可以赋给变量，也可以包装在另一个函数中。

### **#23 解释如何在 Python 中复制对象**

Python 中的赋值语句不会复制对象。它通过将现有对象绑定到目标变量的名称来工作。

开发人员可以使用复制模块创建对象的副本。复制模块使程序员能够以两种不同的方式复制一个对象:

1.  **浅拷贝:** 它创建一个对象的按位拷贝，其值与原始值相同。如果任何值引用其他对象，则复制这些对象的引用地址。
2.  **深度复制:** 它以递归的方式将源对象的所有值复制到目标对象。源对象引用的对象也会被复制。

### **# 24 range 和 xrange 函数有什么不同？**

在功能上，range()和 xrange()函数是相似的，因为它们都生成一个整数序列。但是，range()函数返回一个列表，xrange()函数输出一个 xrange 对象。

换句话说，xrange()函数不生成静态列表，而是动态生成值。因此，xrange()函数通常与对象类型生成器一起使用。这种同时使用生成器和 xrange()函数的技术被称为“屈服”。

在有限内存上运行的应用程序中，让步技术是非常宝贵的。运行 range()函数会占用太多内存，导致“内存错误”

需要注意的是，xrange()在 Python 3 的所有版本中都被否决了。在 Python 3 中，range()与 xrange()具有相同的功能。另一方面，在 Python 2.x. 中，开发人员仍然更喜欢使用 xrange()而不是 range()

### **#25 定义酸洗和拆线**

标准的 Python 库内置了序列化。序列化的过程包括将对象转换为可存储的格式。这样做是为了以后反序列化该对象以获得原始对象。

系列化的过程也称为腌制。在这个过程中，任何对象都可以序列化为字节流，并作为文件转储到内存中。这是使用 pickle.dump()函数完成的。

这个过程很快，但是 Python 在这个过程中在压缩上做出了妥协。换句话说，pickle 对象可以进一步压缩。

pickle 模块最大的优点是它跟踪序列化的对象，并且 pickle 对象可以跨 Python 版本移植。

unpick 是 pick 的逆操作，它反序列化字节流，重新模拟一个对象并将其加载到内存中。这是使用 pickle.load()函数执行的。

### **# 26 Python 中的生成器是什么？**

生成器是一个函数，它一个接一个地返回一个可迭代的项目集合。这些函数通常用于创建迭代器，但是生成器使用 yield 关键字返回生成器对象，而不是使用 return 关键字。

### **#27 什么是 PYTHONPATH？**

这是一个环境变量，程序员必须设置它来添加额外的目录。Python 将在这些目录中寻找包和模块。PYTHONPATH 环境变量特别有用，因为它使程序员能够在全局默认位置之外维护 Python 库。

### **#28 什么是 help()和 dir()函数？**

运行 help()函数显示模块、类、方法、关键字等的文档。如果程序员不向函数传递任何参数，控制台上会出现一个交互式帮助实用程序。

dir()函数返回一个有效方法和属性的列表，这些方法和属性与它所调用的对象相关联。该函数对不同的对象表现不同，因为它试图生成最相关的数据，而不是完整的信息。

当用于库对象或模块时，该函数返回模块中的所有属性。当用于类对象时，它返回所有基本和有效属性的列表。最后，如果没有传递参数，函数将返回当前范围内的属性。

### 你好。py 文件不同于。pyc 文件？

。py 和。pyc 文件以完全不同的格式存储程序。而。py 文件有一个程序的源代码。pyc 文件存储程序的字节码。编译. py 文件时会生成字节码。。pyc 文件只为您导入的文件生成。这些不是为您运行的所有文件生成的。

在执行任何程序之前，Python 解释器会检查编译后的文件是否可用。如果存在. pyc 文件，则执行该文件。但是如果它不存在，Python 会寻找一个. py 文件并执行它。

简单来说，. pyc 文件会节省一个程序员的编译时间。

### **#30 解释解释过程**

Python 既不解释也不编译，因为解释和编译都是实现的两个方面。由于这个原因，Python 被认为是一种字节码解释的语言。

Python 程序存储为。py 文件，程序被编译以产生被称为“字节码”的指令供虚拟机处理。这个字节码存储为。pyc 文件。

Python 解释器是虚拟机的实现。通常，字节码由 CPython(官方解释器)或 JIT 编译器解释。

### **#31 什么是按值传递和按引用传递？**

按值传递和按引用传递是传递参数的两种不同方法。

按值传递方法包括传递对象的副本。这意味着如果复制的对象被更改，原始项目将保持不受影响。

另一方面，通过引用传递涉及到作为参数传递对对象的引用。如果修改了新对象，原始对象也会改变。Python 通过引用传递参数。

### **#32 定义迭代器**

迭代器是一个将自身状态(在迭代中所处的位置)存储在自身中的对象。对象由 __iter__()方法初始化，而 __next__()方法返回序列中的下一项。当 __next__()函数到达迭代器的末尾时，它抛出 StopIteration 异常。

### **# 33 Python 中文件是如何删除的？**

OS . remove()函数提供了删除 Python 文件的最简单方法:

```py
import os

os.remove("XYZFile.csv")

print("File Deleted")
```

### 函数的作用是:根据分隔符将一个字符串分割成一个字符串列表。join()函数与 split()函数相反，它根据分隔符连接字符串列表并返回单个字符串。**# 34 split()和 join()函数是什么？**

### *args 和**kwargs 有什么不同？

“* args”是在函数定义期间使用的特殊语法，用于传递变长参数。星号表示语法中的可变长度，并且习惯上使用“args”。

“* * kwargs”也是一种特殊的语法；但是，它与*args 不同。它用于在函数定义期间传递可变长度的关键字参数。带关键字的参数是在传递给函数时有名称的变量。

这个语法实际上是一个变量名和它们各自值的字典。通常使用“kwargs”位，但程序员可以使用任何其他名称。

### **#36 负指标有什么用？**

从列表、元组或字符串末尾开始的索引称为负索引。这些用于从列表、字符串或元组的末尾获取元素。“Arr[-1]”表示数组中的最后一个元素，“Arr[-2]”是倒数第二个元素，依此类推。

## **Python 面向对象编程面试问题**

### 创建一个类并解释它是如何工作的

关键字“ **类** ”在 Python 中创建了一个类，然后可以用它来创建对象、访问名称属性以及创建和使用方法。

| 

```py
class Pet:

  def __init__(self, name, age):

    self.name = name

    self.age = age

p1 = Pet("Snowy", 3)

print(p1.name)

print(p1.age)
```

 |

### **# 38 Python 中什么是继承？**

继承使一个类能够访问另一个类的所有方法和属性，并且是使 Python 代码易于重用的特性之一。

继承消除了开发人员在应用程序中重复复制和使用大量代码的需要，使得编程更加复杂和有目的。

从另一个类继承的类被称为派生类或子类。另一方面，子类从其继承属性和方法的类被称为父类或超类。

在 Python 中，继承有许多不同的种类:

*   在单一继承中，一个父类提供对一个子类的成员访问。
*   **多级:** 在这种继承中，父类 X 的成员由子类 Y 继承，然后，派生类 Z 从类 Y 继承成员，换句话说，X 是 Z 的祖父，Y 作为中间类。
*   在这种类型的继承中，一个子类继承多个超类的成员。父类的所有成员都由派生类继承。
*   当一个父类向几个子类提供对其成员的访问时，这就是所谓的层次继承。

### 如何使用访问说明符？

在 Python 中，诸如 public、private 和 protected 这样的访问说明符不是直接实现的。变量的访问限制是通过在变量名前加单下划线或双下划线来定义的。如果变量名前没有下划线，Python 默认将它们识别为公共变量。

### **#40 程序员不创建实例可以调用父类吗？**

如果基类是一个静态方法或者被另一个子类实例化，父类可以被调用而不需要创建实例。

### **#41 什么是空班？**

没有任何已定义成员的类是空类。 **pass** 关键字用于定义这类，空类的对象可以在类之外创建。

### 新修改量和覆盖修改量有什么不同？

**新** 修饰符指示编译器使用新的实现来代替基类函数。 **覆盖** 在程序员想要覆盖子类内的基类函数时很有帮助。

### 什么是最终确定？

Finalize 是一个内置的方法，它在调用垃圾收集方法之前释放非托管资源并清理 Python。这是最有用的内存管理方法之一。

### **#44 如何检查给定的类是否是子类？**

Python 在标准库中提供了一种方法来帮助程序员确定一个类是否是子类。issubclass()方法使得判断一个类是否是另一个子类的子类变得容易。

也可以使用 Python 内置的 isinstance()方法检查一个对象是否是一个类的实例。

## **Python 熊猫面试问题**

### 熊猫是什么？

这是一个开源的 Python 库，使得高性能的数据操作更容易实现。这个库的名字来自“面板数据”，它有多维数据。Wes McKinney 在 2008 年首次发布了 Pandas，它因其在数据分析方面的应用而受到欢迎。

程序员可以使用 Pandas 库完成数据分析的所有五个步骤。

### 熊猫的数据框架是什么？

数据帧是可变的 2D 表格结构。这些用于用行和列表示数据。您可以使用以下语法使用 pandas 库创建一个数据帧:

```py
import pandas as pd

dataframe = pd.DataFrame(data, index, columns, dtype)
```

数据表现为序列、列表、地图、字典等形式。在这里，

*   index 是可选参数，代表行标签的索引
*   columns 也是可选参数，但它代表列标签
*   dtype 是可选的，表示每一列的数据类型

### 如何组合熊猫数据帧？

有三种简单的方法来组合数据帧:

1.  **Append():**Append()方法将数据帧水平堆叠
2.  **Concat():** 该方法垂直堆叠数据帧。当数据帧具有相同的列和相似的字段时，效果最好。
3.  **Join():** 它从具有一个或多个公共列的不同数据帧中提取数据。

### 如何确定数据帧中的值是否丢失？

isnull()和 isna()方法有助于识别数据帧是否缺少任何值。缺失的值可以用 0 或列的平均值替换。

### 什么是重新索引？

将一个数据帧装入一个新索引的过程，可选地使用一些填充逻辑，被称为重新索引。如果前一个索引中缺少某个值，则在该位置放置“NaN”或“n a”。

如果新索引等同于旧索引，则不返回任何对象。但是，如果新索引不同于原始索引，则返回一个新对象。

copy 值为 false，通常用于更改数据帧中行和列的索引。

### 如何从数据帧中删除行、列和索引？

del df . index . name 语句按名称删除索引。另一方面，drop()方法对于删除行或列很有用。

程序员将轴参数传递给 drop 方法。如果值为 0，该方法将删除该行。但是如果值为 1，该方法将删除该列。

将 inplace 值设置为 True 可以就地删除行或列，无需重新分配即可完成任务。使用 drop_duplicates()方法可以很容易地从数据帧中删除重复项。

### 当从各种来源导入数据时，熊猫图书馆能识别日期吗？

图书馆可以识别日期，但不能自动识别。首先，程序员在从数据源读取数据时必须添加 parse_dates 参数。如果我们从一个 CSV 文件中读取数据，它可能有不同的日期时间格式，这是 Pandas 库无法处理的。

在这种情况下，该库为程序员提供了创建自定义解析器的灵活性。使用 lambda 函数可以很容易地构建解析器。

## **Numpy 面试问题**

### 什么是 NumPy？

NumPy 是最流行的基于 Python 的包之一，它被认为非常有用，因为它用于处理数组。该库易于使用，是开源的，具有优化的工具，使其能够以卓越的速度执行 N 维数组处理。

该库被明确地设计为处理复杂的数组，并执行统计、代数和三角计算。因此，该库最常用于执行科学计算和广播功能。

除了帮助执行上述所有计算，使用 NumPy，程序员还可以执行:

1.  堆叠
2.  搜索、分类和计数
3.  矩阵运算
4.  复制和查看数组
5.  按位运算

### **# 53 NumPy 数组比列表好吗？**

Python 列表是高效的数据结构，使程序员能够执行一系列不同的功能。然而，在计算矢量化运算时，列表也有一些限制。这些操作包括执行元素式加法和乘法。

除非拥有每个元素的数据类型信息，否则 Python 列表不起作用。这种对信息的需求导致了开销，因为每次对列表中的任何元素执行操作时，都会运行类型调度代码。

NumPy 数组处理 Python 列表的这些限制，使它们非常适合在计算矢量化运算时使用。NumPy 数组几乎比 Python 列表快 30 倍，因为它们的同质性允许它们被密集地打包到计算机的内存中。

由于这个原因，使用 NumPy 数组时释放内存也比使用 lists 时释放内存更快。

### 如何高效地从文本文件中加载数据？

numpy.loadtxt()方法可以自动读取文件的页眉和页脚。如果文件中有注释，它也会读取注释。

loadtxt()方法以高效著称。当它进展缓慢时，程序员通常会将文件的格式更改为 CSV 文件，以帮助 Python 更有效地加载数据。

根据 NumPy 版本的不同，该方法有多种替代方案。

该方法支持以下文件格式:

*   这些文件很大，但却是可移植的，可读的。通常，从这些数据库加载数据很慢。
*   **原始二进制:** 没有元数据的不可移植文件，但数据加载速度很快。
*   **Pickle:** 这些文件是可移植的，但是比 CSV 和二进制文件慢。性能取决于 NumPy 版本。
*   **HDF5:** 代表“高性能厨房水槽”这种文件格式支持 PyTables 和 H5PY 格式。
*   **。npy:** 是 NumPy 的原生二进制格式。它的简单、高效和可移植性得到了认可。

### **#55 如何使用 NumPy 将 CSV 数据加载到数组中？**

genfromtxt()方法使得将 CSV 数据加载到数组中变得容易。但是，分隔符必须设置为逗号。

```py
from numpy import genfromtxt

csv_data = genfromtxt(‘example_file.csv', delimiter=',')
```

**#56 如何用一行反转一个 NumPy 数组？**

使用切片语法可以很容易地反转 NumPy 数组，并将结果存储在另一个数组中。

```py
reversed_array = arr[::-1]
```

## **Python 库面试问题**

### Python 中的包和模块有什么不同？

在 Python 中，一个模块是一个单独的文件，它可以将其他模块(文件)作为对象导入。相比之下，包是包含各种子包和模块的文件夹或目录。

程序员通过用。py 扩展名。这些文件包含可以跨模块重用的类和方法。

### **#58 最有用的 Python 模块有哪些？**

模块是保存有 Python 代码的文件。py 扩展，这些可以包含变量、函数和类。最有用的内置模块包括:

*   数学
*   随机
*   datetime
*   缝好了
*   os
*   JSON

### **#59 如何生成随机数？**

**随机** 模块来自标准 Python 库，允许程序员生成随机数。首先，导入模块，然后调用 random()方法。方法生成一个介于 0 和 1 之间的随机浮点值。

```py
import random

print(random.random())
```

该模块也可用于生成指定范围内的随机数。将某个范围的开始、结束和步长放入 randrang()方法将在该范围内生成一个随机数。

```py
import random

print(random.randrange(5,100,2))
```

**#60 酸洗和拆洗有什么区别？**

pickle 进程将 Python 对象转换成二进制，unpickling 进程将二进制形式的数据转换成对象。

酸洗对象有助于存储磁盘和外部存储位置。另一方面，取消拾取的对象将数据作为可以在 Python 中使用的对象进行检索。

**pickle**模块方便了 Python 中的 pickle 和 unpicking。pickle.dump()方法将 Python 对象转储到内存中，并使用 pickle.load()方法对数据进行解拾取。

### 什么是 GIL？

全局解释器锁是一种互斥锁(一种锁定机制),有助于限制对 Python 对象的访问。GIL 还有助于确保正确的线程同步并避免死锁。

GIL 是 Python 中支持多任务处理的主要组件。我们可以通过一个例子来理解它是如何做到这一点的。让我们假设一个系统中有三个线程。

线程一次获取一个 GIL。当 I/O 操作完成时，GIL 由第一个线程释放，并由另一个线程获取。这个循环一直持续到所有线程都完成执行。

在进程中的任何时刻都没有 GIL 的线程继续处于等待状态。只有获得了 GIL，才能执行死刑。

### 什么是 PIP？

Python 安装程序包是一个命令行工具，用于安装 Python 模块。其无缝界面使得安装各种模块变得简单。

该工具在互联网上搜索你想要安装的包，找到后，将它安装到 Python 的工作目录中。这个过程不需要用户交互。

### 哪些工具可以帮助识别 bug 并执行静态分析？

有许多工具可以用来发现 Python 代码中的错误，PyChecker 是许多程序员的首选。当 PyChecker 发现错误时，它会发出问题警报，并指出错误的复杂性。

Pylint 是一个流行的林挺工具，用于检查模块是否符合编码标准。该工具支持几个插件，这些插件使定制功能能够满足开发人员的需求。

### **#64 主要功能是什么？**

“main”函数被认为是程序中跨编程语言执行的起点。然而，在 Python 中，解释器逐行解释文件，并不显式提供 main()函数。

也就是说，在 Python 中可以很容易地模拟 main()函数的执行。想法是使用 __name__ 属性定义一个 main()函数。__name__ 变量内置于 Python 中，指向当前模块的名称。

### **#65 什么是烧瓶？**

Flask 是一个 Python 微框架，它使用 Jinja2 和 Werkzeug 作为依赖项。Flask 提供了一些其他框架没有的优势:

*   它没有使用太多对外部库的依赖
*   外部依赖性的缺乏使得微框架异常轻便。这也导致需要发布的安全补丁更少。
*   内置开发服务器和高性能调试器

### 当开发者退出 Python 时，并不是所有的内存都被释放。为什么？

Python 有一个有效的清理机制，当用户退出 Python 时，它会自动运行。这种机制试图释放或销毁所有对象。

但是一些 Python 模块有对对象的循环引用。有时，从全局命名空间引用的对象也不会被释放，因为释放或销毁这些由 C 库保留的部分是不可能的。

### **# 67 Flask 比 Django 好吗？**

【Flask 和 Django 都将浏览器中键入的 URL 映射到函数；然而，这两个框架之间有一些关键的区别。

烧瓶更容易使用，但不需要用户做太多的跑腿工作。因此，Flask 用户必须手动指定 Flask 的详细信息。

另一方面，Django 有用户可以分析和使用的预写代码。这消除了程序员使用框架时需要做的大量工作。

虽然 Flask 和 Django 都同样有用，但是开发者的选择取决于他们对自己喜欢做的工作的偏好。

### 烧瓶、金字塔和姜戈有什么不同？

Flask 是一个适用于小型应用的现成的微框架。它使用外部库。

金字塔是为大型应用程序设计的高度可配置的工具。它为用户提供了使用工具的选择，还提供了选择数据库、模板风格等的灵活性。

Django 是为大型应用程序构建的，它带有一个 ORM，使得从关系数据库和应用程序模型传输数据成为可能。

### **#69 什么是狗堆效应？**

缓存过期，网站同时收到客户端多个请求的事件。使用信号量锁可以避免该事件。

## **结论**

浏览这篇文章中的问题不足以通过面试。你必须练习回答这些问题，并且每天提高你的编程技能。如果你保持专注，破解任何 Python 面试都不会太有挑战性。****