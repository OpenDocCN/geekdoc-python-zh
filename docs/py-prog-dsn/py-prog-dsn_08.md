# 第七章 面向对象思想与编程

面向对象思想和方法具有强大的描述复杂数据和构建复杂系统的能力，因此面向对象编 程已成为当今流行的编程范型，是大多数程序员在解决问题时的不二之选。第五章中通过图 形对象初步介绍了对象概念，本章将系统地介绍面向对象思想和面向对象编程。

# 7.1 数据与操作：两种观点

## 7.1 数据与操作：两种观点

任何计算机程序都是对特定数据进行特定处理的过程。当我们利用计算机解决问题时，

不外乎要做两件事情：一是将问题要处理的数据表示出来，这可以借助编程语言提供的基本 数据类型、复杂类型构造手段以及更高级的逻辑数据结构等来实现；二是设计对这些数据进 行处理的算法过程，并利用编程语言提供的各种语句编制成一步一步执行的操作序列。因此， 用计算机解决问题的关键是确定问题所涉及的数据以及对数据的操作。

关于数据和操作这两部分的关系，在程序设计思想和方法的发展过程中存在两种不同的 观点：一种是传统的以操作为中心的面向过程观点，一种是现代的以数据为中心的面向对象 观点。

# 7.1.1 面向过程观点

### 7.1.1 面向过程观点

我们用一个简单程序来说明传统程序设计的思维方式。

【程序 7.1】eg7_1.py

```py
x = 1
y = 2
z = x + y 
print z 
```

到目前为止，我们在编程时基本上都是这样思考的：先用特定数据类型的常量或变量来 表示数据（如程序 7.1 中分别存入变量 x 和 y 的整数类型值 1 和 2），然后再利用合适的操作（如程序 7.1 中的加法运算“+”）按一定的步骤来处理数据。在这种思考方式下，数据和对 数据的操作被看作是分离的两件事情：数据只是信息的表示，不表达任何操作，在程序中处 于“被动”地位；而对数据的操作在程序中则处于“主动”地位，是驱动程序实现特定功能 的力量。程序 7.1 可视为用操作“+”主动地去处理被动的数据 x 和 y，从而实现加法功能。 图 7.1 以一个比喻来形象地展示这种观点：数据与操作之间的关系正如心与箭的关系——没 有丘比特的箭，两颗心是不会彼此连结的。

![](img/程序设计思想与方法 208190.png)

图 7.1 传统观点：数据与操作分离

在数据与操作分离的传统观点下，通常以算法过程的设计为主线来展开程序设计，故可称为以过程为中心的程序设计。以求解一元二次方程的程序 3.6 为例，数据（系数 a、b、c） 明确后，需要精心设计的是处理这些数据的操作过程：先计算判别式 b2-4ac，然后根据判别 式的值判断方程是否有解，有解的情况下再利用公式求解，最后输出结果。

在以操作为中心的设计理念下，程序中的数据有时对整个操作过程都是公开的，可以被 操作过程中的每个步骤访问、处理。例如，假设程序 7.1 的操作不是单一的加法，而是在加法操作（第 3 行）之后还有两个操作：

```py
w = x – y 
z = z * w 
```

可以看出，数据（x、y、z、w）对程序中所有的操作都是公开的。这时，程序中对数据的访问不受任何控制，非常容易出现错误的操作。

当然，实际的应用程序不会像程序 7.1 这样简单。复杂程序中不但数据复杂，而且对数 据的操作也非常复杂，所有操作可能形成漫长而曲折的过程。为了应付操作过程的复杂性， 按照第四章所介绍的模块化编程思想，可以将复杂操作过程组织成为若干个较小的模块—— 函数，每个函数实现一个相对简单的、单一的功能。例如下面这个“复杂”程序①：

【程序 7.2】eg7_2.py

```py
def op1(a,b):
    return a * a - b * b
def op2(a,b):
    return a ** b + b ** a
x = 1
y = 2
z = 3
result1 = op1(x,y) 
result2 = op2(x,z) 
print result1 + result2 
```

从一个更抽象的层次看，每个函数其实相当于一个操作。与程序 7.1 相比，程序 7.2 对 更多的数据（x、y、z）进行更复杂的操作：先执行 op1 操作，再执行 op2 操作，最后输出结 果。无论是程序 7.1 的简单操作“+”还是程序 7.2 的复杂操作“op1”、“op2”，它们都是“对 数据的操作”，仍然属于“数据与操作相互分离”的思考方式，整个程序仍然是对数据按一定 顺序执行操作的过程。

不过，作为高抽象级别操作的函数具有一定的访问控制能力。函数就像一个提供某种功 能的黑箱，使用者需要的只是它的功能，并不需要知晓它内部是如何实现功能的。函数内部 处理的数据不是对整个程序都公开的数据，一个函数不能访问另一个函数内部的数据。然而， 程序中仍然有一些全局数据是对所有操作（包括函数）公开的，仍然存在前述访问控制问题， 例如程序 7.2 中的两个函数 op1 和 op2 都在处理数据 x。

总之，不管程序是简单还是复杂，不管操作是语句级的还是函数级的，传统程序设计都 是按照数据与操作分离的观点，以过程为中心展开程序设计的。在这种面向过程的编程范型 中，强调的是对数据的操作过程，程序员思考的主要问题是数据如何表示、对各数据执行什 么操作以及各操作的先后顺序如何安排。当程序很复杂时，可以采用自顶向下设计和模块化 设计方法，将使用低级别操作的复杂过程设计成使用高级别操作的简单过程。

要指出的是，基于数据与操作分离观点的面向过程编程具有其内在的局限性，在处理某 些复杂问题和系统时显得不合适。例如，图形用户界面（GUI）程序②就不属于“对给定数据，

> ① 这个程序自然一点也不复杂，但不妨碍它可以用于说明复杂操作的问题。
> 
> ② 详见第八章。

按特定次序对数据进行操作，操作完毕程序即告结束”的程序执行模式。以 Word 程序为例， 当启动 Word 打开文档（即程序数据）之后，接下去对数据如何操作呢？Word 程序并不知道 该做什么，它只能等在那里。接下去用户可能用键盘输入文本，也可能用鼠标点击菜单或工 具栏进行存盘或打印，总之用户需要通过某种交互事件来告诉 Word 程序该如何操作数据， 一个操作完成后 Word 又进入等待状态。可见，GUI 程序属于“先建立一个图形界面，然后 等待来自用户的不可预知的事件发生；事件发生后才导致执行某些操作，事件处理完毕又回 到等待状态”这样一种程序执行模式，程序从启动到结束的具体执行过程取决于事件发生的 顺序，不像传统程序那样预定义了执行顺序。

为了适应 GUI 程序这类没有明确的预定义操作次序、靠不确定的事件来驱动的程序和系 统的开发，提高开发效率和质量，计算机科学家提出了一种新的观点来看待数据与操作之间 的关系，即面向对象的观点。

# 7.1.2 面向对象观点

### 7.1.2 面向对象观点

什么是面向对象？要回答这个问题，首先要理解面向对象思想中最基本的观点：数据和对数据的操作不可分离。

其实这个观点对我们来说并不完全陌生。通过第二章介绍的数据类型的概念，我们已经 意识到：特定的数据值与能对该数据执行的操作是密切关联的。对于数值型数据，合法的操 作不外乎加减乘除之类；对于字符串数据，合法的操作不外乎查找串中字符或子串、改变字 母大小写之类。脱离数据的类型来考虑操作是没有意义的，例如在 Python 中单独的一个操作 符“+”的意义是不确定的，因为数值、字符串和列表类型的数据都能施加意义不同的“+” 操作。即使是对同为数值型的整数和浮点数数据，除法操作“/”也有不同的含义。

除了语言本身提供的基本数据类型，对于复杂数据类型同样可以说明数据与操作的密切 关联。例如，圆形是一种复杂的数据类型，对圆形可以施加求面积、移动位置等操作；而对 于一个由姓名、年龄、考试成绩等多个简单数据项组合而成的学生数据，可以施加查询姓名、 计算平均绩点等操作，绝不会提出计算学生面积的要求。

总之，数据与对数据的操作确实是紧密相关、不可分离的。既然如此，那我们干脆将数 据和操作两者结合在一起，抽象出一种实体：该实体拥有一些数据，同时也知道如何对这些 数据进行操作。这种数据和操作结合在一起所形成的实体称为对象（object）。图 7.2 展示了这种思考方式，与图 7.1 相比，现在心、箭合为一体，就好比青年男女不是等待丘比特的撮 合，而是自备弓箭，随心而动。

![](img/程序设计思想与方法 210894.png)

图 7.2 对象是数据和操作的结合体 可以将对象视为广义的“数据”，因为对象里确实存储着数据。但与传统数据不同的是，对象自己掌控对自己存储的数据的处理方法，而不是由外部来决定如何处理。外部如果想对 某个对象存储的数据进行操作，只能向对象发送一个表示操作请求的消息（message），然后由对象来响应这个请求，执行被特定的操作，并将结果告知请求者。显然，对象并不是对什 么消息都能做出响应，对象能够响应的消息由该对象能够执行的操作决定。对象将它能响应 的消息对外公布，就像一个服务机构对外公布服务项目，这些消息（可执行的操作）构成了 对象与外部进行交互的界面（interface，也称接口），外部只能通过这个界面与对象打交道。 基于对象概念来分析问题和设计解法，这就是 面向对象编程 （ object-orientation programming，简称 OOP）。通过 OOP 所得到的程序是一个由很多对象组成的系统，可以向 对象发送消息来实现对数据的处理，全体对象通过相互协作来完成程序的数据处理功能。而 传统的面向过程编程，得到的程序是一组对数据进行操作的过程，通过按顺序执行这些过程来实现程序功能。 面向对象是强大的分析问题、解决问题的思维工具，因为“对象”这个概念可以用来抽象、描述现实世界的几乎一切事物，例如人、电视机、汽车等等。可以说，世界是由各种对 象组成的，每个对象都具有一些数据特性和一些操作行为，了解了对象的数据特性和操作行 为就认识了对象。作为例子，我们来看“人”为什么可视为“对象”：第一，每个人都具有自 己的数据，如姓名、出生日期、身高、体重等；第二，每个人对他的数据都有自己的操作方 法，例如通过计算当前日期与出生日期的差值来得到年龄、通过公式“标准体重 =（身高－ 100）× 0.9）”来判断自己是否超重等。而且每个人都能响应外部发来的消息（如询问年龄 的消息），也就是执行相应的数据操作。再看一个例子，“电视机”也可视为“对象”：第一， 每台电视机都具有自己的数据，如型号、尺寸、频道数目等；第二，每台电视机都有自己的 数据操作，例如开机、关机、调频道、调音量等。而且电视机能够响应外部发来的消息并执 行相应的操作，如按下遥控器上的某个按键就能让电视机执行执行调频道的操作。图 7.3 中 给出了两个“人”对象和一个“电视机”对象的示意图。

![](img/程序设计思想与方法 211512.png)

![](img/程序设计思想与方法 211513.png)

图 7.3 两个“人”对象和一个“电视机”对象

除了“人”、“电视机”这种有形的、具体的对象，我们也可以将无形的、抽象的事物看作是对象。例如可以将“室内环境”视为对象：该对象的数据包括温度、湿度、容积等，该 对象能够响应的操作包括提高温度（具体也许是通过空调设备）、增加湿度（具体也许是通过 人工洒水）、换算容积单位等。

综上所述，我们将数据和对数据的操作融为一体，形成具有静态信息和动态行为的对象。 以面向对象的观点去描述现实世界，就是要将现实世界刻画成由各种对象组成，并且各对象之间进行交互、协作的系统。

# 7.1.3 类是类型概念的发展

### 7.1.3 类是类型概念的发展

如上所述，对象可以视为广义的数据，因此和普通数据一样属于某种数据类型。从图 7.3 可以看出，“人”和“电视机”就属于两种完全不同的对象类别，而 John 和 Mary 这两个“人” 对象则具有完全相同的数据构成和操作，只是各自的数据值不同。

用计算机解决问题时，首先需要明确问题中涉及哪些数据，并在程序中将这些数据用编 程语言提供的数据类型表示出来，然后再去考虑需要对这些数据执行何种操作。为了表示数 据，编程语言一般提供若干基本数据类型（如 Python 的 int、float、str 和 list 等类型），并为 这些基本类型提供相应的基本操作（如 Python 中对 int、float、str 和 list 都提供了+运算，尽 管含义不同）。

然而，实际问题中往往涉及很复杂的数据，不能用基本数据类型直接表示。为了表示复 杂数据，大体有两种办法：一种是将复杂数据分解成若干个简单数据项，以便每个数据项可 以用基本类型表示；另一种是由用户自定义新的数据类型，以便对复杂数据进行直接的、整 体的表示。例如，如果要表示一个学生的姓名，可以简单地用一个字符串数据表示；如果要 表示一个学生的年龄，可以简单地用一个整数数据表示。但如果要整体表示一个“学生”，包 括该学生的姓名、年龄、地址等信息，就没法用基本数据类型直接表示了。一种解决办法是 将整体的“学生”分解成姓名、年龄、地址等简单数据，并通过分别处理这些简单数据而达 到处理“学生”数据的目的。但这不是好办法，因为这种表示法丢失了数据的整体性，在维 护姓名、年龄、地址等数据间的联系时很麻烦。另一种解决办法是将学生整体视为一个数据 值，并为这种数据值定义新的数据类型（因为编程语言中没有现成的类型能够表示该数据）。

假设我们要为“学生”数据定义一个新的数据类型 S，那么 S 应该是由若干更简单的数 据项构成的（如学号、姓名等），我们称这些构成 S 的成员数据为 S 的属性。除了定义 S 类 型数据的属性，还需要定义能对 S 数据执行什么操作（如修改姓名或年龄、读取地址等）。 可以利用编程语言提供的基本类型和新类型定义机制来实现 S，例如用 str 类型表示姓名和学 号，用 int 类型表示年龄之类，用函数实现对 S 数据的操作。定义了 S，就好像为编程语言添 加了一个新的数据类型，应用程序就可以像使用整数、字符串等基本类型一样去使用 S。

![](img/程序设计思想与方法 212999.png)

图 7.4 复杂数据类型 S 是多个属性的组合体

在传统观点下，由于数据和操作被视为分离的，因此定义新数据类型时只需定义复杂数据是怎样构成的，例如将“学生”数据定义成学号、姓名、年龄、地址的组合体①。至于如 何操作这种复杂数据，则需要另行编写处理代码，例如写一个函数 update(s)来实现对 S 型数据的修改，写另一个函数 get(s)来实现对 S 型数据的读取等等。总之，数据类型 S 与对这种 类型的数据的操作 update()、get()等是分离的两件事情，设计也是分离的（如图 7.4 所示）。 顺便提一下，将一些数据组合起来构成更复杂的数据的过程是可以重复进行的，即组合体成 员本身可以是复杂数据，如图 7.4 中的属性 address 一样。而在面向对象观点下，数据与操作 是不可分离的，是同一实体（即对象）的两个侧面。因此，当用户为复杂数据定义新的数据 类型 T 时，必须同时描述 T 的值的构成以及对 T 型值的操作。这样，上面的“学生”类型 S 将被定义成如图 7.5 所示的样子：

> ① 这种组合体在不同编程语言中有不同术语，如 Pascal 语言的记录类型和 C 语言的结构类型。

![](img/程序设计思想与方法 213491.png)

图 7.5 复杂数据类型 S 是多个属性及操作的组合体

由此，我们从传统的数据类型概念发展出了“类”的概念。类（class）是广义的数据类型，能够定义复杂数据的特性，包括静态特性（即数据）和动态特性（即对数据的操作方法）。 正如传统类型 int 可视为由 3、525 等合法整数值组成的集合一样，类也规定了它的合法值的 形式和范围。类的值就是“对象”，也称为类的实例。例如图 7.5 中的类 S 的合法值就是每一 个学生。

早期编程语言在创建新类型方面比较弱，但随着数据类型概念的发展，现代编程语言大 多都提供了强大的自定义数据类型的语言构造。面向对象编程语言中的类定义机制使得自定 义数据类型的能力达到了比较完善的程度。

# 7.2 面向对象编程

## 7.2 面向对象编程

OOP 的特色包括抽象、封装、消息、模块化、多态性、继承等。

# 7.2.1 类的定义

### 7.2.1 类的定义

利用 OOP 来解决问题时，首要任务是确定该问题涉及哪些对象，每种对象分别具有什 么数据和操作。类就是对这些信息的表达。类的创建，体现了面向对象的诸多思想和方法， 本节对此进行详细介绍。

抽象

人们在认识客观世界时，经常采用抽象方法来对客观世界的众多事物进行归纳、分类。 抽象就是忽略事物中与当前目标无关的、非本质的特征，而抽取与当前目标有关的、本质的特征。经过抽象，能够确认事物间的共性，并将具有共性的事物归入一类，从而得到一个抽 象概念。抽象时需要考虑“当前目标”，对于某个事物，根据不同的解题目标，可以进行不同 的抽象。

抽象是面向对象的基本方法，而抽象的工具就是“类”。我们用类来抽象、描述待求解 问题所涉及的事物，具体包括两个方面的抽象：数据抽象和行为抽象。数据抽象描述某类对 象共有的属性或状态，行为抽象描述某类对象共有的行为或功能特征。

例如，对学校里一个个具体的学生张三、李四、王五等进行概括，可以抽取出学号、姓 名等数据属性，还可以抽取出选课、做项目、加入学生社团等行为属性，从而建立“学生类”。 又如，对马路上形形色色的汽车进行概括，可以抽取出制造商、型号、排量等数据属性，还 可以抽取出启动、刹车、加速等行为属性，从而建立“汽车类”。

抽象可以是在多个层次上进行的。例如，当抽象出学生、教师、职工等类别之后，可以 从他们进一步抽象出“师生员工”类；当建立了汽车、火车、飞机等类别之后，可以从他们 进一步抽象出“交通工具”类。如此进行，最终可以形成一个抽象层次，称为类层次。这种 抽象方法在各学科中都是常用的，最典型的如生物学中的分类层次：

```py
智人 → 人科 → 灵长目 → 哺乳纲 → 脊索动物门 → 动物界 
```

封装

在日常生活中，人们使用着各种提供特定服务的设备，如汽车、彩电等等。对于这些设备，人们通常只需了解它们的功能，而不关心它们的内部是怎样工作的。类似地，计算机程 序也是提供特定服务的“设备”，我们使用程序时通常也只关心程序的功能，而不关心程序内 部的实现过程。OOP 中的封装概念正是这种思想的体现。

封装（encapsulation）是指用类将对象的数据和操作结合成一个封闭的程序单元，并对 外部隐藏内部实现细节。隐藏信息包含两重意思：一是用户无需了解隐藏的信息就能使用该 类，二是不允许用户直接操作类中被隐藏的信息。

封装导致外界不能直接存取对象的数据，但这并不是说我们就无法处理对象数据了。与 数据封装在一起的还有对数据的操作（称为方法的一些函数），类会对外公开这些方法的名称 和调用格式，亦即提供了与外界的交互界面。外界可以向对象发消息（所请求的方法名称及 参数），然后对象通过执行方法来响应外界的消息。所以，外界可通过消息机制来间接处理对 象数据。当然，外界只能按对象允许的方式来处理对象数据，因为对象能够响应的消息是由 类定义决定的。

封装对类的实现者和使用者都有好处。第一，防止使用者直接操作对象数据时有意无意 造成的错误，毕竟对象自己的方法处理自己的数据才是安全的；第二，使用者通过方法调用 来操作数据时无需了解内部实现细节，类的功能非常易用；第三，即使实现者以后修改了类 的内部实现，只要不改变方法界面，使用者就不会受到任何影响，这使得程序非常容易维护； 第四，可以使同类甚至不同类的对象对使用者都呈现标准化的操作界面。以电视机为例可以 很清楚地看出上述优点。电视机将内部各种器件封装起来，使用户只能通过面板上的按键来 操作电视机，这样既保护了内部器件使之不易被用户损坏，又使电视机简单易用；电视机内 部器件的维修和升级对用户来说没有任何影响；所有品牌的电视机几乎都提供标准化的面板（电源开关、频道切换、音量调节等），只要会使用一种电视机，基本上就会使用其他任何电 视机甚至收音机（因为收音机界面也是类似的调换频道、调节音量等）。

Python 类定义

如前所述，类是用来刻划对象的数据特性和行为特性的。Python 中类定义形如：

```py
class <类名>:
    <方法定义 1>:
        ...
    <方法定义 n>: 
```

其中诸“方法定义”就是对对象的操作行为的定义，外界能够请求对象所做的事情完全由这 些方法决定。

每个方法定义其实都是一个函数定义，即形如：

```py
def <方法名>(<参数>):
    ... 
```

方法与普通函数略有差别。首先，每个方法都必须有一个特殊的形参 self，并且 self 必 须是该方法的第一个形参（如果还有其他参数的话）。至于这个特殊参数的作用，我们在稍后 介绍方法调用的时候再解释。其次，方法只能通过对象来调用，即向对象发消息请求对象执 行某个方法。

至此，读者也许会有疑问：不是说类中包含了数据和操作的定义吗，怎么上述类定义形 式中只有操作没有数据？在 Python 中，类的实例所拥有的数据一般在类的方法中定义的，尤 其是在一个特殊方法 init**方法①中。这里的方法名 init**是 Python 规定的，通常每个类 都会定义 init__ 方法，其功能将在介绍类实例创建时进行解释。

作为例子，我们来定义类 Person。Person 是对现实世界中“人”的抽象，每个人都有自 己的姓名和出生年份，并且都能回答外界有关其姓名和年龄的提问。我们将 Person 类的定义 保存在文件 person.py 中，将来任何程序都可以通过导入此文件而使用 Person 类。

【程序 7.3】person.py

```py
class Person:
    def __init__ (self,n,y): 
        self.name = n self.year = y
    def whatName(self):
        print "My name is",self.name 
    def howOld(self,y):
        age = y – self.year 
        if age > 0:
            print "My age in",y,"is",age 
        else:
            print "I was born in",self.year 
```

Person 对象的数据就是在 init__ 方法中定义的 self.name 和 self.year，Person 对象能够执 行的操作就是方法 whatName()和 howOld()。

像 Person 类中的 self.name 和 self.year 这样，以“self.<变量名>”形式定义的变量称为实 例变量（instance variable），意思是这种数据是属于类的实例的，不同实例可有不同的值。实 例变量可以在类的任何方法中定义（通常在 init**中定义），也可以在类的任何方法中直接 引用。Person 类中，self.name 和 self.year 是实例变量，将来创建的每一个 Person 实例都拥有 这两个数据，每个实例各自的姓名和出生年份的值可以是不同的；另外，这两个实例变量虽 然是在 init**中定义，但在 whatName 和 howOld 方法中都可以直接引用。注意，如果方法 中定义的某个变量名前没有 self 前缀，则该变量是普通的函数局部变量，其作用域仅限于该方法。例如上例中在 howOld 方法中定义的 age 就是局部变量，它只能在 howOld 中引用。 类的方法定义中可以通过 self.f()的方式调用同一个类中的其它方法 f。例如：

> ① 注意，这个名称中 init 前后各是两个下划线字符！Python 常用这种形式的标识符来命名内部对象。

```py
class Person1:
    def __init__ (self,n,y): 
        self.name = n 
        self.year = y
    def whatName(self):
        print "My name is",self.name 
    def howOld(self,y):
        age = y – self.year 
        if age > 0:
            print "My age in",y,"is",age 
        else:
            print "I was born in",self.year 
    def allInfo(self,y):
        self.whatName() 
        self.howOld(y) 
```

其中的方法 allInfo 调用了本类中的另外两个方法 whatName 和 howOld。

类实际上是用户自定义的数据类型，是对 Python 语言本身提供的基本数据类型的扩充。 一旦定义了类，就可以将它当作 Python 标准数据类型来使用。

作为特例，如果某种对象只包含一些数据，不包含对数据的操作，则可以在类中只定义 实例变量而不定义操作方法（除了特殊的 init 方法）。这样的类相当于很多编程语言中的 “结构”类型①，其作用是将一些数据项组合成一个整体。事实上，类可以看作是传统结构 类型的发展，即类是添加了数据操作的“结构”。

最后说一下命名问题。面向对象编程中习惯上使用大写字母开头的标识符来为类命名（如 Person），而类中方法和实例变量则惯常使用小写字母开头的标识符来命名（如 name、year 和 whatName）。方法名如果由多个单词构成，一般采用骆驼式命名法，即除第一个单词之外 的各单词首字母大写，如 whatName 和 howOld。

# 7.2.2 对象的创建

### 7.2.2 对象的创建

一旦定义了类，就可以创建类的实例，也就是该类的一个对象②。类是抽象的，而对象

则是具体的，就好比“人”是抽象概念，而“张三”是个具体的人。一个类可以创建任意多 个实例（对象），所有实例都具有相同的行为（这是由类中定义的方法决定的），但各自的数 据值可以不同。创建类的实例采用如下形式：

```py
<变量> = <类名>(<参数>) 
```

这里将类名当成一个函数来用，称为类的构造器（constructor，或称构造函数）。构造器返回 一个新对象，通常需要定义<变量>来引用这个新对象。注意，虽然<变量>只是对新对象的引 用，但习惯上我们也常说<变量>就是新对象本身，这一般不会产生混淆。

如果希望创建对象时将对象定制成特定的初始状态，则可以在类中定义特殊的 __init__ 方法③。创建新对象时，Python 自动调用 __init__，实现对新对象的初始化，比如为该对象所 拥有的数据进行赋值。 __init__ 方法可以用参数（至少有一个 self 参数）来传递初始化所需的信息，调用 __init__ 时必须提供相应的实参。但由于 __init__ 不是直接调用的，无法直接将实 参传递给它，所以我们将所需实参传递给构造器，再由构造器自动传递给 __init__ 。不过，__init__ 的特殊参数 self 是一个例外，传递给 self 的实参是新创建的对象（更准确地说是对新 建对象的引用）。

> ① 如 Pascal 语言中的 record 和 C 语言中的 struct 类型。
> 
> ② 本书中混用“实例”和“对象”这两个术语，视之为相同的概念。
> 
> ③ 也可以说 init ()才是类的构造器，不过不能直接调用，而是通过类名来隐含地调用。

例如，下面的语句先导入 Person 类，然后创建一个 Person 对象，并使变量 p1 引用该对象：

```py
>>> from person import Person
>>> p1 = Person("Lucy",2005) 
```

创建对象时自动调用 init__ 方法，该方法所需的三个参数 self、n、y 分别用实参 p1、"Lucy"和 2005 代入，这相当于函数调用

```py
__init__ (p1,"Lucy",2005) 
```

从而导致执行 __init__ 的函数体，为新对象进行初始化：

```py
p1.name = "Lucy" 
p1.year = 2005 
```

图 7.6 给出了上述利用 Person 构造器创建对象 p1 并调用 __init__ 进行初始化的过程。

![](img/程序设计思想与方法 218990.png)

图 7.6 对象创建与初始化

注意， init 方法中对变量 name 和 year 所赋的值"Lucy"和 2005，是专属于新实例 p1 的，它们与同一个类的其他实例（例如下面将创建的 p2）没有关系。这两个变量都属于实例 变量（instance variable），意即它们的值是随实例的不同而不同的。下面再创建一个 Person 对象，并使变量 p2 引用这个新对象：

```py
>>> p2 = Person("Tom",1990) 
```

同样地，Python 自动调用 init 方法，只不过这次传递给该方法的参数是 p2、"Tom"和 1990， 即相当于函数调用

```py
__init__ (p2,"Tom",1990) 
```

从而导致执行 __init__ 的函数体，为新对象 p2 进行初始化：

```py
p2.name = "Tom" 
p2.year = 1990 
```

这里，对实例变量 name 和 year 所赋的值"Tom"和 1990 是专属于新实例 p2 的，与前面创建的实例 p1 没有关系。创建同一个类的多个实例的过程可参见图 7.7。

![](img/程序设计思想与方法 219527.png)

图 7.7 创建同一个类的多个实例

从图 7.7 可见，类与实例的关系就像模具与产品的关系，用同一个模具可以制造出大量 的产品，这些产品总体上是相似的，但可能各有不同的细节。p1 与 p2 是属于同一类的对象， 总体上非常相似，例如都有数据 name 和 year，但各有不同的数据值。

# 7.2.3 对象方法的调用

### 7.2.3 对象方法的调用

一旦创建了对象，就可以通过向对象发消息来调用对象的方法。消息的格式如下：

```py
<对象>.<方法>(<实参>) 
```

其含义是请求<对象>执行<方法>，方法定义中列出的形式参数由<实参>提供。

例如，接着前面的例子执行如下语句：

```py
>>> p1.whatName()
My name is Lucy
>>> p2.whatName()
My name is Tom
>>> p2.howOld(2013)
My age in 2013 is 23 
```

前面说过，类中定义的方法都必须以 self 作为第一个参数，这个参数用来指明当前是哪 一个对象实例要执行类的方法。传给 self 的实参就是上述方法调用格式中的<对象>，只不过 这个实参是由 Python 隐含地传递给 self，而不是由程序员在方法调用表示法中直接传递。上 面例子中的 p1.whatName()和 p2.howOld()引起的方法调用过程可参见图 7.8。

![](img/程序设计思想与方法 220101.png)

图 7.8 对象方法调用过程

要说明的是，类方法的第一个参数所用的参数名 self 只是 Python 语言的惯例，而非硬性 规定，完全可以使用别的名字①。

# 7.2.4 编程实例：模拟炮弹飞行

### 7.2.4 编程实例：模拟炮弹飞行

本节讨论一个模拟炮弹飞行的程序的设计。我们采用三种设计方法，得到三个版本的程序。通过比较各个版本的差别，可以看出 OOP 与传统的面向过程编程相比具有明显优点。

算法设计

程序规格是输入炮弹的发射角度、初速度和高度，输出炮弹的射程。 虽然可以利用复杂的数学公式直接算出射程，但我们采用模拟炮弹飞行过程的方法来求射程。所谓模拟炮弹飞行过程，就是从炮弹射出炮口开始，计算炮弹在每一时刻的位置（水 平距离和高度），直至炮弹落地。注意，时间和炮弹飞行轨迹都是连续的量，由于计算机不能 处理连续的数值，所以需要将时间和炮弹飞行轨迹“离散化”，也就是将时间划分成一系列离 散的时段，飞行轨迹也相应地划分成一系列离散的点。

炮弹在每一时段所处的位置可以利用简单的中学物理知识求得。将炮弹速度分解成水平 分量和垂直分量，则炮弹在水平方向的运动是匀速直线运动（忽略空气阻力），在垂直方向的 运动是加速运动（因为重力的影响，炮弹先向上减速飞行，减到向上速度为 0 后改为自由落 体运动）。算法伪代码如下：

```py
算法：模拟炮弹飞行。
输入：角度 angle（度）、初速度 v（米/秒）、高度 h0（米）、时间间隔 t（秒） 
输出：射程（米）
计算初速度分量：先将 angle 换算成弧度单位的 theta，再计算 
    xv = v * cos(theta)，yv = v * sin(theta)
初始位置：(xpos,ypos) = (0,h0)
当炮弹还未落地（即 ypos &gt;= 0.0）：
    更新炮弹在下一时段的位置(xpos,ypos)和垂直速度分量 yv
输出 xpos 
```

> ① Java 和 C++中使用的是“this”。

为了理解此算法，请参看示意图 7.9。

![](img/程序设计思想与方法 220914.png)

图 7.9 模拟炮弹飞行的有关数据

炮弹飞行过程中，水平位置的更新很简单：按照匀速直线运动的规律，每个时段 t 内，

炮弹都飞行 xv * t 距离，因此炮弹在水平方向从 xpos 运动到了新位置

```py
xpos = xpos + xv * t 
```

炮弹垂直方向位置的变化稍微复杂点：由于重力的影响，炮弹向上速度每秒减少 9.8 米/ 秒，经过时段 t，向上速度变成了

```py
yv1 = yv - 9.8 * t 
```

而炮弹在时段 t 内垂直方向位移可以用这段时间的平均速度乘 t 来计算，因为时段 t 内的平均 速度为起点速度 yv 与终点速度 yv1 之和的一半，故时段 t 内的垂直方向位移为

```py
(yv + yv1) / 2.0 * t 
```

于是，经过时段 t 后，炮弹在垂直方向的新位置为

```py
ypos = ypos + (yv + yv1) / 2.0 * t 
```

最后要说明的是，模拟炮弹飞行的循环语句的条件 y>=0 中之所以用等号，是为了使程 序在初始高度为 h0 = 0 的情况下也能进入循环进行模拟。一旦算出炮弹最新高度小于 0，则 终止循环。

下面是完整程序：

【程序 7.4】cball1.py

```py
# -*- coding: cp936 -*- 
from math import pi,sin,cos
def main():
    angle = input("输入发射角度(度): ") 
    v = input("输入初速度(米/秒): ")
    h0 = input("输入初始高度(米): ")
    t = input("输入时间间隔(秒): ") 
    theta = (angle * pi) / 180.0
    xv = v * cos(theta) 
    yv = v * sin(theta) 
    xpos = 0
    ypos = h0
    while ypos >= 0:
        xpos = xpos + t * xv 
        yv1 = yv - t * 9.8
        ypos = ypos + t * (yv + yv1) / 2.0
        yv = yv1
    print "射程: %0.1f 米." % (xpos)
main() 
```

以下是程序 7.4 的一次执行结果：

```py
输入发射角度(度): 56
输入初速度(米/秒): 300
输入初始高度(米): 2
输入时间间隔(秒): 0.1
射程: 8522.1 米. 
```

用写作文打比方的话，程序 7.4 采用的是流水帐式的、毫无章法结构的作文方法，它将所有数据和操作语句全都混在一起。程序虽然不长，却使用了 10 个变量，要想理解这个程序就必须时刻记牢并跟踪这 10 个数据的变化，这对人脑来说是个不小的负担。 模块化程序设计有助于改善程序的结构，增强程序的易理解性。我们利用模块化来重新组织程序 7.3 中的语句，形成一些具有相对独立性的模块（函数）。下面就是炮弹模拟程序的 模块化版本：

【程序 7.5】cball2.py

```py
# -*- coding: cp936 -*- from math import pi,sin,cos
def getInputs():
    a = input("输入发射角度(度): ")
    v = input("输入初速度(米/秒): ")
    h = input("输入初始高度(米): ")
    t = input("输入时间间隔(秒): ") return a,v,h,t
def getXY(v,angle):
    theta = (angle * pi) / 180.0 
    xv = v * cos(theta)
    yv = v * sin(theta) return xv,yv
def update(t,xpos,ypos,xv,yv): xpos = xpos + t * xv
    yv1 = yv - t * 9.8
    ypos = ypos + t * (yv + yv1) / 2.0 
    yv = yv1
    return xpos,ypos,yv
def main():
    angle, v, h0, t = getInputs()
    xv, yv = getXY(v,angle) xpos = 0
    ypos = h0
    while ypos >= 0:
        xpos,ypos,yv = update(t,xpos,ypos,xv,yv) 
    print "射程: %0.1f 米." % (xpos) 
```

与程序 7.4 相比，程序 7.5 的主程序 main 显得非常简洁、容易理解。main 中用到的变量 从 10 个减到 8 个，少掉的两个变量是 theta 和 yv1。变量 theta 存储的是以弧度为单位的发射 角度，它是为了符合 math 库中三角函数的用法而临时创建的中间数据，对程序来说既不是输 入数据，又不是输出数据，也不是贯穿算法始终的关键数据。因此，将 theta 隐藏在用到它的 函数 getXY 中，是符合它的“跑龙套”身份的做法。基于同样的理由，yv1 也被隐藏在了函 数 update 中。

然而，尽管模块化编程改善了程序的结构，使程序易读易理解，但程序 7.5 的主程序仍 然比较复杂。为了描述炮弹的飞行状态，需要 xpos、ypos、xv 和 yv 等 4 个数据，其中 xpos、 ypos 和 yv 是随时间 t 而变的，需要时时更新，这就导致了主循环中的那个复杂、累赘的函数 调用：

```py
xpos,ypos,yv = update(t,xpos,ypos,xv,yv) 
```

函数作为功能黑盒子，应该提供简明易用的接口，而 update 函数的设计显然不够简明易 用，它需要输入 5 个参数，并输出 3 个返回值。这就像一台设计拙劣的电视机，从机壳内伸 出七八根电线，买回家后需要完成复杂的接线之后才能收看电视。请记住，如果函数接口过 于复杂，往往表明这个函数的设计需要改善。

最后，我们用 OOP 来编写炮弹模拟程序。炮弹原本是现实世界中的一个对象，传统编 程方法却用 xpos、ypos、xv 和 yv 等四个分离的数据来描述它，这是典型的“只见树木不见 森林”。假如有一个 Projectile 类来描述炮弹对象，有关炮弹的一切信息和行为都封装在这个 类中，那么在主程序中要做的就是创建一个炮弹对象，然后由这个对象自己完成所有的计算 任务，代码形如：

```py
def main():
    angle, vel, h0, time = getInputs() 
    cball = Projectile(angle, vel, h0) 
    while cball.getY() >= 0:
        cball.update(time)
    print "射程: %0.1f 米." % (cball.getX()) 
```

这段程序的含义是：首先输入炮弹的初始数据 angle、v、h0 以及计算炮弹飞行位置的时间间 隔 t；然后利用这些初始值创建炮弹对象；接着进入主循环，不断请求炮弹更新其位置，直 至炮弹落地。程序中只用到必不可少的 4 个初始数据，其他数据都隐藏在 Projectile 类当中， 这使得程序逻辑非常清晰、易理解。

当然，主程序之所以简单，是因为复杂性都被隐藏在类当中了。下面来考虑 Projectile 类 的定义。前面主程序中实际上已经提出了对类的要求，即类中必须实现 update、getX 和 getY 方法。此外，还必须定义类的构造器。

构造器 __init__ 用于初始化新创建的对象，比如为对象的实例变量赋初值。炮弹对象的实 例变量显然应该包括描述炮弹状态的四个数据：xpos、ypos、xv 和 yv。初始化代码如下：

```py
def __init (self, angle, velocity, height): 
    self.xpos = 0.0
    self.ypos = height
    theta = pi * angle / 180.0 
    self.xv = velocity * cos(theta) 
    self.yv = velocity * sin(theta) 
```

注意变量 theta 的用途是临时性的，其值只在此处用到，别处不需要，因此没有必要将 theta 也作为炮弹对象的实例变量，而应作为普通的局部变量。

方法 getX 和 getY 很简单，分别返回实例变量 self.xpos 和 self.ypos 的当前值即可。

update 方法是最核心的方法，它的任务是更新炮弹在某个时间间隔后的状态。只需传递 一个时间间隔参数 t 给 update 即可，这比程序 7.5 中的 update 简单多了。代码如下：

```py
def update(self,time):
    self.xpos = self.xpos + time * self.xv 
    yv1 = self.yv - time * 9.8
    self.yp = self.yp + t * (self.yv + yv1)/2.0 
    self.yv = yv1 
```

注意 yv1 也是一个普通的临时变量，它的值在下一次循环中就是 yv 的值，因此程序中将其值保存到实例变量 self.yv 中。

至此，我们就完成了 Projectile 类的定义。再添加 getInputs 函数后，就得到完整的面向 对象版本的炮弹模拟程序。

【程序 7.6】cball3.py

```py
from math import pi,sin,cos 
class Projectile:
    def __init__ (self,angle,velocity,height): 
        self.xpos = 0.0
        self.ypos = height
        theta = pi * angle / 180.0 
        self.xv = velocity * cos(theta) 
        self.yv = velocity * sin(theta)
    def update(self, time):
        self.xpos = self.xpos + time * 
        self.xv yv1 = self.yv - 9.8 * time
        self.ypos = self.ypos + time * (self.yv + yv1) / 2.0 
        self.yv = yv1
    def getX(self): 
        return self.xpos
    def getY(self): 
        return self.ypos
def getInputs():
    a = input("输入发射角度(度): ")
    v = input("输入初速度(米/秒): ")
    h = input("输入初始高度(米): ")
    t = input("输入时间间隔(秒): ") return a,v,h,t
def main():
    angle,v,h0,t = getInputs() 
    cball = Projectile(angle,v,h0) 
    while cball.getY() >= 0:
        cball.update(t)
    print "射程: %0.1f 米." % (cball.getX()) 
```

本程序三种版本的设计思想变迁，可以用图 7.10 来刻划。

![](img/程序设计思想与方法 225539.png)

(a) 非模块化过程 (b) 模块化 （c）面向对象

图 7.10 炮弹模拟程序不同设计方法的变迁

# 7.2.5 类与模块化

### 7.2.5 类与模块化

我们在第四章讨论过模块化编程的思想。对于复杂程序，通常需要用分解的方法将程序 划分成若干模块，使每个模块仅针对有限的数据执行有限的操作。模块化能够使复杂程序的 设计更加可控。

对复杂程序一般有两种分解方法：功能分解和数据分解。功能分解是面向过程编程的基 础，依赖于子程序（如函数）概念，以过程为中心来建立功能模块；数据分解则是面向对象 编程的基础，依赖于类的概念，以数据为中心来建立数据模块。

功能模块不太适合复杂数据的处理。以处理“学生”数据的程序为例，如果按功能分解， 需要建立课程注册模块、修改学生信息模块、成绩登录模块等等。每一个模块（函数）的编 写，都需要知道“学生”数据的各种细节。

而数据模块则可以避免功能模块的不足。通过对“学生”的数据和操作的抽象，创建学 生类 S，对学生数据能够执行的操作构成 S 的对外界面，而操作的实现细节则隐藏在 S 内部， 从而使 S 的使用者无需了解“学生”数据的细节就能执行所需操作。

两种模块化方法具有类似的优点，如代码重用、易维护、支持团队开发等，但他们导致 的程序具有完全不同的执行方式。面向对象程序是由很多对象组成的，对象之间通过交互（发 送、接收消息）、协作完成计算任务，而传统程序则是由一系列预定的过程组成的，通过按顺序执行这些过程而完成计算任务。 模块化设计体现了信息隐藏的思想，即程序模块应当对模块用户尽可能隐藏内部细节，只保留必要的访问界面。对功能模块（函数），以 math 库中的函数 sqrt()为例，我们作为调用 者，并不知道该函数的内部实现细节，如数值的表示细节和求平方根的算法细节，而只需要 知道该函数能够对给定的数值求平方根即可。对数据模块（类）同样如此，以程序 7.6 定义 的 Projectile 类为例，该类的使用者无需了解炮弹究竟用什么数据来表示以及如何计算其飞 行，只需要了解该类的使用界面（update、getX、getY）就能编写炮弹模拟程序。

既然类是一种具有独立性的程序模块，就可以单独存储在模块文件中，无需与使用类的 代码（主程序）存储在一个程序文件中。这样做的好处是类模块可以重用，任何想使用这个 类的程序都可以导入类模块。例如，我们可以将 Projectile 类定义单独保存在模块 proj.py 中， 任何希望使用 Projectile 类的程序只需导入它，导入后即可创建对象、执行对象方法。就像下 面这样：

```py
from proj import Projectile
def main():
    angle, vel, h0, time = getInputs() 
    cball = Projectile(angle, vel, h0) 
    while cball.getY() >= 0:
        cball.update(time)
    print "射程: %0.1f 米." % (cball.getX()) 
```

我们当然可以让每个类单独构成一个模块，但这样一来，当类的数目很多时会导致模块 数目过多，反而增加程序的复杂性。实际上我们通常是将若干个相关的类存储在一个模块文 件中，例如 5.4.2 节介绍的 graphics.py 模块中就包含了所有图形类。不过，使用类的程序一 般都放在与类模块不同的模块中。

很多面向对象编程语言都以“类库”的形式提供具有各种实用功能的类模块给程序员使 用，就像过去面向过程编程语言提供“函数库”一样。OOP 往往能非常简单地解决复杂问题， 因为专业的程序员已经开发了大量可重用的代码。

# 7.2.6 对象的集合体

### 7.2.6 对象的集合体

一个复杂数据之“复杂”主要体现在两个方面：要么该数据是由大量成员数据组成的，要么该数据具有深层的内部结构。第六章介绍了如何利用各种集合体数据类型和数据结构来 表示数量复杂性，本章介绍的类则可以刻画内部结构的复杂性。

可以推想，如果将集合体类型与类相结合，就能表示现实中的任意复杂的信息。即，用 集合体表示大量的数据成员，而每个数据成员是一个具有复杂内部结构的对象。我们不妨用 下面的公式来表达这个思想：

```py
类 + 集合体 ＝ 任意复杂的数据 
```

例如，如果程序中要处理的数据是“一群人”，那么我们可以利用一个 Person 对象的列表来表示这一群人。假设我们已经创建了若干个 Person 对象，如 7.2.2 中创建的 p1 和 p2，下 面的代码将这两个对象存储在一个列表 people 中。现在 people 就是一个非常复杂的数据，既 有大量的成员，而且每个成员本身又是复杂的对象。我们可以利用循环语句对复杂数据 people 中的所有成员进行特定处理（如显示姓名和年龄）：

```py
>>> people = [p1, p2]
>>> for p in people:
        p.whatName() 
        p.howOld(2013)
My name is Lucy
My age in 2013 : 8 My name is Tom
My age in 2013 : 23 
```

# 7.3 超类与子类*

## 7.3 超类与子类*

当我们用类去描述现实世界的对象时，有时会发现某些类之间是“一般与特殊”的关系。

例如，“人”与“学生”之间就是一般与特殊的关系，而“学生”与“研究生”也是一般与特 殊的关系。当然，“人”的特殊例子还包括“教师”，“学生”的特殊例子还包括“旁听生”。 总之，通过一般与特殊的关系，可以将所有类组织成为一个层次结构，称为类层次。如图 7.11 所示。

![](img/程序设计思想与方法 227730.png)

图 7.11 类层次

为了描述这种一般与特殊的关系，面向对象语言中提供了相应的类定义方式。具有一般性的类称为超类（superclass），具有特殊性的类称为子类（subclass）①。例如在图 7.11 中， “人”是“学生”的超类，“学生”是“人”的子类；“人”也是“教师”的超类，“教师”是 “人”的子类；“学生”又是“研究生”的超类，“研究生”是“学生”的子类；等等。

# 7.3.1 继承

### 7.3.1 继承

不难理解，子类拥有超类的一切特性，凡是超类适用的地方，子类也适用。例如，“研究 生”具有“学生”的全部属性，包括数据属性（如学号、姓名、年龄）和行为属性（如选课、 参加学生社团等），凡是“学生”能做的，“研究生”都能做。子类拥有超类的全部属性（数 据和方法），这是面向对象方法中极为重要的一个特色，称为继承（inheritance）。

子类除了继承超类的属性，还包含一些自己的特殊属性。例如，“研究生”具有导师信 息，而一般的“学生”未必有导师。在进行面向对象设计时，一般先定义超类，然后在超类 基础上通过添加一些特殊属性来定义子类。这种定义方式下，子类中不必重复定义那些继承 来的属性，从而简化了子类定义。这也是继承机制带来了的另一个重要特色——代码重用（code reuse），即超类中的代码可以通过继承机制被子类重复使用。当我们需要定义一个新 类时，如果发现它与某个现有的类在很多方面都相同，那么就无需重新写代码来实现这些相 同行为，而只需继承现有功能。

> ① 超类/子类也称为基类（base class）/派生类（derived class）。

Python 中定义子类采用如下形式：

```py
class <子类名>(<超类名>):
    <特殊属性 1>
    ...
    <特殊属性 n> 
```

注意，超类与子类的定义一般置于同一个模块中。如果超类在另一个模块中定义，则定义子 类时必须指明模块信息，形如：

```py
class <子类名>(<模块名>.<超类名>):
    ... 
```

下面通过具体例子来说明超类、子类以及继承概念。程序 7.3 中定义了一个 Person 类， 它在最一般的层次上刻划了“人”对象：每个人有姓名和出生年份数据，并且能回答外界提 出的“叫什么名字”、“今年多大了”之类的问题。为便于阅读、比较，我们将 Person 类的定 义复制于此：

```py
class Person:
def __init__ (self,n,y): 
    self.name = n 
    self.year = y
def whatName(self):
    print "My name is",self.name 
def howOld(self,y):
    age = y – self.year 
    if age > 0:
        print "My age in",y,"is",age 
    else:
        print "I was born in",self.year 
```

下面以 Person 作为超类，来定义几种具有特殊属性（数据和行为）的人。 首先定义“学生”。学生是人，因此拥有 Person 类的所有信息。学生还具有一些特殊属性，比如学校、学号信息。按照子类的定义方式，我们可以定义如下的 Student 类：

```py
class Student(Person):
    def __init__ (self,n,y,u,id): 
        Person.__init__ (self,n,y) 
        self.univ = u
        self.snum = id 
    def getUniv(self):
        return self.univ 
    def getNum(self):
        return self.snum 
```

Student 类定义的第一行表明，Student 类是 Person 类的子类。作为特殊的人，学生拥有 普通人不一定有的 self.univ（学校）和 self.snum（学号）数据，因此 Student 类的构造器与 Person 不同，需要四个初始参数：姓名、出生年份、学校和学号。创建 Student 对象时要进 行的初始化工作包括：首先作为 Person 对象要执行 Person 对象的初始化，即 Person.__init ()； 然后再执行 Student 对象特有的初始化工作，即对 self.univ 和 self.snum 两个实例变量进行赋 值。可见，子类的构造器一般是在超类构造器的基础上另外执行一些初始化工作。Student 对象除了能响应 Person 对象都能响应的 whatName 和 howOld 之外，还具有两个特有的方法： getUniv 和 getNum。 我们再来定义另一种特殊的人——教师。假设教师拥有指导的学生人数信息，以及设置和获取这个信息的方法，则可定义 Teacher 类如下：

```py
class Teacher(Person): 
    def setNum(self,n):
        self.snum = n 
    def getNum(self):
        return self.snum 
```

Teacher 类没有定义自己的初始化方法 init**，因此创建 Teacher 对象时将自动调用超类 Person 的 init**方法来进行初始化。Teacher 对象有一个特殊的实例变量 num，但其值不是 在创建对象时初始化的，而是在创建之后利用 setNum 方法来设置。不要忘了，Python 对象 的实例变量可以在任何方法中定义，可以在任何时候赋值。

定义了以上各种类之后，就可以编写使用这些类的程序了。假设 Person、Student 和 Teacher 类定义都存储在模块文件 person.py 之中，下面以交互方式演示对这些类的使用：

```py
>>> from person import *
>>> tom = Student("Tom",1995,"SJTU","S001")
>>> tom.whatName()
My name is Tom
>>> tom.howOld(2013)
My age in 2013 is 18
>>> tom.getUniv()
'SJTU'
>>> print tom.getNum()
S001
>>> huck = Teacher("Huck",1975)
>>> huck.whatName()
My name is Huck
>>> huck.howOld(2013)
My age in 2013 is 38
>>> huck.setNum(8)
>>> print huck.getNum()
8
>>> lucy = Person("Lucy",2005)
>>> lucy.getUniv()
Traceback (most recent call last):
File "&lt;pyshell#4&gt;", line 1, in &lt;module&gt; p.getUniv()
AttributeError: Person instance has no attribute 'getUniv' 
```

子类继承超类的所有属性，因此当创建了 Student 对象 tom 后，就可以向 tom 发消息 whatName 和 howOld，tom 对象能够正确地响应这两个消息。当然还可以向 tom 发送 getUniv 和 getNum 消息，这两个方法是 Student 特有的，tom 自然能做出响应。Teacher 对象 huck 的行为也是类似的。注意，超类的实例并不具有子类中特殊属性，因此上例中向 Person 对象 lucy 发送 getUniv 消息，将导致错误。

# 7.3.2 覆写

### 7.3.2 覆写

子类除了原样继承超类的方法，还可以修改继承来的超类方法，以便以自己的方式行事。 这种在子类中重新定义超类方法的情况是面向对象的又一特色，称为覆写（override，或称重 定义）。

例如，我们来定义另一类特殊的人——娱乐圈明星。娱乐圈明星当然是人，所以他们都 具有 Person 的属性。但明星们一般都很忌讳被问年龄，他们才不会像普通人那样直接回答 howOld 问题。因此，我们在定义 Star 类时需要重新实现 howOld 方法，不能直接使用 Person 中定义的 howOld 的代码。Star 定义如下：

```py
class Star(Person): 
def howOld(self,y):
    print "You guess?" 
def setYear(self,y):
    self.year = y 
```

类 Star 中重新定义了 howOld()方法，将来向 Star 对象发送 howOld 信息时，它就会执行自己 独特的 howOld 方法。当然，如果向 Star 对象发送 whatName 消息，由于明星们在这个问题 上与常人无异，该对象就会去执行原样继承来的超类 Person 中的 whatName 方法。顺便指出， 上述 Star 类定义中还定义了一个特殊方法 setYear，这是为了满足某些明星直接修改自己出生 年份的需求:-)，同时也是为了说明子类既可以覆写从超类继承来的行为，也可以干脆定义新 的行为。下面是 Star 类的使用例子（假设 Star 类定义已经导入）：

```py
>>> liu = Star("Liu",1955)
>>> liu.whatName()
My name is Liu
>>> liu.howOld(2013)
You guess? 
```

注意，覆写是指在子类中重新实现超类的方法，该方法的调用界面（参数和返回值）是 不能改变的。另外，子类中覆写的方法仅适用于子类对象，并不能取代超类中的对应方法。 还用上述例子，当向 Person 类的实例发送 howOld 消息时，仍会执行原来的 howOld 代码。 有趣的是，由于 Star 对象也是 person 对象，我们甚至能强迫 Star 对象执行 Person 中的 howOld 方法来如实回答年龄，做法如下（参见图 7.8）：

```py
>>> Person.howOld(liu,2013)
My age in 2013 is 58 
```

# 7.3.3 多态性

### 7.3.3 多态性

在 7.3.1 中定义的类 Student 和 Teacher 中，有一个同名的方法 getNum。虽然同名，但这 个方法在两个类中的行为是完全不同的：在 Student 中返回的是学号，而在 Teacher 中返回的 是学生人数。因此，当我们向一个对象 obj 发送 getNum 消息时，所得结果取决于 obj 的类型。 在 OOP 中，多个不同类的对象都支持相同的消息，但各对象响应消息的行为不同，这种能 力称为多态性（polymorphism），即同一操作具有不同形态的意思。

其实多态性对我们来说并非很陌生的概念。考虑表达式“a+b”，请问这个表达式执行什么操作？答案是有多种可能。如果 a、b 是数值，则该表达式执行数值加法运算；如果 a、b 是字符串，则该表达式执行字符串合并操作；如果 a、b 是两个二元组，则该表达式执行结果 是一个四元组；等等。像这样，一个操作的含义依赖于被操作的对象，就是多态性。

多态性使得我们能够刻划不同类所提供的相似方法，对使用者来说易理解、易使用，能 够减少编程错误。相反，不同类的相似方法如果定义为不同名字，对使用者来说就很不方便。 例如，在 Windows 环境下，“双击”就是一个多态操作，双击不同对象导致的行为是不同的。 双击可执行文件，能够执行程序；双击 mp3 文件，可以播放音乐；双击窗口标题栏，可以极 大化或恢复窗口大小；等等。用户如果知道“双击”大体上执行“打开”这个动作的话，那 么学习使用 Windows 时就能举一反三。

多态性的一种典型用法是，让处于同一层次的多种对象都能响应同一个消息，但导致的 行为由各对象决定。例如，如果“人”有学生、教师、官员等子类，这些子类就是处于同一 层次的，假设他们都能响应消息 getNum：学生返回自己的学号，教师返回学生人数，官员返 回工资数额。尽管对象行为各不相同，但在编程时我们可以不管这些差别，以一种统一的方 式来处理他们。假设 tom 是个学生，huck 是个教师，jerry 是个官员，则我们可能写出下列代 码来统一处理这些对象：

```py
>>> people = [tom,huck,jerry]
>>> for p in people:
print p.getNum() 
```

# 7.4 面向对象设计*

## 7.4 面向对象设计*

理解了面 向 对象的基 本 概念之后 ， 就可以应 用 这些概念 来 进行面向 对 象 设 计（object-oriented design，简称 OOD）。 传统的程序设计方法是结构化的自顶向下设计，其思想是将软件系统分解为若干个功能，

每个功能都是对数据的一个操作过程。功能又可以划分为若干个子功能，如此反复分解下去， 直至每个功能所对应的操作过程显而易见为止。在分解功能的同时，还要考虑各功能之间的 接口。这种方法是以过程（函数）为中心的，每个函数都是一个黑盒子，函数调用者只需了 解函数的功能，无需知道实现功能的细节。

面向对象设计是以数据为中心来展开的。对于某种客观实体的数据，考虑可能施加在数 据上的各种操作，然后将数据和操作封装成一个黑盒子——对象。对象通过界面向外界提供 数据操作服务，服务的使用者只需了解服务接口，不必关心服务的实现细节。即使改动了对 象内部的实现细节，只要服务接口不变，所有使用该服务的程序代码就不需要改变。同样地， 对象作为服务提供者，也不需要考虑它的服务将被使用者如何使用，只需确保其服务能正确 处理数据即可。

因此，OOD 的中心任务就是设计各种对象，将对象的数据和行为用类定义出来。OOD 将一个复杂问题分解成一组相互协作的类，以类为设计单位可以大大减小设计的复杂性。

下面是 OOD 的一些指导准则。

描述问题

面向对象技术专家 G. Booch 提出了一种基于词性分析的设计方法，该方法要求设计人员 从目标系统的描述出发，通过问题描述中的名词和动词，来发现候选对象及对象方法。因此， OOD 的第一步是要建立待解决问题的准确、无二义性的描述。问题描述应该是自然、客观的， 不要加入人工的、主观的因素，这是因为面向对象思想的宗旨就是按客观世界的本来面目来 建模并开发应用系统。

找出候选对象

我们的目标是找出有助于解决问题的对象。从问题描述入手，找出问题描述中的名词， 然后逐个考察这些名词，看看是否合适作为对象。对象一般都包含一组相关数据项，如学生（包含学号、姓名、年龄等数据项）、课程（包含课程名、学分、教材等数据项）。而能用单 一数据表示的，或者只有单一行为的实体，一般不适合作为对象，如人数、姓名等。

注意，由于人类可以同时考虑和理解的问题数目受到大脑记忆和处理能力的制约，因此 认定的对象数目不宜过多。合适的对象通常是问题中自然出现的而非人工生硬构造的实体， 而且对象应该向外界提供足够复杂的服务。

确定对象的数据属性

对于认定的对象，接下来就该确定对象的数据。能确定为对象数据的信息一般都具有普遍性，即所有同类对象都拥有的数据，例如学生的学号和姓名。另外，对象数据必须对解决 问题有用，例如，学生的学号、姓名都是信息管理应用中必需的信息，而学生的发型可能就 与应用无关。注意，对象的数据可能是学号、姓名这样的基本数据类型值，也有可能是复杂 类型的值，甚至可能是另一种对象。例如，学生选修的课程也是属于学生对象的数据，课程 本身也是对象。

确定对象的行为属性

认定了对象及其数据之后，接着考虑对象需要什么操作。我们从问题描述中找出动词，它们通常描述了对象的行为。例如，“学生选修课程”中的“选修”就是学生对象的行为。对 象的方法通常使用动词来命名。

一类常见的方法是对实例变量的读取和设置方法。假设对象有实例变量 value，则通常应 提供 getValue 和 setValue 方法。这是因为对象数据是隐藏的，外界只能通过对象的方法来操 作对象数据。

对象的方法就是对象向外界提供的界面。界面不完善（如缺少某些方法）会使对象的使 用者无从完成工作，但也不是说向外提供的方法越多越好。对象的界面设计应当遵循恰好够 用的原则，即在能满足用户需要的条件下，界面越简洁越好。

实现对象的方法

有些方法用寥寥数行代码就能实现，有些方法则可能需要设计复杂的算法来实现。对于复杂方法，可以利用自顶向下逐步求精方法来设计。 在方法实现过程中，可能发现一个对象与其他对象之间的新的交互，这会提示我们为类增加新方法，或者增加新的类。

迭代设计

对于复杂程序设计，没有人能够一次性地顺利走过设计全过程。在设计过程中，经常需 要在设计、测试、增加新类或为现有类增加新方法等步骤之间循环往复。

应当多尝试替代方案，即使一个设计方案看上去不太灵，也可以沿着该方案的方向试着 前行，看看会导致什么结果。好的设计一定是通过大量试错而得到的，正是因为错误的设计 才使我们明白应该设计什么样的系统。

最后要指出，上述基于名词动词分析的 OOD 方法只是一个简单的策略，真正进行类的 设计时情况往往很复杂。究竟是否应当设计某个类并没有绝对的设计准则，经常依赖于设计 者的经验。和任何别的设计一样，程序设计既是艺术也是经验，可以通过不断的实践来掌握设计方法。

还要指出，对于小程序，OOD 一般起不了什么作用，说不定反而使编程变得麻烦。但当 编写的程序越来越大，类和对象就能很好地组织程序，减少代码量。

# 7.5 练习

## 7.5 练习

1\. 比较关于数据和操作的两种观点。

2\. 什么是封装？

3\. 类中方法 init 的作用是什么？

4\. 类中方法定义的第一个参数为什么很特殊？

5\. 创建类的实例的过程是怎样的？

6\. 解释实例变量与普通函数局部变量的异同。

7\. 为什么对象集合体能表示任意复杂的数据？

8\. 创建交通工具类，以及汽车、飞机子类。

9\. 读下列代码，给出其执行结果。

```py
class Toy:
    def __init__ (self, value):
        print "Creating a Toy from:", value self.value = 2 * value
    def play(self, x): 
        print "Playing:", x 
        print x * self.value
        return x + self.value 
def main():
    print "Playing around now." 
    t1 = Toy(3)
    t2 = Toy(4) 
    print t1.play(3)
    print t2.play(t1.play(2)) 
main() 
```

10\. 设计实现 Card 类和 Deck 类，Card 实例是一张扑克牌，Deck 实例是一副扑克牌。这两个类应该提供诸如洗牌、发牌等方法。编写主程序来使用这两个类。