# 四、函数

## 函数(1)

函数，对于人类来讲，能够发展到这个数学思维层次，是一个飞跃。可以说，它的提出，直接加快了现代科技和社会的发展，不论是现代的任何科技门类，乃至于经济学、政治学、社会学等，都已经普遍使用函数。

下面一段来自维基百科（在本教程中，大量的定义来自维基百科，因为它真的很百科）：[函数词条](http://zh.wikipedia.org/zh/%E5%87%BD%E6%95%B0)

> 函数这个数学名词是莱布尼兹在 1694 年开始使用的，以描述曲线的一个相关量，如曲线的斜率或者曲线上的某一点。莱布尼兹所指的函数现在被称作可导函数，数学家之外的普通人一般接触到的函数即属此类。对于可导函数可以讨论它的极限和导数。此两者描述了函数输出值的变化同输入值变化的关系，是微积分学的基础。
> 
> 中文的“函数”一词由清朝数学家李善兰译出。其《代数学》书中解释：“凡此變數中函（包含）彼變數者，則此為彼之函數”。

函数，从简单到复杂，各式各样。前面提供的维基百科中的函数词条，里面可以做一个概览。但不管什么样子的函数，都可以用下图概括：

![](img/20101.png)

有初中数学水平都能理解一个大概了。这里不赘述。

本讲重点说明用 Python 怎么来构造一个函数。

### 深入理解函数

在中学数学中，可以用这样的方式定义函数：y=4x+3，这就是一个一次函数，当然，也可以写成：f(x)=4x+3。其中 x 是变量，它可以代表任何数。

```py
当 x=2 时，代入到上面的函数表达式：
f(2) = 4*2+3 = 11
所以：f(2) = 11 
```

但是，这并不是函数的全部，在函数中，其实变量并没有规定只能是一个数，它可以是馒头、还可是苹果，不知道读者是否对函数有这个层次的理解。请继续阅读即更深刻

#### 变量不仅仅是数

变量 x 只能是任意数吗？其实，一个函数，就是一个对应关系。看官尝试着将上面表达式的 x 理解为馅饼，4x+3,就是 4 个馅饼在加上 3（一般来讲，单位是统一的，但你非让它不统一，也无妨），这个结果对应着另外一个东西，那个东西比如说是 iphone。或者说可以理解为 4 个馅饼加 3 就对应一个 iphone。这就是所谓映射关系。

所以，x，不仅仅是数，可以是你认为的任何东西。

#### 变量本质——占位符

函数中为什么变量用 x？这是一个有趣的问题，自己 google 一下，看能不能找到答案。

我也不清楚原因。不过，我清楚地知道，变量可以用 x，也可以用别的符号，比如 y,z,k,i,j...，甚至用 alpha,beta 这样的字母组合也可以。

**变量在本质上就是一个占位符。**这是一针见血的理解。什么是占位符？就是先把那个位置用变量占上，表示这里有一个东西，至于这个位置放什么东西，以后再说，反正先用一个符号占着这个位置（占位符）。

其实在高级语言编程中，变量比我们在初中数学中学习的要复杂。但是，先不管那些，复杂东西放在以后再说了。现在，就按照初中数学来研究 Python 中的变量。

通常使小写字母来命名 Python 中的变量，也可以在其中加上下划线什么的，表示区别。

比如：alpha,x,j,p_beta，这些都可以做为 Python 的变量。

### 建立简单函数

```py
>>> a = 2
>>> y=3*a+2
>>> y
8 
```

这种方式建立的函数，跟在初中数学中学习的没有什么区别。当然，这种方式的函数，在编程实践中的用途不大，一般是在学习阶段理解函数来使用的。

别急躁，你在输入 a=3,然后输入 y，看看得到什么结果呢？

```py
>>> a=2
>>> y=3*a+2
>>> y
8
>>> a=3
>>> y
8 
```

是不是很奇怪？为什么后面已经让 a 等于 3 了，结果 y 还是 8。

还记得前面已经学习过的关于“变量赋值”的原理吗？`a=2` 的含义是将 2 这个对象贴上了变量 a 标签，经过计算，得到了 8，之后变量 y 引用了对象 8。当变量 a 引用的对象修改为 3 的时候，但是 y 引用的对象还没有变，所以，还是 8。再计算一次，y 的连接对象就变了：

```py
>>> a=3
>>> y
8
>>> y=3*a+2
>>> y
11 
```

特别注意，如果没有先 a=2，就直接下函数表达式了，像这样，就会报错。

```py
>>> y=3*a+2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  NameError: name 'a' is not defined 
```

注意看错误提示，a 是一个变量，提示中告诉我们这个变量没有定义。显然，如果函数中要使用某个变量，不得不提前定义出来。定义方法就是给这个变量赋值。

### 建立实用的函数

上面用命令方式建立函数，还不够“正规化”，那么就来写一个.py 文件吧。

例如下面的代码：

```py
#!/usr/bin/env python
#coding:utf-8

def add_function(a,b):
    c = a + b
    print c

if __name__ == "__main__":
    add_function(2,3) 
```

然后将文件保存，我把她命名为 20101.py，你根据自己的喜好取个名字。

然后我就进入到那个文件夹，运行这个文件，出现下面的结果，如图：

![](img/20102.png)

你运行的结果是什么？如果没有得到上面的结果，你就非常认真地检查代码，是否跟我写的完全一样，注意，包括冒号和空格，都得一样。**冒号和空格很重要。**

下面开始庖丁解牛：

*   `def add_function(a,b)`: 这里是函数的开始。在声明要建立一个函数的时候，一定要使用 def（def 就是英文 define 的前三个字母），意思就是告知计算机，这里要声明一个函数；add_function 是这个函数名称，取名字是有讲究的，就好比你的名字一样。在 Python 中取名字的讲究就是要有一定意义，能够从名字中看出这个函数是用来干什么的。从 add_function 这个名字中，是不是看出她是用来计算加法的呢（严格地说，是把两个对象“相加”，这里相加的含义是比较宽泛的，包括对字符串等相加）？(a,b)这个括号里面的是这个函数的参数，也就是函数变量。冒号，这个冒号非常非常重要，如果少了，就报错了。冒号的意思就是下面好开始真正的函数内容了。
*   `c=a+b` 特别注意，这一行比上一行要缩进四个空格。这是 Python 的规定，要牢记，不可丢掉，丢了就报错。然后这句话就是将两个参数(变量)相加，结果赋值与另外一个变量 c。
*   `print c` 还是提醒看官注意，缩进四个空格。将得到的结果 c 的值打印出来。
*   `if __name__=="__main__"`: 这句话先照抄，不解释，因为在《自省》有说明，不知道你是不是认真阅读了。注意就是不缩进了。
*   add_function(2,3) 这才是真正调用前面建立的函数，并且传入两个参数：a=2,b=3。仔细观察传入参数的方法，就是把 2 放在 a 那个位置，3 放在 b 那个位置（所以说，变量就是占位符).

解牛完毕，做个总结：

定义函数的格式为：

```py
def 函数名(参数 1，参数 2，...，参数 n)：

    函数体（语句块） 
```

是不是样式很简单呢？

几点说明：

*   函数名的命名规则要符合 Python 中的命名要求。一般用小写字母和单下划线、数字等组合
*   def 是定义函数的关键词，这个简写来自英文单词 define
*   函数名后面是圆括号，括号里面，可以有参数列表，也可以没有参数
*   千万不要忘记了括号后面的冒号
*   函数体（语句块），相对于 def 缩进，按照 Python 习惯，缩进四个空格

看简单例子，深入理解上面的要点：

```py
>>> def name():         #定义一个无参数的函数，只是通过这个函数打印
...     print "qiwsir"  #缩进 4 个空格
... 
>>> name()              #调用函数，打印结果
qiwsir

>>> def add(x,y):       #定义一个非常简单的函数
...     return x+y      #缩进 4 个空格
... 
>>> add(2,3)            #通过函数，计算 2+3
5 
```

注意上面的 add(x,y)函数，在这个函数中，没有特别规定参数 x,y 的类型。其实，这句话本身就是错的，还记得在前面已经多次提到，在 Python 中，变量无类型，只有对象才有类型，这句话应该说成：x,y 并没有严格规定其所引用的对象类型。这是 Python 跟某些语言比如 java 很大的区别，在有些语言中，需要在定义函数的时候告诉函数参数的数据类型。Python 不用那样做。

为什么？列位不要忘记了，这里的所谓参数，跟前面说的变量，本质上是一回事。只有当用到该变量的时候，才建立变量与对象的对应关系，否则，关系不建立。而对象才有类型。那么，在 add(x,y) 函数中，x,y 在引用对象之前，是完全飘忽的，没有被贴在任何一个对象上，换句话说它们有可能引用任何对象，只要后面的运算许可，如果后面的运算不许可，则会报错。

```py
>>> add("qiw","sir")    #这里，x="qiw",y="sir"，让函数计算 x+y,也就是"qiw"+"sir"
'qiwsir'

>>> add("qiwsir",4)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in add
TypeError: cannot concatenate 'str' and 'int' objects  #仔细阅读报错信息，就明白错误之处了 
```

从实验结果中发现：x+y 的意义完全取决于对象的类型。在 Python 中，将这种依赖关系，称之为**多态**。对于 Python 中的多态问题，以后还会遇到，这里仅仅以此例子显示一番。请看官要留心注意的：**Python 中为对象编写接口，而不是为数据类型。**读者先留心一下这句话，或者记住它，随着学习的深入，会领悟到其真谛的。

此外，也可以将函数通过赋值语句，与某个变量建立引用关系：

```py
>>> result = add(3,4)
>>> result
7 
```

在这里，其实解释了函数的一个秘密。add(x,y) 在被运行之前，计算机内是不存在的，直到代码运行到这里的时候，在计算机中，就建立起来了一个对象，这就如同前面所学习过的字符串、列表等类型的对象一样，运行 add(x,y) 之后，也建立了一个 add(x,y) 的对象，这个对象与变量 result 可以建立引用关系，并且 add(x,y) 将运算结果返回。于是，通过 result 就可以查看运算结果。

如果看官上面一段，感觉有点吃力或者晕乎，也不要紧，那就再读一边。是在搞不明白，就不要搞了。随着学习的深入，它会被明白的。

### 关于命名

到现在为止，我们已经接触过变量的命名、函数的命名问题。似乎已经到了将命名问题进行总结的时候了。

在某国，向来重视“名”，所谓“名不正言不顺”，取名字或者给什么东西命名，常常是天大的事情，在很多时候就是为了那个“名”进行争斗。

江湖上还有的大师，会通过某个人的名字来预测他/她的吉凶祸福等。看来名字这玩意太重要了。“名不正，言不顺”，歪解：名字不正规化，就不顺。这是歪解，希望不要影响看官正确理解。不知道大师们是不是能够通过外国人名字预测外国人大的吉凶祸福呢？

不管怎样，某国人是很在意名字的，旁边有个国家似乎就不在乎。

Python 也很在乎名字问题，其实，所有高级语言对名字都有要求。为什么呢？因为如果命名乱了，计算机就有点不知所措了。看 Python 对命名的一般要求。

*   文件名:全小写,可使用下划线

*   函数名:小写，可以用下划线风格单词以增加可读性。如：myfunction，my_example_function。*注意*：混合大小写仅被允许用于这种风格已经占据优势的时候，以便保持向后兼容。有的人，喜欢用这样的命名风格：myFunction，除了第一个单词首字母外，后面的单词首字母大写。这也是可以的，因为在某些语言中就习惯如此。

*   函数的参数：如果一个函数的参数名称和保留的关键字(所谓保留关键字，就是 Python 语言已经占用的名称，通常被用来做为已经有的函数等的命名了，你如果还用，就不行了。)冲突，通常使用一个后缀下划线好于使用缩写或奇怪的拼写。

*   变量:变量名全部小写，由下划线连接各个单词。如 color = WHITE，this_is_a_variable = 1。

其实，关于命名的问题，还有不少争论呢？最典型的是所谓匈牙利命名法、驼峰命名等。如果你喜欢，可以 google 一下。以下内容供参考：

*   [匈牙利命名法](http://zh.wikipedia.org/zh/%E5%8C%88%E7%89%99%E5%88%A9%E5%91%BD%E5%90%8D%E6%B3%95)
*   [驼峰式大小写](http://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB)
*   [帕斯卡命名法](http://zh.wikipedia.org/w/index.php?title=%E5%B8%95%E6%96%AF%E5%8D%A1%E5%91%BD%E5%90%8D%E6%B3%95&variant=zh-cn)
*   [Python 命名的官方要求](http://legacy.python.org/dev/peps/pep-0008/#prescriptive-naming-conventions)，如果看官的英文可以，一定要阅读。如果英文稍逊，可以来阅读[中文](http://wiki.jiayun.org/PEP_8_--_Style_Guide_for_Python_Code#.E5.91.BD.E5.90.8D.E6.85.A3.E4.BE.8B),不用梯子能行吗？看你命了。

### 调用函数

前面的例子中已经有了一些关于调用的问题，为了深入理解，把这个问题单独拿出来看看。

为什么要写函数？从理论上说，不用函数，也能够编程，我们在前面已经写了程序，就没有写函数，当然，用 Python 的内建函数姑且不算了。现在之所以使用函数，主要是：

1.  降低编程的难度，通常将一个复杂的大问题分解成一系列更简单的小问题，然后将小问题继续划分成更小的问题，当问题细化为足够简单时，就可以分而治之。为了实现这种分而治之的设想，就要通过编写函数，将各个小问题逐个击破，再集合起来，解决大的问题。（看官请注意，分而治之的思想是编程的一个重要思想，所谓“分治”方法也。）
2.  代码重(chong，二声音)用。在编程的过程中，比较忌讳同样一段代码不断的重复，所以，可以定义一个函数，在程序的多个位置使用，也可以用于多个程序。当然，后面我们还会讲到“模块”（此前也涉及到了，就是 import 导入的那个东西），还可以把函数放到一个模块中供其他程序员使用。也可以使用其他程序员定义的函数（比如 import ...,前面已经用到了，就是应用了别人——创造 Python 的人——写好的函数）。这就避免了重复劳动，提供了工作效率。

这样看来，函数还是很必要的了。废话少说，那就看函数怎么调用吧。以 add(x,y) 为例，前面已经演示了基本调用方式，此外，还可以这样：

```py
>>> def add(x,y):       #为了能够更明了显示参数赋值特点，重写此函数
...     print "x=",x    #分别打印参数赋值结果
...     print "y=",y
...     return x+y
... 
>>> add(10,3)           #x=10,y=3
x= 10
y= 3
13

>>> add(3,10)           #x=3,y=10
x= 3
y= 10
13 
```

所谓调用，最关键是要弄清楚如何给函数的参数赋值。这里就是按照参数次序赋值，根据参数的位置，值与之对应。

```py
>>> add(x=10,y=3)       #同上
x= 10
y= 3
13 
```

还可以直接把赋值语句写到里面，就明确了参数和对象的关系。当然，这时候顺序就不重要了，也可以这样

```py
>>> add(y=10,x=3)       #x=3,y=10
x= 3
y= 10
13 
```

在定义函数的时候，参数可以像前面那样，等待被赋值，也可以定义的时候就赋给一个默认值。例如：

```py
>>> def times(x,y=2):       #y 的默认值为 2
...     print "x=",x
...     print "y=",y
...     return x*y
... 
>>> times(3)                #x=3,y=2
x= 3
y= 2
6

>>> times(x=3)              #同上
x= 3
y= 2
6 
```

如果不给那个有默认值的参数传递值（赋值的另外一种说法），那么它就是用默认的值。如果给它传一个，它就采用新赋给它的值。如下：

```py
>>> times(3,4)              #x=3,y=4,y 的值不再是 2
x= 3
y= 4
12

>>> times("qiwsir")         #再次体现了多态特点
x= qiwsir
y= 2
'qiwsirqiwsir' 
```

给列位看官提一个思考题，请在闲暇之余用 Python 完成：写两个数的加、减、乘、除的函数，然后用这些函数，完成简单的计算。

### 注意事项

下面的若干条，是常见编写代码的注意事项：

1.  别忘了冒号。一定要记住符合语句首行末尾输入“：”（if,while,for 等的第一行）
2.  从第一行开始。要确定顶层（无嵌套）程序代码从第一行开始。
3.  空白行在交互模式提示符下很重要。模块文件中符合语句内的空白行常被忽视。但是，当你在交互模式提示符下输入代码时，空白行则是会结束语句。
4.  缩进要一致。避免在块缩进中混合制表符和空格。
5.  使用简洁的 for 循环，而不是 while or range.相比，for 循环更易写，运行起来也更快
6.  要注意赋值语句中的可变对象。
7.  不要期待在原处修改的函数会返回结果,比如 list.append()，这在可修改的对象中特别注意
8.  调用函数是，函数名后面一定要跟随着括号，有时候括号里面就是空空的，有时候里面放参数。
9.  不要在导入和重载中使用扩展名或路径。

以上各点如果有不理解的，也不要紧，在以后编程中，是不是地回来复习一下，能不断领悟其内涵。

* * *

总目录

如果你认为有必要打赏我，请通过支付宝：**qiwsir@126.com**,不胜感激。

## 函数(2)

在上一节中，已经明确了函数的基本结构和初步的调用方法。但是，上一节中写的函数，还有点缺憾，不知道读者是否觉察到了。我把结果是用 `print` 语句打印出来的。这是实际编程中广泛使用的吗？肯定不是。因为函数在编程中，起到一段具有抽象价值的代码作用，一般情况下，用它得到一个结果，这个结果要用在其它的运算中。所以，不能仅仅局限在把某个结果打印出来。所以，函数必须返回一个结果。

结论：函数要有返回值，也必须有返回值。

### 返回值

为了能够说明清楚，先编写一个函数。还记得斐波那契数列吗？我打算定义一个能够得到斐波那契数列的函数，从而实现可以实现任意的数列。你先想想，要怎么写？

参考代码：

```py
#!/usr/bin/env Python
# coding=utf-8

def fibs(n):
    result = [0,1]
    for i in range(n-2):
        result.append(result[-2] + result[-1])
    return result

if __name__ == "__main__":
    lst = fibs(10)
    print lst 
```

把含有这些代码的文件保存为名为 20202.py 的文件。在这个文件中，首先定义了一个函数，名字叫做 fibs，其参数是输入一个整数。在后面，通过 `lst = fibs(10)` 调用这个函数。这里参数给的是 10，就意味着要得到 n=10 的斐波那契数列。

运行后打印数列：

```py
$ python 20202.py
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 
```

当然，如果要换 n 的值，只需要在调用函数的时候，修改一下参数即可。这才体现出函数的优势呢。

观察 fibs 函数，最后有一个语句 `return result`，意思是将变量 result 的值返回。返回给谁呢？一般这类函数调用的时候，要通过类似 `lst = fibs(10)` 的语句，那么返回的那个值，就被变量 lst 贴上了，通过 lst 就能得到该值。如果没有这个赋值语句，虽然函数照样返回值，但是它飘忽在内存中，我们无法得到，并且最终还被当做垃圾被 Python 回收了。

注意：上面的函数之返回了一个返回值（是一个列表），有时候需要返回多个，是以元组形式返回。

```py
>>> def my_fun():
...     return 1,2,3
... 
>>> a = my_fun()
>>> a
(1, 2, 3) 
```

有的函数，没有 renturn，一样执行完毕，就算也干了某些活儿吧。事实上，不是没有返回值，也有，只不过是 None。比如这样一个函数：

```py
>>> def my_fun():
...     print "I am doing somthin."
... 
```

我在交互模式下构造一个很简单的函数，注意，我这是构造了一个简单函数，如果是复杂的，千万不要在交互模式下做。如果你非要做，是能尝到苦头的。

这个函数的作用就是打印出一段话。也就是执行这个函数，就能打印出那段话，但是没有 return。

```py
>>> a = my_fun()
I am doing somthin. 
```

我们再看看那个变量 a，到底是什么

```py
>>> print a
None 
```

这就是这类只干活儿，没有 `return` 的函数，返回给变量的是一个 `None`。这种模样的函数，通常不用上述方式调用，而采用下面的方式，因为他们返回的是 None，似乎这个返回值利用价值不高，于是就不用找一个变量来接受返回值了。

```py
>>> my_fun()
I am doing somthin. 
```

特别注意那个 return，它还有一个作用。观察下面的函数和执行结果，看看能不能发现它的另外一个作用。

```py
>>> def my_fun():
...     print "I am coding."
...     return
...     print "I finished."
... 
>>> my_fun()
I am coding. 
```

看出玄机了吗？在函数中，本来有两个 print 语句，但是中间插入了一个 return，仅仅是一个 return。当执行函数的时候，只执行了第一个 print 语句，第二个并没有执行。这是因为第一个之后，遇到了 return，它告诉函数要返回，即中断函数体内的流程，离开这个函数。结果第二个 print 就没有被执行。所以，return 在这里就有了一个作用，结束正在执行的函数。有点类似循环中的 break 的作用。

### 函数中的文档

“程序在大多数情况下是给人看的，只是偶尔被机器执行以下。”所以，写程序必须要写注释。前面已经有过说明，如果用 `#` 开始，Python 就不执行那句（Python 看不到它，但是人能看到），它就作为注释存在。

除了这样的一句之外，一般在每个函数名字的下面，还要写一写文档，以此来说明这个函数的用途。

```py
#!/usr/bin/env python
# coding=utf-8

def fibs(n):
    """
    This is a Fibonacci sequence.
    """
    result = [0,1]
    for i in range(n-2):
        result.append(result[-2] + result[-1])
    return result

if __name__ == "__main__":
    lst = fibs(10)
    print lst 
```

在这个函数的名称下面，用三个引号的方式，包裹着对这个函数的说明，那个就是函数文档。

还记得在《自省》那节中，提到的`__doc__`吗？对于函数，它的内容就来自这里。

```py
>>> def my_fun():
...     """
...     This is my function.
...     """
...     print "I am a craft."
... 
>>> my_fun.__doc__
'\n    This is my function.\n    ' 
```

如果在交互模式中用 `help(my_fun)` 得到的也是三个引号所包裹的文档信息。

```py
Help on function my_fun in module __main__:

my_fun()
    This is my function. 
```

### 参数和变量

#### 参数

虽然在上一节，已经知道如何通过函数的参数传值，如何调用函数等。但是，这里还有必要进一步讨论参数问题。在别的程序员嘴里，你或许听说过“形参”、“实参”、“参数”等名词，到底指什么呢？

> 在定义函数的时候（def 来定义函数，称为 def 语句），函数名后面的括号里如果有变量，它们通常被称为“形参”。调用函数的时候，给函数提供的值叫做“实参”，或者“参数”。

其实，根本不用区分这个，因为没有什么意义，只不过类似孔乙己先生知道茴香豆的茴字有多少种写法罢了。但是，我居然碰到过某公司面试官问这种问题。

**在本教程中，把那个所谓实参，就称之为值（或者数据、或者对象），形参就笼统称之为参数（似乎不很合理，但是接近数学概念）。**

#### 比较参数和变量

参数问题就算说明白了，糊涂就糊涂吧，也没有什么关系。不过，对于变量和参数，这两个就不能算糊涂账了。因为它容易让人糊涂了。

在数学的函数中 `y = 3x + 2`,那个 x 叫做参数，也可以叫做变量。但是，在编程语言的函数中，与此有异。

先参考一段来自[微软网站](http://msdn.microsoft.com/zh-cn/library/9kewt1b3.aspx)的比较高度抽象，而且意义涵盖深远的说明。我摘抄过来，看官读一读，是否理解，虽然是针对 VB 而言的，一样有启发。

> 参数和变量之间的差异 (Visual Basic)
> 
> 多数情况下，过程必须包含有关调用环境的一些信息。执行重复或共享任务的过程对每次调用使用不同的信息。此信息包含每次调用过程时传递给它的变量、常量和表达式。
> 
> 若要将此信息传递给过程，过程先要定义一个形参，然后调用代码将一个实参传递给所定义的形参。 您可以将形参当作一个停车位，而将实参当作一辆汽车。 就像一个停车位可以在不同时间停放不同的汽车一样，调用代码在每次调用过程时可以将不同的实参传递给同一个形参。
> 
> 形参表示一个值，过程希望您在调用它时传递该值。
> 
> 当您定义 Function 或 Sub 过程时，需要在紧跟过程名称的括号内指定形参列表。对于每个形参，您可以指定名称、数据类型和传入机制（ByVal (Visual Basic) 或 ByRef (Visual Basic)）。您还可以指示某个形参是可选的。这意味着调用代码不必传递它的值。
> 
> 每个形参的名称均可作为过程内的局部变量。形参名称的使用方法与其他任何变量的使用方法相同。
> 
> 实参表示在您调用过程时传递给过程形参的值。调用代码在调用过程时提供参数。
> 
> 调用 Function 或 Sub 过程时，需要在紧跟过程名称的括号内包括实参列表。每个实参均与此列表中位于相同位置的那个形参相对应。
> 
> 与形参定义不同，实参没有名称。每个实参就是一个表达式，它包含零或多个变量、常数和文本。求值的表达式的数据类型通常应与为相应形参定义的数据类型相匹配，并且在任何情况下，该表达式值都必须可转换为此形参类型。

看官如果硬着头皮看完这段引文，发现里面有几个关键词：参数、变量、形参、实参。本来想弄清楚参数和变量，结果又冒出另外两个东东，更混乱了。请稍安勿躁，本来这段引文就是有点多余，但是，之所以引用，就是让列位开阔一下眼界，在编程业界，类似的东西有很多名词。下次听到有人说这些，不用害怕啦，反正自己听过了。

在 Python 中，没有这么复杂。

看完上面让人晕头转向的引文之后，再看下面的代码，就会豁然开朗了。

```py
>>> def add(x):     #x 是参数，准确说是形参
...     a = 10      #a 是变量
...     return a+x  #x 就是那个形参作为变量，其本质是要传递赋给这个函数的值
... 
>>> x = 3           #x 是变量，只不过在函数之外
>>> add(x)          #这里的 x 是参数，但是它由前面的变量 x 传递对象 3
13
>>> add(3)          #把上面的过程合并了
13 
```

至此，看官是否清楚了一点点。当然，我所表述不正确之处或者理解错误之处，也请看官不吝赐教，小可作揖感谢。

其实没有那么复杂。关键要理解函数名括号后面的东东（管它什么参呢）的作用是传递值。

### 全局变量和局部变量

下面是一段代码，注意这段代码中有一个函数 funcx()，这个函数里面有一个变量 x=9，在函数的前面也有一个变量 x=2

```py
x = 2

def funcx():
    x = 9
    print "this x is in the funcx:-->",x

funcx()
print "--------------------------"
print "this x is out of funcx:-->",x 
```

那么，这段代码输出的结果是什么呢？看：

```py
this x is in the funcx:--> 9
--------------------------
this x is out of funcx:--> 2 
```

从输出看出，运行 funcx()，输出了 funcx() 里面的变量 x=9；然后执行代码中的最后一行，print "this x is out of funcx:-->",x

特别要关注的是，前一个 x 输出的是函数内部的变量 x;后一个 x 输出的是函数外面的变量 x。两个变量彼此没有互相影响，虽然都是 x。从这里看出，两个 x 各自在各自的领域内起到作用。

把那个只在函数体内（某个范围内）起作用的变量称之为**局部变量**。

有局部，就有对应的全部，在汉语中，全部变量，似乎有歧义，幸亏汉语丰富，于是又取了一个名词：**全局变量**

```py
x = 2
def funcx():
    global x    #跟上面函数的不同之处
    x = 9
    print "this x is in the funcx:-->",x

funcx()
print "--------------------------"
print "this x is out of funcx:-->",x 
```

以上两段代码的不同之处在于，后者在函数内多了一个 `global x`，这句话的意思是在声明 x 是全局变量，也就是说这个 x 跟函数外面的那个 x 同一个，接下来通过 x=9 将 x 的引用对象变成了 9。所以，就出现了下面的结果。

```py
this x is in the funcx:--> 9
--------------------------
this x is out of funcx:--> 9 
```

好似全局变量能力很强悍，能够统帅函数内外。但是，要注意，这个东西要慎重使用，因为往往容易带来变量的换乱。内外有别，在程序中一定要注意的。

### 命名空间

这是一个比较不容易理解的概念，特别是对于初学者而言，似乎它很飘渺。我在维基百科中看到对它的定义，不仅定义比较好，连里面的例子都不错。所以，抄录下来，帮助读者理解这个名词。

> 命名空间（英语：Namespace）表示标识符（identifier）的可见范围。一个标识符可在多个命名空间中定义，它在不同命名空间中的含义是互不相干的。这样，在一个新的命名空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其它命名空间中。
> 
> 例如，设 Bill 是 X 公司的员工，工号为 123，而 John 是 Y 公司的员工，工号也是 123。由于两人在不同的公司工作，可以使用相同的工号来标识而不会造成混乱，这里每个公司就表示一个独立的命名空间。如果两人在同一家公司工作，其工号就不能相同了，否则在支付工资时便会发生混乱。
> 
> 这一特点是使用命名空间的主要理由。在大型的计算机程序或文档中，往往会出现数百或数千个标识符。命名空间（或类似的方法，见“命名空间的模拟”一节）提供一隐藏区域标识符的机制。通过将逻辑上相关的标识符组织成相应的命名空间，可使整个系统更加模块化。
> 
> 在编程语言中，命名空间是对作用域的一种特殊的抽象，它包含了处于该作用域内的标识符，且本身也用一个标识符来表示，这样便将一系列在逻辑上相关的标识符用一个标识符组织了起来。许多现代编程语言都支持命名空间。在一些编程语言（例如 C++ 和 Python）中，命名空间本身的标识符也属于一个外层的命名空间，也即命名空间可以嵌套，构成一个命名空间树，树根则是无名的全局命名空间。
> 
> 函数和类的作用域可被视作隐式命名空间，它们和可见性、可访问性和对象生命周期不可分割的联系在一起。

显然，用“命名空间”或者“作用域”这样的名词，就是因为有了函数（后面还会有类）之后，在函数内外都可能有外形一样的符号（标识符），在 Python 中（乃至于其它高级语言），通常就是变量，为了区分此变量非彼变量（虽然外形一样），需要用这样的东西来框定每个变量所对应的值（发生作用的范围）。

前面已经讲过，变量和对象（就是所变量所对应的值）之间的关系是：变量类似标签，贴在了对象上。也就是，通过赋值语句实现了一个变量标签对应一个数据对象（值），这种对应关系让你想起了什么？映射！Python 中唯一的映射就是 dict，里面有“键值对”。变量和值得关系就有点像“键”和“值”的关系。有一个内建函数 vars，可以帮助我们研究一下这种对应关系。

```py
>>> x = 7
>>> scope = vars()
>>> scope['x']
7
>>> scope['x'] += 1
>>> x
8
>>> scope['x']
8 
```

既然如此，诚如前面的全局变量和局部变量，即使是同样一个变量名称。但是它在不同范围（还是用“命名空间”这个词是不是更专业呢？）对应不同的值。

* * *

总目录

如果你认为有必要打赏我，请通过支付宝：**qiwsir@126.com**,不胜感激。

## 函数(3)

在设计函数的时候，有时候我们能够确认参数的个数，比如一个用来计算圆面积的函数，它所需要的参数就是半径（πr²），这个函数的参数是确定的。

> 你能不能写一个能够计算圆面积的函数呢？

然而，这个世界不总是这么简单的，也不总是这么确定的，反而不确定性是这个世界常常存在的。如果看官了解量子力学——好多人听都没有听过的东西——就更理解真正的不确定性了。当然，不用研究量子力学也一样能够体会到，世界充满里了不确定性。不是吗？塞翁失马焉知非福，这不就是不确定性吗？

### 参数收集

既然有很多不确定性，那么函数的参数的个数，也当然有不确定性，函数怎么解决这个问题呢？Python 用这样的方式解决参数个数的不确定性：

```py
def func(x,*arg):
    print x         #输出参数 x 的值
    result = x
    print arg       #输出通过 *arg 方式得到的值
    for i in arg:
        result +=i
    return result

print func(1,2,3,4,5,6,7,8,9)    #赋给函数的参数个数不仅仅是  2 个 
```

运行此代码后，得到如下结果：

```py
1                       #这是函数体内的第一个 print，参数 x 得到的值是 1
(2, 3, 4, 5, 6, 7, 8, 9) #这是函数内的第二个 print，参数 arg 得到的是一个元组
45                      #最后的计算结果 
```

从上面例子可以看出，如果输入的参数个数不确定，其它参数全部通过 *arg，以元组的形式由 arg 收集起来。对照上面的例子不难发现：

*   值 1 传给了参数 x
*   值 2,3,4,5,6.7.8.9 被塞入一个 tuple 里面，传给了 arg

为了能够更明显地看出 *args（名称可以不一样，但是 * 符号必须要有），可以用下面的一个简单函数来演示：

```py
>>> def foo(*args):
...     print args      #打印通过这个参数得到的对象
... 
```

下面演示分别传入不同的值，通过参数 *args 得到的结果：

```py
>>> foo(1,2,3)
(1, 2, 3)

>>> foo("qiwsir","qiwsir.github.io","python")
('qiwsir', 'qiwsir.github.io', 'python')

>>> foo("qiwsir",307,["qiwsir",2],{"name":"qiwsir","lang":"python"})
('qiwsir', 307, ['qiwsir', 2], {'lang': 'python', 'name': 'qiwsir'}) 
```

不管是什么，都一股脑地塞进了 tuple 中。

```py
>>> foo("python")
('python',) 
```

即使只有一个值，也是用 tuple 收集它。特别注意，在 tuple 中，如果只有一个元素，后面要有一个逗号。

还有一种可能，就是不给那个 `*args` 传值，也是许可的。例如：

```py
>>> def foo(x, *args):
...     print "x:",x
...     print "tuple:",args
... 
>>> foo(7)
x: 7
tuple: () 
```

这时候 `*args` 收集到的是一个空的 tuple。

> 在各类编程语言中，常常会遇到以 foo，bar，foobar 等之类的命名，不管是对变量、函数还是后面要讲到的类。这是什么意思呢？下面是来自维基百科的解释。
> 
> 在计算机程序设计与计算机技术的相关文档中，术语 foobar 是一个常见的无名氏化名，常被作为“伪变量”使用。
> 
> 从技术上讲，“foobar”很可能在 1960 年代至 1970 年代初通过迪吉多的系统手册传播开来。另一种说法是，“foobar”可能来源于电子学中反转的 foo 信号；这是因为如果一个数字信号是低电平有效（即负压或零电压代表“1”），那么在信号标记上方一般会标有一根水平横线，而横线的英文即为“bar”。在《新黑客辞典》中，还提到“foo”可能早于“FUBAR”出现。
> 
> 单词“foobar”或分离的“foo”与“bar”常出现于程序设计的案例中，如同 Hello World 程序一样，它们常被用于向学习者介绍某种程序语言。“foo”常被作为函数／方法的名称，而“bar”则常被用作变量名。

除了用 *args 这种形式的参数接收多个值之外，还可以用 **kargs 的形式接收数值，不过这次有点不一样：

```py
>>> def foo(**kargs):
...     print kargs
...
>>> foo(a=1,b=2,c=3)    #注意观察这次赋值的方式和打印的结果
{'a': 1, 'c': 3, 'b': 2} 
```

如果这次还用 foo(1,2,3)的方式，会有什么结果呢？

```py
>>> foo(1,2,3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: foo() takes exactly 0 arguments (3 given) 
```

如果用 `**kargs` 的形式收集值，会得到 dict 类型的数据，但是，需要在传值的时候说明“键”和“值”，因为在字典中是以键值对形式出现的。

看官到这里可能想了，不是不确定性吗？我也不知道参数到底会可能用什么样的方式传值呀，这好办，把上面的都综合起来。

```py
>>> def foo(x,y,z,*args,**kargs):
...     print x   
...     print y
...     print z
...     print args
...     print kargs        
... 
>>> foo('qiwsir',2,"python")
qiwsir
2
python
()
{}
>>> foo(1,2,3,4,5)
1
2
3
(4, 5)
{}
>>> foo(1,2,3,4,5,name="qiwsir")
1
2
3
(4, 5)
{'name': 'qiwsir'} 
```

很 good 了，这样就能够足以应付各种各样的参数要求了。

### 另外一种传值方式

```py
>>> def add(x,y):
...     return x + y
... 
>>> add(2,3)
5 
```

这是通常的函数调用方法，在前面已经屡次用到。这种方法简单明快，很容易理解。但是，世界总是多样性的，有时候你秀出下面的方式，甚至在某种情况用下面的方法可能更优雅。

```py
>>> bars = (2,3)
>>> add(*bars)
5 
```

先把要传的值放到元组中，赋值给一个变量 `bars`，然后用 `add(*bars)` 的方式，把值传到函数内。这有点像前面收集参数的逆过程。注意的是，元组中元素的个数，要跟函数所要求的变量个数一致。如果这样：

```py
>>> bars = (2,3,4)
>>> add(*bars)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: add() takes exactly 2 arguments (3 given) 
```

就报错了。

这是使用一个星号 `*`，是以元组形式传值，如果用 `**` 的方式，是不是应该以字典的形式呢？理当如此。

```py
>>> def book(author,name):
...     print "%s is writing %s" % (author,name)
... 
>>> bars = {"name":"Starter learning Python","author":"Kivi"}
>>> book(**bars)
Kivi is writing Starter learning Python 
```

这种调用函数传值的方式，至少在我的编程实践中，用的不多。不过，不代表读者不用。这或许是习惯问题。

### 复习

python 中函数的参数通过赋值的方式来传递引用对象。下面总结通过总结常见的函数参数定义方式，来理解参数传递的流程。

#### def foo(p1,p2,p3,...)

这种方式最常见了，列出有限个数的参数，并且彼此之间用逗号隔开。在调用函数的时候，按照顺序以此对参数进行赋值，特备注意的是，参数的名字不重要，重要的是位置。而且，必须数量一致，一一对应。第一个对象（可能是数值、字符串等等）对应第一个参数，第二个对应第二个参数，如此对应，不得偏左也不得偏右。

```py
>>> def foo(p1,p2,p3):
...     print "p1==>",p1
...     print "p2==>",p2
...     print "p3==>",p3
... 
>>> foo("python",1,["qiwsir","github","io"])    #一一对应地赋值
p1==> python
p2==> 1
p3==> ['qiwsir', 'github', 'io']

>>> foo("python")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: foo() takes exactly 3 arguments (1 given)    #注意看报错信息

>>> foo("python",1,2,3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: foo() takes exactly 3 arguments (4 given)    #要求 3 个参数，实际上放置了 4 个，报错 
```

#### def foo(p1=value1,p2=value2,...)

这种方式比前面一种更明确某个参数的赋值，貌似这样就不乱子了，很明确呀。颇有一个萝卜对着一个坑的意味。

还是上面那个函数，用下面的方式赋值，就不用担心顺序问题了。

```py
>>> foo(p3=3,p1=10,p2=222)
p1==> 10
p2==> 222
p3==> 3 
```

也可以采用下面的方式定义参数，给某些参数有默认的值

```py
>>> def foo(p1,p2=22,p3=33):    #设置了两个参数 p2,p3 的默认值
...     print "p1==>",p1
...     print "p2==>",p2
...     print "p3==>",p3
... 
>>> foo(11)     #p1=11，其它的参数为默认赋值
p1==> 11
p2==> 22
p3==> 33
>>> foo(11,222)     #按照顺序，p2=222,p3 依旧维持原默认值
p1==> 11
p2==> 222
p3==> 33
>>> foo(11,222,333)  #按顺序赋值
p1==> 11
p2==> 222
p3==> 333

>>> foo(11,p2=122)
p1==> 11
p2==> 122
p3==> 33

>>> foo(p2=122)     #p1 没有默认值，必须要赋值的，否则报错
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: foo() takes at least 1 argument (1 given) 
```

#### def foo(*args)

这种方式适合于不确定参数个数的时候，在参数 args 前面加一个 *，注意，仅一个哟。

```py
>>> def foo(*args):         #接收不确定个数的数据对象
...     print args
... 
>>> foo("qiwsir.github.io") #以 tuple 形式接收到，哪怕是一个
('qiwsir.github.io',)
>>> foo("qiwsir.github.io","python")
('qiwsir.github.io', 'python') 
```

##### def foo(**args)

这种方式跟上面的区别在于，必须接收类似 arg=val 形式的。

```py
>>> def foo(**args):    #这种方式接收，以 dictionary 的形式接收数据对象
...     print args
... 

>>> foo(1,2,3)          #这样就报错了
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: foo() takes exactly 0 arguments (3 given)

>>> foo(a=1,b=2,c=3)    #这样就可以了，因为有了键值对
{'a': 1, 'c': 3, 'b': 2} 
```

下面来一个综合的，看看以上四种参数传递方法的执行顺序

```py
>>> def foo(x,y=2,*targs,**dargs):
...     print "x==>",x
...     print "y==>",y
...     print "targs_tuple==>",targs
...     print "dargs_dict==>",dargs
... 

>>> foo("1x")
x==> 1x
y==> 2
targs_tuple==> ()
dargs_dict==> {}

>>> foo("1x","2y")
x==> 1x
y==> 2y
targs_tuple==> ()
dargs_dict==> {}

>>> foo("1x","2y","3t1","3t2")
x==> 1x
y==> 2y
targs_tuple==> ('3t1', '3t2')
dargs_dict==> {}

>>> foo("1x","2y","3t1","3t2",d1="4d1",d2="4d2")
x==> 1x
y==> 2y
targs_tuple==> ('3t1', '3t2')
dargs_dict==> {'d2': '4d2', 'd1': '4d1'} 
```

* * *

总目录

如果你认为有必要打赏我，请通过支付宝：**qiwsir@126.com**,不胜感激。

## 函数(4)

还记得在《迭代》中提到的那几个说出来就让人感觉牛 X 的名词吗？前面已经学习过“循环”、“遍历”和“迭代”了。现在来看“递归”。

### 递归

什么是递归？

> 递归，见递归.

这是对“递归”最精简的定义。还有故事类型的定义.

> 从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事。故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事。故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事。故事是什么呢？……””

如果用上面的做递归的定义，总感觉有点调侃，来个严肃的(选自维基百科)：

> 递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。

最典型的递归例子之一是斐波那契数列，虽然前面用迭代的方式实现了它，但是那种方法在理解上不很直接。如果忘记了这个数列的定义，可以回到《练习》中查看。

根据斐波那契数列的定义，可以直接写成这样的斐波那契数列递归函数。

```py
#!/usr/bin/env Python
# coding=utf-8

def fib(n):
    """
    This is Fibonacci by Recursion.
    """
    if n==0:
        return 0
    elif n==1:
        return 1
    else:
        return fib(n-1) + fib(n-2)

if __name__ == "__main__":
    f = fib(10)
    print f 
```

把上述代码保存。这个代码的意图是要得到 n=10 的值。运行之：

```py
$ python 20401.py
55 
```

`fib(n-1) + fib(n-2)`就是又调用了这个函数自己，实现递归。为了明确递归的过程，下面走一个计算过程（考虑到次数不能太多，就让 n=3）

1.  n=3,fib(3)，自然要走 `return fib(3-1) + fib(3-2)` 分支
2.  先看 fib(3-1),即 fib(2)，也要走 else 分支，于是计算 `fib(2-1) + fib(2-2)`
3.  fib(2-1) 即 fib(1)，在函数中就要走 elif 分支，返回 1，即 fib(2-1)=1。同理，容易得到 fib(2-2)=0。将这两个值返回到上面一步。得到 `fib(3-1)=1+0=1`
4.  再计算 fib(3-2),就简单了一些，返回的值是 1，即 fib(3-2)=1
5.  最后计算第一步中的结果：`fib(3-1) + fib(3-2) = 1 + 1 = 2`，将计算结果 2 作为返回值

从而得到 fib(3) 的结果是 2。

从上面的过程中可以看出，每个递归的过程，都是向着最初的已知条件 `a0=0,a1=1` 方向挺近一步，直到通过这个最底层的条件得到结果，然后再一层一层向上回馈计算机结果。

其实，上面的代码有一个问题。因为 `a0=0,a1=1` 是已知的了，不需要每次都判断一边。所以，还可以优化一下。优化的基本方案就是初始化最初的两个值。

```py
#!/usr/bin/env Python
# coding=utf-8

"""
the better Fibonacci
"""
meno = {0:0, 1:1}    #初始化

def fib(n):
    if not n in meno:    #如果不在初始化范围内
        meno[n] = fib(n-1) + fib(n-2)
    return meno[n]

if __name__ == "__main__":
    f = fib(10)
    print f

#运行结果
$ python 20402.py 
55 
```

以上实现了递归，但是，至少在 Python 中，递归要慎重使用。在一般情况下，递归是能够被迭代或者循环替代的，而且后者的效率常常比递归要高。所以，我个人的建议是，对使用递归要考虑的周密一下，不小心就永远运行下去了。

### 几个特殊函数

前面已经知道了如何编写、调用函数。此外，在 Python 中，有几个特别的函数，很有意思，它们常常被看做是 Python 能够进行所谓“函数式编程”的见证。

> 如果以前没有听过，等你开始进入编程界，也会经常听人说“函数式编程”、“面向对象编程”、“指令式编程”等属于。它们是什么呢？这个话题要从“编程范式”讲起。（以下内容源自维基百科）
> 
> 编程范型或编程范式（英语：Programming paradigm），（范即模范之意，范式即模式、方法），是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照方法学）。如：函数式编程、程序编程、面向对象编程、指令式编程等等为不同的编程范型。
> 
> 编程范型提供了（同时决定了）程序员对程序执行的看法。例如，在面向对象编程中，程序员认为程序是一系列相互作用的对象，而在函数式编程中一个程序会被看作是一个无状态的函数计算的串行。
> 
> 正如软件工程中不同的群体会提倡不同的“方法学”一样，不同的编程语言也会提倡不同的“编程范型”。一些语言是专门为某个特定的范型设计的（如 Smalltalk 和 Java 支持面向对象编程，而 Haskell 和 Scheme 则支持函数式编程），同时还有另一些语言支持多种范型（如 Ruby、Common Lisp、Python 和 Oz）。
> 
> 编程范型和编程语言之间的关系可能十分复杂，由于一个编程语言可以支持多种范型。例如，C++ 设计时，支持过程化编程、面向对象编程以及泛型编程。然而，设计师和程序员们要考虑如何使用这些范型元素来构建一个程序。一个人可以用 C++ 写出一个完全过程化的程序，另一个人也可以用 C++ 写出一个纯粹的面向对象程序，甚至还有人可以写出杂揉了两种范型的程序。

不管读者是初学还是老油条，都建议将上面这段话认真读完，不管理解还是不理解，总能有点感觉的。

正如前面引文中所说的，Python 是支持多种范型的语言，可以进行所谓函数式编程，其突出体现在有这么几个函数：

filter、map、reduce、lambda、yield

有了它们，最大的好处是程序更简洁；没有它们，程序也可以用别的方式实现，只不过麻烦一些罢了。所以，还是能用则用之吧。更何况，恰当地使用这几个函数，能让别人感觉你更牛 X。

（注：本节不对 yield 进行介绍，请阅读《生成器》）

### lambda

lambda 函数，是一个只用一行就能解决问题的函数，听着是多么诱人呀。看下面的例子：

```py
>>> def add(x):     #定义一个函数，将输入的变量增加 3,然后返回增加之后的值
...     x += 3
...     return x
... 
>>> numbers = range(10)
>>> numbers
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  #有这样一个 list，想让每个数字增加 3,然后输出到一个新的 list 中

>>> new_numbers = []
>>> for i in numbers:
...     new_numbers.append(add(i))  #调用 add() 函数，并 append 到 list 中
... 
>>> new_numbers
[3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 
```

在这个例子中，add() 只是一个中间操作。当然，上面的例子完全可以用别的方式实现。比如：

```py
>>> new_numbers = [ i+3 for i in numbers ]
>>> new_numbers
[3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 
```

首先说明，这种列表解析的方式是非常非常好的。

但是，我们偏偏要用 lambda 这个函数替代 add(x)，如果看官和我一样这么偏执，就可以：

```py
>>> lam = lambda x:x+3
>>> n2 = []
>>> for i in numbers:
...     n2.append(lam(i))
... 
>>> n2
[3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 
```

这里的 lam 就相当于 add(x)，请看官对应一下，这一行 lambda x:x+3 就完成 add(x) 的三行（还是两行？），特别是最后返回值。还可以写这样的例子：

```py
>>> g = lambda x,y:x+y  #x+y,并返回结果
>>> g(3,4)
7
>>> (lambda x:x**2)(4)  #返回 4 的平方
16 
```

通过上面例子，总结一下 lambda 函数的使用方法：

*   在 lambda 后面直接跟变量
*   变量后面是冒号
*   冒号后面是表达式，表达式计算结果就是本函数的返回值

为了简明扼要，用一个式子表示是必要的：

```py
lambda arg1, arg2, ...argN : expression using arguments 
```

要特别提醒看官：虽然 lambda 函数可以接收任意多个参数 (包括可选参数) 并且返回单个表达式的值，但是**lambda 函数不能包含命令，包含的表达式不能超过一个。不要试图向 lambda 函数中塞入太多的东西；如果你需要更复杂的东西，应该定义一个普通函数，然后想让它多长就多长。**

就 lambda 而言，它并没有给程序带来性能上的提升，它带来的是代码的简洁。比如，要打印一个 list，里面依次是某个数字的 1 次方，二次方，三次方，四次方。用 lambda 可以这样做：

```py
>>> lamb = [ lambda x:x,lambda x:x**2,lambda x:x**3,lambda x:x**4 ]
>>> for i in lamb:
...     print i(3),
... 
3 9 27 81 
```

lambda 做为一个单行的函数，在编程实践中，可以选择使用。

### map

先看一个例子，还是上面讲述 lambda 的时候第一个例子，用 map 也能够实现：

```py
>>> numbers
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]      #把列表中每一项都加 3

>>> map(add,numbers)                #add(x) 是上面讲述的那个函数，但是这里只引用函数名称即可
[3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

>>> map(lambda x: x+3,numbers)      #用 lambda 当然可以啦
[3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 
```

map() 是 Python 的一个内置函数，它的基本样式是：

`map(func,seq)`

func 是一个函数，seq 是一个序列对象。在执行的时候，序列对象中的每个元素，按照从左到右的顺序，依次被取出来，并塞入到 func 那个函数里面，并将 func 的返回值依次存到一个 list 中。

在应用中，map 的所能实现的，也可以用别的方式实现。比如：

```py
>>> items = [1,2,3,4,5]
>>> squared = []
>>> for i in items:
...     squared.append(i**2)
... 
>>> squared
[1, 4, 9, 16, 25]

>>> def sqr(x): return x**2
... 
>>> map(sqr,items)
[1, 4, 9, 16, 25]

>>> map(lambda x: x**2, items)
[1, 4, 9, 16, 25]

>>> [ x**2 for x in items ]     #这个我最喜欢了，一般情况下速度足够快，而且可读性强
[1, 4, 9, 16, 25] 
```

条条大路通罗马，以上方法，在编程中，自己根据需要来选用啦。

在以上感性认识的基础上，在来浏览有关 map() 的官方说明，能够更明白一些。

> map(function, iterable, ...)
> 
> Apply function to every item of iterable and return a list of the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. If one iterable is shorter than another it is assumed to be extended with None items. If function is None, the identity function is assumed; if there are multiple arguments, map() returns a list consisting of tuples containing the corresponding items from all iterables (a kind of transpose operation). The iterable arguments may be a sequence or any iterable object; the result is always a list.

理解要点：

*   对 iterable 中的每个元素，依次应用 function 的方法（函数）（这本质上就是一个 for 循环）。
*   将所有结果返回一个 list。
*   如果参数很多，则对那些参数并行执行 function。

例如：

```py
>>> lst1 = [1,2,3,4,5]
>>> lst2 = [6,7,8,9,0]
>>> map(lambda x,y: x+y, lst1,lst2)     #将两个列表中的对应项加起来，并返回一个结果列表
[7, 9, 11, 13, 5] 
```

请看官注意了，上面这个例子如果用 for 循环来写，还不是很难，如果扩展一下，下面的例子用 for 来改写，就要小心了：

```py
>>> lst1 = [1,2,3,4,5]
>>> lst2 = [6,7,8,9,0]
>>> lst3 = [7,8,9,2,1]
>>> map(lambda x,y,z: x+y+z, lst1,lst2,lst3)
[14, 17, 20, 15, 6] 
```

这才显示出 map 的简洁优雅。

### reduce

直接看这个：

```py
>>> reduce(lambda x,y: x+y,[1,2,3,4,5])
15 
```

请看官仔细观察，是否能够看出是如何运算的呢？画一个图：

![](img/20401.png)

还记得 map 是怎么运算的吗？忘了？看代码：

```py
>>> list1 = [1,2,3,4,5,6,7,8,9]
>>> list2 = [9,8,7,6,5,4,3,2,1]
>>> map(lambda x,y: x+y, list1,list2)
[10, 10, 10, 10, 10, 10, 10, 10, 10] 
```

看官对比一下，就知道两个的区别了。原来 map 是上下运算，reduce 是横着逐个元素进行运算。

权威的解释来自官网：

> reduce(function, iterable[, initializer])
> 
> Apply function of two arguments cumulatively to the items of iterable, from left to right, so as to reduce the iterable to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5). The left argument, x, is the accumulated value and the right argument, y, is the update value from the iterable. If the optional initializer is present, it is placed before the items of the iterable in the calculation, and serves as a default when the iterable is empty. If initializer is not given and iterable contains only one item, the first item is returned. Roughly equivalent to:

```py
def reduce(function, iterable, initializer=None):
    it = iter(iterable)
    if initializer is None:
        try:
            initializer = next(it)
        except StopIteration:    
            raise TypeError('reduce() of empty sequence with no initial value')    
    accum_value = initializer                                                                   
    for x in it:
        accum_value = function(accum_value, x)    
    return accum_value 
```

如果用我们熟悉的 for 循环来做上面 reduce 的事情，可以这样来做：

```py
>>> lst = range(1,6)
>>> lst
[1, 2, 3, 4, 5]
>>> r = 0
>>> for i in range(len(lst)):
...     r += lst[i]
... 
>>> r
15 
```

for 普世的，reduce 是简洁的。

为了锻炼思维，看这么一个问题，有两个 list，a = [3,9,8,5,2],b=[1,4,9,2,6],计算：a[0]*b[0]+a[1]*b[1]+...的结果。

```py
>>> a
[3, 9, 8, 5, 2]
>>> b
[1, 4, 9, 2, 6]

>>> zip(a,b)        #复习一下 zip，下面的方法中要用到
[(3, 1), (9, 4), (8, 9), (5, 2), (2, 6)]

>>> sum(x*y for x,y in zip(a,b))    #解析后直接求和
133

>>> new_list = [x*y for x,y in zip(a,b)]    #可以看做是上面方法的分布实施

>>> #这样解析也可以：new_tuple = (x*y for x,y in zip(a,b))
>>> new_list
[3, 36, 72, 10, 12]
>>> sum(new_list)     #或者:sum(new_tuple)
133

>>> reduce(lambda sum,(x,y): sum+x*y,zip(a,b),0)    #这个方法是在耍酷呢吗？
133

>>> from operator import add,mul            #耍酷的方法也不止一个
>>> reduce(add,map(mul,a,b))
133

>>> reduce(lambda x,y: x+y, map(lambda x,y: x*y, a,b))  #map,reduce,lambda 都齐全了，更酷吗？
133 
```

最后，要特别提醒：如果读者使用的是 Python3，跟上面有点不一样，因为在 Python3 中，reduce() 已经从全局命名空间中移除，放到了 functools 模块中，如果要是用，需要用 `from functools import reduce` 引入之。

### filter

filter 的中文含义是“过滤器”，在 Python 中，它就是起到了过滤器的作用。首先看官方说明：

> filter(function, iterable)
> 
> Construct a list from those elements of iterable for which function returns true. iterable may be either a sequence, a container which supports iteration, or an iterator. If iterable is a string or a tuple, the result also has that type; otherwise it is always a list. If function is None, the identity function is assumed, that is, all elements of iterable that are false are removed.
> 
> Note that filter(function, iterable) is equivalent to [item for item in iterable if function(item)] if function is not None and [item for item in iterable if item] if function is None.

这次真的不翻译了（好像以往也没有怎么翻译呀），而且也不解释要点了。请列位务必自己阅读上面的文字，并且理解其含义。英语，无论怎么强调都是不过分的，哪怕是做乞丐，说两句英语，没准还可以讨到英镑美元呢。

通过下面代码体会：

```py
>>> numbers = range(-5,5)
>>> numbers
[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]

>>> filter(lambda x: x>0, numbers) 
[1, 2, 3, 4]

>>> [x for x in numbers if x>0]     #与上面那句等效
[1, 2, 3, 4]

>>> filter(lambda c: c!='i', 'qiwsir')  #能不能对应上面文档说明那句话呢？
'qwsr'                                  #“If iterable is a string or a tuple, the result also has that type;” 
```

至此，介绍了几个函数，这些函数在对程序的性能提高上，并没有显著或者稳定预期，但是，在代码的简洁上，是有目共睹的。有时候是可以用来秀一秀，彰显 Python 的优雅和自己耍酷。如何用、怎么用，看你自己的喜好了。

* * *

总目录

如果你认为有必要打赏我，请通过支付宝：**qiwsir@126.com**,不胜感激。

## 函数练习

已经学习了函数的基本知识，现在练习练习。完成下面练习的原则：

1.  请读者先根据自己的设想写下代码，然后运行调试，检查得到的结果是否正确
2.  我也给出参考代码，但是，参考代码并不是最终结果
3.  读者可以在上述基础上对代码进行完善
4.  如果读者愿意，可以将代码提交到 github 上，或者到我的 QQ 群(群号:26913719)中跟大家分享讨论

### 解一元二次方程

解一元二次方程，是初中数学中的基本知识，一般来讲解法有：公式法、因式分解法等。读者可以根据自己的理解，写一段求解一元二次方程的程序。

最简单的思路就是用公式法求解，这是普适法则（普世法则？普适是否等同于普世？）。

> 古巴比伦留下的陶片显示，在大约公元前 2000 年（2000 BC）古巴比伦的数学家就能解一元二次方程了。在大約公元前 480 年，中國人已经使用配方法求得了二次方程的正根，但是并没有提出通用的求解方法。公元前 300 年左右，欧几里得提出了一种更抽象的几何方法求解二次方程。
> 
> 7 世紀印度的婆罗摩笈多（Brahmagupta）是第一位懂得用使用代数方程，它同时容许有正负数的根。
> 
> 11 世紀阿拉伯的花拉子密 独立地发展了一套公式以求方程的正数解。亚伯拉罕·巴希亚（亦以拉丁文名字萨瓦索达著称）在他的著作 Liber embadorum 中，首次将完整的一元二次方程解法传入欧洲。(源自《维基百科》)

参考代码：

```py
#!/usr/bin/env Python
# coding=utf-8

"""
solving a quadratic equation
"""

from __future__ import division
import math

def quadratic_equation(a,b,c):
    delta = b*b - 4*a*c
    if delta<0:
        return False
    elif delta==0:
        return -(b/(2*a))
    else:
        sqrt_delta = math.sqrt(delta)
        x1 = (-b + sqrt_delta)/(2*a)
        x2 = (-b - sqrt_delta)/(2*a)
        return x1, x2

if __name__ == "__main__":
    print "a quadratic equation: x² + 2x + 1 = 0"
    coefficients = (1, 2, 1)
    roots = quadratic_equation(*coefficients)
    if roots:
        print "the result is:",roots
    else:
        print "this equation has no solution." 
```

保存为 20501.py，并运行之：

```py
$ python 20501.py 
a quadratic equation: x² + 2x + 1 = 0
the result is: -1.0 
```

能够正常运行，求解方程。

但是，如果再认真思考，发现上述代码是有很大改进空间的。至少我发现：

*   如果不小心将第一个系数(a)的值输入了 0，程序肯定会报错。如何避免之？要记住，任何人的输入都是不可靠的。
*   结果貌似只能是小数，这在某些情况下是近似值，能不能得到以分数形式表示的精确结果呢？
*   复数，Python 是可以表示复数的，如果 delta<0，是不是写成复数更好，毕竟我是学过高中数学的。

读者是否还有其它改进呢？你能不能进行改进，然后跟我和其他朋友一起来分享你的成就呢？

至少要完成上述改进，可能需要其它的有关 Python 知识，甚至于前面没有介绍。这都不要紧，掌握了基本知识之后，在编程的过程中，就要不断发挥 google 的优势，让她帮助你找寻完成任务的工具。

> Python 是一个开发的语言，很多大牛人都写了一些工具，让别人使用，减轻了后人的劳动负担。这就是所谓的第三方模块。虽然 Python 中已经有一些“自带电池”，即默认安装的，比如上面程序中用到的 math，但是我们还嫌不够。于是又很多第三方的模块来专门解决某个问题。比如这个解方程问题，就可以使用 SymPy(www.sympy.org)来解决，当然 NumPy 也是非常强悍的工具。

### 统计考试成绩

每次考试之后，教师都要统计考试成绩，一般包括：平均分，对所有人按成绩从高到低排队，谁成绩最好，谁成绩最差。还有其它的统计项，暂且不做了。只统计这几项吧。下面的任务就是读者转动脑筋，思考如何用程序实现上面的统计。为了简化，以字典形式表示考试成绩记录，例如：`{"zhangsan":90, "lisi":78, "wangermazi":39}`，当然，也许不止这三项，可能还有，每个老师所处理的内容稍有不同，因此字典里的键值对也不一样。

怎么做？

有几种可能要考虑到：

*   最高分或者最低分，可能有人并列。
*   要实现不同长度的字典作为输入值。
*   输出结果中，除了平均分，其它的都要有姓名和分数两项，否则都匿名了，怎么刺激学渣，表扬学霸呢？

不管你是学渣还是学霸，都能学好 Python。请思考后敲代码调试你的程序，调试之后再阅读下文。

参考代码：

```py
#!/usr/bin/env Python
# coding=utf-8
"""
统计考试成绩
"""
from __future__ import division

def average_score(scores):
    """
    统计平均分.
    """
    score_values = scores.values()
    sum_scores = sum(score_values)
    average = sum_scores/len(score_values)
    return average

def sorted_score(scores):
    """
    对成绩从高到低排队.
    """
    score_lst = [(scores[k],k) for k in scores]
    sort_lst = sorted(score_lst, reverse=True)
    return [(i[1], i[0]) for i in sort_lst]

def max_score(scores):
    """
    成绩最高的姓名和分数.
    """
    lst = sorted_score(scores)    #引用分数排序的函数 sorted_score
    max_score = lst[0][1]
    return [(i[0],i[1]) for i in lst if i[1]==max_score]

def min_score(scores):
    """
    成绩最低的姓名和分数.
    """
    lst = sorted_score(scores)
    min_score = lst[len(lst)-1][1]
    return [(i[0],i[1]) for i in lst if i[1]==min_score]

if __name__ == "__main__":
    examine_scores = {"google":98, "facebook":99, "baidu":52, "alibaba":80, "yahoo":49, "IBM":70, "android":76, "apple":99, "amazon":99}

    ave = average_score(examine_scores)
    print "the average score is: ",ave    #平均分

    sor = sorted_score(examine_scores)
    print "list of the scores: ",sor      #成绩表

    xueba = max_score(examine_scores)
    print "Xueba is: ",xueba              #学霸们

    xuezha = min_score(examine_scores)
    print "Xuzha is: ",xuezha             #学渣们 
```

保存为 20502.py，然后运行：

```py
$ python 20502.py
the average score is:  80.2222222222
list of the scores:  [('facebook', 99), ('apple', 99), ('amazon', 99), ('google', 98), ('alibaba', 80), ('android', 76), ('IBM', 70), ('baidu', 52), ('yahoo', 49)]
Xueba is:  [('facebook', 99), ('apple', 99), ('amazon', 99)]
Xuzha is:  [('yahoo', 49)] 
```

貌似结果还不错。不过，还有改进余地，看看现实，就感觉不怎么友好了。看官能不能优化一下？当然，里面的函数也不一定是最好的方法，你也可以修改优化。期盼能够在我上面公布的途径中交流一二。

### 找素数

这是一个比较常见的题目。我们姑且将范围缩小一下，找出 100 以内的素数吧。

还是按照前面的管理，读者先做，然后我提供参考代码，然后自行优化。

> 質數（Prime number），又称素数，指在大於 1 的自然数中，除了 1 和此整数自身外，無法被其他自然数整除的数（也可定義為只有 1 和本身两个因数的数）。
> 
> 哥德巴赫猜想是数论中存在最久的未解问题之一。这个猜想最早出现在 1742 年普鲁士人克里斯蒂安·哥德巴赫与瑞士数学家莱昂哈德·欧拉的通信中。用现代的数学语言，哥德巴赫猜想可以陈述为：“任一大于 2 的偶数，都可表示成两个质数之和。”。哥德巴赫猜想在提出后的很长一段时间内毫无进展，直到二十世纪二十年代，数学家从组合数学与解析数论两方面分别提出了解决的思路，并在其后的半个世纪里取得了一系列突破。目前最好的结果是陈景润在 1973 年发表的陈氏定理（也被称为“1+2”）。（源自《维基百科》）

对这个练习，我的思路是先做一个函数，用它来判断某个整数是否是素数。然后循环即可。参考代码：

```py
#!/usr/bin/env Python
# coding=utf-8

"""
寻找素数
"""

import math

def is_prime(n):
    """
    判断一个数是否是素数
    """
    if n <= 1:
        return False
    for i in range(2, int(math.sqrt(n) + 1)):
        if n % i == 0:
            return False
    return True

if __name__ == "__main__":
    primes = [i for i in range(2,100) if is_prime(i)]    #从 2 开始，因为 1 显然不是质数
    print primes 
```

代码保存后运行：

```py
$ python 20503.py 
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] 
```

打印出了 100 以内的质数。

还是前面的观点，这个程序你或许也发现了需要进一步优化的地方，那就太好了。另外，关于判断质数的方法，还有好多种，读者可以自己创造或者网上搜索一些，拓展思路。

### 编写函数的注意事项

编写函数，在开发实践中是非常必要和常见的，一般情况，你写的函数应该是：

1.  尽量不要使用全局变量。
2.  如果参数是可变类型数据，在函数内，不要修改它。
3.  每个函数的功能和目标要单纯，不要试图一个函数做很多事情。
4.  函数的代码行数尽量少。
5.  函数的独立性越强越好，不要跟其它的外部东西产生关联。

* * *

总目录

如果你认为有必要打赏我，请通过支付宝：**qiwsir@126.com**,不胜感激。