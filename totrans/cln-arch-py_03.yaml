- en: Chapter 1 - A day in the life of a clean system
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 - 清洁系统的一天
- en: 原文：[https://www.thedigitalcatbooks.com/pycabook-chapter-01/](https://www.thedigitalcatbooks.com/pycabook-chapter-01/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://www.thedigitalcatbooks.com/pycabook-chapter-01/](https://www.thedigitalcatbooks.com/pycabook-chapter-01/)
- en: Must be my lucky day.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 必须是我的幸运日。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Terminator 2, 1991
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 终结者2，1991
- en: In this chapter I will introduce the reader to a (very simple) system designed
    with a clean architecture. The purpose of this introductory chapter is to familiarise
    with main concepts like separation of concerns and inversion of control, which
    are paramount in system design. While I describe how data flows in the system,
    I will purposefully omit details, so that we can focus on the global idea and
    not worry too much about the implementation. This example will be then explored
    in all its glorious details in the following chapters, so there will be time to
    discuss specific choices. For now, try to get the big picture.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向读者介绍一个（非常简单）采用清晰架构设计的系统。本章的目的是使读者熟悉主要概念，如关注点分离和反转控制，这些在系统设计中至关重要。在描述数据在系统中的流动时，我将故意省略细节，以便我们能够关注全局观念，不必过于担心实现细节。这个例子将在接下来的章节中详细探讨，因此将有时间讨论具体的选择。现在，试着把握整体图景。
- en: The data flow
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据流
- en: In the rest of the book, we will design together part of a simple web application
    that provides a room renting system. So, let's consider that our "Rent-o-Matic"
    application^([[1](#fd-58102884)]) is running at [https://www.rentomatic.com](https://www.rentomatic.com),
    and that a user wants to see the available rooms. They open the browser and type
    the address, then clicking on menus and buttons they reach the page with the list
    of all the rooms that our company rents.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将共同设计一个简单网络应用程序的一部分，该应用程序提供房间租赁系统。因此，让我们假设我们的“Rent-o-Matic”应用程序^([[1](#fd-58102884)])运行在[https://www.rentomatic.com](https://www.rentomatic.com)，并且用户想要查看可用的房间。他们打开浏览器并输入地址，然后点击菜单和按钮，到达显示我们公司租赁的所有房间列表的页面。
- en: Let's assume that this URL is `/rooms?status=available`. When the user's browser
    accesses that URL, an HTTP request reaches our system, where there is a component
    that is waiting for HTTP connections. Let's call this component "web framework"^([[2](#fd-54651647)]).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个URL是`/rooms?status=available`。当用户的浏览器访问这个URL时，一个HTTP请求到达我们的系统，系统中有一个等待HTTP连接的组件。让我们称这个组件为“网络框架"^([[2](#fd-54651647)]).
- en: The purpose of the web framework is to understand the HTTP request and to retrieve
    the data that we need to provide a response. In this simple case there are two
    important parts of the request, namely the endpoint itself (`/rooms`), and a single
    query string parameter, `status=available`. Endpoints are like commands for our
    system, so when a user accesses one of them, they signal to the system that a
    specific service has been requested, which in this case is the list of all the
    rooms that are available for rent.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 网络框架的目的是理解HTTP请求并检索我们需要提供响应的数据。在这个简单案例中，请求有两个重要部分，即端点本身（`/rooms`）和一个单一的查询字符串参数，`status=available`。端点就像是我们系统的命令，因此当用户访问其中一个端点时，他们向系统发出请求特定服务的信号，在这种情况下是列出所有可出租的房间。
- en: '![The web framework serving HTTP](../Images/a310516e1746da7b71d809116b6ca785.png)The
    web framework serving HTTP'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![The web framework serving HTTP](../Images/a310516e1746da7b71d809116b6ca785.png)The
    web framework serving HTTP'
- en: The domain in which the web framework operates is that of the HTTP protocol,
    so when the web framework has decoded the request it should pass the relevant
    information to another component that will process it. This other component is
    called *use case*, and it is the crucial and most important component of the whole
    clean system as it implements the *business logic*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 网络框架操作的范围是HTTP协议的领域，因此当网络框架解码请求后，它应将相关信息传递给另一个将处理它的组件。这个其他组件被称为*用例*，它是整个清晰系统的关键和最重要的组件，因为它实现了*业务逻辑*。
- en: '![The business logic](../Images/afc423201f73500320f3bca14eafc350.png)The business
    logic'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![The business logic](../Images/afc423201f73500320f3bca14eafc350.png)The business
    logic'
- en: The business logic is an important concept in system design. You are creating
    a system because you have some knowledge that you think might be useful to the
    world, or at the very least marketable. This knowledge is, at the end of the day,
    a way to process data, a way to extract or present data that maybe others don't
    have. A search engine can find all the web pages that are related to the terms
    in a query, a social network shows you the posts of people you follow and sorts
    them according to a specific algorithm, a travel company finds the best options
    for your journey between two locations, and so on. All these are good examples
    of business logic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑是系统设计中的一个重要概念。你创建系统是因为你有一些你认为可能对世界有用的知识，或者至少是可销售的。最终，这种知识是一种处理数据的方式，是一种提取或展示数据的方式，可能是其他人没有的。搜索引擎可以找到与查询中的术语相关的所有网页，社交网络显示你关注的用户的帖子，并按特定的算法排序，旅行社为你找到两个地点之间的最佳旅行选择，等等。所有这些都是业务逻辑的好例子。
- en: '*Business logic'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*业务逻辑'
- en: Business logic is the specific algorithm or process that you want to implement,
    the way you transform data to provide a service. It is the most important part
    of the system.*
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑是你想要实现的具体算法或过程，是你将数据转换为提供服务的样子。它是系统中最重要的一部分。
- en: '*The use case implements a very specific part of the whole business logic.
    In this case we have a use case to search for rooms with a given value of the
    parameter `status`. This means that the use case has to extract all the rooms
    that are managed by our company and filter them to show only the ones that are
    available.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*用例实现了整个业务逻辑的一个非常具体的部分。在这种情况下，我们有一个用例来搜索具有给定参数`status`值的房间。这意味着用例必须提取我们公司管理的所有房间，并过滤它们以仅显示可用的房间。*'
- en: '*Why can''t the web framework do it? Well, the main purpose of a good system
    architecture is to *separate concerns*, that is to keep different responsibilities
    and domains separated. The web framework is there to process the HTTP protocol,
    and is maintained by programmers that are concerned with that specific part of
    the system, and adding the business logic to it mixes two very different fields.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么Web框架不能这样做？嗯，良好的系统架构的主要目的是*分离关注点*，也就是说，保持不同的责任和领域分离。Web框架在那里处理HTTP协议，由关注该系统特定部分的程序员维护，将业务逻辑添加到其中将两个非常不同的领域混合在一起。'
- en: '**Separation of concerns'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**关注点分离'
- en: Different parts a system should manage different parts of the process. Whenever
    two separate parts of a system work on the same data or the same part of a process
    they are *coupled*. While coupling is unavoidable, the higher the coupling between
    two components the harder is to change one without affecting the other.**
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的不同部分应该管理不同的过程部分。当系统的两个独立部分在相同的数据或过程的同一部分上工作时，它们是*耦合的*。虽然耦合是不可避免的，但两个组件之间的耦合度越高，在不影响另一个组件的情况下更改一个组件就越困难。
- en: '**As we will see, separating layers allows us to maintain the system with less
    effort, making single parts of it more testable and easily replaceable.**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**正如我们将看到的，分离层可以让我们以更少的努力维护系统，使系统的单个部分更容易测试和替换。**'
- en: '**In the example that we are discussing here, the use case needs to fetch all
    the rooms that are in an available state, extracting them from a source of data.
    This is the business logic, and in this case it is very straightforward, as it
    will probably consist of a simple filtering on the value of an attribute. This
    might however not be the case. An example of a more advanced business logic might
    be an ordering based on a recommendation system, which might require the use case
    to connect with more components than just the data source.**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**在我们讨论的例子中，用例需要检索所有处于可用状态的房间，从数据源中提取它们。这是业务逻辑，在这种情况下它非常直接，因为它可能只涉及对属性值的简单过滤。然而，情况可能并非如此。更高级的业务逻辑的例子可能基于推荐系统进行排序，这可能需要用例与比数据源更多的组件进行连接。**'
- en: '**So, the information that the use case wants to process is stored somewhere.
    Let''s call this component *storage system*. Many of you probably already pictured
    a database in your mind, maybe a relational one, but that is just one of the possible
    data sources. The abstraction represented by the storage system is: anything that
    the use case can access and that can provide data is a source. It might be a file,
    a database (either relational or not), a network endpoint, or a remote sensor.**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**因此，用例想要处理的信息存储在某个地方。让我们称这个组件为**存储系统**。你们中的许多人可能已经在脑海中想象了一个数据库，可能是一个关系型数据库，但这只是可能的数据源之一。存储系统所代表的抽象是：用例可以访问并能提供数据的任何东西都是一个源。它可能是一个文件、一个数据库（无论是关系型还是非关系型）、一个网络端点或一个远程传感器。**'
- en: '***Abstraction'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '***抽象'
- en: When designing a system, it is paramount to think in terms of abstractions,
    or building blocks. A component has a role in the system, regardless of the specific
    implementation of that component. The higher the level of the abstraction, the
    less detailed are the components. Clearly, high-level abstractions don't consider
    practical problems, which is why the abstract design has to be then implemented
    using specific solutions or technologies.***
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计系统时，以抽象或构建块的方式思考至关重要。组件在系统中有其作用，而不管该组件的具体实现方式如何。抽象级别越高，组件的细节就越少。显然，高级抽象不考虑实际问题，这就是为什么抽象设计必须通过特定的解决方案或技术来实现。***
- en: '***For simplicity''s sake, let''s use a relational database like Postgres in
    this example, as it is likely to be familiar to the majority of readers, but keep
    in mind the more generic case.***'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '***为了简化起见，让我们在这个例子中使用一个关系型数据库，比如 Postgres，因为它可能对大多数读者来说都很熟悉，但请记住更通用的情况。***'
- en: '***![](../Images/07c9999c184018213f3bfc4b4c902b70.png)The storage***'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '***![](../Images/07c9999c184018213f3bfc4b4c902b70.png)存储***'
- en: '***How does the use case connect with the storage system? Clearly, if we hard
    code into the use case the calls to a specific system (e.g. using SQL) the two
    components will be *strongly coupled*, which is something we try to avoid in system
    design. Coupled components are not independent, they are tightly connected, and
    changes occurring in one of the two force changes in the second one (and vice
    versa). This also means that testing components is more difficult, as one component
    cannot live without the other, and when the second component is a complex system
    like a database this can severely slow down development.***'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '***如何将用例与存储系统连接起来？显然，如果我们将针对特定系统的调用（例如使用 SQL）硬编码到用例中，这两个组件将会**紧密耦合**，这是我们试图在系统设计中避免的事情。耦合的组件不是独立的，它们紧密相连，一个组件中的变化会强制另一个组件发生变化（反之亦然）。这也意味着测试组件会更加困难，因为一个组件不能没有另一个组件而存在，而当第二个组件是一个复杂的系统，如数据库时，这可能会严重减缓开发速度。***'
- en: '***For example, let''s assume the use case called directly a specific Python
    library to access PostgreSQL such as [psycopg](https://www.psycopg.org/). This
    would couple the use case with that specific source, and a change of database
    would result in a change of its code. This is far from being ideal, as the use
    case contains the business logic, which has not changed moving from one database
    system to the other. Parts of the system that do not contain the business logic
    should be treated like implementation details.***'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '***例如，让我们假设有一个用例直接调用特定的 Python 库来访问 PostgreSQL，比如 [psycopg](https://www.psycopg.org/)。这将使用例与该特定源耦合，数据库的改变将导致其代码的改变。这远非理想，因为用例包含的业务逻辑在从一种数据库系统迁移到另一种数据库系统时并未改变。系统中不包含业务逻辑的部分应被视为实现细节。***'
- en: '****Implementation detail'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '****实现细节'
- en: A specific solution or technology is called a *detail* when it is not central
    to the design as a whole. The word doesn't refer to the inherent complexity of
    the subject, which might be greater than that of more central parts.****
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个解决方案或技术不是整体设计中的核心时，它被称为**细节**。这个词并不指代主题固有的复杂性，其复杂性可能大于更核心的部分。****
- en: '***A relational database is hundred of times richer and more complex than an
    HTTP endpoint, and this in turn is more complex than ordering a list of objects,
    but the core of the application is the use case, not the way we store data or
    the way we provide access to that. Usually, implementation details are mostly
    connected with performances or usability, while the core parts implement the pure
    business logic.***'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系数据库比HTTP端点丰富和复杂数百倍，而这反过来又比按顺序排列对象列表复杂，但应用程序的核心是使用场景，而不是我们存储数据的方式或提供访问数据的方式。通常，实现细节主要与性能或可用性相关，而核心部分实现的是纯业务逻辑。**'
- en: '***How can we avoid strong coupling? A simple solution is called *inversion
    of control*, and I will briefly sketch it here, and show a proper implementation
    in a later section of the book, when we will implement this very example.***'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何避免强耦合？一个简单的解决方案叫做*控制反转*，我将在这里简要描述它，并在本书的后续部分展示一个适当的实现，当我们实现这个例子时。**'
- en: '***Inversion of control happens in two phases. First, the called object (the
    database in this case) is wrapped with a standard interface. This is a set of
    functionalities shared by every implementation of the target, and each interface
    translates the functionalities to calls to the specific language^([[3](#fd-33501696)])
    of the wrapped implementation.***'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制反转发生在两个阶段。首先，被调用对象（在这个例子中是数据库）被一个标准接口包装。这是一组由目标实现的每个实现共享的功能，每个接口将功能转换为对包装实现的具体语言的调用。**'
- en: '****Inversion of control'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制反转**'
- en: A technique used to avoid strong coupling between components of a system, that
    involves wrapping them so that they expose a certain interface. A component expecting
    that interface can then connect to them without knowing the details of the specific
    implementation, and thus being strongly coupled to the interface instead of the
    specific implementation.****
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一种用于避免系统组件之间强耦合的技术，它涉及将它们包装起来，以便它们暴露出一定的接口。一个期望该接口的组件可以连接到它们，而无需了解特定实现的细节，因此它被强耦合到接口而不是特定实现。
- en: '***A real world example of this is that of power plugs: electric appliances
    are designed to be connected not with specific power plugs, but to any power plug
    that is build according to the specification (size, number of poles, etc). When
    you buy a TV in the UK, you expect it to come with a UK plug (BS 1363). If it
    doesn''t, you need an *adapter* that allows you to plug electronic devices into
    sockets of a foreign nation. In this case, we need to connect the use case (TV)
    to a database (power system) that have not been designed to match a common interface.***'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个现实世界的例子是电源插座：电器设计成可以连接到任何符合规格（尺寸、极数等）的电源插座，而不是特定的电源插座。当你在英国购买电视时，你期望它带有英国插座（BS
    1363）。如果没有，你需要一个*适配器*，这样你就可以将电子设备插入外国国家的插座。在这种情况下，我们需要将使用场景（电视）连接到一个数据库（电源系统）上，而这个数据库并没有设计成匹配一个通用接口。**'
- en: '***In the example we are discussing, the use case needs to extract all rooms
    with a given status, so the database wrapper needs to provide a single entry point
    that we might call `list_rooms_with_status`.***'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的例子中，使用场景需要提取具有给定状态的所有房间，因此数据库包装器需要提供一个单一的入口点，我们可以称之为 `list_rooms_with_status`。
- en: '***![The storage interface](../Images/85cec2f977b76c2397802b1486f0b7ba.png)The
    storage interface***'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**![存储接口](../Images/85cec2f977b76c2397802b1486f0b7ba.png)存储接口**'
- en: '***In the second phase of inversion of control the caller (the use case) is
    modified to avoid hard coding the call to the specific implementation, as this
    would again couple the two. The use case accepts an incoming object as a parameter
    of its constructor, and receives a concrete instance of the adapter at creation
    time. The specific technique used to implement this depends greatly on the programming
    language we use. Python doesn''t have an explicit syntax for interfaces, so we
    will just assume the object we pass implements the required methods.***'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**在控制反转的第二阶段，调用者（使用场景）被修改以避免硬编码对特定实现的调用，因为这又会将两者耦合在一起。使用场景接受一个作为其构造函数参数的传入对象，并在创建时接收适配器的具体实例。实现这一特定技术的方法在很大程度上取决于我们使用的编程语言。Python没有显式的接口语法，所以我们假设我们传递的对象实现了所需的方法。**'
- en: '***![Inversion of control on the storage interface](../Images/aa24cf11fcf4a3e27515f07ca4bbc306.png)Inversion
    of control on the storage interface***'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**![存储接口上的控制反转](../Images/aa24cf11fcf4a3e27515f07ca4bbc306.png)存储接口上的控制反转**'
- en: '***Now the use case is connected with the adapter and knows the interface,
    and it can call the entry point `list_rooms_with_status` passing the status `available`.
    The adapter knows the details of the storage system, so it converts the method
    call and the parameter in a specific call (or set of calls) that extract the requested
    data, and then converts them in the format expected by the use case. For example,
    it might return a Python list of dictionaries that represent rooms.***'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '***现在用例已经连接到适配器并知道了接口，它可以调用`list_rooms_with_status`入口点，传递状态`available`。适配器知道存储系统的细节，因此它将方法调用和参数转换为特定的调用（或一系列调用），以提取所需的数据，然后将它们转换为用例期望的格式。例如，它可能返回一个表示房间的Python字典列表。***'
- en: '***![The business logic extracts data from the storage](../Images/a0de932ea207de9d0894271b2353b1c9.png)The
    business logic extracts data from the storage***'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '***![业务逻辑从存储中提取数据](../Images/a0de932ea207de9d0894271b2353b1c9.png)业务逻辑从存储中提取数据***'
- en: '***At this point, the use case has to apply the rest of the business logic,
    if needed, and return the result to the web framework.***'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '***在这个阶段，用例必须应用剩余的业务逻辑（如果需要的话），并将结果返回给Web框架。***'
- en: '***![The business logic returns processed data to the web framework](../Images/412e495f5aa209edd764e1fa65824bcc.png)The
    business logic returns processed data to the web framework***'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '***![业务逻辑将处理后的数据返回给Web框架](../Images/412e495f5aa209edd764e1fa65824bcc.png)业务逻辑将处理后的数据返回给Web框架***'
- en: '***The web framework converts the data received from the use case into an HTTP
    response. In this case, as we are considering an endpoint that is supposed to
    be reached explicitly by the user of the website, the web framework will return
    an HTML page in the body of the response, but if this was an internal endpoint,
    for example called by some asynchronous JavaScript code in the front-end, the
    body of the response would probably just be a JSON structure.***'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '***Web框架将用例接收到的数据转换为HTTP响应。在这种情况下，因为我们正在考虑一个用户应该明确访问的端点，所以Web框架将在响应体中返回一个HTML页面，但如果这是一个内部端点，例如由前端中的某些异步JavaScript代码调用，响应体可能只是一个JSON结构。***'
- en: '***![The web framework returns the data in an HTTP response](../Images/e4b6ce92027a26aa198e39c8d4afa4b5.png)The
    web framework returns the data in an HTTP response***'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '***![Web框架在HTTP响应中返回数据](../Images/e4b6ce92027a26aa198e39c8d4afa4b5.png)Web框架在HTTP响应中返回数据***'
- en: '***Advantages of a layered architecture***'
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '***分层架构的优势***'
- en: '***As you can see, the stages of this process are clearly separated, and there
    is a great deal of data transformation between them. Using common data formats
    is one of the way we achieve independence, or loose coupling, between components
    of a computer system.***'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '***如你所见，这个过程的各个阶段是明显分开的，它们之间有大量的数据转换。使用常见的数据格式是我们实现计算机系统组件之间独立性的方法之一。***'
- en: '***To better understand what loose coupling means for a programmer, let''s
    consider the last picture. In the previous paragraphs I gave an example of a system
    that uses a web framework for the user interface and a relational database for
    the data source, but what would change if the front-end part was a command-line
    interface? And what would change if, instead of a relational database, there was
    another type of data source, for example a set of text files?***'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '***为了更好地理解松耦合对程序员意味着什么，让我们考虑最后一张图。在前面的段落中，我给出了一个使用Web框架作为用户界面和关系型数据库作为数据源的系统的例子，但如果前端部分是一个命令行界面会发生什么变化？如果，而不是关系型数据库，有一个其他类型的数据源，例如一组文本文件，会发生什么变化？***'
- en: '***![The web framework replaced by a CLI](../Images/179d70402b2999599ed5160872cb40ed.png)The
    web framework replaced by a CLI******![A database replaced by a more trivial file-based
    storage](../Images/063c5d5885cb494eb48ab604e8507c5d.png)A database replaced by
    a more trivial file-based storage***'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '***![Web框架被CLI取代](../Images/179d70402b2999599ed5160872cb40ed.png)Web框架被CLI取代******![数据库被更简单的基于文件的存储取代](../Images/063c5d5885cb494eb48ab604e8507c5d.png)数据库被更简单的基于文件的存储取代***'
- en: '***As you can see, both changes would require the replacement of some components.
    After all, we need different code to manage a command line instead of a web page.
    But the external shape of the system doesn''t change, neither does the way data
    flows. We created a system in which the user interface (web framework, command-line
    interface) and the data source (relational database, text files) are details of
    the implementation, and not core parts of it.***'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '***正如你所见，这两个更改都需要替换一些组件。毕竟，我们需要不同的代码来管理命令行而不是网页。但系统的外部形状并没有改变，数据流动的方式也没有改变。我们创建了一个系统，其中用户界面（Web框架、命令行界面）和数据源（关系数据库、文本文件）是实现的细节，而不是其核心部分。***'
- en: '***The main immediate advantage of a layered architecture, however, is testability.
    When you clearly separate components you clearly establish the data each of them
    has to receive and produce, so you can ideally disconnect a single component and
    test it in isolation. Let''s take the Web framework component that we added and
    consider it for a moment forgetting the rest of the architecture. We can ideally
    connect a tester to its inputs and outputs as you can see in the figure***'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '***然而，分层架构的主要直接优势是可测试性。当你清楚地分离组件时，你可以清楚地确定每个组件需要接收和产生哪些数据，因此你可以理想地断开单个组件并对其进行单独测试。让我们暂时忽略其他架构，考虑我们添加的Web框架组件。如图所示***'
- en: '***![Testing the web layer in isolation](../Images/d224037cf8f8a3df62c3dd6ed643fa3e.png)Testing
    the web layer in isolation******![Detailed setup of the web layer testing, width=80%](../Images/0bc5e22566f89d5f79ef5be8103fe6aa.png)Detailed
    setup of the web layer testing***'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '***![单独测试网络层](../Images/d224037cf8f8a3df62c3dd6ed643fa3e.png)单独测试网络层******![网络层测试的详细设置，宽度=80%](../Images/0bc5e22566f89d5f79ef5be8103fe6aa.png)网络层测试的详细设置***'
- en: '***We know that the Web framework receives an HTTP request (1) with a specific
    target and a specific query string, and that it has to call (2) a method on the
    use case passing specific parameters. When the use case returns data (3), the
    Web framework has to convert that into an HTTP response (4). Since this is a test
    we can have a fake use case, that is an object that just mimics what the use case
    does without really implementing the business logic. We will then test that the
    Web framework calls the method (2) with the correct parameters, and that the HTTP
    response (4) contains the correct data in the proper format, and all this will
    happen without involving any other part of the system.***'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '***我们知道Web框架接收一个带有特定目标和特定查询字符串的HTTP请求（1），并且它必须调用（2）用例上的一个方法，传递特定的参数。当用例返回数据（3）时，Web框架必须将其转换为HTTP响应（4）。由于这是一个测试，我们可以有一个模拟用例，即一个仅模仿用例行为而不真正实现业务逻辑的对象。然后我们将测试Web框架是否以正确的参数调用方法（2），以及HTTP响应（4）是否包含正确格式的数据，所有这一切都将不涉及系统的任何其他部分。***'
- en: '* * *'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '***So, now that we had a 10,000 feet overview of the system, let''s go deeper
    into its components and the concepts behind them. In the next chapter I will detail
    how the design principles called "clean architecture" help to implement and use
    effectively concepts like separation of concerns, abstraction, implementation,
    and inversion of control.***'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '***因此，现在我们已经对系统有了10,000英尺的高度概述，让我们更深入地了解其组件及其背后的概念。在下一章中，我将详细说明被称为“清洁架构”的设计原则如何帮助有效地实现和利用诸如关注点分离、抽象、实现和控制反转等概念。***'
- en: '***[1](#fr-58102884)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '***[1](#fr-58102884)'
- en: I was inspired by the Sludge-O-Matic™ from Day of the Tentacle*** ***[2](#fr-54651647)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我受到了《时空怪客》中的Sludge-O-Matic™的启发*** ***[2](#fr-54651647)
- en: There are many more layers that the HTTP request has to go through before reaching
    the actual web framework, for example the web server, but since the purpose of
    those layers is mostly to increase performances, I am not going to consider them
    until the end of the book.*** ***[3](#fr-33501696)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在到达实际的Web框架之前，HTTP请求必须通过许多其他层，例如Web服务器，但由于这些层的目的是主要提高性能，我将在本书的结尾再考虑它们。*** ***[3](#fr-33501696)
- en: The word *language*, here, is meant in its broader sense. It might be a programming
    language, but also an API, a data format, or a protocol.***
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“语言”一词是指其更广泛的意义。它可能是一种编程语言，也可能是API、数据格式或协议。***
