["```py\nhttp://example.org/index.html\n\n```", "```py\ntelnet example.org 80\n```", "```py\nnc -v example.org 80\n```", "```py\nTrying 93.184.216.34...\nConnected to example.org.\nEscape character is '^]'.\n```", "```py\nGET /index.html HTTP/1.0\nHost: example.org\n\n```", "```py\nHTTP/1.0 200 OK\n\n```", "```py\nAge: 545933\nCache-Control: max-age=604800\nContent-Type: text/html; charset=UTF-8\nDate: Mon, 25 Feb 2019 16:49:28 GMT\nEtag: \"1541025663+gzip+ident\"\nExpires: Mon, 04 Mar 2019 16:49:28 GMT\nLast-Modified: Fri, 09 Aug 2013 23:54:35 GMT\nServer: ECS (sec/96EC)\nVary: Accept-Encoding\nX-Cache: HIT\nContent-Length: 1270\nConnection: close\n```", "```py\nclass URL:\n def __init__(self, url):\n # ...\n```", "```py\nclass URL:\n def __init__(self, url):\n self.scheme, url = url.split(\"://\", 1)\n assert self.scheme == \"http\"\n```", "```py\nclass URL:\n def __init__(self, url):\n # ...\n if \"/\" not in url:\n url = url + \"/\"\n self.host, url = url.split(\"/\", 1)\n self.path = \"/\" + url\n```", "```py\nclass URL:\n def request(self):\n # ...\n```", "```py\nimport socket\n\nclass URL:\n def request(self):\n s = socket.socket(\n family=socket.AF_INET,\n type=socket.SOCK_STREAM,\n proto=socket.IPPROTO_TCP,\n )\n```", "```py\nclass URL:\n def request(self):\n # ...\n s.connect((self.host, 80))\n```", "```py\nclass URL:\n def request(self):\n # ...\n request = \"GET {} HTTP/1.0\\r\\n\".format(self.path)\n request += \"Host: {}\\r\\n\".format(self.host)\n request += \"\\r\\n\"\n s.send(request.encode(\"utf8\"))\n```", "```py\n>>> type(\"text\")\n<class 'str'>\n>>> type(\"text\".encode(\"utf8\"))\n<class 'bytes'>\n```", "```py\nclass URL:\n def request(self):\n # ...\n response = s.makefile(\"r\", encoding=\"utf8\", newline=\"\\r\\n\")\n```", "```py\nclass URL:\n def request(self):\n # ...\n statusline = response.readline()\n version, status, explanation = statusline.split(\" \", 2)\n```", "```py\nclass URL:\n def request(self):\n # ...\n response_headers = {}\n while True:\n line = response.readline()\n if line == \"\\r\\n\": break\n header, value = line.split(\":\", 1)\n response_headers[header.casefold()] = value.strip()\n```", "```py\nclass URL:\n def request(self):\n # ...\n assert \"transfer-encoding\" not in response_headers\n assert \"content-encoding\" not in response_headers\n```", "```py\nclass URL:\n def request(self):\n # ...\n content = response.read()\n s.close()\n```", "```py\nclass URL:\n def request(self):\n # ...\n return content\n```", "```py\ndef show(body):\n in_tag = False\n for c in body:\n if c == \"<\":\n in_tag = True\n elif c == \">\":\n in_tag = False\n elif not in_tag:\n print(c, end=\"\")\n```", "```py\ndef load(url):\n body = url.request()\n show(body)\n```", "```py\nif __name__ == \"__main__\":\n import sys\n load(URL(sys.argv[1]))\n```", "```py\npython3 browser.py http://example.org/\n```", "```py\nimport ssl\nctx = ssl.create_default_context()\ns = ctx.wrap_socket(s, server_hostname=host)\n```", "```py\nimport ssl\n\nclass URL:\n def __init__(self, url):\n self.scheme, url = url.split(\"://\", 1)\n assert self.scheme in [\"http\", \"https\"]\n # ...\n```", "```py\nclass URL:\n def __init__(self, url):\n # ...\n if self.scheme == \"http\":\n self.port = 80\n elif self.scheme == \"https\":\n self.port = 443\n```", "```py\nclass URL:\n def request(self):\n # ...\n s.connect((self.host, self.port))\n # ...\n```", "```py\nclass URL:\n def request(self):\n # ...\n s.connect((self.host, self.port))\n if self.scheme == \"https\":\n ctx = ssl.create_default_context()\n s = ctx.wrap_socket(s, server_hostname=self.host)\n # ...\n```", "```py\nhttp://example.org:8080/index.html\n\n```", "```py\nclass URL:\n def __init__(self, url):\n # ...\n if \":\" in self.host:\n self.host, port = self.host.split(\":\", 1)\n self.port = int(port)\n```", "```py\npython3 -m http.server 8000 -d /some/directory\n```", "```py\n This is a simple\n    web page with some\n    text in it. \n```", "```py\nimport tkinter\nwindow = tkinter.Tk()\ntkinter.mainloop()\n```", "```py\nwhile True:\n for evt in pendingEvents():\n handleEvent(evt)\n drawScreen()\n```", "```py\nwindow = tkinter.Tk()\ncanvas = tkinter.Canvas(window, width=800, height=600)\ncanvas.pack()\n```", "```py\nWIDTH, HEIGHT = 800, 600\n\nclass Browser:\n def __init__(self):\n self.window = tkinter.Tk()\n self.canvas = tkinter.Canvas(\n self.window, \n width=WIDTH,\n height=HEIGHT\n )\n self.canvas.pack()\n```", "```py\nclass Browser:\n def load(self, url):\n # ...\n self.canvas.create_rectangle(10, 20, 400, 300)\n self.canvas.create_oval(100, 100, 150, 150)\n self.canvas.create_text(200, 150, text=\"Hi!\")\n```", "```py\nif __name__ == \"__main__\":\n import sys\n Browser().load(URL(sys.argv[1]))\n tkinter.mainloop()\n```", "```py\ndef lex(body):\n text = \"\"\n # ...\n for c in body:\n # ...\n elif not in_tag:\n text += c\n return text\n```", "```py\ndef load(self, url):\n # ...\n for c in text:\n self.canvas.create_text(100, 100, text=c)\n```", "```py\nHSTEP, VSTEP = 13, 18\ncursor_x, cursor_y = HSTEP, VSTEP\nfor c in text:\n self.canvas.create_text(cursor_x, cursor_y, text=c)\n cursor_x += HSTEP\n```", "```py\nfor c in text:\n # ...\n if cursor_x >= WIDTH - HSTEP:\n cursor_y += VSTEP\n cursor_x = HSTEP\n```", "```py\ndef layout(text):\n display_list = []\n cursor_x, cursor_y = HSTEP, VSTEP\n for c in text:\n display_list.append((cursor_x, cursor_y, c))\n # ...\n return display_list\n```", "```py\nclass Browser:\n def draw(self):\n for x, y, c in self.display_list:\n self.canvas.create_text(x, y, text=c)\n```", "```py\nclass Browser:\n def load(self, url):\n body = url.request()\n text = lex(body)\n self.display_list = layout(text)\n self.draw()\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.scroll = 0\n```", "```py\ndef draw(self):\n for x, y, c in self.display_list:\n self.canvas.create_text(x, y - self.scroll, text=c)\n```", "```py\ndef __init__(self):\n # ...\n self.window.bind(\"<Down>\", self.scrolldown)\n```", "```py\nSCROLL_STEP = 100\n\ndef scrolldown(self, e):\n self.scroll += SCROLL_STEP\n self.draw()\n```", "```py\ndef draw(self):\n self.canvas.delete(\"all\")\n # ...\n```", "```py\nfor x, y, c in self.display_list:\n if y > self.scroll + HEIGHT: continue\n if y + VSTEP < self.scroll: continue\n # ...\n```", "```py\nimport tkinter.font\nwindow = tkinter.Tk()\nbi_times = tkinter.font.Font(\n family=\"Times\",\n size=16,\n weight=\"bold\",\n slant=\"italic\",\n)\n```", "```py\ncanvas.create_text(200, 100, text=\"Hi!\", font=bi_times)\n```", "```py\n>>> bi_times.metrics()\n{'ascent': 15, 'descent': 4, 'linespace': 19, 'fixed': 0}\n>>> bi_times.measure(\"Hi!\")\n24\n```", "```py\n>>> tkinter.font.Font(family=\"Courier\", size=16).metrics()\n{'fixed': 1, 'ascent': 13, 'descent': 4, 'linespace': 17}\n>>> tkinter.font.Font(family=\"Times\", size=16).metrics()\n{'fixed': 0, 'ascent': 14, 'descent': 4, 'linespace': 18}\n>>> tkinter.font.Font(family=\"Helvetica\", size=16).metrics()\n{'fixed': 0, 'ascent': 15, 'descent': 4, 'linespace': 19}\n```", "```py\n>>> bi_times.measure(\"Hi!\")\n24\n>>> bi_times.measure(\"H\")\n13\n>>> bi_times.measure(\"i\")\n5\n>>> bi_times.measure(\"!\")\n7\n>>> 13 + 5 + 7\n25\n```", "```py\nfont1 = tkinter.font.Font(family=\"Times\", size=16)\nfont2 = tkinter.font.Font(family=\"Times\", size=16, slant='italic')\n```", "```py\nx, y = 200, 200\ncanvas.create_text(x, y, text=\"Hello, \", font=font1)\nx += font1.measure(\"Hello, \")\ncanvas.create_text(x, y, text=\"world!\", font=font2)\n```", "```py\nx, y = 200, 225\ncanvas.create_text(x, y, text=\"Hello, \", font=font1, anchor='nw')\nx += font1.measure(\"Hello, \")\ncanvas.create_text(\n x, y, text=\"overlapping!\", font=font2, anchor='nw')\n```", "```py\ndef layout(text):\n # ...\n for word in text.split():\n # ...\n return display_list\n```", "```py\nimport tkinter.font\n\ndef layout(text):\n font = tkinter.font.Font()\n # ...\n for word in text.split():\n w = font.measure(word)\n # ...\n```", "```py\ndef layout(text):\n for word in text.split():\n # ...\n if cursor_x + w > WIDTH - HSTEP:\n cursor_y += font.metrics(\"linespace\") * 1.25\n cursor_x = HSTEP\n```", "```py\ndef layout(text):\n for word in text.split():\n # ...\n display_list.append((cursor_x, cursor_y, word))\n cursor_x += w + font.measure(\" \")\n```", "```py\nclass Text:\n def __init__(self, text):\n self.text = text\n\nclass Tag:\n def __init__(self, tag):\n self.tag = tag\n```", "```py\ndef lex(body):\n out = []\n buffer = \"\"\n in_tag = False\n for c in body:\n if c == \"<\":\n in_tag = True\n if buffer: out.append(Text(buffer))\n buffer = \"\"\n elif c == \">\":\n in_tag = False\n out.append(Tag(buffer))\n buffer = \"\"\n else:\n buffer += c\n if not in_tag and buffer:\n out.append(Text(buffer))\n return out\n```", "```py\ndef layout(tokens):\n # ...\n for tok in tokens:\n if isinstance(tok, Text):\n for word in tok.text.split():\n # ...\n # ...\n```", "```py\nweight = \"normal\"\nstyle = \"roman\"\n```", "```py\nif isinstance(tok, Text):\n # ...\nelif tok.tag == \"i\":\n style = \"italic\"\nelif tok.tag == \"/i\":\n style = \"roman\"\nelif tok.tag == \"b\":\n weight = \"bold\"\nelif tok.tag == \"/b\":\n weight = \"normal\"\n```", "```py\nif isinstance(tok, Text):\n for word in tok.text.split():\n font = tkinter.font.Font(\n size=16,\n weight=weight,\n slant=style,\n )\n # ...\n```", "```py\nif isinstance(tok, Text):\n for word in tok.text.split():\n # ...\n display_list.append((cursor_x, cursor_y, word, font))\n```", "```py\nclass Layout:\n def __init__(self, tokens):\n self.display_list = []\n```", "```py\nself.cursor_x = HSTEP\nself.cursor_y = VSTEP\nself.weight = \"normal\"\nself.style = \"roman\"\n```", "```py\ndef __init__(self, tokens):\n # ...\n for tok in tokens:\n self.token(tok)\n\ndef token(self, tok):\n if isinstance(tok, Text):\n for word in tok.text.split():\n # ...\n elif tok.tag == \"i\":\n self.style = \"italic\"\n # ...\n```", "```py\ndef word(self, word):\n font = tkinter.font.Font(\n size=16,\n weight=self.weight,\n slant=self.style,\n )\n w = font.measure(word)\n # ...\n```", "```py\nclass Browser:\n def load(self, url):\n body = url.request()\n tokens = lex(body)\n self.display_list = Layout(tokens).display_list\n self.draw()\n```", "```py\nself.size = 12\n```", "```py\nfont = tkinter.font.Font(\n size=self.size,\n weight=self.weight,\n slant=self.style,\n)\n```", "```py\ndef token(self, tok):\n # ...\n elif tok.tag == \"small\":\n self.size -= 2\n elif tok.tag == \"/small\":\n self.size += 2\n elif tok.tag == \"big\":\n self.size += 4\n elif tok.tag == \"/big\":\n self.size -= 4\n```", "```py\nclass Layout:\n def __init__(self, tokens):\n # ...\n self.line = []\n # ...\n\n def word(self, word):\n # ...\n self.line.append((self.cursor_x, word, font))\n```", "```py\nclass Layout:\n def word(self, word):\n if self.cursor_x + w > WIDTH - HSTEP:\n self.flush()\n```", "```py\nclass Layout:\n def __init__(self, tokens):\n # ...\n self.flush()\n```", "```py\ndef flush(self):\n if not self.line: return\n metrics = [font.metrics() for x, word, font in self.line]\n max_ascent = max([metric[\"ascent\"] for metric in metrics])\n```", "```py\nbaseline = self.cursor_y + 1.25 * max_ascent\n```", "```py\nfor x, word, font in self.line:\n y = baseline - font.metrics(\"ascent\")\n self.display_list.append((x, y, word, font))\n```", "```py\nmax_descent = max([metric[\"descent\"] for metric in metrics])\nself.cursor_y = baseline + 1.25 * max_descent\n```", "```py\nself.cursor_x = HSTEP\nself.line = []\n```", "```py\ndef token(self, tok):\n # ...\n elif tok.tag == \"br\":\n self.flush()\n```", "```py\ndef token(self, tok):\n # ...\n elif tok.tag == \"/p\":\n self.flush()\n self.cursor_y += VSTEP\n```", "```py\nFONTS = {}\n```", "```py\ndef get_font(size, weight, style):\n key = (size, weight, style)\n if key not in FONTS:\n font = tkinter.font.Font(size=size, weight=weight,\n slant=style)\n label = tkinter.Label(font=font)\n FONTS[key] = (font, label)\n return FONTS[key][0]\n```", "```py\nclass Layout:\n def word(self, word):\n font = get_font(self.size, self.weight, self.style)\n # ...\n```", "```py\nclass Text:\n def __init__(self, text, parent):\n self.text = text\n self.children = []\n self.parent = parent\n```", "```py\nclass Element:\n def __init__(self, tag, parent):\n self.tag = tag\n self.children = []\n self.parent = parent\n```", "```py\n<html><video></video><section><h1>This is my webpage\n```", "```py\nclass HTMLParser:\n def __init__(self, body):\n self.body = body\n self.unfinished = []\n```", "```py\nclass HTMLParser:\n def parse(self):\n # ...\n```", "```py\ndef parse(self):\n text = \"\"\n in_tag = False\n for c in self.body:\n if c == \"<\":\n in_tag = True\n if text: self.add_text(text)\n text = \"\"\n elif c == \">\":\n in_tag = False\n self.add_tag(text)\n text = \"\"\n else:\n text += c\n if not in_tag and text:\n self.add_text(text)\n return self.finish()\n```", "```py\nclass HTMLParser:\n def add_text(self, text):\n parent = self.unfinished[-1]\n node = Text(text, parent)\n parent.children.append(node)\n```", "```py\nclass HTMLParser:\n def add_tag(self, tag):\n if tag.startswith(\"/\"):\n # ...\n else:\n # ...\n```", "```py\ndef add_tag(self, tag):\n # ...\n else:\n parent = self.unfinished[-1]\n node = Element(tag, parent)\n self.unfinished.append(node)\n```", "```py\ndef add_tag(self, tag):\n if tag.startswith(\"/\"):\n node = self.unfinished.pop()\n parent = self.unfinished[-1]\n parent.children.append(node)\n # ...\n```", "```py\nclass HTMLParser:\n def finish(self):\n while len(self.unfinished) > 1:\n node = self.unfinished.pop()\n parent = self.unfinished[-1]\n parent.children.append(node)\n return self.unfinished.pop()\n```", "```py\ndef add_tag(self, tag):\n # ...\n else:\n parent = self.unfinished[-1] if self.unfinished else None\n # ...\n```", "```py\ndef add_tag(self, tag):\n if tag.startswith(\"/\"):\n if len(self.unfinished) == 1: return\n # ...\n```", "```py\ndef print_tree(node, indent=0):\n print(\" \" * indent, node)\n for child in node.children:\n print_tree(child, indent + 2)\n```", "```py\nclass Text:\n def __repr__(self):\n return repr(self.text)\n\nclass Element:\n def __repr__(self):\n return \"<\" + self.tag + \">\"\n```", "```py\nbody = URL(sys.argv[1]).request()\nnodes = HTMLParser(body).parse()\nprint_tree(nodes)\n```", "```py\n <!doctype html>\n   '\\n'\n   <html lang=\"en-US\" xml:lang=\"en-US\">\n     '\\n'\n     <head>\n       '\\n  '\n       <meta charset=\"utf-8\" />\n```", "```py\ndef add_tag(self, tag):\n if tag.startswith(\"!\"): return\n # ...\n```", "```py\ndef add_text(self, text):\n if text.isspace(): return\n # ...\n```", "```py\n <html lang=\"en-US\" xml:lang=\"en-US\">\n   <head>\n     <meta charset=\"utf-8\" /=\"\">\n       <link rel=\"prefetch\" ...>\n         <link rel=\"prefetch\" ...>\n```", "```py\nSELF_CLOSING_TAGS = [\n \"area\", \"base\", \"br\", \"col\", \"embed\", \"hr\", \"img\", \"input\",\n \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\",\n]\n```", "```py\ndef add_tag(self, tag):\n # ...\n elif tag in self.SELF_CLOSING_TAGS:\n parent = self.unfinished[-1]\n node = Element(tag, parent)\n parent.children.append(node)\n```", "```py\nclass HTMLParser:\n def get_attributes(self, text):\n parts = text.split()\n tag = parts[0].casefold()\n attributes = {}\n for attrpair in parts[1:]:\n # ...\n return tag, attributes\n```", "```py\ndef get_attributes(self, text):\n # ...\n for attrpair in parts[1:]:\n if \"=\" in attrpair:\n key, value = attrpair.split(\"=\", 1)\n attributes[key.casefold()] = value\n # ...\n```", "```py\nfor attrpair in parts[1:]:\n # ...\n else:\n attributes[attrpair.casefold()] = \"\"\n```", "```py\nif \"=\" in attrpair:\n # ...\n if len(value) > 2 and value[0] in [\"'\", \"\\\"\"]:\n value = value[1:-1]\n # ...\n```", "```py\nclass Element:\n def __init__(self, tag, attributes, parent):\n self.tag = tag\n self.attributes = attributes\n # ...\n```", "```py\ndef add_tag(self, tag):\n tag, attributes = self.get_attributes(tag)\n # ...\n```", "```py\n <html>\n    <head>\n      <meta>\n      <link>\n      <link>\n      <link>\n      <link>\n      <link>\n      <meta>\n```", "```py\nclass Layout:\n def open_tag(self, tag):\n if tag == \"i\":\n self.style = \"italic\"\n # ...\n\n def close_tag(self, tag):\n if tag == \"i\":\n self.style = \"roman\"\n # ...\n```", "```py\ndef recurse(self, tree):\n if isinstance(tree, Text):\n for word in tree.text.split():\n self.word(word)\n else:\n self.open_tag(tree.tag)\n for child in tree.children:\n self.recurse(child)\n self.close_tag(tree.tag)\n```", "```py\nclass Browser:\n def load(self, url):\n body = url.request()\n self.nodes = HTMLParser(body).parse()\n self.display_list = Layout(self.nodes).display_list\n self.draw()\n```", "```py\n<!doctype html>\n<html>\n <head>\n </head>\n <body>\n </body>\n</html>\n```", "```py\nclass HTMLParser:\n def add_text(self, text):\n if text.isspace(): return\n self.implicit_tags(None)\n # ...\n\n def add_tag(self, tag):\n tag, attributes = self.get_attributes(tag)\n if tag.startswith(\"!\"): return\n self.implicit_tags(tag)\n # ...\n```", "```py\nclass HTMLParser:\n def finish(self):\n if not self.unfinished:\n self.implicit_tags(None)\n # ...\n```", "```py\nclass HTMLParser:\n def implicit_tags(self, tag):\n while True:\n open_tags = [node.tag for node in self.unfinished]\n # ...\n```", "```py\nwhile True:\n # ...\n if open_tags == [] and tag != \"html\":\n self.add_tag(\"html\")\n```", "```py\nwhile True:\n # ...\n elif open_tags == [\"html\"] \\\n and tag not in [\"head\", \"body\", \"/html\"]:\n if tag in self.HEAD_TAGS:\n self.add_tag(\"head\")\n else:\n self.add_tag(\"body\")\n```", "```py\nclass HTMLParser:\n HEAD_TAGS = [\n \"base\", \"basefont\", \"bgsound\", \"noscript\",\n \"link\", \"meta\", \"title\", \"style\", \"script\",\n ]\n```", "```py\nwhile True:\n # ...\n elif open_tags == [\"html\", \"head\"] and \\\n tag not in [\"/head\"] + self.HEAD_TAGS:\n self.add_tag(\"/head\")\n```", "```py\nwhile True:\n # ...\n else:\n break\n```", "```py\nclass Browser:\n def load(self, url):\n # ...\n self.display_list = Layout(self.nodes).display_list\n #...\n```", "```py\nclass Browser:\n def load(self, url):\n # ...\n self.document = Layout(self.nodes)\n self.document.layout()\n #...\n```", "```py\nclass Layout:\n def __init__(self, node):\n self.node = node\n```", "```py\nclass Layout:\n def __init__(self, node, parent, previous):\n self.node = node\n self.parent = parent\n self.previous = previous\n self.children = []\n```", "```py\nclass DocumentLayout:\n def __init__(self, node):\n self.node = node\n self.parent = None\n self.children = []\n\n def layout(self):\n child = Layout(self.node, self, None)\n self.children.append(child)\n child.layout()\n```", "```py\nclass BlockLayout:\n # ...\n```", "```py\nclass BlockLayout:\n def layout_intermediate(self):\n previous = None\n for child in self.node.children:\n next = BlockLayout(child, self, previous)\n self.children.append(next)\n previous = next\n```", "```py\nclass BlockLayout:\n def layout_mode(self):\n if isinstance(self.node, Text):\n return \"inline\"\n elif any([isinstance(child, Element) and \\\n child.tag in BLOCK_ELEMENTS\n for child in self.node.children]):\n return \"block\"\n elif self.node.children:\n return \"inline\"\n else:\n return \"block\"\n```", "```py\nBLOCK_ELEMENTS = [\n \"html\", \"body\", \"article\", \"section\", \"nav\", \"aside\",\n \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"hgroup\", \"header\",\n \"footer\", \"address\", \"p\", \"hr\", \"pre\", \"blockquote\",\n \"ol\", \"ul\", \"menu\", \"li\", \"dl\", \"dt\", \"dd\", \"figure\",\n \"figcaption\", \"main\", \"div\", \"table\", \"form\", \"fieldset\",\n \"legend\", \"details\", \"summary\"\n]\n```", "```py\nclass BlockLayout:\n def layout(self):\n mode = self.layout_mode()\n if mode == \"block\":\n previous = None\n for child in self.node.children:\n next = BlockLayout(child, self, previous)\n self.children.append(next)\n previous = next\n else:\n self.cursor_x = 0\n self.cursor_y = 0\n self.weight = \"normal\"\n self.style = \"roman\"\n self.size = 12\n\n self.line = []\n self.recurse(self.node)\n self.flush()\n```", "```py\nclass BlockLayout:\n def layout(self):\n # ...\n for child in self.children:\n child.layout()\n```", "```py\nclass BlockLayout:\n def __init__(self, node, parent, previous):\n # ...\n self.x = None\n self.y = None\n self.width = None\n self.height = None\n```", "```py\nclass BlockLayout:\n def layout(self):\n else:\n self.cursor_x = 0\n self.cursor_y = 0\n\n def flush(self):\n # ...\n self.cursor_x = 0\n # ...\n```", "```py\nclass BlockLayout:\n def flush(self):\n # ...\n for rel_x, word, font in self.line:\n x = self.x + rel_x\n y = self.y + baseline - font.metrics(\"ascent\")\n self.display_list.append((x, y, word, font))\n # ...\n```", "```py\nclass BlockLayout:\n def word(self, word):\n # ...\n if self.cursor_x + w > self.width:\n # ...\n # ...\n```", "```py\nclass BlockLayout:\n def layout(self):\n self.x = self.parent.x\n self.width = self.parent.width\n # ...\n```", "```py\nclass BlockLayout:\n def layout(self):\n if self.previous:\n self.y = self.previous.y + self.previous.height\n else:\n self.y = self.parent.y\n # ...\n```", "```py\nclass BlockLayout:\n def layout(self):\n # ...\n if mode == \"block\":\n self.height = sum([\n child.height for child in self.children])\n```", "```py\nclass BlockLayout:\n def layout(self):\n # ...\n else:\n self.height = self.cursor_y\n```", "```py\nclass DocumentLayout:\n def layout(self):\n # ...\n self.width = WIDTH - 2*HSTEP\n self.x = HSTEP\n self.y = VSTEP\n child.layout()\n self.height = child.height\n```", "```py\ndef paint_tree(layout_object, display_list):\n display_list.extend(layout_object.paint())\n\n for child in layout_object.children:\n paint_tree(child, display_list)\n```", "```py\nclass DocumentLayout:\n def paint(self):\n return []\n```", "```py\nclass BlockLayout:\n def paint(self):\n return self.display_list\n```", "```py\nclass Browser:\n def load(self, url):\n # ...\n self.display_list = []\n paint_tree(self.document, self.display_list)\n self.draw()\n```", "```py\nclass DrawText:\n def __init__(self, x1, y1, text, font):\n self.top = y1\n self.left = x1\n self.text = text\n self.font = font\n\nclass DrawRect:\n def __init__(self, x1, y1, x2, y2, color):\n self.top = y1\n self.left = x1\n self.bottom = y2\n self.right = x2\n self.color = color\n```", "```py\nclass BlockLayout:\n def paint(self):\n cmds = []\n if self.layout_mode() == \"inline\":\n for x, y, word, font in self.display_list:\n cmds.append(DrawText(x, y, word, font))\n return cmds\n```", "```py\nclass BlockLayout:\n def paint(self):\n # ...\n if isinstance(self.node, Element) and self.node.tag == \"pre\":\n x2, y2 = self.x + self.width, self.y + self.height\n rect = DrawRect(self.x, self.y, x2, y2, \"gray\")\n cmds.append(rect)\n # ...\n```", "```py\nclass DrawText:\n def execute(self, scroll, canvas):\n canvas.create_text(\n self.left, self.top - scroll,\n text=self.text,\n font=self.font,\n anchor='nw')\n```", "```py\nclass DrawRect:\n def execute(self, scroll, canvas):\n canvas.create_rectangle(\n self.left, self.top - scroll,\n self.right, self.bottom - scroll,\n width=0,\n fill=self.color)\n```", "```py\ndef __init__(self, x1, y1, text, font):\n # ...\n self.bottom = y1 + font.metrics(\"linespace\")\n```", "```py\nclass Browser:\n def draw(self):\n self.canvas.delete(\"all\")\n for cmd in self.display_list:\n if cmd.top > self.scroll + HEIGHT: continue\n if cmd.bottom < self.scroll: continue\n cmd.execute(self.scroll, self.canvas)\n```", "```py\ndef scrolldown(self, e):\n max_y = max(self.document.height + 2*VSTEP - HEIGHT, 0)\n self.scroll = min(self.scroll + SCROLL_STEP, max_y)\n self.draw()\n```", "```py\n<div><i>Hello, </i><b>world!</b><p>So it began...</p></div>\n```", "```py\n<div style=\"background-color:lightblue\">Blue background</div>\n```", "```py\nclass CSSParser:\n def __init__(self, s):\n self.s = s\n self.i = 0\n```", "```py\ndef whitespace(self):\n while self.i < len(self.s) and self.s[self.i].isspace():\n self.i += 1\n```", "```py\ndef word(self):\n start = self.i\n while self.i < len(self.s):\n if self.s[self.i].isalnum() or self.s[self.i] in \"#-.%\":\n self.i += 1\n else:\n break\n if not (self.i > start):\n raise Exception(\"Parsing error\")\n return self.s[start:self.i]\n```", "```py\ndef literal(self, literal):\n if not (self.i < len(self.s) and self.s[self.i] == literal):\n raise Exception(\"Parsing error\")\n self.i += 1\n```", "```py\ndef pair(self):\n prop = self.word()\n self.whitespace()\n self.literal(\":\")\n self.whitespace()\n val = self.word()\n return prop.casefold(), val\n```", "```py\ndef body(self):\n pairs = {}\n while self.i < len(self.s):\n prop, val = self.pair()\n pairs[prop.casefold()] = val\n self.whitespace()\n self.literal(\";\")\n self.whitespace()\n return pairs\n```", "```py\ndef ignore_until(self, chars):\n while self.i < len(self.s):\n if self.s[self.i] in chars:\n return self.s[self.i]\n else:\n self.i += 1\n return None\n```", "```py\ndef body(self):\n # ...\n while self.i < len(self.s):\n try:\n # ...\n except Exception:\n why = self.ignore_until([\";\"])\n if why == \";\":\n self.literal(\";\")\n self.whitespace()\n else:\n break\n # ...\n```", "```py\ndef style(node):\n node.style = {}\n if isinstance(node, Element) and \"style\" in node.attributes:\n pairs = CSSParser(node.attributes[\"style\"]).body()\n for property, value in pairs.items():\n node.style[property] = value\n```", "```py\ndef style(node):\n # ...\n for child in node.children:\n style(child)\n```", "```py\nclass BlockLayout:\n def paint(self):\n # ...\n bgcolor = self.node.style.get(\"background-color\",\n \"transparent\")\n if bgcolor != \"transparent\":\n x2, y2 = self.x + self.width, self.y + self.height\n rect = DrawRect(self.x, self.y, x2, y2, bgcolor)\n cmds.append(rect)\n # ...\n```", "```py\nclass TagSelector:\n def __init__(self, tag):\n self.tag = tag\n```", "```py\nclass TagSelector:\n def matches(self, node):\n return isinstance(node, Element) and self.tag == node.tag\n```", "```py\nclass DescendantSelector:\n def __init__(self, ancestor, descendant):\n self.ancestor = ancestor\n self.descendant = descendant\n```", "```py\nclass DescendantSelector:\n def matches(self, node):\n if not self.descendant.matches(node): return False\n while node.parent:\n if self.ancestor.matches(node.parent): return True\n node = node.parent\n return False\n```", "```py\nclass CSSParser:\n def selector(self):\n out = TagSelector(self.word().casefold())\n self.whitespace()\n while self.i < len(self.s) and self.s[self.i] != \"{\":\n tag = self.word()\n descendant = TagSelector(tag.casefold())\n out = DescendantSelector(out, descendant)\n self.whitespace()\n return out\n```", "```py\ndef parse(self):\n rules = []\n while self.i < len(self.s):\n self.whitespace()\n selector = self.selector()\n self.literal(\"{\")\n self.whitespace()\n body = self.body()\n self.literal(\"}\")\n rules.append((selector, body))\n return rules\n```", "```py\ndef body(self):\n # ...\n while self.i < len(self.s) and self.s[self.i] != \"}\":\n try:\n # ...\n except Exception:\n why = self.ignore_until([\";\", \"}\"])\n if why == \";\":\n self.literal(\";\")\n self.whitespace()\n else:\n break\n # ...\n```", "```py\ndef parse(self):\n # ...\n while self.i < len(self.s):\n try:\n # ...\n except Exception:\n why = self.ignore_until([\"}\"])\n if why == \"}\":\n self.literal(\"}\")\n self.whitespace()\n else:\n break\n # ...\n```", "```py\ndef style(node, rules):\n # ...\n for selector, body in rules:\n if not selector.matches(node): continue\n for property, value in body.items():\n node.style[property] = value\n # ...\n```", "```py\npre { background-color: gray; }\n```", "```py\nDEFAULT_STYLE_SHEET = CSSParser(open(\"browser.css\").read()).parse()\n```", "```py\ndef load(self, url):\n # ...\n rules = DEFAULT_STYLE_SHEET.copy()\n style(self.nodes, rules)\n # ...\n```", "```py\n<link rel=\"stylesheet\" href=\"/main.css\">\n```", "```py\ndef tree_to_list(tree, list):\n list.append(tree)\n for child in tree.children:\n tree_to_list(child, list)\n return list\n```", "```py\ndef load(self, url):\n # ...\n links = [node.attributes[\"href\"]\n for node in tree_to_list(self.nodes, [])\n if isinstance(node, Element)\n and node.tag == \"link\"\n and node.attributes.get(\"rel\") == \"stylesheet\"\n and \"href\" in node.attributes]\n # ...\n```", "```py\nclass URL:\n def resolve(self, url):\n if \"://\" in url: return URL(url)\n if not url.startswith(\"/\"):\n dir, _ = self.path.rsplit(\"/\", 1)\n url = dir + \"/\" + url\n if url.startswith(\"//\"):\n return URL(self.scheme + \":\" + url)\n else:\n return URL(self.scheme + \"://\" + self.host + \\\n \":\" + str(self.port) + url)\n```", "```py\nclass URL:\n def resolve(self, url):\n if not url.startswith(\"/\"):\n dir, _ = self.path.rsplit(\"/\", 1)\n while url.startswith(\"../\"):\n _, url = url.split(\"/\", 1)\n if \"/\" in dir:\n dir, _ = dir.rsplit(\"/\", 1)\n url = dir + \"/\" + url\n```", "```py\ndef load(self, url):\n # ...\n for link in links:\n style_url = url.resolve(link)\n try:\n body = style_url.request()\n except:\n continue\n rules.extend(CSSParser(body).parse())\n```", "```py\nclass TagSelector:\n def __init__(self, tag):\n # ...\n self.priority = 1\n\nclass DescendantSelector:\n def __init__(self, ancestor, descendant):\n # ...\n self.priority = ancestor.priority + descendant.priority\n```", "```py\ndef cascade_priority(rule):\n selector, body = rule\n return selector.priority\n```", "```py\ndef load(self, url):\n # ...\n style(self.nodes, sorted(rules, key=cascade_priority))\n # ...\n```", "```py\nINHERITED_PROPERTIES = {\n \"font-size\": \"16px\",\n \"font-style\": \"normal\",\n \"font-weight\": \"normal\",\n \"color\": \"black\",\n}\n```", "```py\ndef style(node, rules):\n # ...\n for property, default_value in INHERITED_PROPERTIES.items():\n if node.parent:\n node.style[property] = node.parent.style[property]\n else:\n node.style[property] = default_value\n # ...\n```", "```py\ndef style(node, rules):\n # ...\n if node.style[\"font-size\"].endswith(\"%\"):\n # ...\n\n for child in node.children:\n style(child, rules)\n```", "```py\ndef style(node, rules):\n # ...\n if node.style[\"font-size\"].endswith(\"%\"):\n if node.parent:\n parent_font_size = node.parent.style[\"font-size\"]\n else:\n parent_font_size = INHERITED_PROPERTIES[\"font-size\"]\n node_pct = float(node.style[\"font-size\"][:-1]) / 100\n parent_px = float(parent_font_size[:-2])\n node.style[\"font-size\"] = str(node_pct * parent_px) + \"px\"\n```", "```py\na { color: blue; }\ni { font-style: italic; }\nb { font-weight: bold; }\nsmall { font-size: 90%; }\nbig { font-size: 110%; }\n```", "```py\nclass BlockLayout:\n def recurse(self, node):\n if isinstance(node, Text):\n for word in node.text.split():\n self.word(node, word)\n else:\n # ...\n\n def word(self, node, word):\n weight = node.style[\"font-weight\"]\n style = node.style[\"font-style\"]\n if style == \"normal\": style = \"roman\"\n size = int(float(node.style[\"font-size\"][:-2]) * .75)\n font = get_font(size, weight, style)\n # ...\n```", "```py\ndef word(self, node, word):\n color = node.style[\"color\"]\n # ...\n self.line.append((self.cursor_x, word, font, color))\n # ...\n```", "```py\ndef flush(self):\n # ...\n metrics = [font.metrics() for x, word, font, color in self.line]\n # ...\n for rel_x, word, font, color in self.line:\n # ...\n self.display_list.append((x, y, word, font, color))\n # ...\n```", "```py\ndef paint(self):\n # ...\n if self.layout_mode() == \"inline\":\n for x, y, word, font, color in self.display_list:\n cmds.append(DrawText(x, y, word, font, color))\n```", "```py\nclass DrawText:\n def __init__(self, x1, y1, text, font, color):\n # ...\n self.color = color\n\n def execute(self, scroll, canvas):\n canvas.create_text(\n # ...\n fill=self.color)\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.canvas = tkinter.Canvas(\n # ...\n bg=\"white\",\n )\n # ...\n```", "```py\nclass BlockLayout:\n def recurse(self, node):\n if isinstance(node, Text):\n for word in node.text.split():\n self.word(node, word)\n else:\n if node.tag == \"br\":\n self.flush()\n for child in node.children:\n self.recurse(child)\n```", "```py\n#banner a { color: black !important; }\n```", "```py\n<html>\n <body>\n Here is some text that is\n <br>\n spread across multiple lines\n </body>\n</html>\n```", "```py\nDocumentLayout\n  BlockLayout[block] (html element)\n    BlockLayout[inline] (body element)\n      LineLayout (first line of text)\n        TextLayout (\"Here\")\n        TextLayout (\"is\")\n        TextLayout (\"some\")\n        TextLayout (\"text\")\n        TextLayout (\"that\")\n        TextLayout (\"is\")\n      LineLayout (second line of text)\n        TextLayout (\"spread\")\n        TextLayout (\"across\")\n        TextLayout (\"multiple\")\n        TextLayout (\"lines\")\n```", "```py\nclass LineLayout:\n def __init__(self, node, parent, previous):\n self.node = node\n self.parent = parent\n self.previous = previous\n self.children = []\n```", "```py\nclass TextLayout:\n def __init__(self, node, word, parent, previous):\n self.node = node\n self.word = word\n self.children = []\n self.parent = parent\n self.previous = previous\n```", "```py\nself.line.append((self.cursor_x, word, font, color))\n```", "```py\nclass BlockLayout:\n def word(self, node, word):\n line = self.children[-1]\n previous_word = line.children[-1] if line.children else None\n text = TextLayout(node, word, line, previous_word)\n line.children.append(text)\n```", "```py\nclass BlockLayout:\n def word(self, node, word):\n # ...\n if self.cursor_x + w > self.width:\n self.new_line()\n```", "```py\nclass BlockLayout:\n def new_line(self):\n self.cursor_x = 0\n last_line = self.children[-1] if self.children else None\n new_line = LineLayout(self.node, self, last_line)\n self.children.append(new_line)\n```", "```py\nclass BlockLayout:\n def layout(self):\n # ...\n else:\n self.new_line()\n self.recurse(self.node)\n```", "```py\nclass BlockLayout:\n def layout(self):\n # ...\n self.height = sum([child.height for child in self.children])\n```", "```py\nclass LineLayout:\n def layout(self):\n self.width = self.parent.width\n self.x = self.parent.x\n\n if self.previous:\n self.y = self.previous.y + self.previous.height\n else:\n self.y = self.parent.y\n\n # ...\n```", "```py\nclass TextLayout:\n def layout(self):\n weight = self.node.style[\"font-weight\"]\n style = self.node.style[\"font-style\"]\n if style == \"normal\": style = \"roman\"\n size = int(float(self.node.style[\"font-size\"][:-2]) * .75)\n self.font = get_font(size, weight, style)\n```", "```py\nclass TextLayout:\n def layout(self):\n # ...\n\n self.width = self.font.measure(self.word)\n\n if self.previous:\n space = self.previous.font.measure(\" \")\n self.x = self.previous.x + space + self.previous.width\n else:\n self.x = self.parent.x\n\n self.height = self.font.metrics(\"linespace\")\n```", "```py\nclass LineLayout:\n def layout(self):\n # ...\n for word in self.children:\n word.layout()\n```", "```py\n# ...\nmax_ascent = max([word.font.metrics(\"ascent\")\n for word in self.children])\nbaseline = self.y + 1.25 * max_ascent\nfor word in self.children:\n word.y = baseline - word.font.metrics(\"ascent\")\nmax_descent = max([word.font.metrics(\"descent\")\n for word in self.children])\n```", "```py\n# ...\nself.height = 1.25 * (max_ascent + max_descent)\n```", "```py\nclass LineLayout:\n def paint(self):\n return []\n```", "```py\nclass TextLayout:\n def paint(self):\n color = self.node.style[\"color\"]\n return [DrawText(self.x, self.y, self.word, self.font, color)]\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.window.bind(\"<Button-1>\", self.click)\n```", "```py\nclass Browser:\n def click(self, e):\n x, y = e.x, e.y\n```", "```py\nclass Browser:\n def click(self, e):\n # ...\n y += self.scroll\n```", "```py\n# ...\nobjs = [obj for obj in tree_to_list(self.document, [])\n if obj.x <= x < obj.x + obj.width\n and obj.y <= y < obj.y + obj.height]\n```", "```py\n# ...\nif not objs: return\nelt = objs[-1].node\n```", "```py\n# ...\nwhile elt:\n if isinstance(elt, Text):\n pass\n elif elt.tag == \"a\" and \"href\" in elt.attributes:\n # ...\n elt = elt.parent\n```", "```py\n# ...\nelif elt.tag == \"a\" and \"href\" in elt.attributes:\n url = self.url.resolve(elt.attributes[\"href\"])\n return self.load(url)\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.url = None\n\n def load(self, url):\n self.url = url\n # ...\n```", "```py\nclass Tab:\n # ...\n```", "```py\nclass Browser:\n def __init__(self):\n self.tabs = []\n self.active_tab = None\n```", "```py\nclass Browser:\n def __init__(self):\n self.window = tkinter.Tk()\n self.canvas = tkinter.Canvas(\n # ...\n )\n self.canvas.pack()\n self.window.bind(\"<Down>\", self.handle_down)\n self.window.bind(\"<Button-1>\", self.handle_click)\n```", "```py\nclass Browser:\n def handle_down(self, e):\n self.active_tab.scrolldown()\n self.draw()\n\n def handle_click(self, e):\n self.active_tab.click(e.x, e.y)\n self.draw()\n```", "```py\nclass Browser:\n def draw(self):\n self.canvas.delete(\"all\")\n self.active_tab.draw(self.canvas)\n```", "```py\nclass Tab:\n def draw(self, canvas):\n # ...\n```", "```py\nclass Browser:\n def new_tab(self, url):\n new_tab = Tab()\n new_tab.load(url)\n self.active_tab = new_tab\n self.tabs.append(new_tab)\n self.draw()\n```", "```py\nif __name__ == \"__main__\":\n import sys\n Browser().new_tab(URL(sys.argv[1]))\n tkinter.mainloop()\n```", "```py\nclass Chrome:\n def __init__(self, browser):\n self.browser = browser\n\nclass Browser:\n def __init__(self):\n # ...\n self.chrome = Chrome(self)\n```", "```py\nclass Chrome:\n def __init__(self, browser):\n # ...\n self.font = get_font(20, \"normal\", \"roman\")\n self.font_height = self.font.metrics(\"linespace\")\n```", "```py\nclass Chrome:\n def __init__(self, browser):\n # ...\n self.padding = 5\n self.tabbar_top = 0\n self.tabbar_bottom = self.font_height + 2*self.padding\n```", "```py\nclass Rect:\n def __init__(self, left, top, right, bottom):\n self.left = left\n self.top = top\n self.right = right\n self.bottom = bottom\n```", "```py\nclass Chrome:\n def __init__(self, browser):\n # ...\n plus_width = self.font.measure(\"+\") + 2*self.padding\n self.newtab_rect = Rect(\n self.padding, self.padding,\n self.padding + plus_width,\n self.padding + self.font_height)\n```", "```py\nclass Chrome:\n def tab_rect(self, i):\n tabs_start = self.newtab_rect.right + self.padding\n tab_width = self.font.measure(\"Tab X\") + 2*self.padding\n return Rect(\n tabs_start + tab_width * i, self.tabbar_top,\n tabs_start + tab_width * (i + 1), self.tabbar_bottom)\n```", "```py\nclass Chrome:\n def paint(self):\n cmds = []\n # ...\n return cmds\n```", "```py\nclass Chrome:\n def paint(self):\n # ...\n cmds.append(DrawOutline(self.newtab_rect, \"black\", 1))\n cmds.append(DrawText(\n self.newtab_rect.left + self.padding,\n self.newtab_rect.top,\n \"+\", self.font, \"black\"))\n # ...\n```", "```py\nclass DrawOutline:\n def __init__(self, rect, color, thickness):\n self.rect = rect\n self.color = color\n self.thickness = thickness\n\n def execute(self, scroll, canvas):\n canvas.create_rectangle(\n self.rect.left, self.rect.top - scroll,\n self.rect.right, self.rect.bottom - scroll,\n width=self.thickness,\n outline=self.color)\n```", "```py\nclass Chrome:\n def paint(self):\n # ...\n for i, tab in enumerate(self.browser.tabs):\n bounds = self.tab_rect(i)\n cmds.append(DrawLine(\n bounds.left, 0, bounds.left, bounds.bottom,\n \"black\", 1))\n cmds.append(DrawLine(\n bounds.right, 0, bounds.right, bounds.bottom,\n \"black\", 1))\n cmds.append(DrawText(\n bounds.left + self.padding, bounds.top + self.padding,\n \"Tab {}\".format(i), self.font, \"black\"))\n # ...\n```", "```py\nclass Chrome:\n def paint(self):\n for i, tab in enumerate(self.browser.tabs):\n # ...\n if tab == self.browser.active_tab:\n cmds.append(DrawLine(\n 0, bounds.bottom, bounds.left, bounds.bottom,\n \"black\", 1))\n cmds.append(DrawLine(\n bounds.right, bounds.bottom, WIDTH, bounds.bottom,\n \"black\", 1))\n```", "```py\nclass DrawLine:\n def __init__(self, x1, y1, x2, y2, color, thickness):\n self.rect = Rect(x1, y1, x2, y2)\n self.color = color\n self.thickness = thickness\n\n def execute(self, scroll, canvas):\n canvas.create_line(\n self.rect.left, self.rect.top - scroll,\n self.rect.right, self.rect.bottom - scroll,\n fill=self.color, width=self.thickness)\n```", "```py\nclass Chrome:\n def __init__(self, browser):\n # ...\n self.bottom = self.tabbar_bottom\n\n def paint(self):\n # ...\n cmds.append(DrawRect(\n Rect(0, 0, WIDTH, self.bottom),\n \"white\"))\n cmds.append(DrawLine(\n 0, self.bottom, WIDTH,\n self.bottom, \"black\", 1))\n # ...\n```", "```py\nclass BlockLayout:\n def self_rect(self):\n return Rect(self.x, self.y,\n self.x + self.width, self.y + self.height)\n\n def paint(self):\n # ...\n if bgcolor != \"transparent\":\n rect = DrawRect(self.self_rect(), bgcolor)\n cmds.append(rect)\n return cmds\n```", "```py\nclass Browser:\n def draw(self):\n # ...\n for cmd in self.chrome.paint():\n cmd.execute(0, self.canvas)\n```", "```py\nclass Tab:\n def __init__(self, tab_height):\n # ...\n self.tab_height = tab_height\n```", "```py\nclass Browser:\n def new_tab(self, url):\n new_tab = Tab(HEIGHT - self.chrome.bottom)\n # ...\n```", "```py\nclass Tab:\n def scrolldown(self):\n max_y = max(\n self.document.height + 2*VSTEP - self.tab_height, 0)\n self.scroll = min(self.scroll + SCROLL_STEP, max_y)\n```", "```py\nclass Tab:\n def draw(self, canvas, offset):\n for cmd in self.display_list:\n if cmd.rect.top > self.scroll + self.tab_height:\n continue\n if cmd.rect.bottom < self.scroll: continue\n cmd.execute(self.scroll - offset, canvas)\n```", "```py\nclass Browser:\n def draw(self):\n self.canvas.delete(\"all\")\n self.active_tab.draw(self.canvas, self.chrome.bottom)\n for cmd in self.chrome.paint():\n cmd.execute(0, self.canvas)\n```", "```py\nclass Browser:\n def handle_click(self, e):\n if e.y < self.chrome.bottom:\n self.chrome.click(e.x, e.y)\n else:\n tab_y = e.y - self.chrome.bottom\n self.active_tab.click(e.x, tab_y)\n self.draw()\n```", "```py\nclass Rect:\n def contains_point(self, x, y):\n return x >= self.left and x < self.right \\\n and y >= self.top and y < self.bottom\n```", "```py\nclass Chrome:\n def click(self, x, y):\n if self.newtab_rect.contains_point(x, y):\n self.browser.new_tab(URL(\"https://browser.engineering/\"))\n else:\n for i, tab in enumerate(self.browser.tabs):\n if self.tab_rect(i).contains_point(x, y):\n self.browser.active_tab = tab\n break\n```", "```py\nclass Chrome:\n def __init__(self, browser):\n # ...\n self.urlbar_top = self.tabbar_bottom\n self.urlbar_bottom = self.urlbar_top + \\\n self.font_height + 2*self.padding\n self.bottom = self.urlbar_bottom\n```", "```py\nclass Chrome:\n def __init__(self, browser):\n # ...\n back_width = self.font.measure(\"<\") + 2*self.padding\n self.back_rect = Rect(\n self.padding,\n self.urlbar_top + self.padding,\n self.padding + back_width,\n self.urlbar_bottom - self.padding)\n\n self.address_rect = Rect(\n self.back_rect.top + self.padding,\n self.urlbar_top + self.padding,\n WIDTH - self.padding,\n self.urlbar_bottom - self.padding)\n```", "```py\nclass Chrome:\n def paint(self):\n # ...\n cmds.append(DrawOutline(self.back_rect, \"black\", 1))\n cmds.append(DrawText(\n self.back_rect.left + self.padding,\n self.back_rect.top,\n \"<\", self.font, \"black\"))\n```", "```py\nclass Chrome:\n def paint(self):\n # ...\n cmds.append(DrawOutline(self.address_rect, \"black\", 1))\n url = str(self.browser.active_tab.url)\n cmds.append(DrawText(\n self.address_rect.left + self.padding,\n self.address_rect.top,\n url, self.font, \"black\"))\n```", "```py\nclass URL:\n def __str__(self):\n port_part = \":\" + str(self.port)\n if self.scheme == \"https\" and self.port == 443:\n port_part = \"\"\n if self.scheme == \"http\" and self.port == 80:\n port_part = \"\"\n return self.scheme + \"://\" + self.host + port_part + self.path\n```", "```py\nclass Chrome:\n def click(self, x, y):\n # ...\n elif self.back_rect.contains_point(x, y):\n self.browser.active_tab.go_back()\n```", "```py\nclass Tab:\n def __init__(self, tab_height):\n # ...\n self.history = []\n```", "```py\nclass Tab:\n def load(self, url):\n self.history.append(url)\n # ...\n```", "```py\nclass Tab:\n def go_back(self):\n if len(self.history) > 1:\n self.load(self.history[-2])\n```", "```py\nclass Tab:\n def go_back(self):\n if len(self.history) > 1:\n self.history.pop()\n back = self.history.pop()\n self.load(back)\n```", "```py\nclass Chrome:\n def __init__(self, browser):\n # ...\n self.focus = None\n self.address_bar = \"\"\n```", "```py\nclass Chrome:\n def click(self, x, y):\n self.focus = None\n # ...\n elif self.address_rect.contains_point(x, y):\n self.focus = \"address bar\"\n self.address_bar = \"\"\n```", "```py\nclass Chrome:\n def paint(self):\n # ...\n if self.focus == \"address bar\":\n cmds.append(DrawText(\n self.address_rect.left + self.padding,\n self.address_rect.top,\n self.address_bar, self.font, \"black\"))\n else:\n url = str(self.browser.active_tab.url)\n cmds.append(DrawText(\n self.address_rect.left + self.padding,\n self.address_rect.top,\n url, self.font, \"black\"))\n```", "```py\nclass Chrome:\n def paint(self):\n # ...\n if self.focus == \"address bar\":\n # ...\n w = self.font.measure(self.address_bar)\n cmds.append(DrawLine(\n self.address_rect.left + self.padding + w,\n self.address_rect.top,\n self.address_rect.left + self.padding + w,\n self.address_rect.bottom,\n \"red\", 1))\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.window.bind(\"<Key>\", self.handle_key)\n\n def handle_key(self, e):\n if len(e.char) == 0: return\n if not (0x20 <= ord(e.char) < 0x7f): return\n self.chrome.keypress(e.char)\n self.draw()\n```", "```py\nclass Chrome:\n def keypress(self, char):\n if self.focus == \"address bar\":\n self.address_bar += char\n```", "```py\nclass Chrome:\n def enter(self):\n if self.focus == \"address bar\":\n self.browser.active_tab.load(URL(self.address_bar))\n self.focus = None\n\nclass Browser:\n def __init__(self):\n # ...\n self.window.bind(\"<Return>\", self.handle_enter)\n\n def handle_enter(self, e):\n self.chrome.enter()\n self.draw()\n```", "```py\n<form action=\"/submit\" method=\"post\">\n <p>Name: <input name=name value=1></p>\n <p>Comment: <input name=comment value=2></p>\n <p><button>Submit!</button></p>\n</form>\n```", "```py\nPOST /submit HTTP/1.0\nHost: example.org\nContent-Length: 16\n\nname=1&comment=2\n```", "```py\nclass InputLayout:\n def __init__(self, node, parent, previous):\n self.node = node\n self.children = []\n self.parent = parent\n self.previous = previous\n```", "```py\nINPUT_WIDTH_PX = 200\n\nclass InputLayout:\n def layout(self):\n # ...\n self.width = INPUT_WIDTH_PX\n # ...\n```", "```py\ninput {\n font-size: 16px; font-weight: normal; font-style: normal;\n background-color: lightblue;\n}\nbutton {\n font-size: 16px; font-weight: normal; font-style: normal;\n background-color: orange;\n}\n```", "```py\nclass InputLayout:\n def paint(self):\n cmds = []\n bgcolor = self.node.style.get(\"background-color\",\n \"transparent\")\n if bgcolor != \"transparent\":\n rect = DrawRect(self.self_rect(), bgcolor)\n cmds.append(rect)\n return cmds\n```", "```py\nclass InputLayout:\n def paint(self):\n # ...\n if self.node.tag == \"input\":\n text = self.node.attributes.get(\"value\", \"\")\n elif self.node.tag == \"button\":\n if len(self.node.children) == 1 and \\\n isinstance(self.node.children[0], Text):\n text = self.node.children[0].text\n else:\n print(\"Ignoring HTML contents inside button\")\n text = \"\"\n # ...\n```", "```py\nclass InputLayout:\n def paint(self):\n # ...\n color = self.node.style[\"color\"]\n cmds.append(\n DrawText(self.x, self.y, text, self.font, color))\n return cmds\n```", "```py\nclass BlockLayout:\n def recurse(self, node):\n if isinstance(node, Text):\n # ...\n else:\n if node.tag == \"br\":\n self.new_line()\n elif node.tag == \"input\" or node.tag == \"button\":\n self.input(node)\n else:\n for child in node.children:\n self.recurse(child)\n```", "```py\nclass BlockLayout:\n def input(self, node):\n w = INPUT_WIDTH_PX\n if self.cursor_x + w > self.width:\n self.new_line()\n line = self.children[-1]\n previous_word = line.children[-1] if line.children else None\n input = InputLayout(node, line, previous_word)\n line.children.append(input)\n\n weight = node.style[\"font-weight\"]\n style = node.style[\"font-style\"]\n if style == \"normal\": style = \"roman\"\n size = int(float(node.style[\"font-size\"][:-2]) * .75)\n font = get_font(size, weight, style)\n\n self.cursor_x += w + font.measure(\" \")\n```", "```py\nclass BlockLayout:\n def layout_mode(self):\n # ...\n elif self.node.children or self.node.tag == \"input\":\n return \"inline\"\n # ...\n```", "```py\nclass BlockLayout:\n # ...\n def should_paint(self):\n return isinstance(self.node, Text) or \\\n (self.node.tag != \"input\" and self.node.tag !=  \"button\")\n```", "```py\ndef paint_tree(layout_object, display_list):\n if layout_object.should_paint():\n display_list.extend(layout_object.paint())\n # ...\n```", "```py\nclass Tab:\n def click(self, x, y):\n while elt:\n # ...\n elif elt.tag == \"input\":\n elt.attributes[\"value\"] = \"\"\n # ...\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n # ...\n self.render()\n\n def render(self):\n style(self.nodes, sorted(self.rules, key=cascade_priority))\n self.document = DocumentLayout(self.nodes)\n self.document.layout()\n self.display_list = []\n paint_tree(self.document, self.display_list)\n```", "```py\nclass Tab:\n def click(self, x, y):\n while elt:\n elif elt.tag == \"input\":\n elt.attributes[\"value\"] = \"\"\n return self.render()\n```", "```py\nclass Tab:\n def __init__(self):\n # ...\n self.focus = None\n```", "```py\nclass Tab:\n def click(self, x, y):\n self.focus = None\n # ...\n while elt:\n elif elt.tag == \"input\":\n self.focus = elt\n # ...\n```", "```py\nclass Chrome:\n def blur(self):\n self.focus = None\n```", "```py\nclass Browser:\n def handle_click(self, e):\n if e.y < self.chrome.bottom:\n self.focus = None\n # ...\n else:\n self.focus = \"content\"\n self.chrome.blur()\n # ...\n self.draw()\n```", "```py\nclass Browser:\n def handle_key(self, e):\n # ...\n if self.chrome.keypress(e.char):\n self.draw()\n elif self.focus == \"content\":\n self.active_tab.keypress(e.char)\n self.draw()\n```", "```py\nclass Chrome:\n def keypress(self, char):\n if self.focus == \"address bar\":\n self.address_bar += char\n return True\n return False\n```", "```py\nclass Tab:\n def keypress(self, char):\n if self.focus:\n self.focus.attributes[\"value\"] += char\n self.render()\n```", "```py\nclass Element:\n def __init__(self, tag, attributes, parent):\n # ...\n self.is_focused = False\n```", "```py\nclass Tab:\n def click(self, x, y):\n while elt:\n elif elt.tag == \"input\":\n elt.attributes[\"value\"] = \"\"\n if self.focus:\n self.focus.is_focused = False\n self.focus = elt\n elt.is_focused = True\n return self.render()\n```", "```py\nclass InputLayout:\n def paint(self):\n # ...\n if self.node.is_focused:\n cx = self.x + self.font.measure(text)\n cmds.append(DrawLine(\n cx, self.y, cx, self.y + self.height, \"black\", 1))\n # ...\n```", "```py\nclass Tab:\n def click(self, x, y):\n while elt:\n # ...\n elif elt.tag == \"button\":\n # ...\n # ...\n```", "```py\nelif elt.tag == \"button\":\n while elt:\n if elt.tag == \"form\" and \"action\" in elt.attributes:\n return self.submit_form(elt)\n elt = elt.parent\n```", "```py\nclass Tab:\n def submit_form(self, elt):\n inputs = [node for node in tree_to_list(elt, [])\n if isinstance(node, Element)\n and node.tag == \"input\"\n and \"name\" in node.attributes]\n```", "```py\nclass Tab:\n def submit_form(self, elt):\n # ...\n body = \"\"\n for input in inputs:\n name = input.attributes[\"name\"]\n value = input.attributes.get(\"value\", \"\")\n body += \"&\" + name + \"=\" + value\n body = body[1:]\n```", "```py\nfor input in inputs:\n # ...\n name = urllib.parse.quote(name)\n value = urllib.parse.quote(value)\n # ...\n```", "```py\ndef submit_form(self, elt):\n # ...\n url = self.url.resolve(elt.attributes[\"action\"])\n self.load(url, body)\n```", "```py\ndef load(self, url, payload=None):\n # ...\n body = url.request(payload)\n # ...\n```", "```py\nclass URL:\n def request(self, payload=None):\n # ...\n method = \"POST\" if payload else \"GET\"\n # ...\n request = \"{}  {} HTTP/1.0\\r\\n\".format(method, self.path)\n # ...\n```", "```py\nclass URL:\n def request(self, payload=None):\n # ...\n if payload:\n length = len(payload.encode(\"utf8\"))\n request += \"Content-Length: {}\\r\\n\".format(length)\n # ...\n```", "```py\nclass URL:\n def request(self, payload=None):\n # ...\n if payload: request += payload\n s.send(request.encode(\"utf8\"))\n # ...\n```", "```py\nimport socket\ns = socket.socket(\n family=socket.AF_INET,\n type=socket.SOCK_STREAM,\n proto=socket.IPPROTO_TCP)\ns.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n```", "```py\ns.bind(('', 8000))\ns.listen()\n```", "```py\nwhile True:\n conx, addr = s.accept()\n handle_connection(conx)\n```", "```py\ndef handle_connection(conx):\n req = conx.makefile(\"b\")\n reqline = req.readline().decode('utf8')\n method, url, version = reqline.split(\" \", 2)\n assert method in [\"GET\", \"POST\"]\n```", "```py\ndef handle_connection(conx):\n # ...\n headers = {}\n while True:\n line = req.readline().decode('utf8')\n if line == '\\r\\n': break\n header, value = line.split(\":\", 1)\n headers[header.casefold()] = value.strip()\n```", "```py\ndef handle_connection(conx):\n # ...\n if 'content-length' in headers:\n length = int(headers['content-length'])\n body = req.read(length).decode('utf8')\n else:\n body = None\n```", "```py\ndef handle_connection(conx):\n # ...\n status, body = do_request(method, url, headers, body)\n```", "```py\ndef handle_connection(conx):\n # ...\n response = \"HTTP/1.0 {}\\r\\n\".format(status)\n response += \"Content-Length: {}\\r\\n\".format(\n len(body.encode(\"utf8\")))\n response += \"\\r\\n\" + body\n conx.send(response.encode('utf8'))\n conx.close()\n```", "```py\nENTRIES = [ 'Pavel was here' ]\n```", "```py\ndef do_request(method, url, headers, body):\n out = \"<!doctype html>\"\n for entry in ENTRIES:\n out += \"<p>\" + entry + \"</p>\"\n return \"200 OK\", out\n```", "```py\ndef do_request(method, url, headers, body):\n # ...\n out += \"<form action=add method=post>\"\n out +=   \"<p><input name=guest></p>\"\n out +=   \"<p><button>Sign the book!</button></p>\"\n out += \"</form>\"\n # ...\n```", "```py\ndef show_comments():\n # ...\n return out\n```", "```py\ndef do_request(method, url, headers, body):\n if method == \"GET\" and url == \"/\":\n return \"200 OK\", show_comments()\n elif method == \"POST\" and url == \"/add\":\n params = form_decode(body)\n return \"200 OK\", add_entry(params)\n else:\n return \"404 Not Found\", not_found(url, method)\n```", "```py\ndef form_decode(body):\n params = {}\n for field in body.split(\"&\"):\n name, value = field.split(\"=\", 1)\n name = urllib.parse.unquote_plus(name)\n value = urllib.parse.unquote_plus(value)\n params[name] = value\n return params\n```", "```py\ndef add_entry(params):\n if 'guest' in params:\n ENTRIES.append(params['guest'])\n return show_comments()\n```", "```py\ndef not_found(url, method):\n out = \"<!doctype html>\"\n out += \"<h1>{}  {} not found!</h1>\".format(method, url)\n return out\n```", "```py\npython3 -m pip install dukpy\n```", "```py\nimport dukpy\ndukpy.evaljs(\"2 + 2\")\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n # ...\n scripts = [node.attributes[\"src\"] for node\n in tree_to_list(self.nodes, [])\n if isinstance(node, Element)\n and node.tag == \"script\"\n and \"src\" in node.attributes]\n # ...\n```", "```py\ndef load(self, url, payload=None):\n # ...\n for script in scripts:\n script_url = url.resolve(script)\n try:\n body = script_url.request()\n except:\n continue\n print(\"Script returned: \", dukpy.evaljs(body))\n # ...\n```", "```py\n<script src=test.js></script>\n```", "```py\nvar x = 2\nx + x\n```", "```py\nScript returned: 4\n```", "```py\nclass JSContext:\n def __init__(self):\n self.interp = dukpy.JSInterpreter()\n\n def run(self, code):\n return self.interp.evaljs(code)\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n # ...\n self.js = JSContext()\n for script in scripts:\n # ...\n self.js.run(body)\n```", "```py\n<script src=a.js></script>\n<script src=b.js></script>\n```", "```py\nclass JSContext:\n def __init__(self):\n # ...\n self.interp.export_function(\"log\", print)\n```", "```py\ncall_python(\"log\", \"Hi from JS\")\n```", "```py\nconsole = { log: function(x) { call_python(\"log\", x); } }\n```", "```py\nRUNTIME_JS = open(\"runtime.js\").read()\n\nclass JSContext:\n def __init__(self):\n # ...\n self.interp.evaljs(RUNTIME_JS)\n```", "```py\nthrow Error(\"bad\");\n```", "```py\nclass JSContext:\n def run(self, script, code):\n try:\n return self.interp.evaljs(code)\n except dukpy.JSRuntimeError as e:\n print(\"Script\", script, \"crashed\", e)\n```", "```py\nfunction foo() {\n try {\n // ...\n } catch(e) {\n console.log(\"Crash in function foo()\", e.stack);\n throw e;\n }\n}\n```", "```py\nclass JSContext:\n def foo(self, arg):\n try:\n # ...\n except:\n import traceback\n traceback.print_exc()\n raise\n```", "```py\nclass JSContext:\n def __init__(self):\n # ...\n self.interp.export_function(\"querySelectorAll\",\n self.querySelectorAll)\n # ...\n```", "```py\ndocument = { querySelectorAll: function(s) {\n return call_python(\"querySelectorAll\", s);\n}}\n```", "```py\nclass JSContext:\n def querySelectorAll(self, selector_text):\n selector = CSSParser(selector_text).selector()\n```", "```py\nclass JSContext:\n def __init__(self, tab):\n self.tab = tab\n # ...\n\nclass Tab:\n def load(self, url, payload=None):\n # ...\n self.js = JSContext(self)\n # ...\n```", "```py\ndef querySelectorAll(self, selector_text):\n # ...\n nodes = [node for node\n in tree_to_list(self.tab.nodes, [])\n if selector.matches(node)]\n```", "```py\ndef querySelectorAll(self, selector_text):\n # ...\n return nodes\n```", "```py\n_dukpy.JSRuntimeError: EvalError:\nError while calling Python Function:\nTypeError('Object of type Element is not JSON serializable')\n```", "```py\nclass JSContext:\n def __init__(self, tab):\n # ...\n self.node_to_handle = {}\n self.handle_to_node = {}\n # ...\n```", "```py\ndef querySelectorAll(self, selector_text):\n # ...\n return [self.get_handle(node) for node in nodes]\n```", "```py\nclass JSContext:\n def get_handle(self, elt):\n if elt not in self.node_to_handle:\n handle = len(self.node_to_handle)\n self.node_to_handle[elt] = handle\n self.handle_to_node[handle] = elt\n else:\n handle = self.node_to_handle[elt]\n return handle\n```", "```py\nfunction Node(handle) { this.handle = handle; }\n```", "```py\ndocument = { querySelectorAll: function(s) {\n var handles = call_python(\"querySelectorAll\", s);\n return handles.map(function(h) { return new Node(h) });\n}}\n```", "```py\nNode.prototype.getAttribute = function(attr) {\n return call_python(\"getAttribute\", this.handle, attr);\n}\n```", "```py\nclass JSContext:\n def getAttribute(self, handle, attr):\n elt = self.handle_to_node[handle]\n attr = elt.attributes.get(attr, None)\n return attr if attr else \"\"\n```", "```py\ninputs = document.querySelectorAll('input')\nfor (var i = 0; i < inputs.length; i++) {\n var name = inputs[i].getAttribute(\"name\");\n var value = inputs[i].getAttribute(\"value\");\n if (value.length > 100) {\n console.log(\"Input \" + name + \" has too much text.\")\n }\n}\n```", "```py\nclass Tab:\n def click(self, x, y):\n # ...\n elif elt.tag == \"a\" and \"href\" in elt.attributes:\n self.js.dispatch_event(\"click\", elt)\n # ...\n elif elt.tag == \"input\":\n self.js.dispatch_event(\"click\", elt)\n # ...\n elif elt.tag == \"button\":\n self.js.dispatch_event(\"click\", elt)\n # ...\n # ...\n```", "```py\nclass Tab:\n def keypress(self, char):\n if self.focus:\n self.js.dispatch_event(\"keydown\", self.focus)\n # ...\n```", "```py\ndef submit_form(self, elt):\n self.js.dispatch_event(\"submit\", elt)\n # ...\n```", "```py\nLISTENERS = {}\n\nNode.prototype.addEventListener = function(type, listener) {\n if (!LISTENERS[this.handle]) LISTENERS[this.handle] = {};\n var dict = LISTENERS[this.handle];\n if (!dict[type]) dict[type] = [];\n var list = dict[type];\n list.push(listener);\n}\n```", "```py\nNode.prototype.dispatchEvent = function(type) {\n var handle = this.handle;\n var list = (LISTENERS[handle] && LISTENERS[handle][type]) || [];\n for (var i = 0; i < list.length; i++) {\n list[i].call(this);\n }\n}\n```", "```py\nclass JSContext:\n def dispatch_event(self, type, elt):\n handle = self.node_to_handle.get(elt, -1)\n self.interp.evaljs(\n EVENT_DISPATCH_JS, type=type, handle=handle)\n```", "```py\nEVENT_DISPATCH_JS = \\\n \"new Node(dukpy.handle).dispatchEvent(dukpy.type)\"\n```", "```py\nfunction lengthCheck() {\n var name = this.getAttribute(\"name\");\n var value = this.getAttribute(\"value\");\n if (value.length > 100) {\n console.log(\"Input \" + name + \" has too much text.\")\n }\n}\n```", "```py\nvar inputs = document.querySelectorAll(\"input\");\nfor (var i = 0; i < inputs.length; i++) {\n inputs[i].addEventListener(\"keydown\", lengthCheck);\n}\n```", "```py\nnode.innerHTML = \"This is my <b>new</b> bit of content!\";\n```", "```py\nObject.defineProperty(Node.prototype, 'innerHTML', {\n set: function(s) {\n call_python(\"innerHTML_set\", this.handle, s.toString());\n }\n});\n```", "```py\ndef innerHTML_set(self, handle, s):\n doc = HTMLParser(\"<html><body>\" + s + \"</body></html>\").parse()\n new_nodes = doc.children[0].children\n```", "```py\ndef innerHTML_set(self, handle, s):\n # ...\n elt = self.handle_to_node[handle]\n elt.children = new_nodes\n for child in elt.children:\n child.parent = elt\n```", "```py\nclass JSContext:\n def innerHTML_set(self, handle, s):\n # ...\n self.tab.render()\n```", "```py\ndef show_comments():\n # ...\n out += \"<strong></strong>\"\n # ...\n```", "```py\ndef show_comments():\n # ...\n out += \"<script src=/comment.js></script>\"\n # ...\n```", "```py\ndef do_request(method, url, headers, body):\n # ...\n elif method == \"GET\" and url == \"/comment.js\":\n with open(\"comment.js\") as f:\n return \"200 OK\", f.read()\n # ...\n```", "```py\nvar strong = document.querySelectorAll(\"strong\")[0];\n\nfunction lengthCheck() {\n var value = this.getAttribute(\"value\");\n if (value.length > 100) {\n strong.innerHTML = \"Comment too long!\";\n }\n}\n\nvar inputs = document.querySelectorAll(\"input\");\nfor (var i = 0; i < inputs.length; i++) {\n inputs[i].addEventListener(\"keydown\", lengthCheck);\n}\n```", "```py\nstrong { font-weight: bold; color: red; }\n```", "```py\nfunction Event(type) {\n this.type = type\n this.do_default = true;\n}\n\nEvent.prototype.preventDefault = function() {\n this.do_default = false;\n}\n```", "```py\nNode.prototype.dispatchEvent = function(evt) {\n var type = evt.type;\n // ...\n for (var i = 0; i < list.length; i++) {\n list[i].call(this, evt);\n }\n // ...\n return evt.do_default;\n}\n```", "```py\nEVENT_DISPATCH_JS = \\\n \"new Node(dukpy.handle).dispatchEvent(new Event(dukpy.type))\"\n```", "```py\nclass JSContext:\n def dispatch_event(self, type, elt):\n # ...\n do_default = self.interp.evaljs(\n EVENT_DISPATCH_JS, type=type, handle=handle)\n return not do_default\n```", "```py\nclass Tab:\n def click(self, x, y):\n while elt:\n # ...\n elif elt.tag == \"a\" and \"href\" in elt.attributes:\n if self.js.dispatch_event(\"click\", elt): return\n # ...\n elif elt.tag == \"input\":\n if self.js.dispatch_event(\"click\", elt): return\n # ...\n elif elt.tag == \"button\":\n if self.js.dispatch_event(\"click\", elt): return\n # ...\n # ...\n # ...\n```", "```py\nclass Tab:\n def submit_form(self, elt):\n if self.js.dispatch_event(\"submit\", elt): return\n```", "```py\nclass Tab:\n def keypress(self, char):\n if self.focus:\n if self.js.dispatch_event(\"keydown\", self.focus): return\n```", "```py\nvar allow_submit = true;\n\nfunction lengthCheck() {\n // ...\n allow_submit = value.length <= 100;\n if (!allow_submit) {\n // ...\n }\n}\n\nvar form = document.querySelectorAll(\"form\")[0];\nform.addEventListener(\"submit\", function(e) {\n if (!allow_submit) e.preventDefault();\n});\n```", "```py\ndef add_entry(params):\n if 'guest' in params and len(params['guest']) <= 100:\n ENTRIES.append(params['guest'])\n```", "```py\nelement.innerHTML = '<span id=foo>Chris was here</span>';\nelement.id = 'bar';\nconsole.log(element.innerHTML);\n// Prints \"<span id=bar>Chris was here</span>\":\n```", "```py\nSet-Cookie: foo=bar\n```", "```py\nCookie: foo=bar\n```", "```py\nimport random\n\ndef handle_connection(conx):\n # ...\n if \"cookie\" in headers:\n token = headers[\"cookie\"][len(\"token=\"):]\n else:\n token = str(random.random())[2:]\n # ...\n```", "```py\ndef handle_connection(conx):\n # ...\n if 'cookie' not in headers:\n template = \"Set-Cookie: token={}\\r\\n\"\n response += template.format(token)\n # ...\n```", "```py\nSESSIONS = {}\n\ndef handle_connection(conx):\n # ...\n session = SESSIONS.setdefault(token, {})\n status, body = do_request(session, method, url, headers, body)\n # ...\n```", "```py\ndef do_request(session, method, url, headers, body):\n if method == \"GET\" and url == \"/\":\n return \"200 OK\", show_comments(session)\n # ...\n elif method == \"POST\" and url == \"/add\":\n params = form_decode(body)\n add_entry(session, params)\n return \"200 OK\", show_comments(session)\n # ...\n```", "```py\nLOGINS = {\n \"crashoverride\": \"0cool\",\n \"cerealkiller\": \"emmanuel\"\n}\n```", "```py\ndef do_request(session, method, url, headers, body):\n # ...\n elif method == \"GET\" and url == \"/login\":\n return \"200 OK\", login_form(session)\n # ...\n```", "```py\ndef login_form(session):\n body = \"<!doctype html>\"\n body += \"<form action=/ method=post>\"\n body += \"<p>Username: <input name=username></p>\"\n body += \"<p>Password: <input name=password type=password></p>\"\n body += \"<p><button>Log in</button></p>\"\n body += \"</form>\"\n return body \n```", "```py\ndef do_request(session, method, url, headers, body):\n # ...\n elif method == \"POST\" and url == \"/\":\n params = form_decode(body)\n return do_login(session, params)\n # ...\n```", "```py\ndef do_login(session, params):\n username = params.get(\"username\")\n password = params.get(\"password\")\n if username in LOGINS and LOGINS[username] == password:\n session[\"user\"] = username\n return \"200 OK\", show_comments(session)\n else:\n out = \"<!doctype html>\"\n out += \"<h1>Invalid password for {}</h1>\".format(username)\n return \"401 Unauthorized\", out\n```", "```py\ndef show_comments(session):\n # ...\n if \"user\" in session:\n out += \"<h1>Hello, \" + session[\"user\"] + \"</h1>\"\n out += \"<form action=add method=post>\"\n out +=   \"<p><input name=guest></p>\"\n out +=   \"<p><button>Sign the book!</button></p>\"\n out += \"</form>\"\n else:\n out += \"<a href=/login>Sign in to write in the guest book</a>\"\n # ...\n```", "```py\ndef add_entry(session, params):\n if \"user\" not in session: return\n if 'guest' in params and len(params['guest']) <= 100:\n ENTRIES.append((params['guest'], session[\"user\"]))\n```", "```py\nENTRIES = [\n (\"No names. We are nameless!\", \"cerealkiller\"),\n (\"HACK THE PLANET!!!\", \"crashoverride\"),\n]\n```", "```py\ndef show_comments(session):\n # ...\n for entry, who in ENTRIES:\n out += \"<p>\" + entry + \"\\n\"\n out += \"<i>by \" + who + \"</i></p>\"\n # ...\n```", "```py\nCOOKIE_JAR = {}\n```", "```py\nclass URL:\n def request(self, payload=None):\n # ...\n if self.host in COOKIE_JAR:\n cookie = COOKIE_JAR[self.host]\n request += \"Cookie: {}\\r\\n\".format(cookie)\n # ...\n```", "```py\nclass URL:\n def request(self, payload=None):\n # ...\n if \"set-cookie\" in response_headers:\n cookie = response_headers[\"set-cookie\"]\n COOKIE_JAR[self.host] = cookie\n # ...\n```", "```py\nx = new XMLHttpRequest();\nx.open(\"GET\", url, false);\nx.send();\n// use x.responseText\n```", "```py\nfunction XMLHttpRequest() {}\n\nXMLHttpRequest.prototype.open = function(method, url, is_async) {\n if (is_async) throw Error(\"Asynchronous XHR is not supported\");\n this.method = method;\n this.url = url;\n}\n```", "```py\nXMLHttpRequest.prototype.send = function(body) {\n this.responseText = call_python(\"XMLHttpRequest_send\",\n this.method, this.url, body);\n}\n```", "```py\nclass JSContext:\n def XMLHttpRequest_send(self, method, url, body):\n full_url = self.tab.url.resolve(url)\n headers, out = full_url.request(body)\n return out\n```", "```py\nx = new XMLHttpRequest();\nx.open(\"GET\", \"http://localhost:8000/\", false);\nx.send();\nuser = x.responseText.split(\" \")[2].split(\"<\")[0];\n```", "```py\nclass JSContext:\n def XMLHttpRequest_send(self, method, url, body):\n # ...\n if full_url.origin() != self.tab.url.origin():\n raise Exception(\"Cross-origin XHR request not allowed\")\n # ...\n```", "```py\nclass URL:\n def origin(self):\n return self.scheme + \"://\" + self.host + \":\" + str(self.port)\n```", "```py\n<form action=\"http://localhost:8000/add\" method=post>\n <p><input name=guest></p>\n <p><button>Sign the book!</button></p>\n</form>\n```", "```py\ndef show_comments(session):\n # ...\n if \"user\" in session:\n nonce = str(random.random())[2:]\n session[\"nonce\"] = nonce\n # ...\n out +=   \"<input name=nonce type=hidden value=\" + nonce + \">\"\n```", "```py\ndef add_entry(session, params):\n if \"nonce\" not in session or \"nonce\" not in params: return\n if session[\"nonce\"] != params[\"nonce\"]: return\n # ...\n```", "```py\nSet-Cookie: foo=bar; SameSite=Lax\n```", "```py\ndef request(self, payload=None):\n if \"set-cookie\" in response_headers:\n cookie = response_headers[\"set-cookie\"]\n params = {}\n if \";\" in cookie:\n cookie, rest = cookie.split(\";\", 1)\n for param in rest.split(\";\"):\n if '=' in param:\n param, value = param.split(\"=\", 1)\n else:\n value = \"true\"\n params[param.strip().casefold()] = value.casefold()\n COOKIE_JAR[self.host] = (cookie, params)\n```", "```py\ndef request(self, payload=None):\n if self.host in COOKIE_JAR:\n cookie, params = COOKIE_JAR[self.host]\n request += \"Cookie: {}\\r\\n\".format(cookie)\n```", "```py\nclass URL:\n def request(self, referrer, payload=None):\n # ...\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n headers, body = url.request(self.url, payload)\n # ...\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n # ...\n for script in scripts:\n # ...\n try:\n header, body = script_url.request(url)\n except:\n continue\n # ...\n # ...\n for link in links:\n # ...\n try:\n header, body = style_url.request(url)\n except:\n continue\n # ...\n # ...\n```", "```py\nclass JSContext:\n def XMLHttpRequest_send(self, method, url, body):\n # ...\n headers, out = full_url.request(self.tab.url, body)\n # ...\n```", "```py\ndef request(self, referrer, payload=None):\n if self.host in COOKIE_JAR:\n # ...\n cookie, params = COOKIE_JAR[self.host]\n allow_cookie = True\n if referrer and params.get(\"samesite\", \"none\") == \"lax\":\n if method != \"GET\":\n allow_cookie = self.host == referrer.host\n if allow_cookie:\n request += \"Cookie: {}\\r\\n\".format(cookie)\n # ...\n```", "```py\ndef handle_connection(conx):\n if 'cookie' not in headers:\n template = \"Set-Cookie: token={}; SameSite=Lax\\r\\n\"\n response += template.format(token)\n```", "```py\nout += \"<p>\" + entry + \"\\n\"\nout += \"<i>by \" + who + \"</i></p>\"\n```", "```py\nHi! <script src=\"http://my-server/evil.js\"></script>\n```", "```py\n<p>Hi! <script src=\"http://my-server/evil.js\"></script>\n<i>by crashoverride</i></p>\n```", "```py\nimport html\n\ndef show_comments(session):\n # ...\n out += \"<p>\" + html.escape(entry) + \"\\n\"\n out += \"<i>by \" + html.escape(who) + \"</i></p>\"\n # ...\n```", "```py\nContent-Security-Policy: default-src http://example.org\n```", "```py\nclass URL:\n def request(self, referrer, payload=None):\n # ...\n return response_headers, content\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n # ...\n self.allowed_origins = None\n if \"content-security-policy\" in headers:\n csp = headers[\"content-security-policy\"].split()\n if len(csp) > 0 and csp[0] == \"default-src\":\n self.allowed_origins = []\n for origin in csp[1:]:\n self.allowed_origins.append(URL(origin).origin())\n # ...\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n # ...\n for script in scripts:\n script_url = url.resolve(script)\n if not self.allowed_request(script_url):\n print(\"Blocked script\", script, \"due to CSP\")\n continue\n # ...\n```", "```py\nclass JSContext:\n def XMLHttpRequest_send(self, method, url, body):\n full_url = self.tab.url.resolve(url)\n if not self.tab.allowed_request(full_url):\n raise Exception(\"Cross-origin XHR blocked by CSP\")\n # ...\n```", "```py\nclass Tab:\n def allowed_request(self, url):\n return self.allowed_origins == None or \\\n url.origin() in self.allowed_origins\n```", "```py\ndef handle_connection(conx):\n # ...\n csp = \"default-src http://localhost:8000\"\n response += \"Content-Security-Policy: {}\\r\\n\".format(csp)\n # ...\n```", "```py\ndef show_comments(session):\n # ...\n out += \"<script src=https://example.com/evil.js></script>\"\n # ...\n```", "```py\npython3 -m pip install 'skia-python==87.*' pysdl2 pysdl2-dll\n```", "```py\nimport ctypes\nimport sdl2\nimport skia\n```", "```py\nif __name__ == \"__main__\":\n sdl2.SDL_Init(sdl2.SDL_INIT_EVENTS)\n browser = Browser()\n browser.new_tab(URL(sys.argv[1]))\n # ...\n```", "```py\nclass Browser:\n def __init__(self):\n self.sdl_window = sdl2.SDL_CreateWindow(b\"Browser\",\n sdl2.SDL_WINDOWPOS_CENTERED, sdl2.SDL_WINDOWPOS_CENTERED,\n WIDTH, HEIGHT, sdl2.SDL_WINDOW_SHOWN)\n```", "```py\ndef mainloop(browser):\n event = sdl2.SDL_Event()\n while True:\n while sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:\n if event.type == sdl2.SDL_QUIT:\n browser.handle_quit()\n sdl2.SDL_Quit()\n sys.exit()\n # ...\n```", "```py\nclass Browser:\n def handle_quit(self):\n sdl2.SDL_DestroyWindow(self.sdl_window)\n```", "```py\nif __name__ == \"__main__\":\n # ...\n mainloop(browser)\n```", "```py\ndef mainloop(browser):\n while True:\n while sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:\n # ...\n elif event.type == sdl2.SDL_MOUSEBUTTONUP:\n browser.handle_click(event.button)\n elif event.type == sdl2.SDL_KEYDOWN:\n if event.key.keysym.sym == sdl2.SDLK_RETURN:\n browser.handle_enter()\n elif event.key.keysym.sym == sdl2.SDLK_DOWN:\n browser.handle_down()\n elif event.type == sdl2.SDL_TEXTINPUT:\n browser.handle_key(event.text.text.decode('utf8'))\n```", "```py\nclass Browser:\n def __init__(self):\n self.root_surface = skia.Surface.MakeRaster(\n skia.ImageInfo.Make(\n WIDTH, HEIGHT,\n ct=skia.kRGBA_8888_ColorType,\n at=skia.kUnpremul_AlphaType))\n```", "```py\nclass Pixel:\n def __init__(self, r, g, b, a):\n self.r = r\n self.g = g\n self.b = b\n self.a = a\n```", "```py\ndef parse_color(color):\n if color.startswith(\"#\") and len(color) == 7:\n r = int(color[1:3], 16)\n g = int(color[3:5], 16)\n b = int(color[5:7], 16)\n return skia.Color(r, g, b)\n```", "```py\nNAMED_COLORS = {\n \"black\": \"#000000\",\n \"white\": \"#ffffff\",\n \"red\":   \"#ff0000\",\n # ...\n}\n\ndef parse_color(color):\n # ...\n elif color in NAMED_COLORS:\n return parse_color(NAMED_COLORS[color])\n else:\n return skia.ColorBLACK\n```", "```py\nclass Browser:\n def draw(self):\n # ...\n skia_image = self.root_surface.makeImageSnapshot()\n skia_bytes = skia_image.tobytes()\n```", "```py\nclass Browser:\n def __init__(self):\n if sdl2.SDL_BYTEORDER == sdl2.SDL_BIG_ENDIAN:\n self.RED_MASK = 0xff000000\n self.GREEN_MASK = 0x00ff0000\n self.BLUE_MASK = 0x0000ff00\n self.ALPHA_MASK = 0x000000ff\n else:\n self.RED_MASK = 0x000000ff\n self.GREEN_MASK = 0x0000ff00\n self.BLUE_MASK = 0x00ff0000\n self.ALPHA_MASK = 0xff000000\n```", "```py\nclass Browser:\n def draw(self):\n # ...\n depth = 32 # Bits per pixel\n pitch = 4 * WIDTH # Bytes per row\n sdl_surface = sdl2.SDL_CreateRGBSurfaceFrom(\n skia_bytes, WIDTH, HEIGHT, depth, pitch,\n self.RED_MASK, self.GREEN_MASK,\n self.BLUE_MASK, self.ALPHA_MASK)\n```", "```py\nclass Browser:\n def draw(self):\n # ...\n rect = sdl2.SDL_Rect(0, 0, WIDTH, HEIGHT)\n window_surface = sdl2.SDL_GetWindowSurface(self.sdl_window)\n # SDL_BlitSurface is what actually does the copy.\n sdl2.SDL_BlitSurface(sdl_surface, rect, window_surface, rect)\n sdl2.SDL_UpdateWindowSurface(self.sdl_window)\n```", "```py\nclass Browser:\n def draw(self, canvas, offset):\n # ...\n canvas = self.root_surface.getCanvas()\n # ...\n```", "```py\nclass DrawText:\n def __init__(self, x1, y1, text, font, color):\n self.rect = skia.Rect.MakeLTRB(\n x1, y1,\n x1 + font.measureText(text),\n y1 - font.getMetrics().fAscent \\\n + font.getMetrics().fDescent)\n # ...\n\nclass DrawLine:\n def __init__(self, x1, y1, x2, y2, color, thickness):\n self.rect = skia.Rect.MakeLTRB(x1, y1, x2, y2)\n # ...\n```", "```py\nclass DrawLine:\n def execute(self, canvas, scroll):\n path = skia.Path().moveTo(\n self.rect.left(), self.rect.top() - scroll) \\\n .lineTo(self.rect.right(),\n self.rect.bottom() - scroll)\n paint = skia.Paint(\n Color=parse_color(self.color),\n StrokeWidth=self.thickness,\n Style=skia.Paint.kStroke_Style,\n )\n canvas.drawPath(path, paint)\n```", "```py\nclass DrawText:\n def execute(self, canvas, scroll):\n paint = skia.Paint(\n AntiAlias=True,\n Color=parse_color(self.color),\n )\n baseline = self.rect.top() - scroll \\\n - self.font.getMetrics().fAscent\n canvas.drawString(self.text, float(self.rect.left()),\n baseline, self.font, paint)\n```", "```py\nclass DrawRect:\n def execute(self, canvas, scroll):\n paint = skia.Paint(\n Color=parse_color(self.color),\n )\n canvas.drawRect(self.rect.makeOffset(0, -scroll), paint)\n```", "```py\nclass DrawOutline:\n def execute(self, scroll, canvas):\n paint = skia.Paint(\n Color=parse_color(self.color),\n StrokeWidth=self.thickness,\n Style=skia.Paint.kStroke_Style,\n )\n canvas.drawRect(self.rect.makeOffset(0, -scroll), paint)\n```", "```py\ndef get_font(size, weight, style):\n key = (weight, style)\n if key not in FONTS:\n if weight == \"bold\":\n skia_weight = skia.FontStyle.kBold_Weight\n else:\n skia_weight = skia.FontStyle.kNormal_Weight\n if style == \"italic\":\n skia_style = skia.FontStyle.kItalic_Slant\n else:\n skia_style = skia.FontStyle.kUpright_Slant\n skia_width = skia.FontStyle.kNormal_Width\n style_info = \\\n skia.FontStyle(skia_weight, skia_width, skia_style)\n font = skia.Typeface('Arial', style_info)\n FONTS[key] = font\n return skia.Font(FONTS[key], size)\n```", "```py\nclass InputLayout:\n def paint(self):\n if self.node.is_focused:\n cx = self.x + self.font.measureText(text)\n # ...\n```", "```py\ndef linespace(font):\n metrics = font.getMetrics()\n return metrics.fDescent - metrics.fAscent\n```", "```py\nclass DrawRRect:\n def __init__(self, rect, radius, color):\n self.rect = rect\n self.rrect = skia.RRect.MakeRectXY(rect, radius, radius)\n self.color = color\n\n def execute(self, scroll, canvas):\n paint = skia.Paint(\n Color=parse_color(self.color),\n )\n canvas.drawRRect(self.rrect, paint)\n```", "```py\nclass BlockLayout:\n def paint(self):\n if bgcolor != \"transparent\":\n radius = float(\n self.node.style.get(\n \"border-radius\", \"0px\")[:-2])\n cmds.append(DrawRRect(\n self.self_rect(), radius, bgcolor))\n```", "```py\n<link rel=stylesheet href=\"example11-longword.css\">\n<div>\nBackground is rounded\n</div>\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.chrome_surface = skia.Surface(\n WIDTH, math.ceil(self.chrome.bottom))\n self.tab_surface = None\n```", "```py\nclass Browser:\n def raster_tab(self):\n canvas = self.tab_surface.getCanvas()\n canvas.clear(skia.ColorWHITE)\n # ...\n\n def raster_chrome(self):\n canvas = self.chrome_surface.getCanvas()\n canvas.clear(skia.ColorWHITE)\n # ...\n\n def draw(self):\n canvas = self.root_surface.getCanvas()\n canvas.clear(skia.ColorWHITE)\n # ...\n```", "```py\nimport math\n\nclass Browser:\n def raster_tab(self):\n tab_height = math.ceil(\n self.active_tab.document.height + 2*VSTEP)\n\n if not self.tab_surface or \\\n tab_height != self.tab_surface.height():\n self.tab_surface = skia.Surface(WIDTH, tab_height)\n\n # ...\n```", "```py\nclass Browser:\n def draw(self):\n # ...\n\n tab_rect = skia.Rect.MakeLTRB(\n 0, self.chrome.bottom, WIDTH, HEIGHT)\n tab_offset = self.chrome.bottom - self.active_tab.scroll\n canvas.save()\n canvas.clipRect(tab_rect)\n canvas.translate(0, tab_offset)\n self.tab_surface.draw(canvas, 0, 0)\n canvas.restore()\n\n chrome_rect = skia.Rect.MakeLTRB(\n 0, 0, WIDTH, self.chrome.bottom)\n canvas.save()\n canvas.clipRect(chrome_rect)\n self.chrome_surface.draw(canvas, 0, 0)\n canvas.restore()\n\n # ...\n```", "```py\nclass Browser:\n def handle_click(self, e):\n if e.y < self.chrome.bottom:\n # ...\n self.raster_chrome()\n else:\n # ...\n self.raster_tab()\n self.draw()\n```", "```py\nclass Browser:\n def handle_click(self, e):\n if e.y < self.chrome.bottom:\n # ...\n else:\n # ...\n url = self.active_tab.url\n tab_y = e.y - self.chrome.bottom\n self.active_tab.click(e.x, tab_y)\n if self.active_tab.url != url:\n self.raster_chrome()\n self.raster_tab()\n```", "```py\nclass Tab:\n def raster(self, canvas):\n for cmd in self.display_list:\n cmd.execute(canvas)\n```", "```py\nclass DrawRect:\n def execute(self, canvas):\n paint = skia.Paint(\n Color=parse_color(self.color),\n )\n canvas.drawRect(self.rect, paint)\n```", "```py\ndef parse_color(color):\n # ...\n elif color.startswith(\"#\") and len(color) == 9:\n r = int(color[1:3], 16)\n g = int(color[3:5], 16)\n b = int(color[5:7], 16)\n a = int(color[7:9], 16)\n return skia.Color(r, g, b, a)\n # ...\n```", "```py\n# draw parent\ncanvas.saveLayer(None, skia.Paint(Alphaf=0.5))\n# draw children\ncanvas.restore()\n```", "```py\nclass Opacity:\n def __init__(self, opacity, children):\n self.opacity = opacity\n self.children = children\n self.rect = skia.Rect.MakeEmpty()\n for cmd in self.children:\n self.rect.join(cmd.rect)\n\n def execute(self, canvas):\n paint = skia.Paint(\n Alphaf=self.opacity\n )\n canvas.saveLayer(None, paint)\n for cmd in self.children:\n cmd.execute(canvas)\n canvas.restore()\n```", "```py\nclass BlockLayout:\n def paint_effects(self, cmds):\n cmds = paint_visual_effects(\n self.node, cmds, self.self_rect())\n return cmds\n```", "```py\ndef paint_visual_effects(node, cmds, rect):\n opacity = float(node.style.get(\"opacity\", \"1.0\"))\n\n return [\n Opacity(opacity, cmds)\n ]\n```", "```py\ndef paint_tree(layout_object, display_list):\n if layout_object.should_paint():\n cmds = layout_object.paint()\n for child in layout_object.children:\n paint_tree(child, cmds)\n\n if layout_object.should_paint():\n cmds = layout_object.paint_effects(cmds)\n display_list.extend(cmds)\n```", "```py\nclass Pixel:\n def alphaf(self, opacity):\n self.a = self.a * opacity\n```", "```py\nclass Pixel:\n def source_over(self, source):\n new_a = source.a + self.a * (1 - source.a)\n if new_a == 0: return self\n self.r = \\\n (self.r * (1 - source.a) * self.a + \\\n source.r * source.a) / new_a\n self.g = \\\n (self.g * (1 - source.a) * self.a + \\\n source.g * source.a) / new_a\n self.b = \\\n (self.b * (1 - source.a) * self.a + \\\n source.b * source.a) / new_a\n self.a = new_a\n```", "```py\nfor (x, y) in destination.coordinates():\n source[x, y].alphaf(opacity)\n destination[x, y].source_over(source[x, y])\n```", "```py\nclass Pixel:\n def multiply(self, source):\n self.r = self.r * source.r\n self.g = self.g * source.g\n self.b = self.b * source.b\n```", "```py\nclass Pixel:\n def difference(self, source):\n self.r = abs(self.r - source.r)\n self.g = abs(self.g - source.g)\n self.b = abs(self.b - source.b)\n```", "```py\n<div style=\"background-color:orange\">\n Parent\n <div style=\"background-color:blue;mix-blend-mode:difference\">\n Child\n </div>\n Parent\n</div>\n```", "```py\nfor (x, y) in destination.coordinates():\n source[x, y].alphaf(opacity)\n source[x, y].difference(destination[x, y])\n destination[x, y].source_over(source[x, y])\n```", "```py\ndef parse_blend_mode(blend_mode_str):\n if blend_mode_str == \"multiply\":\n return skia.BlendMode.kMultiply\n elif blend_mode_str == \"difference\":\n return skia.BlendMode.kDifference\n else:\n return skia.BlendMode.kSrcOver\n```", "```py\nclass Blend:\n def __init__(self, blend_mode, children):\n self.blend_mode = blend_mode\n\n self.children = children\n self.rect = skia.Rect.MakeEmpty()\n for cmd in self.children:\n self.rect.join(cmd.rect)\n\n def execute(self, canvas):\n paint = skia.Paint(\n BlendMode=parse_blend_mode(self.blend_mode),\n )\n canvas.saveLayer(None, paint)\n for cmd in self.children:\n cmd.execute(canvas)\n canvas.restore()\n```", "```py\ndef paint_visual_effects(node, cmds, rect):\n # ...\n blend_mode = node.style.get(\"mix-blend-mode\")\n\n return [\n Blend(blend_mode, [\n Opacity(opacity, cmds),\n ]),\n ]\n```", "```py\n<div \n style=\"border-radius:30px;background-color:lightblue;overflow:clip\">\n This test text exists here to ensure that the \"div\" element is\n large enough that the border radius is obvious.\n</div>\n```", "```py\nclass Pixel:\n def destination_in(self, source):\n self.a = self.a * source.a\n```", "```py\ndef paint_visual_effects(node, cmds, rect):\n # ...\n if node.style.get(\"overflow\", \"visible\") == \"clip\":\n border_radius = float(node.style.get(\n \"border-radius\", \"0px\")[:-2])\n cmds.append(Blend(\"destination-in\", [\n DrawRRect(rect, border_radius, \"white\")\n ]))\n\n return [\n Blend(blend_mode, [\n Opacity(opacity, cmds),\n ]),\n ]\n```", "```py\ndef parse_blend_mode(blend_mode_str):\n # ...\n elif blend_mode_str == \"destination-in\":\n return skia.BlendMode.kDstIn\n # ...\n```", "```py\nclass Opacity:\n def execute(self, canvas):\n paint = skia.Paint(\n Alphaf=self.opacity,\n )\n if self.opacity < 1:\n canvas.saveLayer(None, paint)\n for cmd in self.children:\n cmd.execute(canvas)\n if self.opacity < 1:\n canvas.restore()\n```", "```py\ndef paint_visual_effects(node, cmds, rect):\n if node.style.get(\"overflow\", \"visible\") == \"clip\":\n if not blend_mode:\n blend_mode = \"source-over\"\n # ...\n```", "```py\ndef parse_blend_mode(blend_mode_str):\n # ...\n elif blend_mode_str == \"source-over\":\n return skia.BlendMode.kSrcOver\n # ...\n```", "```py\nclass Blend:\n def execute(self, canvas):\n paint = skia.Paint(\n BlendMode=parse_blend_mode(self.blend_mode),\n )\n if self.blend_mode:\n canvas.saveLayer(None, paint)\n for cmd in self.children:\n cmd.execute(canvas)\n if self.blend_mode:\n canvas.restore()\n```", "```py\nclass Blend:\n def __init__(self, opacity, blend_mode, children):\n self.opacity = opacity\n self.blend_mode = blend_mode\n self.should_save = self.blend_mode or self.opacity < 1\n\n self.children = children\n self.rect = skia.Rect.MakeEmpty()\n for cmd in self.children:\n self.rect.join(cmd.rect)\n\n def execute(self, canvas):\n paint = skia.Paint(\n Alphaf=self.opacity,\n BlendMode=parse_blend_mode(self.blend_mode),\n )\n if self.should_save:\n canvas.saveLayer(None, paint)\n for cmd in self.children:\n cmd.execute(canvas)\n if self.should_save:\n canvas.restore()\n```", "```py\ndef paint_visual_effects(node, cmds, rect):\n # ...\n\n if node.style.get(\"overflow\", \"visible\") == \"clip\":\n # ...\n cmds.append(Blend(1.0, \"destination-in\", [\n DrawRRect(rect, border_radius, \"white\")\n ]))\n\n return [Blend(opacity, blend_mode, cmds)]\n```", "```py\nclass Task:\n def __init__(self, task_code, *args):\n self.task_code = task_code\n self.args = args\n\n def run(self):\n self.task_code(*self.args)\n self.task_code = None\n self.args = None\n```", "```py\nclass TaskRunner:\n def __init__(self):\n self.tab = tab\n self.tasks = []\n\n def schedule_task(self, task):\n self.tasks.append(task)\n```", "```py\nclass TaskRunner:\n def run(self):\n if len(self.tasks) > 0:\n task = self.tasks.pop(0)\n task.run()\n```", "```py\nclass Tab:\n def __init__(self):\n self.task_runner = TaskRunner(self)\n```", "```py\ndef mainloop(browser):\n while True:\n # ...\n browser.active_tab.task_runner.run()\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n # ...\n for script in scripts:\n # ...\n try:\n header, body = script_url.request(url)\n except:\n continue\n task = Task(self.js.run, script_url, body)\n self.task_runner.schedule_task(task)\n```", "```py\nfunction callback() { console.log('Callback'); }\nsetTimeout(callback, 1000);\n```", "```py\nSET_TIMEOUT_REQUESTS = {}\n\nfunction setTimeout(callback, time_delta) {\n var handle = Object.keys(SET_TIMEOUT_REQUESTS).length;\n SET_TIMEOUT_REQUESTS[handle] = callback;\n call_python(\"setTimeout\", handle, time_delta)\n}\n```", "```py\nfunction __runSetTimeout(handle) {\n var callback = SET_TIMEOUT_REQUESTS[handle]\n callback();\n}\n```", "```py\nimport threading\ndef callback():\n # ...\nthreading.Timer(1.0, callback).start()\n```", "```py\nSETTIMEOUT_JS = \"__runSetTimeout(dukpy.handle)\"\n\nclass JSContext:\n def __init__(self, tab):\n # ...\n self.interp.export_function(\"setTimeout\",\n self.setTimeout)\n\n def dispatch_settimeout(self, handle):\n self.interp.evaljs(SETTIMEOUT_JS, handle=handle)\n\n def setTimeout(self, handle, time):\n def run_callback():\n task = Task(self.dispatch_settimeout, handle)\n self.tab.task_runner.schedule_task(task)\n threading.Timer(time / 1000.0, run_callback).start()\n```", "```py\nclass TaskRunner:\n def __init__(self, tab):\n # ...\n self.condition = threading.Condition()\n\n def schedule_task(self, task):\n self.condition.acquire(blocking=True)\n self.tasks.append(task)\n self.condition.notify_all()\n self.condition.release()\n\n def run(self):\n task = None\n self.condition.acquire(blocking=True)\n if len(self.tasks) > 0:\n task = self.tasks.pop(0)\n self.condition.release()\n if task:\n task.run()\n\n self.condition.acquire(blocking=True)\n if len(self.tasks) == 0:\n self.condition.wait()\n self.condition.release()\n```", "```py\nclass JSContext:\n def __init__(self, tab):\n # ...\n self.discarded = False\n\n def dispatch_settimeout(self, handle):\n if self.discarded: return\n self.interp.evaljs(SETTIMEOUT_JS, handle=handle)\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n # ...\n if self.js: self.js.discarded = True\n self.js = JSContext(self)\n # ...\n```", "```py\nthreading.Thread(target=callback).start()\n```", "```py\nXHR_REQUESTS = {}\n\nfunction XMLHttpRequest() {\n this.handle = Object.keys(XHR_REQUESTS).length;\n XHR_REQUESTS[this.handle] = this;\n}\n```", "```py\nXMLHttpRequest.prototype.open = function(method, url, is_async) {\n this.is_async = is_async;\n this.method = method;\n this.url = url;\n}\n```", "```py\nXMLHttpRequest.prototype.send = function(body) {\n this.responseText = call_python(\"XMLHttpRequest_send\",\n this.method, this.url, body, this.is_async, this.handle);\n}\n```", "```py\nclass JSContext:\n def XMLHttpRequest_send(\n self, method, url, body, isasync, handle):\n full_url = self.tab.url.resolve(url)\n if not self.tab.allowed_request(full_url):\n raise Exception(\"Cross-origin XHR blocked by CSP\")\n if full_url.origin() != self.tab.url.origin():\n raise Exception(\n \"Cross-origin XHR request not allowed\")\n```", "```py\nclass JSContext:\n def XMLHttpRequest_send(\n self, method, url, body, isasync, handle):\n # ...\n def run_load():\n headers, response = full_url.request(self.tab.url, body)\n task = Task(self.dispatch_xhr_onload, response, handle)\n self.tab.task_runner.schedule_task(task)\n return response\n```", "```py\nclass JSContext:\n def XMLHttpRequest_send(\n self, method, url, body, isasync, handle):\n # ...\n if not isasync:\n return run_load()\n else:\n threading.Thread(target=run_load).start()\n```", "```py\nXHR_ONLOAD_JS = \"__runXHROnload(dukpy.out, dukpy.handle)\"\n\nclass JSContext:\n def dispatch_xhr_onload(self, out, handle):\n if self.discarded: return\n do_default = self.interp.evaljs(\n XHR_ONLOAD_JS, out=out, handle=handle)\n```", "```py\nfunction __runXHROnload(body, handle) {\n var obj = XHR_REQUESTS[handle];\n var evt = new Event('load');\n obj.responseText = body;\n if (obj.onload)\n obj.onload(evt);\n}\n```", "```py\nREFRESH_RATE_SEC = .033\n```", "```py\nclass Browser:\n def raster_and_draw(self):\n self.raster_chrome()\n self.raster_tab()\n self.draw()\n```", "```py\nclass Browser:\n def __init__(self):\n self.animation_timer = None\n\n def schedule_animation_frame(self):\n def callback():\n active_tab = self.active_tab\n task = Task(active_tab.render)\n active_tab.task_runner.schedule_task(task)\n self.animation_timer = None\n if not self.animation_timer:\n self.animation_timer = \\\n threading.Timer(REFRESH_RATE_SEC, callback)\n self.animation_timer.start()\n```", "```py\ndef mainloop(browser):\n while True:\n # ...\n browser.active_tab.task_runner.run()\n browser.raster_and_draw()\n browser.schedule_animation_frame()\n```", "```py\nclass Tab:\n def __init__(self, browser, tab_height):\n # ...\n self.needs_render = False\n\n def set_needs_render(self):\n self.needs_render = True\n\n def render(self):\n if not self.needs_render: return\n # ...\n self.needs_render = False\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n # ...\n self.set_needs_render()\n```", "```py\nclass JSContext:\n def innerHTML_set(self, handle, s):\n # ...\n self.tab.set_needs_render()\n```", "```py\nclass Tab:\n def click(self, x, y):\n self.render()\n # ...\n```", "```py\nclass Browser:\n def __init__(self):\n self.needs_raster_and_draw = False\n\n def set_needs_raster_and_draw(self):\n self.needs_raster_and_draw = True\n\n def raster_and_draw(self):\n if not self.needs_raster_and_draw:\n return\n # ...\n self.needs_raster_and_draw = False\n```", "```py\nclass Browser:\n def handle_click(self, e):\n if e.y < self.chrome.bottom:\n # ...\n self.set_needs_raster_and_draw()\n\n def handle_key(self, char):\n if self.chrome.keypress(char):\n # ...\n self.set_needs_raster_and_draw()\n\n def handle_enter(self):\n if self.chrome.enter():\n # ...\n self.set_needs_raster_and_draw()\n```", "```py\nclass Chrome:\n def enter(self):\n if self.focus == \"address bar\":\n self.browser.active_tab.load(URL(self.address_bar))\n self.focus = None\n return True\n return False\n```", "```py\nclass Tab:\n def __init__(self, browser, tab_height):\n # ...\n self.browser = browser\n\n def render(self):\n # ...\n self.browser.set_needs_raster_and_draw()\n```", "```py\nclass Browser:\n def new_tab(self, url):\n new_tab = Tab(self, HEIGHT - self.chrome.bottom)\n # ...\n```", "```py\nfunction callback() { /* Modify DOM */ }\nrequestAnimationFrame(callback);\n```", "```py\nRAF_LISTENERS = [];\n\nfunction requestAnimationFrame(fn) {\n RAF_LISTENERS.push(fn);\n call_python(\"requestAnimationFrame\");\n}\n```", "```py\nclass JSContext:\n def __init__(self, tab):\n # ...\n self.interp.export_function(\"requestAnimationFrame\",\n self.requestAnimationFrame)\n```", "```py\n def requestAnimationFrame(self):\n task = Task(self.tab.render)\n self.tab.task_runner.schedule_task(task)\n```", "```py\nclass Tab:\n def render(self):\n if not self.needs_render: return\n self.js.interp.evaljs(\"__runRAFHandlers()\")\n # ...\n```", "```py\nfunction __runRAFHandlers() {\n var handlers_copy = RAF_LISTENERS;\n RAF_LISTENERS = [];\n for (var i = 0; i < handlers_copy.length; i++) {\n handlers_copy[i]();\n }\n}\n```", "```py\nvar count = 0;\nfunction callback() {\n var output = document.querySelectorAll(\"div\")[1];\n output.innerHTML = \"count: \" + (count++);\n if (count < 100)\n requestAnimationFrame(callback);\n}\nrequestAnimationFrame(callback);\n```", "```py\ndef do_request(session, method, url, headers, body):\n elif method == \"GET\" and url == \"/count\":\n return \"200 OK\", show_count()\n# ...\ndef show_count():\n out = \"<!doctype html>\"\n out += \"<div>\";\n out += \"  Let's count up to 99!\"\n out += \"</div>\";\n out += \"<div>Output</div>\"\n out += \"<script src=/eventloop.js></script>\"\n return out\n```", "```py\nclass Browser:\n def __init__(self):\n self.needs_animation_frame = True\n```", "```py\n def schedule_animation_frame(self):\n # ...\n if self.needs_animation_frame and not self.animation_timer:\n # ...\n```", "```py\nclass JSContext:\n def requestAnimationFrame(self):\n self.tab.browser.set_needs_animation_frame(self.tab)\n\nclass Tab:\n def set_needs_render(self):\n # ...\n self.browser.set_needs_animation_frame(self)\n\nclass Browser:\n def set_needs_animation_frame(self, tab):\n if tab == self.active_tab:\n self.needs_animation_frame = True\n```", "```py\nclass MeasureTime:\n def __init__(self):\n self.file = open(\"browser.trace\", \"w\")\n```", "```py\nclass MeasureTime:\n def __init__(self):\n # ...\n self.file.write('{\"traceEvents\": [')\n```", "```py\nclass MeasureTime:\n def __init__(self):\n # ...\n ts = time.time() * 1000000\n self.file.write(\n '{ \"name\": \"process_name\",' +\n '\"ph\": \"M\",' +\n '\"ts\": ' + str(ts) + ',' +\n '\"pid\": 1, \"cat\": \"__metadata\",' +\n '\"args\": {\"name\": \"Browser\"}}')\n self.file.flush()\n```", "```py\nclass Browser:\n def __init__(self):\n self.measure = MeasureTime()\n```", "```py\nclass MeasureTime:\n def time(self, name):\n ts = time.time() * 1000000\n self.file.write(\n ', { \"ph\": \"B\", \"cat\": \"_\",' +\n '\"name\": \"' + name + '\",' +\n '\"ts\": ' + str(ts) + ',' +\n '\"pid\": 1, \"tid\": 1}')\n self.file.flush()\n```", "```py\nclass MeasureTime:\n def stop(self, name):\n ts = time.time() * 1000000\n self.file.write(\n ', { \"ph\": \"E\", \"cat\": \"_\",' +\n '\"name\": \"' + name + '\",' +\n '\"ts\": ' + str(ts) + ',' +\n '\"pid\": 1, \"tid\": 1}')\n self.file.flush()\n```", "```py\nclass Tab:\n def render(self):\n if not self.needs_render: return\n self.browser.measure.time('render')\n # ...\n self.browser.measure.stop('render')\n```", "```py\nclass MeasureTime:\n def finish(self):\n self.file.write(']}')\n self.file.close()\n\nclass Browser:\n def handle_quit(self):\n # ...\n self.measure.finish()\n```", "```py\nclass TaskRunner:\n def __init__(self, tab):\n # ...\n self.main_thread = threading.Thread(\n target=self.run,\n name=\"Main thread\",\n )\n\n def start_thread(self):\n self.main_thread.start()\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n threading.current_thread().name = \"Browser thread\"\n```", "```py\nclass TaskRunner:\n def run(self):\n while True:\n # ...\n```", "```py\nclass Browser:\n def handle_quit(self):\n for tab in self.tabs:\n tab.task_runner.set_needs_quit()\n```", "```py\nclass TaskRunner:\n def set_needs_quit(self):\n self.condition.acquire(blocking=True)\n self.needs_quit = True\n self.condition.notify_all()\n self.condition.release()\n\n def run(self):\n while True:\n self.condition.acquire(blocking=True)\n needs_quit = self.needs_quit\n self.condition.release()\n if needs_quit:\n return\n\n # ...\n\n self.condition.acquire(blocking=True)\n if len(self.tasks) == 0 and not self.needs_quit:\n self.condition.wait()\n self.condition.release()\n```", "```py\nclass Browser:\n def schedule_load(self, url, body=None):\n self.active_tab.task_runner.clear_pending_tasks()\n task = Task(self.active_tab.load, url, body)\n self.active_tab.task_runner.schedule_task(task)\n```", "```py\nclass TaskRunner:\n def clear_pending_tasks(self):\n self.condition.acquire(blocking=True)\n self.tasks.clear()\n self.condition.release()\n```", "```py\nclass Browser:\n def new_tab(self, url):\n self.lock.acquire(blocking=True)\n self.new_tab_internal(url)\n self.lock.release()\n\n def new_tab_internal(self, url):\n new_tab = Tab(self, HEIGHT - self.chrome.bottom)\n self.tabs.append(new_tab)\n self.set_active_tab(new_tab)\n self.schedule_load(url)\n```", "```py\nclass Chrome:\n def click(self, x, y):\n if self.newtab_rect.contains(x, y):\n self.browser.new_tab_internal(\n URL(\"https://browser.engineering/\"))\n\n def enter(self):\n if self.focus == \"address bar\":\n self.browser.schedule_load(URL(self.address_bar))\n```", "```py\nclass Browser:\n def handle_click(self, e):\n self.lock.acquire(blocking=True)\n if e.y < self.chrome.bottom:\n # ...\n else:\n # ...\n tab_y = e.y - self.chrome.bottom\n task = Task(self.active_tab.click, e.x, tab_y)\n self.active_tab.task_runner.schedule_task(task)\n self.lock.release()\n```", "```py\nclass Browser:\n def handle_key(self, char):\n if not (0x20 <= ord(char) < 0x7f): return\n if self.chrome.keypress(char):\n # ...\n elif self.focus == \"content\":\n task = Task(self.active_tab.keypress, char)\n self.active_tab.task_runner.schedule_task(task)\n```", "```py\nclass CommitData:\n def __init__(self, url, scroll, height, display_list):\n self.url = url\n self.scroll = scroll\n self.height = height\n self.display_list = display_list\n```", "```py\nclass Tab:\n def __init__(self, browser, tab_height):\n # ...\n self.browser = browser\n\n def run_animation_frame(self):\n self.js.interp.evaljs(\"__runRAFHandlers()\")\n self.render()\n commit_data = CommitData(\n self.url, self.scroll, document_height, \\\n self.display_list)\n self.display_list = None\n self.browser.commit(self, commit_data)\n```", "```py\nclass Browser:\n def schedule_animation_frame(self):\n def callback():\n # ...\n task = Task(self.active_tab.run_animation_frame)\n # ...\n```", "```py\nclass Browser:\n def __init__(self):\n self.lock = threading.Lock()\n\n self.active_tab_url = None\n self.active_tab_scroll = 0\n self.active_tab_height = 0\n self.active_tab_display_list = None\n\n def commit(self, tab, data):\n self.lock.acquire(blocking=True)\n if tab == self.active_tab:\n self.active_tab_url = data.url\n self.active_tab_scroll = data.scroll\n self.active_tab_height = data.height\n if data.display_list:\n self.active_tab_display_list = data.display_list\n self.animation_timer = None\n self.set_needs_raster_and_draw()\n self.lock.release()\n```", "```py\nclass Browser:\n def set_needs_animation_frame(self, tab):\n self.lock.acquire(blocking=True)\n # ...\n self.lock.release()\n```", "```py\nclass Browser:\n def schedule_animation_frame(self):\n def callback():\n self.lock.acquire(blocking=True)\n # ...\n self.lock.release()\n # ...\n self.lock.acquire(blocking=True)\n # ...\n self.lock.release()\n```", "```py\ndef mainloop(browser):\n while True:\n # ...\n browser.raster_and_draw()\n browser.schedule_animation_frame()\n```", "```py\nclass MeasureTime:\n def __init__(self):\n self.lock = threading.Lock()\n # ...\n\n def time(self, name):\n self.lock.acquire(blocking=True)\n # ...\n self.lock.release()\n\n def stop(self, name):\n self.lock.acquire(blocking=True)\n # ...\n self.lock.release()\n\n def finish(self):\n self.lock.acquire(blocking=True)\n # ...\n self.lock.release()\n```", "```py\nclass MeasureTime:\n def time(self, name):\n # ...\n tid = threading.get_ident()\n self.file.write(\n ', { \"ph\": \"B\", \"cat\": \"_\",' +\n '\"name\": \"' + name + '\",' +\n '\"ts\": ' + str(ts) + ',' +\n '\"pid\": 1, \"tid\": ' + str(tid) + '}')\n # ...\n```", "```py\nclass MeasureTime:\n def finish(self):\n self.lock.acquire(blocking=True)\n for thread in threading.enumerate():\n self.file.write(\n ', { \"ph\": \"M\", \"name\": \"thread_name\",' +\n '\"pid\": 1, \"tid\": ' + str(thread.ident) + ',' +\n '\"args\": { \"name\": \"' + thread.name + '\"}}')\n # ...\n```", "```py\nfunction callback() {\n for (var i = 0; i < 5e6; i++);\n // ...\n}\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.active_tab_scroll = 0\n\n def clamp_scroll(self, scroll):\n height = self.active_tab_height\n maxscroll = height - (HEIGHT - self.chrome.bottom)\n return max(0, min(scroll, maxscroll))\n\n def handle_down(self):\n self.lock.acquire(blocking=True)\n if not self.active_tab_height:\n self.lock.release()\n return\n self.active_tab_scroll = self.clamp_scroll(\n self.active_tab_scroll + SCROLL_STEP)\n self.set_needs_raster_and_draw()\n self.needs_animation_frame = True\n self.lock.release()\n```", "```py\nclass Browser:\n def set_active_tab(self, tab):\n self.active_tab = tab\n self.active_tab_scroll = 0\n self.active_tab_url = None\n self.needs_animation_frame = True\n self.animation_timer = None\n```", "```py\nclass Browser:\n def schedule_animation_frame(self):\n # ...\n def callback():\n self.lock.acquire(blocking=True)\n scroll = self.active_tab_scroll\n self.needs_animation_frame = False\n task = Task(self.active_tab.run_animation_frame, scroll)\n self.active_tab.task_runner.schedule_task(task)\n self.lock.release()\n # ...\n```", "```py\nclass Tab:\n def __init__(self, browser, tab_height):\n # ...\n self.scroll_changed_in_tab = False\n\n def run_animation_frame(self, scroll):\n if not self.scroll_changed_in_tab:\n self.scroll = scroll\n # ...\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n # ...\n self.scroll = 0\n self.scroll_changed_in_tab = True\n\n def clamp_scroll(self, scroll):\n height = math.ceil(self.document.height + 2*VSTEP)\n maxscroll = height - self.tab_height\n return max(0, min(scroll, maxscroll))\n\n def run_animation_frame(self, scroll):\n # ...\n self.browser.commit(self, commit_data)\n self.scroll_changed_in_tab = False\n\n def render(self):\n # ...\n clamped_scroll = self.clamp_scroll(self.scroll)\n if clamped_scroll != self.scroll:\n self.scroll_changed_in_tab = True\n self.scroll = clamped_scroll\n # ...\n```", "```py\nclass Tab:\n def run_animation_frame(self, scroll):\n # ...\n scroll = None\n if self.scroll_changed_in_tab:\n scroll = self.scroll\n commit_data = CommitData(\n self.url, scroll, document_height, \\\n self.display_list)\n # ...\n```", "```py\nclass Browser:\n def commit(self, tab, data):\n if tab == self.active_tab:\n # ...\n if data.scroll != None:\n self.active_tab_scroll = data.scroll\n```", "```py\nclass Tab:\n def click(self, x, y):\n self.render()\n # ...\n```", "```py\nfunction run_animation_frame() {\n if (animate())\n requestAnimationFrame(run_animation_frame);\n}\nrequestAnimationFrame(run_animation_frame);\n```", "```py\n<div>This text fades</div>\n```", "```py\nvar div = document.querySelectorAll(\"div\")[0];\nvar total_frames = 120;\nvar current_frame = 0;\nvar change_per_frame = (0.999 - 0.1) / total_frames;\nfunction animate() {\n current_frame++;\n var new_opacity = current_frame * change_per_frame + 0.1;\n div.style = \"opacity:\" + new_opacity;\n return current_frame < total_frames;\n}\n```", "```py\nObject.defineProperty(Node.prototype, 'style', {\n set: function(s) {\n call_python(\"style_set\", this.handle, s.toString());\n }\n});\n```", "```py\nclass JSContext:\n def __init__(self, tab):\n # ...\n self.interp.export_function(\"style_set\", self.style_set)\n\n def style_set(self, handle, s):\n elt = self.handle_to_node[handle]\n elt.attributes[\"style\"] = s;\n self.tab.set_needs_render()\n```", "```py\npip3 install PyOpenGL\n```", "```py\nimport OpenGL.GL\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.sdl_window = sdl2.SDL_CreateWindow(b\"Browser\",\n sdl2.SDL_WINDOWPOS_CENTERED,\n sdl2.SDL_WINDOWPOS_CENTERED,\n WIDTH, HEIGHT,\n sdl2.SDL_WINDOW_SHOWN | sdl2.SDL_WINDOW_OPENGL)\n self.gl_context = sdl2.SDL_GL_CreateContext(\n self.sdl_window)\n print((\"OpenGL initialized: vendor={},\" + \\\n \"renderer={}\").format(\n OpenGL.GL.glGetString(OpenGL.GL.GL_VENDOR),\n OpenGL.GL.glGetString(OpenGL.GL.GL_RENDERER)))\n\n def handle_quit(self):\n # ...\n sdl2.SDL_GL_DeleteContext(self.gl_context)\n sdl2.SDL_DestroyWindow(self.sdl_window)\n```", "```py\nOpenGL initialized: vendor=b'Red Hat', renderer=b'virgl'\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.skia_context = skia.GrDirectContext.MakeGL()\n\n self.root_surface = \\\n skia.Surface.MakeFromBackendRenderTarget(\n self.skia_context,\n skia.GrBackendRenderTarget(\n WIDTH, HEIGHT, 0, 0,\n skia.GrGLFramebufferInfo(\n 0, OpenGL.GL.GL_RGBA8)),\n skia.kBottomLeft_GrSurfaceOrigin,\n skia.kRGBA_8888_ColorType,\n skia.ColorSpace.MakeSRGB())\n assert self.root_surface is not None\n```", "```py\nclass Browser:\n def draw(self):\n # ...\n self.root_surface.flushAndSubmit()\n sdl2.SDL_GL_SwapWindow(self.sdl_window)\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.chrome_surface = skia.Surface.MakeRenderTarget(\n self.skia_context, skia.Budgeted.kNo,\n skia.ImageInfo.MakeN32Premul(\n WIDTH, math.ceil(self.chrome.bottom)))\n assert self.chrome_surface is not None\n```", "```py\nclass DrawRect:\n def __repr__(self):\n return (\"DrawRect(top={} left={} \" +\n \"bottom={} right={} color={})\").format(\n self.top, self.left, self.bottom,\n self.right, self.color)\n```", "```py\nclass Blend:\n def __repr__(self):\n args = \"\"\n if self.opacity < 1:\n args += \", opacity={}\".format(self.opacity)\n if self.blend_mode:\n args += \", blend_mode={}\".format(self.blend_mode)\n if not args:\n args = \", <no-op>\"\n return \"Blend({})\".format(args[2:])\n```", "```py\nclass Tab:\n def render(self):\n # ...\n for item in self.display_list:\n print_tree(item)\n```", "```py\nBlend(alpha=0.119866666667)\n  DrawText(text=This)\n  DrawText(text=text)\n  DrawText(text=fades)\n```", "```py\nBlend(alpha=0.112375)\n  DrawText(text=This)\n  DrawText(text=text)\n  DrawText(text=fades)\n```", "```py\nComposited Layer:\n  DrawText(text=This)\n  DrawText(text=text)\n  DrawText(text=fades)\n```", "```py\nBlend(alpha=0.112375)\n  DrawCompositedLayer()\n```", "```py\nBlend(alpha=0.119866666667)\n  DrawCompositedLayer()\n```", "```py\nclass PaintCommand:\n def __init__(self, rect):\n self.rect = rect\n self.children = []\n```", "```py\nclass DrawLine(PaintCommand):\n def __init__(self, x1, y1, x2, y2, color, thickness):\n super().__init__(skia.Rect.MakeLTRB(x1, y1, x2, y2))\n # ...\n```", "```py\nclass VisualEffect:\n def __init__(self, rect, children):\n self.rect = rect.makeOffset(0.0, 0.0)\n self.children = children\n for child in self.children:\n self.rect.join(child.rect)\n```", "```py\nclass Browser:\n def composite(self):\n all_commands = []\n for cmd in self.active_tab_display_list:\n all_commands = tree_to_list(cmd, all_commands)\n paint_commands = [cmd for cmd in all_commands\n if isinstance(cmd, PaintCommand)]\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.composited_layers = []\n\n def composite(self):\n self.composited_layers = []\n # ...\n for cmd in paint_commands:\n layer = CompositedLayer(self.skia_context, cmd)\n self.composited_layers.append(layer)\n```", "```py\nclass CompositedLayer:\n def __init__(self, skia_context, display_item):\n self.skia_context = skia_context\n self.surface = None\n self.display_items = [display_item]\n```", "```py\ndef add_parent_pointers(nodes, parent=None):\n for node in nodes:\n node.parent = parent\n add_parent_pointers(node.children, node)\n\nclass Browser:\n def composite(self):\n add_parent_pointers(self.active_tab_display_list)\n # ...\n```", "```py\nclass Blend(VisualEffect):\n # ...\n def clone(self, child):\n return Blend(self.opacity, self.blend_mode,\n self.node, [child])\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.draw_list = []\n\n def paint_draw_list(self):\n self.draw_list = []\n for composited_layer in self.composited_layers:\n current_effect = \\\n DrawCompositedLayer(composited_layer)\n if not composited_layer.display_items: continue\n parent = composited_layer.display_items[0].parent\n while parent:\n current_effect = \\\n parent.clone(current_effect)\n parent = parent.parent\n self.draw_list.append(current_effect)\n```", "```py\nclass Browser:\n def paint_draw_list(self):\n new_effects = {}\n self.draw_list = []\n for composited_layer in self.composited_layers:\n # ...\n while parent:\n if parent in new_effects:\n new_parent = new_effects[parent]\n new_parent.children.append(current_effect)\n break\n else:\n current_effect = \\\n parent.clone(current_effect)\n new_effects[parent] = current_effect\n parent = parent.parent\n if not parent:\n self.draw_list.append(current_effect)\n```", "```py\nclass Browser:\n def raster_tab(self):\n for composited_layer in self.composited_layers:\n composited_layer.raster()\n```", "```py\nclass CompositedLayer:\n # ...\n def composited_bounds(self):\n rect = skia.Rect.MakeEmpty()\n for item in self.display_items:\n rect.join(item.rect)\n # ...\n```", "```py\n def composited_bounds(self):\n # ...\n rect.outset(1, 1)\n return rect\n```", "```py\nclass CompositedLayer:\n def raster(self):\n bounds = self.composited_bounds()\n if bounds.isEmpty(): return\n irect = bounds.roundOut()\n\n if not self.surface:\n self.surface = skia.Surface.MakeRenderTarget(\n self.skia_context, skia.Budgeted.kNo,\n skia.ImageInfo.MakeN32Premul(\n irect.width(), irect.height()))\n assert self.surface\n canvas = self.surface.getCanvas()\n```", "```py\nclass CompositedLayer:\n def raster(self):\n # ...\n canvas.clear(skia.ColorTRANSPARENT)\n canvas.save()\n canvas.translate(-bounds.left(), -bounds.top())\n for item in self.display_items:\n item.execute(canvas)\n canvas.restore()\n```", "```py\nclass DrawCompositedLayer(PaintCommand):\n def __init__(self, composited_layer):\n self.composited_layer = composited_layer\n super().__init__(\n self.composited_layer.composited_bounds())\n\n def __repr__(self):\n return \"DrawCompositedLayer()\"\n```", "```py\nclass DrawCompositedLayer(PaintCommand):\n def execute(self, canvas):\n layer = self.composited_layer\n bounds = layer.composited_bounds()\n layer.surface.draw(canvas, bounds.left(), bounds.top())\n```", "```py\nclass Browser:\n def draw(self):\n # ...\n canvas.save()\n canvas.translate(0,\n self.chrome.bottom - self.active_tab_scroll)\n for item in self.draw_list:\n item.execute(canvas)\n canvas.restore()\n # ...\n```", "```py\nclass Browser:\n def composite_raster_and_draw(self):\n # ...\n self.composite()\n self.raster_chrome()\n self.raster_tab()\n self.paint_draw_list()\n self.draw()\n # ...\n```", "```py\ndiv { transition: opacity 2s; }\n```", "```py\nclass Text:\n def __init__(self, text, parent):\n # ...\n self.style = {}\n self.animations = {}\n\nclass Element:\n def __init__(self, tag, attributes, parent):\n # ...\n self.style = {}\n self.animations = {}\n```", "```py\nclass NumericAnimation:\n def __init__(self, old_value, new_value, num_frames):\n self.old_value = float(old_value)\n self.new_value = float(new_value)\n self.num_frames = num_frames\n\n self.frame_count = 1\n total_change = self.new_value - self.old_value\n self.change_per_frame = total_change / num_frames\n```", "```py\nclass NumericAnimation:\n def animate(self):\n self.frame_count += 1\n if self.frame_count >= self.num_frames: return\n current_value = self.old_value + \\\n self.change_per_frame * self.frame_count\n return str(current_value)\n```", "```py\ndef style(node, rules):\n old_style = node.style\n\n # ...\n\n if old_style:\n transitions = diff_styles(old_style, node.style)\n```", "```py\nclass CSSParser:\n def until_chars(self, chars):\n start = self.i\n while self.i < len(self.s) and self.s[self.i] not in chars:\n self.i += 1\n return self.s[start:self.i]\n\n def pair(self, until):\n # ...\n val = self.until_chars(until)\n # ...\n return prop.casefold(), val.strip()\n```", "```py\nclass CSSParser:\n def body(self):\n while self.i < len(self.s) and self.s[self.i] != \"}\":\n try:\n prop, val = self.pair([\";\", \"}\"])\n # ...\n```", "```py\ndef parse_transition(value):\n properties = {}\n if not value: return properties\n for item in value.split(\",\"):\n property, duration = item.split(\" \", 1)\n frames = int(float(duration[:-1]) / REFRESH_RATE_SEC)\n properties[property] = frames\n return properties\n```", "```py\ndef diff_styles(old_style, new_style):\n transitions = {}\n for property, num_frames in \\\n parse_transition(new_style.get(\"transition\")).items():\n if property not in old_style: continue\n if property not in new_style: continue\n old_value = old_style[property]\n new_value = new_style[property]\n if old_value == new_value: continue\n transitions[property] = \\\n (old_value, new_value, num_frames)\n return transitions\n```", "```py\ndef style(node, rules, tab):\n if old_style:\n transitions = diff_styles(old_style, node.style)\n for property, (old_value, new_value, num_frames) \\\n in transitions.items():\n if property == \"opacity\":\n tab.set_needs_render()\n animation = NumericAnimation(\n old_value, new_value, num_frames)\n node.animations[property] = animation\n node.style[property] = animation.animate()\n```", "```py\nclass Tab:\n def run_animation_frame(self, scroll):\n # ...\n self.js.interp.evaljs(\"__runRAFHandlers()\")\n\n for node in tree_to_list(self.nodes, []):\n for (property_name, animation) in \\\n node.animations.items():\n # ...\n```", "```py\nclass Tab:\n def run_animation_frame(self, scroll):\n for node in tree_to_list(self.nodes, []):\n for (property_name, animation) in \\\n node.animations.items():\n value = animation.animate()\n if value:\n node.style[property_name] = value\n self.set_needs_layout()\n```", "```py\nclass Tab:\n def __init__(self, browser, tab_height):\n # ...\n self.needs_style = False\n self.needs_layout = False\n self.needs_paint = False\n # ...\n\n def set_needs_render(self):\n self.needs_style = True\n self.browser.set_needs_animation_frame(self)\n```", "```py\nclass Tab:\n def set_needs_layout(self):\n self.needs_layout = True\n self.browser.set_needs_animation_frame(self)\n```", "```py\nclass Tab:\n def render(self):\n self.browser.measure.time('render')\n\n if self.needs_style:\n # ...\n self.needs_layout = True\n self.needs_style = False\n\n if self.needs_layout:\n # ...\n self.needs_paint = True\n self.needs_layout = False\n\n if self.needs_paint:\n # ...\n self.needs_paint = False\n\n self.browser.measure.stop('render')\n```", "```py\nclass VisualEffect:\n def __init__(self, rect, children, node=None):\n # ...\n self.node = node\n```", "```py\nclass Tab:\n def __init__(self, browser):\n # ...\n self.composited_updates = []\n\n def run_animation_frame(self, scroll):\n for node in tree_to_list(self.nodes, []):\n for (property_name, animation) in \\\n node.animations.items():\n value = animation.animate()\n if value:\n node.style[property_name] = value\n self.composited_updates.append(node)\n self.set_needs_paint()\n```", "```py\ndef paint_visual_effects(node, cmds, rect):\n # ...\n blend_op = Blend(opacity, blend_mode, cmds)\n node.blend_op = blend_op\n return [blend_op]\n```", "```py\nclass CommitData:\n def __init__(self, url, scroll, height,\n display_list, composited_updates):\n # ...\n self.composited_updates = composited_updates\n```", "```py\nclass Tab:\n def run_animation_frame(self, scroll):\n # ...\n needs_composite = self.needs_style or self.needs_layout\n\n self.render()\n\n composited_updates = None\n if not needs_composite:\n composited_updates = {}\n for node in self.composited_updates:\n composited_updates[node] = node.blend_op\n self.composited_updates = []\n\n commit_data = CommitData(\n # ...\n composited_updates,\n )\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.needs_composite = False\n self.needs_raster = False\n self.needs_draw = False\n\n def set_needs_raster(self):\n self.needs_raster = True\n self.needs_draw = True\n\n def set_needs_composite(self):\n self.needs_composite = True\n self.needs_raster = True\n self.needs_draw = True\n\n def composite_raster_and_draw(self):\n if not self.needs_composite and \\\n not self.needs_raster and \\\n not self.needs_draw:\n self.lock.release()\n return\n\n if self.needs_composite:\n self.composite()\n if self.needs_raster:\n self.raster_chrome()\n self.raster_tab()\n if self.needs_draw:\n self.draw()\n```", "```py\nclass Browser:\n def handle_down(self):\n # ...\n self.set_needs_raster()\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.composited_updates = {}\n\n def commit(self, tab, data):\n # ...\n if tab == self.active_tab:\n # ...\n self.composited_updates = data.composited_updates\n if self.composited_updates == None:\n self.composited_updates = {}\n self.set_needs_composite()\n else:\n self.set_needs_draw()\n```", "```py\nclass Browser:\n def get_latest(self, effect):\n node = effect.node\n if node not in self.composited_updates:\n return effect\n if not isinstance(effect, Blend):\n return effect\n return self.composited_updates[node]\n```", "```py\nclass Browser:\n def paint_draw_list(self):\n for composited_layer in self.composited_layers:\n while parent:\n new_parent = self.get_latest(parent)\n # ...\n```", "```py\nclass Browser:\n def clear_data(self):\n self.active_tab_scroll = 0\n self.active_tab_url = None\n self.display_list = []\n self.composited_layers = []\n self.composited_updates = {}\n\n def set_active_tab(self, tab):\n # ...\n self.clear_data()\n```", "```py\nclass CompositedLayer:\n def add(self, display_item):\n self.display_items.append(display_item)\n```", "```py\nclass CompositedLayer:\n def can_merge(self, display_item):\n return display_item.parent == \\\n self.display_items[0].parent\n```", "```py\nclass Browser:\n def composite(self):\n for cmd in paint_commands:\n for layer in reversed(self.composited_layers):\n if layer.can_merge(cmd):\n layer.add(cmd)\n break\n else:\n # ...\n```", "```py\nclass VisualEffect:\n def __init__(self, rect, children):\n self.needs_compositing = False\n```", "```py\nclass Blend(VisualEffect):\n def __init__(self, opacity, blend_mode, node, children):\n # ...\n if self.should_save:\n self.needs_compositing = True\n```", "```py\nclass VisualEffect:\n def __init__(self, rect, children, node=None):\n # ...\n self.needs_compositing = any([\n child.needs_compositing for child in self.children\n ])\n```", "```py\nclass Browser:\n def composite(self):\n # ...\n non_composited_commands = [cmd\n for cmd in all_commands\n if isinstance(cmd, PaintCommand) or \\\n not cmd.needs_compositing\n if not cmd.parent or cmd.parent.needs_compositing\n ]\n # ...\n for cmd in non_composited_commands:\n # ...\n```", "```py\nclass CompositedLayer:\n def raster(self):\n # ...\n if SHOW_COMPOSITED_LAYER_BORDERS:\n border_rect = skia.Rect.MakeXYWH(\n 1, 1, irect.width() - 2, irect.height() - 2)\n DrawOutline(border_rect, \"red\", 1).execute(canvas)\n```", "```py\nclass Browser:\n def composite(self):\n # ...\n for cmd in non_composited_commands:\n for layer in reversed(self.composited_layers):\n if layer.can_merge(cmd):\n # ...\n elif skia.Rect.Intersects(\n layer.composited_bounds(),\n cmd.rect):\n layer = CompositedLayer(self.skia_context, cmd)\n self.composited_layers.append(layer)\n break\n```", "```py\n<div style=\"background-color:lightblue;\n transform:translate(50px, 50px)\">Underneath</div>\n<div style=\"background-color:lightgreen;\n transform:translate(0px, 0px)\">On top</div>\n```", "```py\ndef parse_transform(transform_str):\n if transform_str.find('translate(') < 0:\n return None\n left_paren = transform_str.find('(')\n right_paren = transform_str.find(')')\n (x_px, y_px) = \\\n transform_str[left_paren + 1:right_paren].split(\",\")\n return (float(x_px[:-2]), float(y_px[:-2]))\n```", "```py\ndef paint_visual_effects(node, cmds, rect):\n translation = parse_transform(\n node.style.get(\"transform\", \"\"))\n # ...\n return [Transform(translation, rect, node, [blend_op])]\n```", "```py\nclass Transform(VisualEffect):\n def __init__(self, translation, rect, node, children):\n super().__init__(rect, children, node)\n self.self_rect = rect\n self.translation = translation\n\n def execute(self, canvas):\n if self.translation:\n (x, y) = self.translation\n canvas.save()\n canvas.translate(x, y)\n for cmd in self.children:\n cmd.execute(canvas)\n if self.translation:\n canvas.restore()\n\n def clone(self, child):\n return Transform(self.translation, self.self_rect,\n self.node, [child])\n\n def __repr__(self):\n if self.translation:\n (x, y) = self.translation\n return \"Transform(translate({}, {}))\".format(x, y)\n else:\n return \"Transform(<no-op>)\"\n```", "```py\ndef map_translation(rect, translation):\n if not translation:\n return rect\n else:\n (x, y) = translation\n matrix = skia.Matrix()\n matrix.setTranslate(x, y)\n return matrix.mapRect(rect)\n\ndef absolute_bounds_for_obj(obj):\n rect = skia.Rect.MakeXYWH(\n obj.x, obj.y, obj.width, obj.height)\n cur = obj.node\n while cur:\n rect = map_translation(rect,\n parse_transform(\n cur.style.get(\"transform\", \"\")))\n cur = cur.parent\n return rect\n```", "```py\nclass Tab:\n # ...\n def click(self, x, y):\n # ...\n loc_rect = skia.Rect.MakeXYWH(x, y, 1, 1)\n objs = [obj for obj in tree_to_list(self.document, [])\n if absolute_bounds_for_obj(obj).intersects(\n loc_rect)] \n```", "```py\nclass Browser:\n def composite(self):\n for cmd in non_composited_commands:\n for layer in reversed(self.composited_layers):\n if layer.can_merge(cmd):\n # ...\n elif skia.Rect.Intersects(\n layer.absolute_bounds(),\n local_to_absolute(cmd, cmd.rect)):\n # ...\n```", "```py\nclass CompositedLayer:\n def absolute_bounds(self):\n rect = skia.Rect.MakeEmpty()\n for item in self.display_items:\n rect.join(local_to_absolute(item, item.rect))\n return rect\n```", "```py\nclass Transform(VisualEffect):\n def map(self, rect):\n return map_translation(rect, self.translation)\n```", "```py\nclass Blend(VisualEffect):\n def map(self, rect):\n if self.children and \\\n isinstance(self.children[-1], Blend) and \\\n self.children[-1].blend_mode == \"destination-in\":\n bounds = rect.makeOffset(0.0, 0.0)\n bounds.intersect(self.children[-1].rect)\n return bounds\n else:\n return rect\n```", "```py\ndef local_to_absolute(display_item, rect):\n while display_item.parent:\n rect = display_item.parent.map(rect)\n display_item = display_item.parent\n return rect\n```", "```py\nclass CompositedLayer:\n def composited_bounds(self):\n rect = skia.Rect.MakeEmpty()\n for item in self.display_items:\n rect.join(absolute_to_local(\n item, local_to_absolute(item, item.rect)))\n rect.outset(1, 1)\n return rect\n```", "```py\ndef absolute_to_local(display_item, rect):\n parent_chain = []\n while display_item.parent:\n parent_chain.append(display_item.parent)\n display_item = display_item.parent\n for parent in reversed(parent_chain):\n rect = parent.unmap(rect)\n return rect\n```", "```py\ndef map_translation(rect, translation, reversed=False):\n # ...\n else:\n # ...\n if reversed:\n matrix.setTranslate(-x, -y)\n else:\n matrix.setTranslate(x, y)\n\nclass Transform(VisualEffect):\n def unmap(self, rect):\n return map_translation(rect, self.translation, True)\n```", "```py\ndef mainloop(browser):\n # ...\n ctrl_down = False\n while True:\n if sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:\n elif event.type == sdl2.SDL_KEYDOWN:\n # ...\n elif event.key.keysym.sym == sdl2.SDLK_RCTRL or \\\n event.key.keysym.sym == sdl2.SDLK_LCTRL:\n ctrl_down = True \n elif event.type == sdl2.SDL_KEYUP:\n if event.key.keysym.sym == sdl2.SDLK_RCTRL or \\\n event.key.keysym.sym == sdl2.SDLK_LCTRL:\n ctrl_down = False\n # ...\n```", "```py\ndef mainloop(browser):\n while True:\n if sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:\n elif event.type == sdl2.SDL_KEYDOWN:\n if ctrl_down:\n if event.key.keysym.sym == sdl2.SDLK_EQUALS:\n browser.increment_zoom(True)\n elif event.key.keysym.sym == sdl2.SDLK_MINUS:\n browser.increment_zoom(False)\n elif event.key.keysym.sym == sdl2.SDLK_0:\n browser.reset_zoom()\n # ...\n```", "```py\nclass Browser:\n # ...\n def increment_zoom(self, increment):\n task = Task(self.active_tab.zoom_by, increment)\n self.active_tab.task_runner.schedule_task(task)\n\n def reset_zoom(self):\n task = Task(self.active_tab.reset_zoom)\n self.active_tab.task_runner.schedule_task(task)\n```", "```py\nclass Tab:\n def __init__(self, browser, tab_height):\n # ...\n self.zoom = 1\n\n def zoom_by(self, increment):\n if increment:\n self.zoom *= 1.1\n self.scroll *= 1.1\n else:\n self.zoom *= 1/1.1\n self.scroll *= 1/1.1\n self.scroll_changed_in_tab = True\n self.set_needs_render()\n\n def reset_zoom(self):\n self.scroll /= self.zoom\n self.zoom = 1\n self.scroll_changed_in_tab = True\n self.set_needs_render()\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n self.zoom = 1\n # ...\n```", "```py\nclass DocumentLayout:\n def layout(self, zoom):\n self.zoom = zoom\n child = BlockLayout(self.node, self, None)\n # ...\n```", "```py\nclass Tab:\n def render(self):\n if self.needs_layout:\n # ...\n self.document.layout(self.zoom)\n # ...\n```", "```py\nclass BlockLayout:\n def layout(self):\n self.zoom = self.parent.zoom\n # ...\n```", "```py\ndef dpx(css_px, zoom):\n return css_px * zoom\n```", "```py\nclass BlockLayout:\n def word(self, node, word):\n # ...\n px_size = float(node.style[\"font-size\"][:-2])\n size = dpx(px_size * 0.75, self.zoom)\n # ...\n\n def input(self, node):\n # ...\n px_size = float(node.style[\"font-size\"][:-2])\n size = dpx(px_size * 0.75, self.zoom)\n # ...\n```", "```py\nclass InputLayout:\n def layout(self):\n # ...\n px_size = float(self.node.style[\"font-size\"][:-2])\n size = dpx(px_size * 0.75, self.zoom)\n # ...\n```", "```py\nclass TextLayout:\n # ...\n def layout(self):\n # ...\n px_size = float(self.node.style[\"font-size\"][:-2])\n size = dpx(px_size * 0.75, self.zoom)\n```", "```py\nclass BlockLayout:\n # ...\n def input(self, node):\n w = dpx(INPUT_WIDTH_PX, self.zoom) \n```", "```py\nclass DocumentLayout:\n def layout(self, zoom):\n # ...\n self.width = WIDTH - 2 * dpx(HSTEP, self.zoom)\n self.x = dpx(HSTEP, self.zoom)\n self.y = dpx(VSTEP, self.zoom)\n child.layout()\n self.height = child.height\n```", "```py\ndef mainloop(browser):\n while True:\n if sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:\n elif event.type == sdl2.SDL_KEYDOWN:\n if ctrl_down:\n # ...\n elif event.key.keysym.sym == sdl2.SDLK_d:\n browser.toggle_dark_mode()\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.dark_mode = False\n\n def toggle_dark_mode(self):\n self.dark_mode = not self.dark_mode\n```", "```py\nclass Browser:\n def raster_chrome(self):\n if self.dark_mode:\n background_color = skia.ColorBLACK\n else:\n background_color = skia.ColorWHITE\n canvas.clear(background_color)\n # ...\n```", "```py\nclass Chrome:\n def paint(self):\n if self.browser.dark_mode:\n color = \"white\"\n else:\n color = \"black\"\n```", "```py\nclass Browser:\n # ...\n def toggle_dark_mode(self):\n # ...\n self.dark_mode = not self.dark_mode\n task = Task(self.active_tab.set_dark_mode, self.dark_mode)\n self.active_tab.task_runner.schedule_task(task)\n```", "```py\nclass Tab:\n def __init__(self, browser, tab_height):\n # ...\n self.dark_mode = browser.dark_mode\n\n def set_dark_mode(self, val):\n self.dark_mode = val\n self.set_needs_render()\n```", "```py\nclass Browser:\n def set_active_tab(self, tab):\n # ...\n task = Task(self.active_tab.set_dark_mode, self.dark_mode)\n self.active_tab.task_runner.schedule_task(task)\n```", "```py\nclass Tab:\n # ...\n def render(self):\n if self.needs_style:\n if self.dark_mode:\n INHERITED_PROPERTIES[\"color\"] = \"white\"\n else:\n INHERITED_PROPERTIES[\"color\"] = \"black\"\n style(self.nodes,\n sorted(self.rules, key=cascade_priority))\n```", "```py\nclass Browser:\n # ...\n def draw(self):\n # ...\n if self.dark_mode:\n canvas.clear(skia.ColorBLACK)\n else:\n canvas.clear(skia.ColorWHITE)\n```", "```py\n@media (prefers-color-scheme: dark) {\n div { background-color: black; color: white; }\n}\n```", "```py\n@media (prefers-color-scheme: dark) {\n a { color: lightblue; }\n input { background-color: #2222FF; }\n button { background-color: #992500; }\n}\n```", "```py\nclass CSSParser:\n def media_query(self):\n self.literal(\"@\")\n assert self.word() == \"media\"\n self.whitespace()\n self.literal(\"(\")\n self.whitespace()\n prop, val = self.pair([\")\"])\n self.whitespace()\n self.literal(\")\")\n return prop, val\n```", "```py\nclass CSSParser:\n def parse(self):\n # ...\n media = None\n self.whitespace()\n while self.i < len(self.s):\n try:\n if self.s[self.i] == \"@\" and not media:\n prop, val = self.media_query()\n if prop == \"prefers-color-scheme\" and \\\n val in [\"dark\", \"light\"]:\n media = val\n self.whitespace()\n self.literal(\"{\")\n self.whitespace()\n elif self.s[self.i] == \"}\" and media:\n self.literal(\"}\")\n media = None\n self.whitespace()\n else:\n # ...\n rules.append((media, selector, body))\n```", "```py\ndef style(node, rules, tab):\n # ...\n for media, selector, body in rules:\n if media:\n if (media == \"dark\") != tab.dark_mode: continue\n # ...\n```", "```py\ndef mainloop(browser):\n while True:\n if sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:\n elif event.type == sdl2.SDL_KEYDOWN:\n if ctrl_down:\n # ...\n elif event.key.keysym.sym == sdl2.SDLK_LEFT:\n browser.go_back()\n elif event.key.keysym.sym == sdl2.SDLK_l:\n browser.focus_addressbar()\n elif event.key.keysym.sym == sdl2.SDLK_t:\n browser.new_tab(\n \"https://browser.engineering/\")\n elif event.key.keysym.sym == sdl2.SDLK_TAB:\n browser.cycle_tabs()\n elif event.key.keysym.sym == sdl2.SDLK_q:\n browser.handle_quit()\n sdl2.SDL_Quit()\n sys.exit()\n break\n```", "```py\nclass Chrome:\n def focus_addressbar(self):\n self.focus = \"address bar\"\n self.address_bar = \"\"\n\nclass Browser:\n def focus_addressbar(self):\n self.lock.acquire(blocking=True)\n self.chrome.focus_addressbar()\n self.set_needs_raster()\n self.lock.release()\n\n def cycle_tabs(self):\n self.lock.acquire(blocking=True)\n active_idx = self.tabs.index(self.active_tab)\n new_active_idx = (active_idx + 1) % len(self.tabs)\n self.set_active_tab(self.tabs[new_active_idx])\n self.lock.release()\n```", "```py\ndef mainloop(browser):\n while True:\n if sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:\n elif event.type == sdl2.SDL_KEYDOWN:\n # ...\n elif event.key.keysym.sym == sdl2.SDLK_RETURN:\n browser.handle_enter()\n elif event.key.keysym.sym == sdl2.SDLK_TAB:\n browser.handle_tab()\n```", "```py\nclass Browser:\n def handle_tab(self):\n self.focus = \"content\"\n task = Task(self.active_tab.advance_tab)\n self.active_tab.task_runner.schedule_task(task)\n\n def handle_enter(self):\n # ...\n elif self.focus == \"content\":\n task = Task(self.active_tab.enter)\n self.active_tab.task_runner.schedule_task(task)\n # ...\n```", "```py\ndef is_focusable(node):\n return node.tag in [\"input\", \"button\", \"a\"]\n\nclass Tab:\n def advance_tab(self):\n focusable_nodes = [node\n for node in tree_to_list(self.nodes, [])\n if isinstance(node, Element) and is_focusable(node)]\n```", "```py\nclass Tab:\n def advance_tab(self):\n # ...\n if self.focus in focusable_nodes:\n idx = focusable_nodes.index(self.focus) + 1\n else:\n idx = 0\n```", "```py\nclass Tab:\n def advance_tab(self):\n if idx < len(focusable_nodes):\n self.focus = focusable_nodes[idx]\n else:\n self.focus = None\n self.browser.focus_addressbar()\n self.set_needs_render()\n```", "```py\nclass Tab:\n def enter(self):\n if not self.focus: return\n self.activate_element(self.focus)\n```", "```py\nclass Tab:\n def activate_element(self, elt):\n if elt.tag == \"input\":\n elt.attributes[\"value\"] = \"\"\n self.set_needs_render()\n elif elt.tag == \"a\" and \"href\" in elt.attributes:\n url = self.url.resolve(elt.attributes[\"href\"])\n self.load(url)\n elif elt.tag == \"button\":\n while elt:\n if elt.tag == \"form\" and \"action\" in elt.attributes:\n self.submit_form(elt)\n elt = elt.parent\n```", "```py\nclass Tab:\n def click(self, x, y):\n while elt:\n if isinstance(elt, Text):\n pass\n elif is_focusable(elt):\n self.focus_element(elt)\n self.activate_element(elt)\n return\n elt = elt.parent\n```", "```py\nclass Tab:\n def keypress(self, char):\n if self.focus and self.focus.tag == \"input\":\n if not \"value\" in self.focus.attributes:\n self.activate_element(self.focus)\n # ...\n```", "```py\nclass InputLayout:\n def paint(self):\n # ...\n if self.node.is_focused and self.node.tag == \"input\":\n # ...\n # ...\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n self.focus = None\n # ...\n```", "```py\ndef get_tabindex(node):\n tabindex = int(node.attributes.get(\"tabindex\", \"9999999\"))\n return 9999999 if tabindex == 0 else tabindex\n```", "```py\nclass Tab:\n def advance_tab(self):\n focusable_nodes = [node\n for node in tree_to_list(self.nodes, [])\n if isinstance(node, Element) and is_focusable(node)]\n focusable_nodes.sort(key=get_tabindex)\n # ...\n```", "```py\ndef is_focusable(node):\n if get_tabindex(node) < 0:\n return False\n elif \"tabindex\" in node.attributes:\n return True\n else:\n return node.tag in [\"input\", \"button\", \"a\"]\n```", "```py\n[<a tabindex=\"1\" href=\"/\">,\n <button tabindex=\"2\">,\n <div tabindex=\"3\">,\n <div tabindex=\"12\">,\n <input>,\n <a href=\"http://browser.engineering\">]\n```", "```py\nclass Tab:\n def enter(self):\n if not self.focus: return\n if self.js.dispatch_event(\"click\", self.focus): return\n self.activate_element(self.focus)\n```", "```py\ndef paint_outline(node, cmds, rect, zoom):\n if not node.is_focused: return\n cmds.append(DrawOutline(rect, \"black\", 1))\n```", "```py\nclass Tab:\n def focus_element(self, node):\n if self.focus:\n self.focus.is_focused = False\n self.focus = node\n if node:\n node.is_focused = True\n```", "```py\nclass InputLayout:\n def paint_effects(self, cmds):\n cmds = paint_visual_effects(self.node, cmds, self.self_rect())\n paint_outline(self.node, cmds, self.self_rect(), self.zoom)\n return cmds\n```", "```py\nclass LineLayout:\n def paint_effects(self, cmds):\n outline_rect = skia.Rect.MakeEmpty()\n outline_node = None\n for child in self.children:\n if child.node.parent.is_focused:\n outline_rect.join(child.self_rect())\n outline_node = child.node.parent\n if outline_node:\n paint_outline(\n outline_node, cmds, outline_rect, self.zoom)\n return cmds\n```", "```py\nclass Tab:\n def __init__(self, browser, tab_height):\n # ...\n self.needs_focus_scroll = False\n\n def focus_element(self, node):\n if node and node != self.focus:\n self.needs_focus_scroll = True\n```", "```py\nclass Tab:\n def run_animation_frame(self, scroll):\n # ...\n if self.needs_focus_scroll and self.focus:\n self.scroll_to(self.focus)\n self.needs_focus_scroll = False\n # ...\n```", "```py\nclass Tab:\n def scroll_to(self, elt):\n objs = [\n obj for obj in tree_to_list(self.document, [])\n if obj.node == self.focus\n ]\n if not objs: return\n obj = objs[0]\n```", "```py\nclass Tab:\n def scroll_to(self, elt):\n # ...\n\n if self.scroll < obj.y < self.scroll + self.tab_height:\n return\n\n document_height = math.ceil(self.document.height + 2*VSTEP)\n new_scroll = obj.y - SCROLL_STEP\n self.scroll = self.clamp_scroll(new_scroll)\n self.scroll_changed_in_tab = True\n```", "```py\ndiv:focus { ... }\n```", "```py\nclass CSSParser:\n def selector(self):\n out = self.simple_selector()\n # ...\n while self.i < len(self.s) and self.s[self.i] != \"{\":\n descendant = self.simple_selector()\n # ...\n```", "```py\nclass CSSParser:\n def simple_selector(self):\n out = TagSelector(self.word().casefold())\n if self.i < len(self.s) and self.s[self.i] == \":\":\n self.literal(\":\")\n pseudoclass = self.word().casefold()\n out = PseudoclassSelector(pseudoclass, out)\n return out\n```", "```py\nclass PseudoclassSelector:\n def __init__(self, pseudoclass, base):\n self.pseudoclass = pseudoclass\n self.base = base\n self.priority = self.base.priority\n```", "```py\nclass PseudoclassSelector:\n def matches(self, node):\n if not self.base.matches(node):\n return False\n if self.pseudoclass == \"focus\":\n return node.is_focused\n else:\n return False\n```", "```py\noutline: 3px solid red;\n```", "```py\ndef parse_outline(outline_str):\n if not outline_str: return None\n values = outline_str.split(\" \")\n if len(values) != 3: return None\n if values[1] != \"solid\": return None\n return int(values[0][:-2]), values[2]\n```", "```py\ndef paint_outline(node, cmds, rect, zoom):\n outline = parse_outline(node.style.get(\"outline\"))\n if not outline: return\n thickness, color = outline\n cmds.append(DrawOutline(rect, color, dpx(thickness, zoom)))\n```", "```py\ninput:focus { outline: 2px solid black; }\nbutton:focus { outline: 2px solid black; }\ndiv:focus { outline: 2px solid black; }\n```", "```py\n@media (prefers-color-scheme: dark) {\ninput:focus { outline: 2px solid white; }\nbutton:focus { outline: 2px solid white; }\ndiv:focus { outline: 2px solid white; }\na:focus { outline: 2px solid white; }\n}\n```", "```py\nclass LineLayout:\n def paint_effects(self, cmds):\n # ...\n for child in self.children:\n outline_str = child.node.parent.style.get(\"outline\")\n if parse_outline(outline_str):\n outline_rect.join(child.self_rect())\n outline_node = child.node.parent\n```", "```py\nclass Tab:\n def __init__(self, browser, tab_height):\n # ...\n self.needs_accessibility = False\n self.accessibility_tree = None\n\n def render(self):\n # ...\n if self.needs_layout:\n # ...\n self.needs_accessibility = True\n self.needs_paint = True\n self.needs_layout = False\n\n if self.needs_accessibility:\n self.accessibility_tree = AccessibilityNode(self.nodes)\n self.accessibility_tree.build()\n self.needs_accessibility = False\n```", "```py\nclass AccessibilityNode:\n def __init__(self, node):\n self.node = node\n self.children = []\n```", "```py\nclass AccessibilityNode:\n def __init__(self, node):\n # ...\n if isinstance(node, Text):\n if is_focusable(node.parent):\n self.role = \"focusable text\"\n else:\n self.role = \"StaticText\"\n else:\n if \"role\" in node.attributes:\n self.role = node.attributes[\"role\"]\n elif node.tag == \"a\":\n self.role = \"link\"\n elif node.tag == \"input\":\n self.role = \"textbox\"\n elif node.tag == \"button\":\n self.role = \"button\"\n elif node.tag == \"html\":\n self.role = \"document\"\n elif is_focusable(node):\n self.role = \"focusable\"\n else:\n self.role = \"none\"\n```", "```py\nclass AccessibilityNode:\n def build(self):\n for child_node in self.node.children:\n self.build_internal(child_node)\n\n def build_internal(self, child_node):\n child = AccessibilityNode(child_node)\n if child.role != \"none\":\n self.children.append(child)\n child.build()\n else:\n for grandchild_node in child_node.children:\n self.build_internal(grandchild_node)\n```", "```py\n role=document\n   role=button\n     role=focusable text\n   role=StaticText\n   role=textbox\n   role=StaticText\n   role=link\n     role=focusable text\n   role=StaticText\n   role=textbox\n     role=StaticText\n   role=focusable\n     role=focusable text\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=StaticText\n   role=focusable\n     role=focusable text\n   role=link\n     role=focusable text\n```", "```py\nclass CommitData:\n def __init__(self, url, scroll, height, display_list,\n composited_updates, accessibility_tree):\n # ...\n self.accessibility_tree = accessibility_tree\n```", "```py\nclass Tab:\n def run_animation_frame(self, scroll):\n # ...\n commit_data = CommitData(\n self.accessibility_tree,\n # ...\n # ...\n self.accessibility_tree = None\n\nclass Browser:\n def commit(self, tab, data):\n # ...\n self.accessibility_tree = data.accessibility_tree\n\n def clear_data(self):\n # ...\n self.accessibility_tree = None\n```", "```py\npython3 -m pip install gtts\npython3 -m pip install playsound\n```", "```py\nimport os\nimport gtts\nimport playsound\n\nSPEECH_FILE = \"/tmp/speech-fragment.mp3\"\n\ndef speak_text(text):\n print(\"SPEAK:\", text)\n tts = gtts.gTTS(text)\n tts.save(SPEECH_FILE)\n playsound.playsound(SPEECH_FILE)\n os.remove(SPEECH_FILE)\n```", "```py\ndef mainloop(browser):\n while True:\n if sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:\n elif event.type == sdl2.SDL_KEYDOWN:\n if ctrl_down:\n # ...\n elif event.key.keysym.sym == sdl2.SDLK_a:\n browser.toggle_accessibility()\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.needs_accessibility = False\n self.accessibility_is_on = False\n\n def set_needs_accessibility(self):\n if not self.accessibility_is_on:\n return\n self.needs_accessibility = True\n self.needs_draw = True\n\n def toggle_accessibility(self):\n self.lock.acquire(blocking=True)\n self.accessibility_is_on = not self.accessibility_is_on\n self.set_needs_accessibility()\n self.lock.release()\n```", "```py\nclass Browser:\n def composite_raster_and_draw(self):\n # ...\n if self.needs_accessibility:\n self.update_accessibility()\n```", "```py\nclass AccessibilityNode:\n def __init__(self, node):\n # ...\n self.text = \"\"\n\n def build(self):\n for child_node in self.node.children:\n self.build_internal(child_node)\n\n if self.role == \"StaticText\":\n self.text = repr(self.node.text)\n elif self.role == \"focusable text\":\n self.text = \"Focusable text: \" + self.node.text\n elif self.role == \"focusable\":\n self.text = \"Focusable element\"\n elif self.role == \"textbox\":\n if \"value\" in self.node.attributes:\n value = self.node.attributes[\"value\"]\n elif self.node.tag != \"input\" and self.node.children and \\\n isinstance(self.node.children[0], Text):\n value = self.node.children[0].text\n else:\n value = \"\"\n self.text = \"Input box: \" + value\n elif self.role == \"button\":\n self.text = \"Button\"\n elif self.role == \"link\":\n self.text = \"Link\"\n elif self.role == \"alert\":\n self.text = \"Alert\"\n elif self.role == \"document\":\n self.text = \"Document\"\n\n if self.node.is_focused:\n self.text += \" is focused\"\n```", "```py\n role=document text=Document\n   role=button text=Button\n     role=focusable text text=Focusable text: This is a button\n   role=StaticText text='\\nThis is an input element: '\n   role=textbox text=Input box: \n   role=StaticText text=' and\\n'\n   role=link text=Link\n     role=focusable text text=Focusable text: this is a link.\n   role=StaticText text='Not focusable'\n   role=textbox text=Input box: custom contents\n     role=StaticText text='custom contents'\n   role=focusable text=Focusable element\n     role=focusable text text=Focusable text: Tabbable element\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=StaticText text='\\n.\\n'\n   role=focusable text=Focusable element\n     role=focusable text text=Focusable text: Offscreen\n   role=link text=Link\n     role=focusable text text=Focusable text: browser.engineering\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.has_spoken_document = False\n\n def update_accessibility(self):\n if not self.accessibility_tree: return\n\n if not self.has_spoken_document:\n self.speak_document()\n self.has_spoken_document = True\n\n def speak_document(self):\n text = \"Here are the document contents: \"\n tree_list = tree_to_list(self.accessibility_tree, [])\n for accessibility_node in tree_list:\n new_text = accessibility_node.text\n if new_text:\n text += \"\\n\"  + new_text\n\n speak_text(text)\n```", "```py\nclass CommitData:\n def __init__(self, url, scroll, height, display_list,\n composited_updates, accessibility_tree, focus):\n # ...\n self.focus = focus\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.tab_focus = None\n\n def commit(self, tab, data):\n self.lock.acquire(blocking=True)\n if tab == self.active_tab:\n # ...\n self.tab_focus = data.focus\n self.lock.release()\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.last_tab_focus = None\n```", "```py\nclass Browser:\n def update_accessibility(self):\n # ...\n if self.tab_focus and \\\n self.tab_focus != self.last_tab_focus:\n nodes = [node for node in tree_to_list(\n self.accessibility_tree, [])\n if node.node == self.tab_focus]\n if nodes:\n self.focus_a11y_node = nodes[0]\n self.speak_node(\n self.focus_a11y_node, \"element focused \")\n self.last_tab_focus = self.tab_focus\n```", "```py\nclass Browser:\n def speak_node(self, node, text):\n text += node.text\n if text and node.children and \\\n node.children[0].role == \"StaticText\":\n text += \" \" + \\\n node.children[0].text\n\n if text:\n speak_text(text)\n```", "```py\nNode.prototype.setAttribute = function(attr, value) {\n return call_python(\"setAttribute\", this.handle, attr, value);\n}\n```", "```py\nclass JSContext:\n def __init__(self, tab):\n # ...\n self.interp.export_function(\"setAttribute\",\n self.setAttribute)\n # ...\n\n def setAttribute(self, handle, attr, value):\n elt = self.handle_to_node[handle]\n elt.attributes[attr] = value\n self.tab.set_needs_render()\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.active_alerts = []\n\n def update_accessibility(self):\n self.active_alerts = [\n node for node in tree_to_list(\n self.accessibility_tree, [])\n if node.role == \"alert\"\n ]\n # ...\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.spoken_alerts = []\n\n def update_accessibility(self):\n # ...\n for alert in self.active_alerts:\n if alert not in self.spoken_alerts:\n self.speak_node(alert, \"New alert\")\n self.spoken_alerts.append(alert)\n```", "```py\nclass Browser:\n def update_accessibility(self):\n # ...\n new_spoken_alerts = []\n for old_node in self.spoken_alerts:\n new_nodes = [\n node for node in tree_to_list(\n self.accessibility_tree, [])\n if node.node == old_node.node\n and node.role == \"alert\"\n ]\n if new_nodes:\n new_spoken_alerts.append(new_nodes[0])\n self.spoken_alerts = new_spoken_alerts\n # ...\n```", "```py\nclass Element:\n def __init__(self, tag, attributes, parent):\n # ...\n self.layout_object = None\n\nclass Text:\n def __init__(self, text, parent):\n # ...\n self.layout_object = None\n```", "```py\nclass BlockLayout:\n def __init__(self, node, parent, previous):\n # ...\n node.layout_object = self\n```", "```py\nclass AccessibilityNode:\n def __init__(self, node):\n # ...\n self.bounds = self.compute_bounds()\n\n def compute_bounds(self):\n if self.node.layout_object:\n return [absolute_bounds_for_obj(self.node.layout_object)]\n # ...\n```", "```py\nclass AccessibilityNode:\n def compute_bounds(self):\n # ...\n if isinstance(self.node, Text):\n return []\n inline = self.node.parent\n bounds = []\n while not inline.layout_object: inline = inline.parent\n for line in inline.layout_object.children:\n line_bounds = skia.Rect.MakeEmpty()\n for child in line.children:\n if child.node.parent == self.node:\n line_bounds.join(skia.Rect.MakeXYWH(\n child.x, child.y, child.width, child.height))\n bounds.append(line_bounds)\n return bounds\n```", "```py\ndef mainloop(browser):\n while True:\n if sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:\n # ...\n elif event.type == sdl2.SDL_MOUSEMOTION:\n browser.handle_hover(event.motion)\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.pending_hover = None\n\n def handle_hover(self, event):\n if not self.accessibility_is_on or \\\n not self.accessibility_tree:\n return\n self.pending_hover = (event.x, event.y - self.chrome.bottom)\n self.set_needs_accessibility()\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.hovered_a11y_node = None\n\n def paint_draw_list(self):\n # ...\n if self.pending_hover:\n (x, y) = self.pending_hover\n y += self.active_tab_scroll\n a11y_node = self.accessibility_tree.hit_test(x, y)\n```", "```py\nclass AccessibilityNode:\n def contains_point(self, x, y):\n for bound in self.bounds:\n if bound.contains(x, y):\n return True\n return False\n\n def hit_test(self, x, y):\n node = None\n if self.contains_point(x, y):\n node = self\n for child in self.children:\n res = child.hit_test(x, y)\n if res: node = res\n return node\n```", "```py\nclass Browser:\n def paint_draw_list(self):\n if self.pending_hover:\n # ...\n if a11y_node:\n self.hovered_a11y_node = a11y_node\n self.pending_hover = None\n```", "```py\nclass Browser:\n def paint_draw_list(self):\n # ...\n if self.hovered_a11y_node:\n for bound in self.hovered_a11y_node.bounds:\n self.draw_list.append(DrawOutline(\n bound,\n \"white\" if self.dark_mode else \"black\", 2))\n```", "```py\nclass Browser:\n def __init__(self):\n # ...\n self.needs_speak_hovered_node = False\n\n def paint_draw_list(self):\n if self.pending_hover:\n if a11y_node:\n if not self.hovered_a11y_node or \\\n a11y_node.node != self.hovered_a11y_node.node:\n self.needs_speak_hovered_node = True\n # ...\n```", "```py\nclass Browser:\n def update_accessibility(self):\n # ...\n if self.needs_speak_hovered_node:\n self.speak_node(self.hovered_a11y_node, \"Hit test \")\n self.needs_speak_hovered_node = False\n```", "```py\n<img src=\"https://browser.engineering/im/hes.jpg\">\n```", "```py\nclass URL:\n def request(self, referrer, payload=None):\n # ...\n response = s.makefile(\"b\")\n # ...\n```", "```py\nclass URL:\n def request(self, referrer, payload=None):\n # ...\n statusline = response.readline().decode(\"utf8\")\n # ...\n while True:\n line = response.readline().decode(\"utf8\")\n # ...\n # ...\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n # ...\n headers, body = url.request(self.url, payload)\n body = body.decode(\"utf8\", \"replace\")\n # ...\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n # ...\n images = [node\n for node in tree_to_list(self.nodes, [])\n if isinstance(node, Element)\n and node.tag == \"img\"]\n for img in images:\n src = img.attributes.get(\"src\", \"\")\n image_url = url.resolve(src)\n assert self.allowed_request(image_url), \\\n \"Blocked load of \" + str(image_url) + \" due to CSP\"\n header, body = image_url.request(url)\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n for img in images:\n # ...\n img.encoded_data = body\n data = skia.Data.MakeWithoutCopy(body)\n img.image = skia.Image.MakeFromEncoded(data)\n```", "```py\nBROKEN_IMAGE = skia.Image.open(\"Broken_Image.png\")\n\nclass Tab:\n def load(self, url, payload=None):\n for img in images:\n try:\n # ...\n except Exception as e:\n print(\"Image\", img.attributes.get(\"src\", \"\"),\n \"crashed\", e)\n img.image = BROKEN_IMAGE\n```", "```py\nclass DrawImage(PaintCommand):\n def __init__(self, image, rect):\n super().__init__(rect)\n self.image = image\n\n def execute(self, canvas):\n canvas.drawImageRect(self.image, self.rect)\n```", "```py\ndef parse_image_rendering(quality):\n if quality == \"high-quality\":\n return skia.FilterQuality.kHigh_FilterQuality\n elif quality == \"crisp-edges\":\n return skia.FilterQuality.kLow_FilterQuality\n else:\n return skia.FilterQuality.kMedium_FilterQuality\n\nclass DrawImage(PaintCommand):\n def __init__(self, image, rect, quality):\n # ...\n self.quality = parse_image_rendering(quality)\n\n def execute(self, canvas):\n paint = skia.Paint(\n FilterQuality=self.quality,\n )\n canvas.drawImageRect(self.image, self.rect, paint)\n```", "```py\nclass EmbedLayout:\n def __init__(self, node, parent, previous, frame):\n # ...\n\n def layout(self):\n self.zoom = self.parent.zoom\n self.font = font(self.node.style, self.zoom)\n if self.previous:\n space = self.previous.font.measureText(\" \")\n self.x = \\\n self.previous.x + space + self.previous.width\n else:\n self.x = self.parent.x\n```", "```py\nclass InputLayout(EmbedLayout):\n def __init__(self, node, parent, previous):\n super().__init__(node, parent, previous)\n\n def layout(self):\n super().layout()\n```", "```py\nclass InputLayout(EmbedLayout):\n def layout(self):\n # ...\n self.width = dpx(INPUT_WIDTH_PX, self.zoom)\n self.height = linespace(self.font)\n self.ascent = -self.height\n self.descent = 0\n\n def paint(self):\n # ...\n```", "```py\nclass ImageLayout(EmbedLayout):\n def __init__(self, node, parent, previous):\n super().__init__(node, parent, previous)\n\n def layout(self):\n super().layout()\n self.width = dpx(self.node.image.width(), self.zoom)\n self.img_height = dpx(self.node.image.height(), self.zoom)\n self.height = max(self.img_height, linespace(self.font))\n self.ascent = -self.height\n self.descent = 0\n```", "```py\nclass LineLayout:\n def layout(self):\n # ...\n max_ascent = max([-child.ascent \n for child in self.children])\n baseline = self.y + max_ascent\n\n for child in self.children:\n if isinstance(child, TextLayout):\n child.y = baseline + child.ascent / 1.25\n else:\n child.y = baseline + child.ascent\n max_descent = max([child.descent\n for child in self.children])\n self.height = max_ascent + max_descent\n\nclass TextLayout:\n def layout(self):\n # ...\n self.ascent = self.font.getMetrics().fAscent * 1.25\n self.descent = self.font.getMetrics().fDescent * 1.25\n```", "```py\nclass ImageLayout(EmbedLayout):\n def paint(self):\n cmds = []\n rect = skia.Rect.MakeLTRB(\n self.x, self.y + self.height - self.img_height,\n self.x + self.width, self.y + self.height)\n quality = self.node.style.get(\"image-rendering\", \"auto\")\n cmds.append(DrawImage(self.node.image, rect, quality))\n return cmds\n```", "```py\ndef font(style, zoom):\n weight = style[\"font-weight\"]\n variant = style[\"font-style\"]\n size = float(style[\"font-size\"][:-2]) * 0.75\n font_size = dpx(size, zoom)\n return get_font(font_size, weight, variant)\n```", "```py\nclass BlockLayout:\n def add_inline_child(self, node, w, child_class, word=None):\n if self.cursor_x + w > self.x + self.width:\n self.new_line()\n line = self.children[-1]\n previous_word = line.children[-1] if line.children else None\n if word:\n child = child_class(node, word, line, previous_word)\n else:\n child = child_class(node, line, previous_word)\n line.children.append(child)\n self.cursor_x += w + \\\n font(node.style, self.zoom).measureText(\" \")\n```", "```py\nclass BlockLayout:\n def word(self, node, word):\n node_font = font(node.style, self.zoom)\n w = node_font.measureText(word)\n self.add_inline_child(node, w, TextLayout, word)\n\n def input(self, node):\n w = dpx(INPUT_WIDTH_PX, self.zoom)\n self.add_inline_child(node, w, InputLayout) \n```", "```py\nclass BlockLayout:\n def recurse(self, node):\n # ...\n elif node.tag == \"img\":\n self.image(node)\n\n def image(self, node):\n w = dpx(node.image.width(), self.zoom)\n self.add_inline_child(node, w, ImageLayout)\n```", "```py\nclass BlockLayout:\n def layout_mode(self):\n # ...\n elif self.node.tag in [\"input\", \"img\"]:\n return \"inline\"\n\n def should_paint(self):\n return isinstance(self.node, Text) or \\\n (self.node.tag not in \\\n [\"input\", \"button\", \"img\"])\n```", "```py\n<img src=\"https://browser.engineering/im/hes.jpg\"\n alt=\"An operator using the Hypertext Editing System in 1969\">\n```", "```py\nclass AccessibilityNode:\n def __init__(self, node):\n else:\n # ...\n elif node.tag == \"img\":\n self.role = \"image\"\n\n def build(self):\n # ...\n elif self.role == \"image\":\n if \"alt\" in self.node.attributes:\n self.text = \"Image: \" + self.node.attributes[\"alt\"]\n else:\n self.text = \"Image\"\n```", "```py\nclass BlockLayout:\n def image(self, node):\n if \"width\" in node.attributes:\n w = dpx(int(node.attributes[\"width\"]), self.zoom)\n else:\n w = dpx(node.image.width(), self.zoom)\n # ...\n```", "```py\nclass ImageLayout(EmbedLayout):\n def layout(self):\n # ...\n width_attr = self.node.attributes.get(\"width\")\n height_attr = self.node.attributes.get(\"height\")\n image_width = self.node.image.width()\n image_height = self.node.image.height()\n\n if width_attr and height_attr:\n self.width = dpx(int(width_attr), self.zoom)\n self.img_height = dpx(int(height_attr), self.zoom)\n else:\n self.width = dpx(image_width, self.zoom)\n self.img_height = dpx(image_height, self.zoom)\n # ...\n```", "```py\nclass ImageLayout(EmbedLayout):\n # ...\n def layout(self):\n # ...\n aspect_ratio = image_width / image_height\n\n if width_attr and height_attr:\n # ...\n elif width_attr:\n self.width = dpx(int(width_attr), self.zoom)\n self.img_height = self.width / aspect_ratio\n elif height_attr:\n self.img_height = dpx(int(height_attr), self.zoom)\n self.width = self.img_height * aspect_ratio\n else:\n # ...\n # ...\n```", "```py\nOriginal size:  <img src=\"/im/hes.jpg\" alt=\"A computer operator ...\">\n<br>\nSmaller: <img width=50 height=50 src=\"/im/hes.jpg\">\n<br>\nDifferent aspect ratio:\n<img width=50 height=100 src=\"/im/hes.jpg\">\n<br>\nLarger:\n<img width=1000 height=1000 src=\"/im/hes.jpg\">\n<br>\nLarger with only width:\n<img width=1000 src=\"/im/hes.jpg\">\n<br>\nSmaller with only height:\n<img height=50 src=\"/im/hes.jpg\">\nBroken image:\n<img src=\"non-existent-image\">\n<script src=\"example15-img.js\"></script>\n<link rel=\"stylesheet\" href=\"example15-img.css\">\n```", "```py\nclass Frame:\n def __init__(self, tab, parent_frame, frame_element):\n self.tab = tab\n self.parent_frame = parent_frame\n self.frame_element = frame_element\n # ...\n```", "```py\nclass Tab:\n def __init__(self, browser, tab_height):\n # ...\n self.root_frame = None\n\n def load(self, url, payload=None):\n self.history.append(url)\n # ...\n self.root_frame = Frame(self, None, None)\n self.root_frame.load(url, payload)\n```", "```py\nclass Frame:\n def load(self, url, payload=None):\n # ...\n iframes = [node\n for node in tree_to_list(self.nodes, [])\n if isinstance(node, Element)\n and node.tag == \"iframe\"\n and \"src\" in node.attributes]\n for iframe in iframes:\n document_url = url.resolve(iframe.attributes[\"src\"])\n if not self.allowed_request(document_url):\n print(\"Blocked iframe\", document_url, \"due to CSP\")\n iframe.frame = None\n continue\n iframe.frame = Frame(self.tab, self, iframe)\n # ...\n```", "```py\nclass Frame:\n def load(self, url, payload=None):\n for iframe in iframes:\n # ...\n task = Task(iframe.frame.load, document_url)\n self.tab.task_runner.schedule_task(task)\n```", "```py\nclass Frame:\n def __init__(self, tab, parent_frame, frame_element):\n # ...\n self.loaded = False\n\n def load(self, url, payload=None):\n self.loaded = False\n ...\n self.loaded = True\n```", "```py\nclass Tab:\n def __init__(self, browser, tab_height):\n # ...\n self.window_id_to_frame = {}\n```", "```py\nclass Frame:\n def __init__(self, tab, parent_frame, frame_element):\n # ...\n self.window_id = len(self.tab.window_id_to_frame)\n self.tab.window_id_to_frame[self.window_id] = self\n```", "```py\nclass Tab:\n def run_animation_frame(self, scroll):\n # ...\n for (window_id, frame) in self.window_id_to_frame.items():\n if not frame.loaded:\n continue\n frame.js.dispatch_RAF(frame.window_id)\n # ...\n\n def render(self):\n self.browser.measure.time('render')\n\n for id, frame in self.window_id_to_frame.items():\n if frame.loaded:\n frame.render()\n\n if self.needs_accessibility:\n # ...\n\n if self.needs_paint:\n # ...\n\n # ...\n```", "```py\nclass JSContext:\n def dispatch_RAF(self):\n self.interp.evaljs(\"window.__runRAFHandlers()\")\n```", "```py\nclass Frame:\n def __init__(self, tab, parent_frame, frame_element):\n # ...\n self.needs_style = False\n self.needs_layout = False\n\n def set_needs_render(self):\n self.needs_style = True\n self.tab.set_needs_accessibility()\n self.tab.set_needs_paint()\n\n def set_needs_layout(self):\n self.needs_layout = True\n self.tab.set_needs_accessibility()\n self.tab.set_needs_paint()\n\n def render(self):\n if self.needs_style:\n # ...\n\n if self.needs_layout:\n # ...\n```", "```py\nclass BlockLayout:\n def layout_mode(self):\n # ...\n elif self.node.tag in [\"input\", \"img\", \"iframe\"]:\n return \"inline\"\n\n def recurse(self, node):\n else:\n # ...\n elif node.tag == \"iframe\" and \\\n \"src\" in node.attributes:\n self.iframe(node)\n # ...\n\n def iframe(self, node):\n if \"width\" in self.node.attributes:\n w = dpx(int(self.node.attributes[\"width\"]),\n self.zoom)\n else:\n w = IFRAME_WIDTH_PX + dpx(2, self.zoom)\n self.add_inline_child(node, w, IframeLayout, self.frame)\n\n def should_paint(self):\n return isinstance(self.node, Text) or \\\n (self.node.tag not in \\\n [\"input\", \"button\", \"img\", \"iframe\"])\n```", "```py\nclass IframeLayout(EmbedLayout):\n def __init__(self, node, parent, previous, parent_frame):\n super().__init__(node, parent, previous, parent_frame)\n\n def layout(self):\n # ...\n if width_attr:\n self.width = dpx(int(width_attr) + 2, self.zoom)\n else:\n self.width = dpx(IFRAME_WIDTH_PX + 2, self.zoom)\n\n if height_attr:\n self.height = dpx(int(height_attr) + 2, self.zoom)\n else:\n self.height = dpx(IFRAME_HEIGHT_PX + 2, self.zoom)\n self.ascent = -self.height\n self.descent = 0\n```", "```py\nIFRAME_WIDTH_PX = 300\nIFRAME_HEIGHT_PX = 150\n```", "```py\nclass Frame:\n def __init__(self, tab, parent_frame, frame_element):\n # ...\n self.frame_width = 0\n self.frame_height = 0\n```", "```py\nclass IframeLayout(EmbedLayout):\n def layout(self):\n # ...\n if self.node.frame and self.node.frame.loaded:\n self.node.frame.frame_height = \\\n self.height - dpx(2, self.zoom)\n self.node.frame.frame_width = \\\n self.width - dpx(2, self.zoom)\n```", "```py\nclass Tab:\n def set_needs_render_all_frames(self):\n for id, frame in self.window_id_to_frame.items():\n frame.set_needs_render()\n```", "```py\nclass Tab:\n def load(self, url, payload=None):\n # ...\n self.root_frame.frame_width = WIDTH\n self.root_frame.frame_height = self.tab_height\n```", "```py\nclass Tab:\n def render(self):\n if self.needs_paint:\n self.display_list = []\n paint_tree(self.root_frame.document, self.display_list)\n self.needs_paint = False\n```", "```py\ndef paint_tree(layout_object, display_list):\n cmds = layout_object.paint()\n\n if isinstance(layout_object, IframeLayout) and \\\n layout_object.node.frame and \\\n layout_object.node.frame.loaded:\n paint_tree(layout_object.node.frame.document, cmds)\n else:\n for child in layout_object.children:\n paint_tree(child, cmds)\n\n cmds = layout_object.paint_effects(cmds)\n display_list.extend(cmds)\n```", "```py\nclass IframeLayout(EmbedLayout):\n def paint_effects(self, cmds):\n # ...\n\n diff = dpx(1, self.zoom)\n offset = (self.x + diff, self.y + diff)\n cmds = [Transform(offset, rect, self.node, cmds)]\n inner_rect = skia.Rect.MakeLTRB(\n self.x + diff, self.y + diff,\n self.x + self.width - diff, self.y + self.height - diff)\n internal_cmds = cmds\n internal_cmds.append(Blend(1.0, \"destination-in\", None, [\n DrawRRect(inner_rect, 0, \"white\")]))\n cmds = [Blend(1.0, \"source-over\", self.node, internal_cmds)]\n paint_outline(self.node, cmds, rect, self.zoom)\n cmds = paint_visual_effects(self.node, cmds, rect)\n return cmds\n```", "```py\niframe { outline: 1px solid black; }\n```", "```py\nclass AccessibilityNode:\n def __init__(self, node):\n else:\n elif node.tag == \"iframe\":\n self.role = \"iframe\"\n```", "```py\nclass AccessibilityNode:\n def build_internal(self, child_node):\n if isinstance(child_node, Element) \\\n and child_node.tag == \"iframe\" and child_node.frame \\\n and child_node.frame.loaded:\n child = AccessibilityNode(child_node.frame.nodes)\n # ... \n```", "```py\nclass Tab:\n def click(self, x, y):\n self.render()\n self.root_frame.click(x, y)\n```", "```py\nclass Frame:\n def click(self, x, y):\n # ...\n while elt:\n # ...\n elif elt.tag == \"iframe\":\n abs_bounds = \\\n absolute_bounds_for_obj(elt.layout_object)\n border = dpx(1, elt.layout_object.zoom)\n new_x = x - abs_bounds.left() - border\n new_y = y - abs_bounds.top() - border\n elt.frame.click(new_x, new_y)\n return\n```", "```py\nclass Tab:\n def __init__(self, browser, tab_height):\n self.focus = None\n self.focused_frame = None\n```", "```py\nclass Frame:\n def focus_element(self, node):\n # ...\n if self.tab.focused_frame and self.tab.focused_frame != self:\n self.tab.focused_frame.set_needs_render()\n self.tab.focused_frame = self\n # ...\n```", "```py\nclass Tab:\n def advance_tab(self):\n frame = self.focused_frame or self.root_frame\n frame.advance_tab()\n```", "```py\nclass Frame:\n def __init__(self, tab, parent_frame, frame_element):\n self.scroll = 0\n```", "```py\nclass CommitData:\n def __init__(self, url, scroll, root_frame_focused, height,\n display_list, composited_updates, accessibility_tree, focus):\n # ...\n self.root_frame_focused = root_frame_focused\n\nclass Tab:\n def run_animation_frame(self, scroll):\n root_frame_focused = not self.focused_frame or \\\n self.focused_frame == self.root_frame\n # ...\n commit_data = CommitData(\n # ...\n root_frame_focused,\n # ...\n )\n # ...\n```", "```py\nclass Browser:\n def commit(self, tab, data):\n # ...\n self.root_frame_focused = data.root_frame_focused\n\n def handle_down(self):\n self.lock.acquire(blocking=True)\n if self.root_frame_focused:\n # ...\n task = Task(self.active_tab.scrolldown)\n self.active_tab.task_runner.schedule_task(task)\n self.lock.release()\n```", "```py\nclass Tab:\n def scrolldown(self):\n frame = self.focused_frame or self.root_frame\n frame.scrolldown()\n self.set_needs_paint()\n```", "```py\nclass Tab:\n def run_animation_frame(self, scroll):\n # ...\n for (window_id, frame) in self.window_id_to_frame.items():\n if frame == self.root_frame: continue\n if frame.scroll_changed_in_frame:\n needs_composite = True\n frame.scroll_changed_in_frame = False\n # ...\n```", "```py\nclass Frame:\n def scrolldown(self):\n self.scroll = self.clamp_scroll(self.scroll + SCROLL_STEP)\n\n def clamp_scroll(self, scroll):\n height = math.ceil(self.document.height + 2*VSTEP)\n maxscroll = height - self.frame_height\n return max(0, min(scroll, maxscroll))\n```", "```py\nclass Frame:\n def scroll_to(self, elt):\n # ...\n self.scroll = self.clamp_scroll(new_scroll)\n```", "```py\nclass FrameAccessibilityNode(AccessibilityNode):\n pass\n```", "```py\nclass AccessibilityNode:\n def build_internal(self, child_node):\n if isinstance(child_node, Element) \\\n and child_node.tag == \"iframe\" and child_node.frame \\\n and child_node.frame.loaded:\n child = FrameAccessibilityNode(child_node)\n```", "```py\nclass FrameAccessibilityNode(AccessibilityNode):\n def __init__(self, node, parent=None):\n super().__init__(node, parent)\n self.scroll = self.node.frame.scroll\n self.zoom = self.node.layout_object.zoom\n\n def hit_test(self, x, y):\n bounds = self.bounds[0]\n if not bounds.contains(x, y): return\n new_x = x - bounds.left() - dpx(1, self.zoom)\n new_y = y - bounds.top() - dpx(1, self.zoom) + self.scroll\n node = self\n for child in self.children:\n res = child.hit_test(new_x, new_y)\n if res: node = res\n return node\n```", "```py\nclass AccessibilityNode:\n def __init__(self, node, parent=None):\n # ...\n self.parent = parent\n\n def build_internal(self, child_node):\n if isinstance(child_node, Element) \\\n and child_node.tag == \"iframe\" and child_node.frame \\\n and child_node.frame.loaded:\n child = FrameAccessibilityNode(child_node, self)\n else:\n child = AccessibilityNode(child_node, self)\n # ...\n```", "```py\nclass AccessibilityNode:\n def absolute_bounds(self):\n abs_bounds = []\n for bound in self.bounds:\n abs_bound = bound.makeOffset(0.0, 0.0)\n if isinstance(self, FrameAccessibilityNode):\n obj = self.parent\n else:\n obj = self\n while obj:\n obj.map_to_parent(abs_bound)\n obj = obj.parent\n abs_bounds.append(abs_bound)\n return abs_bounds\n```", "```py\nclass AccessibilityNode:\n def map_to_parent(self, rect):\n pass\n```", "```py\nclass FrameAccessibilityNode(AccessibilityNode):\n def map_to_parent(self, rect):\n bounds = self.bounds[0]\n rect.offset(bounds.left(), bounds.top() - self.scroll)\n rect.intersect(bounds)\n```", "```py\nclass Tab:\n def __init__(self, browser, tab_height):\n # ...\n self.origin_to_js = {}\n\n def get_js(self, url):\n origin = url.origin()\n if origin not in self.origin_to_js:\n self.origin_to_js[origin] = JSContext(self, origin)\n return self.origin_to_js[origin]\n```", "```py\nclass Frame:\n def load(self, url, payload=None):\n # ...\n self.js = self.tab.get_js(url)\n # ...\n```", "```py\nwindow.console = { log: function(x) { call_python(\"log\", x); } }\n\n// ...\n\nwindow.Node = function(handle) { this.handle = handle; }\n\n// ...\n```", "```py\ndukpy.JSRuntimeError: ReferenceError: identifier 'Node'\n    undefined\n    duk_js_var.c:1258\n    eval src/pyduktape.c:1 preventsyield\n```", "```py\nEVENT_DISPATCH_JS = \\\n \"new window.Node(dukpy.handle)\" + \\\n \".dispatchEvent(new window.Event(dukpy.type))\"\n```", "```py\nclass JSContext:\n def __init__(self, tab, url_origin):\n self.url_origin = url_origin\n # ...\n self.interp.evaljs(\"function Window(id) { this._id = id };\")\n```", "```py\nclass JSContext:\n def add_window(self, frame):\n code = \"var window_{} = new Window({});\".format(\n frame.window_id, frame.window_id)\n self.interp.evaljs(code)\n\nclass Frame:\n def load(self, url, payload=None):\n # ...\n self.js = self.tab.get_js(url)\n self.js.add_window(self)\n # ...\n```", "```py\nclass JSContext:\n def wrap(self, script, window_id):\n return \"window = window_{}; {}\".format(window_id, script)\n```", "```py\nclass JSContext:\n def add_window(self, frame):\n # ...\n self.interp.evaljs(self.wrap(RUNTIME_JS, frame.window_id))\n```", "```py\nclass JSContext:\n def run(self, script, code, window_id):\n try:\n code = self.wrap(code, window_id)\n self.interp.evaljs(code)\n except dukpy.JSRuntimeError as e:\n print(\"Script\", script, \"crashed\", e)\n```", "```py\nclass Frame:\n def load(self, url, payload=None):\n for script in scripts:\n # ...\n task = Task(self.js.run, script_url, body,\n self.window_id)\n # ...\n```", "```py\nclass JSContext:\n def dispatch_event(self, type, elt, window_id):\n # ...\n code = self.wrap(EVENT_DISPATCH_JS, window_id)\n do_default = self.interp.evaljs(code,\n type=type, handle=handle)\n```", "```py\nwindow.LISTENERS = {}\n\n// ...\n\nwindow.Node.prototype.dispatchEvent = function(evt) {\n var type = evt.type;\n var handle = this.handle\n var list = (window.LISTENERS[handle] &&\n window.LISTENERS[handle][type]) || [];\n for (var i = 0; i < list.length; i++) {\n list[i].call(this, evt);\n }\n return evt.do_default;\n}\n```", "```py\nwindow.document = { querySelectorAll: function(s) {\n var handles = call_python(\"querySelectorAll\", s, window._id);\n return handles.map(function(h) { return new window.Node(h) });\n}}\n```", "```py\nclass JSContext:\n def querySelectorAll(self, selector_text, window_id):\n frame = self.tab.window_id_to_frame[window_id]\n selector = CSSParser(selector_text).selector()\n nodes = [node for node\n in tree_to_list(frame.nodes, [])\n if selector.matches(node)]\n return [self.get_handle(node) for node in nodes]\n```", "```py\nclass JSContext:\n # ...\n def parent(self, window_id):\n parent_frame = \\\n self.tab.window_id_to_frame[window_id].parent_frame\n if not parent_frame:\n return None\n return parent_frame.window_id\n```", "```py\nclass JSContext:\n def __init__(self, tab, url_origin):\n # ...\n self.interp.evaljs(\"WINDOWS = {}\")\n```", "```py\nclass JSContext:\n def add_window(self, frame):\n # ...\n self.interp.evaljs(\"WINDOWS[{}] = window_{};\".format(\n frame.window_id, frame.window_id))\n```", "```py\nObject.defineProperty(Window.prototype, 'parent', {\n configurable: true,\n get: function() {\n var parent_id = call_python('parent', window._id);\n if (parent_id != undefined) {\n var parent = WINDOWS[parent_id];\n if (parent === undefined) parent = new Window(parent_id);\n return parent;\n }\n }\n});\n```", "```py\nclass JSContext:\n def throw_if_cross_origin(self, frame):\n if frame.url.origin() != self.url_origin:\n raise Exception(\n \"Cross-origin access disallowed from script\")\n```", "```py\nclass JSContext:\n def querySelectorAll(self, selector_text, window_id):\n frame = self.tab.window_id_to_frame[window_id]\n self.throw_if_cross_origin(frame)\n # ...\n\n def setAttribute(self, handle, attr, value, window_id):\n frame = self.tab.window_id_to_frame[window_id]\n self.throw_if_cross_origin(frame)\n # ...\n\n def innerHTML_set(self, handle, s, window_id):\n frame = self.tab.window_id_to_frame[window_id]\n self.throw_if_cross_origin(frame)\n # ...\n\n def style_set(self, handle, s, window_id):\n frame = self.tab.window_id_to_frame[window_id]\n self.throw_if_cross_origin(frame)\n # ...\n```", "```py\nwindow.parent.postMessage(\"...\", '*')\n```", "```py\nwindow.addEventListener(\"message\", function(e) {\n console.log(e.data);\n});\n```", "```py\nwindow.WINDOW_LISTENERS = {}\n```", "```py\nwindow.MessageEvent = function(data) {\n this.type = \"message\";\n this.data = data;\n}\n```", "```py\nWindow.prototype.addEventListener = function(type, listener) {\n // ...\n}\n\nWindow.prototype.dispatchEvent = function(evt) {\n // ...\n}\n```", "```py\nWindow.prototype.postMessage = function(message, origin) {\n call_python(\"postMessage\", this._id, message, origin)\n}\n```", "```py\nclass JSContext:\n def postMessage(self, target_window_id, message, origin):\n task = Task(self.tab.post_message,\n message, target_window_id)\n self.tab.task_runner.schedule_task(task)\n```", "```py\nclass Tab:\n def post_message(self, message, target_window_id):\n frame = self.window_id_to_frame[target_window_id]\n frame.js.dispatch_post_message(\n message, target_window_id)\n```", "```py\nPOST_MESSAGE_DISPATCH_JS = \\\n \"window.dispatchEvent(new window.MessageEvent(dukpy.data))\"\n\nclass JSContext:\n def dispatch_post_message(self, message, window_id):\n self.interp.evaljs(\n self.wrap(POST_MESSAGE_DISPATCH_JS, window_id),\n data=message)\n```", "```py\ndef is_focusable(node):\n # ...\n elif \"contenteditable\" in node.attributes:\n return True\n # ...\n```", "```py\nclass Frame:\n def keypress(self, char):\n # ...\n elif self.tab.focus and \\\n \"contenteditable\" in self.tab.focus.attributes:\n text_nodes = [\n t for t in tree_to_list(self.tab.focus, [])\n if isinstance(t, Text)\n ]\n if text_nodes:\n last_text = text_nodes[-1]\n else:\n last_text = Text(\"\", self.tab.focus)\n self.tab.focus.children.append(last_text)\n```", "```py\nclass Frame:\n def keypress(self, char):\n elif self.tab.focus and \\\n \"contenteditable\" in self.tab.focus.attributes:\n # ...\n last_text.text += char\n self.set_needs_render()\n```", "```py\nclass BlockLayout:\n def paint(self):\n # ...\n if self.node.is_focused \\\n and \"contenteditable\" in self.node.attributes:\n text_nodes = [\n t for t in tree_to_list(self, [])\n if isinstance(t, TextLayout)\n ]\n if text_nodes:\n cmds.append(DrawCursor(text_nodes[-1],\n text_nodes[-1].width))\n else:\n cmds.append(DrawCursor(self, 0))\n # ...\n```", "```py\ndef DrawCursor(elt, offset):\n x = elt.x + offset\n return DrawLine(x, elt.y, x, elt.y + elt.height, \"red\", 1)\n```", "```py\nclass InputLayout(EmbedLayout):\n def paint(self):\n if self.node.is_focused and self.node.tag == \"input\":\n cmds.append(DrawCursor(self, self.font.measureText(text)))\n```", "```py\nclass Frame:\n def render(self):\n if self.needs_layout:\n self.document = DocumentLayout(self.nodes, self)\n self.document.layout(self.frame_width, self.tab.zoom)\n # ...\n```", "```py\nclass Frame:\n def load(self, url, payload=None):\n # ...\n self.document = DocumentLayout(self.nodes, self)\n self.set_needs_render()\n\n def render(self):\n if self.needs_layout:\n self.document.layout(self.frame_width, self.tab.zoom)\n # ...\n```", "```py\nclass DocumentLayout:\n def layout(self, width, zoom):\n child = BlockLayout(self.node, self, None, self.frame)\n # ...\n```", "```py\nclass DocumentLayout:\n def layout(self, width, zoom):\n if not self.children:\n child = BlockLayout(self.node, self, None, self.frame)\n else:\n child = self.children[0]\n # ...\n```", "```py\nclass DocumentLayout:\n def layout(self, width, zoom):\n # ...\n self.children.append(child)\n # ...\n```", "```py\nclass DocumentLayout:\n def layout(self, width, zoom):\n # ...\n self.children = [child]\n # ...\n```", "```py\nclass BlockLayout:\n def layout(self):\n if mode == \"block\":\n self.children = []\n # ...\n else:\n self.children = []\n # ...\n```", "```py\nclass BlockLayout:\n def layout(self):\n self.children = []\n # ...\n if mode == \"block\":\n previous = None\n for child in self.node.children:\n next = BlockLayout(child, self, previous, self.frame)\n self.children.append(next)\n previous = next\n # ...\n```", "```py\nclass BlockLayout:\n def __init__(self, node, parent, previous, frame):\n # ...\n self.children_dirty = True\n```", "```py\nclass JSContext:\n def innerHTML_set(self, handle, s, window_id):\n # ...\n obj = elt.layout_object\n while not isinstance(obj, BlockLayout):\n obj = obj.parent\n obj.children_dirty = True\n```", "```py\nclass Frame:\n def keypress(self, char):\n elif self.tab.focus and \\\n \"contenteditable\" in self.tab.focus.attributes:\n # ...\n obj = self.tab.focus.layout_object\n while not isinstance(obj, BlockLayout):\n obj = obj.parent\n obj.children_dirty = True\n```", "```py\nclass BlockLayout:\n def layout(self):\n # ...\n\n assert not self.children_dirty\n for child in self.children:\n child.layout()\n\n assert not self.children_dirty\n self.height = sum([child.height for child in self.children])\n\n def paint(self, display_list):\n assert not self.children_dirty\n # ...\n```", "```py\nclass BlockLayout:\n def layout(self):\n if mode == \"block\":\n # ...\n self.children_dirty = False\n else:\n # ...\n self.children_dirty = False\n```", "```py\nclass BlockLayout:\n def layout(self):\n if mode == \"block\":\n if self.children_dirty:\n # ...\n self.children_dirty = False\n```", "```py\nclass ProtectedField:\n def __init__(self):\n self.value = None\n self.dirty = True\n```", "```py\nclass BlockLayout:\n def __init__(self, node, parent, previous, frame):\n # ...\n self.children = ProtectedField()\n # ...\n```", "```py\nclass ProtectedField:\n def mark(self):\n if self.dirty: return\n self.dirty = True\n```", "```py\nclass JSContext:\n def innerHTML_set(self, handle, s, window_id):\n # ...\n obj.children.mark()\n\nclass Frame:\n def keypress(self, char):\n elif self.tab.focus and \\\n \"contenteditable\" in self.tab.focus.attributes:\n # ...\n obj.children.mark()\n```", "```py\nclass ProtectedField:\n def get(self):\n assert not self.dirty\n return self.value\n```", "```py\nclass BlockLayout:\n def layout(self):\n # ...\n for child in self.children.get():\n child.layout()\n\n self.height = \\\n sum([child.height for child in self.children.get()])\n```", "```py\nclass ProtectedField:\n def set(self, value):\n self.value = value\n self.dirty = False\n```", "```py\nclass BlockLayout:\n def layout(self):\n if mode == \"block\":\n if self.children.dirty:\n children = []\n previous = None\n for child in self.node.children:\n next = BlockLayout(\n child, self, previous, self.frame)\n children.append(next)\n previous = next\n self.children.set(children)\n```", "```py\nclass BlockLayout:\n def layout(self):\n if mode == \"block\":\n # ...\n else:\n self.children = []\n self.new_line()\n self.recurse(self.node)\n```", "```py\nclass DocumentLayout:\n def __init__(self, node, frame):\n # ...\n self.zoom = ProtectedField()\n # ...\n\n def layout(self, width, zoom):\n # ...\n self.zoom.set(zoom)\n # ...\n```", "```py\nclass BlockLayout:\n def __init__(self, node, parent, previous, frame):\n # ...\n self.zoom = ProtectedField()\n # ...\n```", "```py\nclass BlockLayout:\n def layout(self):\n parent_zoom = self.parent.zoom.get()\n self.zoom.set(parent_zoom)\n # ...\n```", "```py\nclass DocumentLayout:\n def layout(self, width, zoom):\n # ...\n self.zoom.set(zoom)\n child.zoom.mark()\n # ...\n```", "```py\nclass BlockLayout:\n def layout(self):\n # ...\n for child in self.children.get():\n child.zoom.mark()\n```", "```py\nclass ProtectedField:\n def __init__(self):\n # ...\n self.invalidations = set()\n```", "```py\nclass BlockLayout:\n def __init__(self, node, parent, previous, frame):\n # ...\n self.parent.zoom.invalidations.add(self.zoom)\n```", "```py\nclass ProtectedField:\n def notify(self):\n for field in self.invalidations:\n field.mark()\n```", "```py\nclass ProtectedField:\n def set(self, value):\n self.notify()\n self.value = value\n self.dirty = False\n```", "```py\nclass ProtectedField:\n def read(self, notify):\n self.invalidations.add(notify)\n return self.get()\n```", "```py\nclass BlockLayout:\n def layout(self):\n parent_zoom = self.parent.zoom.read(notify=self.zoom)\n self.zoom.set(parent_zoom)\n```", "```py\nclass ProtectedField:\n def copy(self, field):\n self.set(field.read(notify=self))\n\nclass BlockLayout:\n def layout(self):\n self.zoom.copy(self.parent.zoom)\n # ...\n```", "```py\nclass BlockLayout:\n def input(self, node):\n zoom = self.zoom.read(notify=self.children)\n # ...\n```", "```py\nclass DocumentLayout:\n def __init__(self, node, frame):\n # ...\n self.width = ProtectedField()\n # ...\n\n def layout(self, width, zoom):\n # ...\n self.width.set(width - 2 * dpx(HSTEP, zoom))\n # ...\n```", "```py\nclass BlockLayout:\n def __init__(self, node, parent, previous, frame):\n # ...\n self.zoom = ProtectedField()\n # ...\n\n def layout(self):\n # ...\n self.width.copy(self.parent.width)\n # ...\n```", "```py\nclass BlockLayout:\n def add_inline_child(self, node, w, child_class,\n frame, word=None):\n width = self.width.read(notify=self.children)\n if self.cursor_x + w > width:\n self.new_line()\n # ...\n```", "```py\nclass BlockLayout:\n def word(self, node, word):\n zoom = self.zoom.read(notify=self.children)\n node_font = font(node.style, zoom)\n w = node_font.measureText(word)\n self.add_inline_child(\n node, w, TextLayout, self.frame, word)\n```", "```py\nclass Element:\n def __init__(self, tag, attributes, parent):\n # ...\n self.style = ProtectedField()\n # ...\n\nclass Text:\n def __init__(self, text, parent):\n # ...\n self.style = ProtectedField()\n # ...\n```", "```py\ndef style(node, rules, frame):\n old_style = node.style.value\n new_style = {}\n # ...\n node.style.set(new_style)\n\n for child in node.children:\n style(child, rules, frame)\n```", "```py\ndef style(node, rules, frame):\n for property, default_value in INHERITED_PROPERTIES.items():\n if node.parent:\n parent_style = node.parent.style.read(notify=node.style)\n new_style[property] = parent_style[property]\n else:\n new_style[property] = default_value\n```", "```py\nclass JSContext:\n def style_set(self, handle, s, window_id):\n # ...\n elt.style.mark()\n```", "```py\nclass BlockLayout:\n def word(self, node, word):\n # ...\n style = self.children.read(node.style)\n node_font = font(style, zoom)\n # ...\n```", "```py\nclass BlockLayout:\n def layout(self):\n # ...\n if mode == \"block\":\n if self.children.dirty:\n # ...\n else:\n if self.children.dirty:\n # ...\n```", "```py\nclass BlockLayout:\n def layout(self):\n # ...\n if mode == \"block\":\n # ...\n else:\n if self.children.dirty:\n self.temp_children = []\n self.new_line()\n self.recurse(self.node)\n self.children.set(self.temp_children)\n self.temp_children = None\n```", "```py\nclass BlockLayout:\n def new_line(self):\n self.previous_word = None\n self.cursor_x = 0\n last_line = self.temp_children[-1] \\\n if self.temp_children else None\n new_line = LineLayout(self.node, self, last_line)\n self.temp_children.append(new_line)\n```", "```py\nclass BlockLayout:\n def add_inline_child(self, node, w, child_class,\n frame, word=None):\n # ...\n line = self.temp_children[-1]\n # ...\n```", "```py\ndef tree_to_list(tree, list):\n # ...\n children = tree.children\n if isinstance(children, ProtectedField):\n children = children.get()\n for child in children:\n tree_to_list(child, list)\n # ...\n```", "```py\nclass LineLayout:\n def __init__(self, node, parent, previous):\n # ...\n self.width = ProtectedField()\n # ...\n\n def layout(self):\n # ...\n self.width.copy(self.parent.width)\n # ...\n```", "```py\nclass TextLayout:\n def __init__(self, node, word, parent, previous):\n # ...\n self.width = ProtectedField()\n # ...\n\n def layout(self):\n # ...\n style = self.width.read(self.node.style)\n zoom = self.width.read(self.zoom)\n self.font = font(style, zoom)\n self.width.set(self.font.measureText(self.word))\n # ...\n```", "```py\nclass EmbedLayout:\n def __init__(self, node, parent, previous, frame):\n # ...\n self.width = ProtectedField()\n # ...\n```", "```py\nclass InputLayout(EmbedLayout):\n def layout(self):\n # ...\n zoom = self.zoom.read(notify=self.width)\n self.width.set(dpx(INPUT_WIDTH_PX, zoom))\n # ...\n```", "```py\nclass JSContext:\n def setAttribute(self, handle, attr, value, window_id):\n # ...\n obj = elt.layout_object\n if isinstance(obj, IframeLayout) or \\\n isinstance(obj, ImageLayout):\n if attr == \"width\" or attr == \"height\":\n obj.width.mark()\n```", "```py\nclass DocumentLayout:\n def __init__(self, node, frame):\n # ...\n self.x = ProtectedField()\n self.y = ProtectedField()\n # ...\n\n def layout(self, width, zoom):\n # ...\n self.x.set(dpx(HSTEP, zoom))\n self.y.set(dpx(VSTEP, zoom))\n # ...\n```", "```py\nclass BlockLayout:\n def __init__(self, node, parent, previous, frame):\n # ...\n self.x = ProtectedField()\n # ...\n\n def layout(self):\n # ...\n self.x.copy(self.parent.x)\n # ...\n```", "```py\nclass BlockLayout:\n def __init__(self, node, parent, previous, frame):\n # ...\n self.y = ProtectedField()\n\n def layout(self):\n # ...\n if self.previous:\n prev_y = self.previous.y.read(notify=self.y)\n prev_height = self.previous.height.read(notify=self.y)\n self.y.set(prev_y + prev_height)\n else:\n self.y.copy(self.parent.y)\n # ...\n```", "```py\nclass DocumentLayout:\n def __init__(self, node, frame):\n # ...\n self.height = ProtectedField()\n # ...\n\n def layout(self, width, zoom):\n # ...\n self.height.copy(child.height)\n```", "```py\nclass BlockLayout:\n def __init__(self, node, parent, previous, frame):\n # ...\n self.height = ProtectedField()\n # ...\n\n def layout(self):\n # ...\n children = self.children.read(notify=self.height)\n new_height = sum([\n child.height.read(notify=self.height)\n for child in children\n ])\n self.height.set(new_height)\n```", "```py\nclass TextLayout:\n def __init__(self, node, word, parent, previous):\n # ...\n self.x = ProtectedField()\n self.y = ProtectedField()\n self.height = ProtectedField()\n self.font = ProtectedField()\n self.ascent = ProtectedField()\n self.descent = ProtectedField()\n # ...\n```", "```py\nclass TextLayout:\n def layout(self):\n # ...\n\n zoom = self.zoom.read(notify=self.font)\n style = self.node.style.read(notify=self.font)\n self.font.set(font(style, zoom))\n\n f = self.font.read(notify=self.width)\n self.width.set(f.measureText(self.word))\n\n f = self.font.read(notify=self.ascent)\n self.ascent.set(f.getMetrics().fAscent * 1.25)\n\n f = self.font.read(notify=self.descent)\n self.descent.set(f.getMetrics().fDescent * 1.25)\n\n f = self.font.read(notify=self.height)\n self.height.set(linespace(f) * 1.25)\n```", "```py\nclass TextLayout:\n def layout(self):\n # ...\n if self.previous:\n prev_x = self.previous.x.read(notify=self.x)\n prev_font = self.previous.font.read(notify=self.x)\n prev_width = self.previous.width.read(notify=self.x)\n self.x.set(\n prev_x + prev_font.measureText(' ') + prev_width)\n else:\n self.x.copy(self.parent.x)\n```", "```py\nclass InputLayout(EmbedLayout):\n def layout(self):\n super().layout()\n zoom = self.zoom.read(notify=self.width)\n self.width.set(dpx(INPUT_WIDTH_PX, zoom))\n\n font = self.font.read(notify=self.height)\n self.height.set(linespace(font))\n\n height = self.height.read(notify=self.ascent)\n self.ascent.set(-height)\n self.descent.set(0)\n```", "```py\nclass ImageLayout(EmbedLayout):\n def layout(self):\n # ...\n font = self.font.read(notify=self.height)\n self.height.set(max(self.img_height, linespace(font)))\n\n height = self.height.read(notify=self.ascent)\n self.ascent.set(-height)\n self.descent.set(0)\n```", "```py\nclass IframeLayout(EmbedLayout):\n def layout(self):\n # ...\n zoom = self.zoom.read(notify=self.height)\n if height_attr:\n self.height.set(dpx(int(height_attr) + 2, zoom))\n else:\n self.height.set(dpx(IFRAME_HEIGHT_PX + 2, zoom))\n # ...\n```", "```py\nclass JSContext:\n def setAttribute(self, handle, attr, value, window_id):\n if isinstance(obj, IframeLayout) or \\\n isinstance(obj, ImageLayout):\n if attr == \"width\" or attr == \"height\":\n # ...\n obj.height.mark()\n```", "```py\nclass LineLayout:\n def __init__(self, node, parent, previous):\n # ...\n self.x = ProtectedField()\n self.y = ProtectedField()\n # ...\n\n def layout(self):\n # ...\n self.x.copy(self.parent.x)\n if self.previous:\n prev_y = self.previous.y.read(notify=self.y)\n prev_height = self.previous.height.read(notify=self.y)\n self.y.set(prev_y + prev_height)\n else:\n self.y.copy(self.parent.y)\n # ...\n```", "```py\nclass LineLayout:\n def __init__(self, node, parent, previous):\n # ...\n self.ascent = ProtectedField()\n self.descent = ProtectedField()\n```", "```py\nclass LineLayout:\n def layout(self):\n # ...\n if not self.children:\n self.height.set(0)\n return\n```", "```py\nclass LineLayout:\n def layout(self):\n # ...\n self.ascent.set(max([\n -child.ascent.read(notify=self.ascent)\n for child in self.children\n ]))\n\n self.descent.set(max([\n child.descent.read(notify=self.descent)\n for child in self.children\n ]))\n```", "```py\nclass LineLayout:\n def layout(self):\n # ...\n for child in self.children:\n new_y = self.y.read(notify=child.y)\n new_y += self.ascent.read(notify=child.y)\n new_y += child.ascent.read(notify=child.y)\n child.y.set(new_y)\n```", "```py\nclass LineLayout:\n def layout(self):\n # ...\n max_ascent = self.ascent.read(notify=self.height)\n max_descent = self.descent.read(notify=self.height)\n self.height.set(max_ascent + max_descent)\n```", "```py\nclass ProtectedField:\n def set(self, value):\n if self.value != None:\n print(\"Change\", self)\n self.notify()\n self.value = value\n self.dirty = False\n```", "```py\nclass ProtectedField:\n def __init__(self, obj, name):\n self.obj = obj\n self.name = name\n # ...\n\n def __repr__(self):\n return \"ProtectedField({}, {})\".format(\n self.obj.node if hasattr(self.obj, \"node\") else self.obj,\n self.name)\n```", "```py\nclass DocumentLayout:\n def __init__(self, node, frame):\n # ...\n self.zoom = ProtectedField(self, \"zoom\")\n self.width = ProtectedField(self, \"width\")\n self.height = ProtectedField(self, \"height\")\n self.x = ProtectedField(self, \"x\")\n self.y = ProtectedField(self, \"y\")\n```", "```py\nChange ProtectedField(<body>, style)\nChange ProtectedField(<header>, style)\nChange ProtectedField(<h1 class=\"title\">, style)\nChange ProtectedField('Reusing Previous Computations', style)\nChange ProtectedField(<a href=\"...\">, style)\nChange ProtectedField('Twitter', style)\nChange ProtectedField(' \\n', style)\n...\n```", "```py\nChange ProtectedField(<html lang=\"en-US\" xml:lang=\"en-US\">, zoom)\nChange ProtectedField(<html lang=\"en-US\" xml:lang=\"en-US\">, zoom)\nChange ProtectedField(<head>, zoom)\nChange ProtectedField(<head>, children)\nChange ProtectedField(<head>, height)\nChange ProtectedField(<body>, zoom)\nChange ProtectedField(<body>, y)\nChange ProtectedField(<header>, zoom)\nChange ProtectedField(<header>, y)\n...\n```", "```py\ndef style(node, rules, frame):\n if node.style.dirty:\n # ...\n\n for child in node.children:\n style(child, rules, frame)\n```", "```py\nclass DocumentLayout:\n def layout(self, width, zoom):\n self.zoom.set(zoom)\n # ...\n```", "```py\nclass ProtectedField:\n def set(self, value):\n if value != self.value:\n self.notify()\n # ...\n```", "```py\nChange ProtectedField(<html lang=\"en-US\" xml:lang=\"en-US\">, zoom)\nChange ProtectedField(<div class=\"demo\" ...>, children)\nChange ProtectedField(<div class=\"demo\" ...>, height)\n```", "```py\nclass BlockLayout:\n def __init__(self, node, parent, previous, frame):\n # ...\n self.has_dirty_descendants = False\n```", "```py\nclass ProtectedField:\n def __init__(self, obj, name, parent=None):\n # ...\n self.parent = parent\n```", "```py\nclass BlockLayout:\n def __init__(self, node, parent, previous, frame):\n # ... \n self.children = ProtectedField(self, \"children\", self.parent)\n self.zoom = ProtectedField(self, \"zoom\", self.parent)\n self.width = ProtectedField(self, \"width\", self.parent)\n self.height = ProtectedField(self, \"height\", self.parent)\n self.x = ProtectedField(self, \"x\", self.parent)\n self.y = ProtectedField(self, \"y\", self.parent)\n```", "```py\nclass ProtectedField:\n def set_ancestor_dirty_bits(self):\n parent = self.parent\n while parent and not parent.has_dirty_descendants:\n parent.has_dirty_descendants = True\n parent = parent.parent\n\n def mark(self):\n # ...\n self.set_ancestor_dirty_bits()\n```", "```py\nclass BlockLayout:\n def layout(self):\n # ...\n for child in self.children.get():\n child.layout()\n\n self.has_dirty_descendants = False \n```", "```py\nclass BlockLayout:\n def layout(self):\n if not self.layout_needed(): return\n # ...\n```", "```py\nclass BlockLayout:\n def layout_needed(self):\n if self.zoom.dirty: return True\n if self.width.dirty: return True\n if self.height.dirty: return True\n if self.x.dirty: return True\n if self.y.dirty: return True\n if self.children.dirty: return True\n if self.has_dirty_descendants: return True\n return False\n```", "```py\nclass IframeLayout(EmbedLayout):\n def layout(self):\n if self.node.frame and self.node.frame.loaded:\n # ...\n self.node.frame.document.width.mark()\n```", "```py\nclass Tab:\n def zoom_by(self, increment):\n # ...\n for id, frame in self.window_id_to_frame.items():\n frame.document.zoom.mark()\n\n def reset_zoom(self):\n # ...\n for id, frame in self.window_id_to_frame.items():\n frame.document.zoom.mark()\n```", "```py\nclass Element:\n def __init__(self, tag, attributes, parent):\n # ...\n self.style = dict([\n (property, ProtectedField(self, property))\n for property in CSS_PROPERTIES\n ])\n # ...\n```", "```py\nCSS_PROPERTIES = {\n \"font-size\": \"inherit\", \"font-weight\": \"inherit\",\n \"font-style\": \"inherit\", \"color\": \"inherit\",\n \"opacity\": \"1.0\", \"transition\": \"\",\n \"transform\": \"none\", \"mix-blend-mode\": None,\n \"border-radius\": \"0px\", \"overflow\": \"visible\",\n \"outline\": \"none\", \"background-color\": \"transparent\",\n \"image-rendering\": \"auto\",\n}\n```", "```py\ndef dirty_style(node):\n for property, value in node.style.items():\n value.mark()\n\nclass JSContext:\n def style_set(self, handle, s, window_id):\n # ...\n dirty_style(elt)\n # ...\n```", "```py\nclass Frame:\n def focus_element(self, node):\n # ...\n if self.tab.focus:\n # ...\n dirty_style(self.tab.focus)\n if node:\n #...\n dirty_style(node)\n```", "```py\ndef style(node, rules, frame):\n needs_style = any([field.dirty for field in node.style.values()])\n if needs_style:\n # ...\n for child in node.children:\n style(child, rules, frame)\n```", "```py\ndef style(node, rules, frame):\n if needs_style:\n old_style = dict([\n (property, field.value)\n for property, field in node.style.items()\n ])\n new_style = CSS_PROPERTIES.copy()\n # ...\n```", "```py\ndef style(node, rules, frame):\n if needs_style:\n for property, default_value in INHERITED_PROPERTIES.items():\n if node.parent:\n parent_field = node.parent.style[property]\n parent_value = \\\n parent_field.read(notify=node.style[property])\n new_style[property] = parent_value\n```", "```py\ndef style(node, rules, frame):\n if needs_style:\n if new_style[\"font-size\"].endswith(\"%\"):\n if node.parent:\n parent_field = node.parent.style[\"font-size\"]\n parent_font_size = \\\n parent_field.read(notify=node.style[\"font-size\"])\n```", "```py\ndef style(node, rules, frame):\n if needs_style:\n # ...\n for property, field in node.style.items():\n field.set(new_style[property])\n```", "```py\ndef paint_visual_effects(node, cmds, rect):\n opacity = float(node.style[\"opacity\"].get())\n blend_mode = node.style[\"mix-blend-mode\"].get()\n translation = parse_transform(node.style[\"transform\"].get())\n\n if node.style[\"overflow\"].get() == \"clip\":\n border_radius = float(node.style[\"border-radius\"].get()[:-2])\n # ...\n\n # ...\n```", "```py\nclass BlockLayout:\n def word(self, node, word):\n zoom = self.children.read(self.zoom)\n style = self.children.read(node.style)\n node_font = font(style, zoom)\n # ...\n```", "```py\ndef font(css_style, zoom, notify):\n weight = css_style['font-weight'].read(notify)\n style = css_style['font-style'].read(notify)\n try:\n size = float(css_style['font-size'].read(notify)[:-2]) * 0.75\n except:\n size = 16\n font_size = dpx(size, zoom)\n return get_font(font_size, weight, style)\n```", "```py\nclass BlockLayout:\n def word(self, node, word):\n zoom = self.zoom.read(notify=self.children)\n node_font = font(node.style, zoom, notify=self.children)\n # ...\n```", "```py\nclass TextLayout:\n def layout(self):\n if self.font.dirty:\n zoom = self.zoom.read(notify=self.font)\n self.font.set(font(\n self.node.style, zoom, notify=self.font))\n```", "```py\nclass Tab:\n def run_animation_frame(self, scroll):\n for (window_id, frame) in self.window_id_to_frame.items():\n for node in tree_to_list(frame.nodes, []):\n for (property_name, animation) in \\\n node.animations.items():\n value = animation.animate()\n if value:\n node.style[property_name].set(value)\n # ...\n```", "```py\nclass ProtectedField:\n def __init__(self, obj, name, parent=None, dependencies=None):\n # ...\n if dependencies != None:\n for dependency in dependencies:\n dependency.invalidations.add(self)\n```", "```py\nclass ProtectedField:\n def __init__(self, obj, name, parent=None, dependencies=None):\n # ...\n self.frozen_dependencies = (dependencies != None)\n if dependencies != None:\n for dependency in dependencies:\n dependency.invalidations.add(self)\n\n def read(self, notify):\n if notify.frozen_dependencies:\n assert notify in self.invalidations\n else:\n self.invalidations.add(notify)\n\n return self.get()\n```", "```py\nclass DocumentLayout:\n def __init__(self, node, frame):\n # ...\n self.zoom = ProtectedField(self, \"zoom\", None, [])\n self.width = ProtectedField(self, \"width\", None, [])\n self.x = ProtectedField(self, \"x\", None, [])\n self.y = ProtectedField(self, \"y\", None, [])\n self.height = ProtectedField(self, \"height\")\n```", "```py\nclass BlockLayout:\n def __init__(self, node, parent, previous, frame):\n # ...\n if self.previous:\n y_dependencies = [self.previous.y, self.previous.height]\n else:\n y_dependencies = [self.parent.y]\n self.y = ProtectedField(\n self, \"y\", self.parent, y_dependencies)\n # ...\n```", "```py\nclass ProtectedField:\n def set_dependencies(self, dependencies):\n for dependency in dependencies:\n dependency.invalidations.add(self)\n self.frozen_dependencies = True\n```", "```py\nclass DocumentLayout:\n def layout(self, width, zoom):\n if not self.children:\n child = BlockLayout(self.node, self, None, self.frame)\n self.height.set_dependencies([child.height])\n```", "```py\nclass BlockLayout:\n def layout(self):\n # ...\n if mode == \"block\":\n if self.children.dirty:\n # ...\n self.children.set(children)\n\n height_dependencies = \\\n [child.height for child in children]\n height_dependencies.append(self.children)\n self.height.set_dependencies(height_dependencies)\n else:\n if self.children.dirty:\n # ...\n self.children.set(self.temp_children)\n\n height_dependencies = \\\n [child.height for child in self.temp_children]\n height_dependencies.append(self.children)\n self.height.set_dependencies(height_dependencies)\n```", "```py\nclass TextLayout:\n def __init__(self, node, word, parent, previous):\n # ...\n self.zoom = ProtectedField(self, \"zoom\", self.parent,\n [self.parent.zoom])\n self.font = ProtectedField(self, \"font\", self.parent,\n [self.zoom,\n self.node.style['font-weight'],\n self.node.style['font-style'],\n self.node.style['font-size']])\n self.width = ProtectedField(self, \"width\", self.parent,\n [self.font])\n self.height = ProtectedField(self, \"height\", self.parent,\n [self.font])\n self.ascent = ProtectedField(self, \"ascent\", self.parent,\n [self.font])\n self.descent = ProtectedField(self, \"descent\", self.parent,\n [self.font])\n if self.previous:\n x_dependencies = [self.previous.x, self.previous.font,\n self.previous.width]\n else:\n x_dependencies = [self.parent.x]\n self.x = ProtectedField(self, \"x\", self.parent,\n x_dependencies)\n self.y = ProtectedField(self, \"y\", self.parent,\n [self.ascent, self.parent.y, self.parent.ascent])\n```", "```py\nclass LineLayout:\n def __init__(self, node, parent, previous):\n # ...\n self.initialized_fields = False\n self.ascent = ProtectedField(self, \"ascent\", self.parent)\n self.descent = ProtectedField(self, \"descent\", self.parent)\n # ...\n\n def layout(self):\n if not self.initialized_fields:\n self.ascent.set_dependencies(\n [child.ascent for child in self.children])\n self.descent.set_dependencies(\n [child.descent for child in self.children])\n self.initialized_fields = True\n # ...\n```", "```py\nclass EmbedLayout:\n def __init__(self, node, parent, previous, frame):\n # ...\n self.zoom = ProtectedField(self, \"zoom\", self.parent,\n [self.parent.zoom])\n self.font = ProtectedField(self, \"font\", self.parent,\n [self.zoom,\n self.node.style['font-weight'],\n self.node.style['font-style'],\n self.node.style['font-size']])\n self.width = ProtectedField(self, \"width\", self.parent,\n [self.zoom])\n self.height = ProtectedField(self, \"height\", self.parent,\n [self.zoom, self.font, self.width])\n self.ascent = ProtectedField(self, \"ascent\", self.parent,\n [self.height])\n self.descent = ProtectedField(\n self, \"descent\", self.parent, [])\n if self.previous:\n x_dependencies = \\\n [self.previous.x, self.previous.font,\n self.previous.width]\n else:\n x_dependencies = [self.parent.x]\n self.x = ProtectedField(\n self, \"x\", self.parent, x_dependencies)\n self.y = ProtectedField(self, \"y\", self.parent,\n [self.ascent,self.parent.y, self.parent.ascent])\n```", "```py\nclass Element:\n def __init__(self, tag, attributes, parent):\n # ...\n self.style = None\n\nclass Text:\n def __init__(self, text, parent):\n # ...\n self.style = None\n```", "```py\ndef style(node, rules, frame):\n if not node.style:\n init_style(node)\n```", "```py\ndef init_style(node):\n node.style = dict([\n (property, ProtectedField(node, property, None,\n [node.parent.style[property]] \\\n if node.parent and \\\n property in INHERITED_PROPERTIES \\\n else []))\n for property in CSS_PROPERTIES\n ])\n```"]