- en: Chapter 8 - Run a production-ready system
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 - 运行生产就绪系统
- en: 原文：[https://www.thedigitalcatbooks.com/pycabook-chapter-08/](https://www.thedigitalcatbooks.com/pycabook-chapter-08/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://www.thedigitalcatbooks.com/pycabook-chapter-08/](https://www.thedigitalcatbooks.com/pycabook-chapter-08/)'
- en: Vilos Cohaagen said troops would be used to ensure full production.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 维洛斯·科哈根说将使用部队来确保全面生产。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Total Recall, 1990
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 《全面回忆》，1990
- en: Now that we developed a repository that connects with PostgreSQL we can discuss
    how to properly set up the application to run a production-ready system. This
    part is not strictly related to the clean architecture, but I think it's worth
    completing the example, showing how the system that we designed can end up being
    the core of a real web application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开发了一个与 PostgreSQL 连接的仓库，我们可以讨论如何正确设置应用程序以运行一个生产就绪的系统。这部分内容与干净的架构不是严格相关，但我认为完成这个例子是值得的，展示我们设计的系统最终可以成为真实网络应用的核心。
- en: Clearly, the definition "production-ready" refers to many different configuration
    that ultimately depend on the load and the business requirements of the system.
    As the goal is to show a complete example and not to cover real production requirements
    I will show a solution that uses real external systems like PostgreSQL and Nginx,
    without being too concerned about performances.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，“生产就绪”的定义指的是许多不同的配置，这些配置最终取决于系统的负载和业务需求。由于目标是展示一个完整的例子，而不是涵盖真正的生产需求，我将展示一个使用真实外部系统（如
    PostgreSQL 和 Nginx）的解决方案，而不太关注性能。
- en: Build a web stack
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个网络栈
- en: Now that we successfully containerised the tests we might try to devise a production-ready
    setup of the whole application, running both a web server and a database in Docker
    containers. Once again, I will follow the approach that I show in the series of
    posts I mentioned in one of the previous sections.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功将测试容器化，我们可以尝试为整个应用程序设计一个生产就绪的设置，在 Docker 容器中运行一个网络服务器和一个数据库。再一次，我将遵循我在前一个部分提到的帖子系列中展示的方法。
- en: To run a production-ready infrastructure we need to put a WSGI server in front
    of the web framework and a Web server in front of it. We will also need to run
    a database container that we will initialise only once.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行生产就绪的基础设施，我们需要在 Web 框架前面放置一个 WSGI 服务器，在它前面放置一个 Web 服务器。我们还需要运行一个数据库容器，我们只初始化一次。
- en: The steps towards a production-ready configuration are not complicated and the
    final setup won't be ultimately too different form what we already did for the
    tests. We need to
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 向生产就绪配置迈进的步骤并不复杂，最终的设置最终也不会与我们为测试所做的设置有太大不同。我们需要
- en: Create a JSON configuration with environment variables suitable for production
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含适合生产的环境变量的 JSON 配置
- en: Create a suitable configuration for Docker Compose and configure the containers
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Docker Compose 创建一个合适的配置，并配置容器
- en: Add commands to `manage.py` that allow us to control the processes
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `manage.py` 中添加命令，以便我们可以控制进程
- en: Let's create the file `config/production.json`, which is very similar to the
    one we created for the tests
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `config/production.json` 的文件，它与为测试创建的文件非常相似。
- en: '`config/production.json`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`config/production.json`'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Please note that now both `FLASK_ENV` and `FLASK_CONFIG` are set to `production`.
    Please remember that the first is an internal Flask variable with two possible
    fixed values (`development` and `production`), while the second one is an arbitrary
    name that has the final effect of loading a specific configuration object (`ProductionConfig`
    in this case). I also changed `POSTGRES_PORT` back to the default `5432` and `APPLICATION_DB`
    to `application` (an arbitrary name).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在 `FLASK_ENV` 和 `FLASK_CONFIG` 都设置为 `production`。请记住，第一个是一个 Flask 的内部变量，有两个可能的固定值（`development`
    和 `production`），而第二个是一个任意名称，最终效果是加载一个特定的配置对象（在这种情况下是 `ProductionConfig`）。我还将 `POSTGRES_PORT`
    改回默认的 `5432`，将 `APPLICATION_DB` 改为 `application`（一个任意名称）。
- en: Let's define which containers we want to run in our production environment,
    and how we want to connect them. We need a production-ready database and I will
    use Postgres, as I already did during the tests. Then we need to wrap Flask with
    a production HTTP server, and for this job I will use `gunicorn`. Last, we need
    a Web Server to act as load balancer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义我们希望在生产环境中运行的容器，以及我们希望如何连接它们。我们需要一个生产就绪的数据库，我将使用 Postgres，就像我在测试中已经做的那样。然后我们需要将
    Flask 包装在一个生产 HTTP 服务器中，为此我将使用 `gunicorn`。最后，我们需要一个 Web 服务器作为负载均衡器。
- en: The file `docker/production.yml` will contain the Docker Compose configuration,
    according to the convention we defined in `manage.py`
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker/production.yml` 文件将包含 Docker Compose 配置，根据我们在 `manage.py` 中定义的约定'
- en: '`docker/production.yml`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker/production.yml`'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see the Postgres configuration is not different from the one we used
    in the file `testing.yml`, but I added the option `volumes` (both in `db` and
    at the end of the file) that allows me to create a stable volume. If you don't
    do it, the database will be destroyed once you shut down the container.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Postgres 配置与我们在 `testing.yml` 文件中使用的配置没有区别，但我添加了 `volumes` 选项（在 `db` 和文件末尾），这允许我创建一个稳定的卷。如果您不这样做，容器关闭时数据库将被销毁。
- en: The container `web` runs the Flask application through `gunicorn`. The environment
    variables come once again from the JSON configuration, and we need to define them
    because the application needs to know how to connect with the database and how
    to run the web framework. The command `gunicorn -w 4 -b 0.0.0.0 wsgi:app` loads
    the WSGI application we created in `wsgi.py` and runs it in 4 concurrent processes.
    This container is created using `docker/web/Dockerfile.production` which I still
    have to define.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 容器 `web` 通过 `gunicorn` 运行 Flask 应用程序。环境变量再次来自 JSON 配置，我们需要定义它们，因为应用程序需要知道如何连接数据库以及如何运行
    Web 框架。命令 `gunicorn -w 4 -b 0.0.0.0 wsgi:app` 加载我们在 `wsgi.py` 中创建的 WSGI 应用程序，并以
    4 个并发进程运行。这个容器是通过 `docker/web/Dockerfile.production` 创建的，我还需要定义它。
- en: The last container is `nginx`, which we will use as it is directly from the
    Docker Hub. The container runs Nginx with the configuration stored in `/etc/nginx/nginx.conf`,
    which is the file we overwrite with the local one `./nginx/nginx.conf`. Please
    note that I configured it to use port 8080 instead of the standard port 80 for
    HTTP to avoid clashing with other software that you might be running on your computer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个容器是 `nginx`，我们将直接从 Docker Hub 使用它。该容器运行 Nginx，配置存储在 `/etc/nginx/nginx.conf`
    中，这是我们用本地文件 `./nginx/nginx.conf` 覆盖的文件。请注意，我将其配置为使用端口 8080 而不是标准的 HTTP 端口 80，以避免与您可能在计算机上运行的其它软件冲突。
- en: The Dockerfile for the web application is the following
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用的 Dockerfile 如下
- en: '`docker/web/Dockerfile.production`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker/web/Dockerfile.production`'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a very simple container that uses the standard `python:3` image, where
    I added the production requirements contained in `requirements/prod.txt`. To make
    the Docker container work we need to add `gunicorn` to this last file
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的容器，使用标准的 `python:3` 镜像，我在其中添加了 `requirements/prod.txt` 中包含的生产需求。为了让
    Docker 容器工作，我们需要将 `gunicorn` 添加到这个最后的文件中
- en: '`requirements/prod.txt`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements/prod.txt`'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The configuration for Nginx is
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 的配置如下
- en: '`docker/nginx/nginx.conf`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker/nginx/nginx.conf`'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As for the rest of the project, this configuration is very basic and lacks some
    important parts that are mandatory in a real production environment, such as HTTPS.
    In its essence, though, it is however not too different from the configuration
    of a production-ready Nginx container.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于项目的其余部分，这个配置非常基础，缺少了一些在真实生产环境中强制要求的某些重要部分，例如 HTTPS。然而，从本质上讲，它却与准备就绪的生产环境中的
    Nginx 容器配置没有太大区别。
- en: As we will use Docker Compose, the script `manage.py` needs a simple change,
    which is a command that wraps `docker-compose` itself. We need the script to just
    initialise environment variables according to the content of the JSON configuration
    file and then run Docker Compose. As we already have the function `docker_compose_cmdline`
    the job is pretty simple
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用 Docker Compose，`manage.py` 需要简单的修改，即一个包装 `docker-compose` 自身的命令。我们需要脚本根据
    JSON 配置文件的内容初始化环境变量，然后运行 Docker Compose。由于我们已经有 `docker_compose_cmdline` 函数，这项工作相当简单
- en: '`manage.py`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`manage.py`'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see I forced the variable `APPLICATION_CONFIG` to be `production`
    if not specified. Usually, my default configuration is the development one, but
    in this simple case I haven't defined one, so this will do for now.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我强制将变量 `APPLICATION_CONFIG` 设置为 `production`，如果没有指定。通常，我的默认配置是开发配置，但在这个简单的情况下，我没有定义一个，所以现在这样就可以了。
- en: The new command is `compose`, that leverages Click's `argument` decorator to
    collect subcommands and attach them to the Docker Compose command line. I also
    use the `signal` library, which I added to the imports, to control keyboard interruptions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 新的命令是 `compose`，它利用 Click 的 `argument` 装饰器来收集子命令并将它们附加到 Docker Compose 命令行。我还使用了
    `signal` 库，我将其添加到导入中，以控制键盘中断。
- en: '*Source code'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码'
- en: '[https://github.com/pycabook/rentomatic/tree/ed2-c08-s01](https://github.com/pycabook/rentomatic/tree/ed2-c08-s01)*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pycabook/rentomatic/tree/ed2-c08-s01](https://github.com/pycabook/rentomatic/tree/ed2-c08-s01)'
- en: '*When all this changes are in place we can test the application Dockerfile
    building the container.*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有这些更改都到位后，我们可以测试应用程序的Dockerfile构建容器
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*This command runs the Click command `compose` that first reads environment
    variables from the file `config/production.json`, and then runs `docker-compose`
    passing it the subcommand `build web`.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令运行Click命令`compose`，首先从`config/production.json`文件中读取环境变量，然后运行`docker-compose`，并传递子命令`build
    web`。
- en: '*You output should be the following (with different image IDs)*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应该是以下内容（带有不同的镜像ID）
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*If this is successful you can run Docker Compose*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这成功了，你可以运行Docker Compose
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*and the output of `docker ps` should show three containers running*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 并且`docker ps`的输出应该显示三个正在运行的容器
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Note that I removed several columns to make the output readable.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我删除了几个列以使输出可读。
- en: '*At this point we can open [http://localhost:8080/rooms](http://localhost:8080/rooms)
    with our browser and see the result of the HTTP request received by Nginx, passed
    to gunicorn, and processed by Flask using the use case `room_list_use_case`.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以用我们的浏览器打开[http://localhost:8080/rooms](http://localhost:8080/rooms)，并查看Nginx接收到的HTTP请求的结果，然后传递给gunicorn，并由Flask使用`room_list_use_case`用例处理
- en: '*The application is not actually using the database yet, as the Flask endpoint
    `room_list` in `application/rest/room.py` initialises the class `MemRepo` and
    loads it with some static values, which are the ones we see in our browser.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序实际上还没有使用数据库，因为`application/rest/room.py`中的Flask端点`room_list`初始化了`MemRepo`类，并用一些静态值加载它，这些值就是我们浏览器中看到的
- en: '*Connect to a production-ready database*'
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到一个生产就绪的数据库
- en: '*Before we start changing the code of the application remember to tear down
    the system running*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始更改应用程序的代码之前，请记住要拆除正在运行的系统
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Thanks to the common interface between repositories, moving from the memory-based
    `MemRepo` to `PostgresRepo` is very simple. Clearly, as the external database
    will not contain any data initially, the response of the use case will be empty.*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存储库之间的公共接口，从基于内存的`MemRepo`到`PostgresRepo`的迁移非常简单。显然，由于外部数据库最初不会包含任何数据，用例的响应将是空的。
- en: '*First of all, let''s move the application to the Postgres repository. The
    new version of the endpoint is*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将应用程序移动到Postgres仓库。端点的新版本是
- en: '*`application/rest/room.py`*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`application/rest/room.py`'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*As you can see the main change is that `repo = MemRepo(rooms)` becomes `repo
    = PostgresRepo(postgres_configuration)`. Such a simple change is made possible
    by the clean architecture and its strict layered approach. The only other notable
    change is that we replaced the initial data for the memory-based repository with
    a dictionary containing connection data, which comes from the environment variables
    set by the management script.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，主要的变化是`repo = MemRepo(rooms)`变成了`repo = PostgresRepo(postgres_configuration)`。这样的简单变化是通过干净的架构和其严格的分层方法实现的。唯一的另一个显著变化是我们用包含连接数据的字典替换了基于内存的存储库的初始数据，这些数据来自管理脚本设置的环境变量。
- en: '*This is enough to make the application connect to the Postgres database that
    we are running in a container, but as I mentioned we also need to initialise the
    database. The bare minimum that we need is an empty database with the correct
    name. Remember that in this particular setup we use for the application a different
    database (`APPLICATION_DB`) from the one that the Postgres container creates automatically
    at startup (`POSTGRES_DB`). I added a specific command to the management script
    to perform this task*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以让应用程序连接到我们在容器中运行的Postgres数据库，但正如我提到的，我们还需要初始化数据库。我们需要的最基本的是具有正确名称的空数据库。记住，在这个特定的设置中，我们为应用程序使用了一个不同的数据库（`APPLICATION_DB`），而不是Postgres容器在启动时自动创建的数据库（`POSTGRES_DB`）。我在管理脚本中添加了一个特定的命令来执行这个任务
- en: '*`manage.py`*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`manage.py`'
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Now spin up your containers*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动你的容器
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*and run the new command that we created*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 并运行我们创建的新命令
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Mind the change between the name of the function `init_postgres` and the name
    of the command `init-postgres`. You only need to run this command once, but repeated
    executions will not affect the database.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数`init_postgres`的名称和命令`init-postgres`的名称之间的变化。你只需要运行这个命令一次，但重复执行不会影响数据库。
- en: '*We can check what this command did connecting to the database. We can do it
    executing `psql` in the database container*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们可以通过连接到数据库来检查这个命令做了什么。我们可以通过在数据库容器中执行 `psql` 来做到这一点。*'
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Please note that we need to specify the user `-U postgres`. That is the user
    that we created through the variable `POSTGRES_USER` in `config/production.json`.
    Once logged in, we can use the command `\l` to see the available databases*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，我们需要指定用户 `-U postgres`。这是我们通过 `config/production.json` 中的变量 `POSTGRES_USER`
    创建的用户。一旦登录，我们可以使用命令 `\l` 来查看可用的数据库。*'
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Please note that the two databases `template0` and `template1` are system
    databases created by Postgres (see [the documentation](https://www.postgresql.org/docs/current/manage-ag-templatedbs.html)),
    `postgres` is the default database created by the Docker container (the name is
    `postgres` by default, but in this case it comes from the environment variable
    `POSTGRES_DB` in `config/production.json`) and `application` is the database created
    by `./manage.py init-postgres` (from `APPLICATION_DB`).*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，`template0` 和 `template1` 这两个数据库是 Postgres 创建的系统数据库（参见[文档](https://www.postgresql.org/docs/current/manage-ag-templatedbs.html)），`postgres`
    是 Docker 容器创建的默认数据库（默认名称为 `postgres`，但在此情况下它来自 `config/production.json` 中的环境变量
    `POSTGRES_DB`），而 `application` 是通过 `./manage.py init-postgres` 创建的数据库（来自 `APPLICATION_DB`）。*'
- en: '*We can connect to a database with the command `\c`*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们可以使用命令 `\c` 连接到数据库。*'
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Please note that the prompt changes with the name of the current database.
    Finally, we can list the available tables with `\dt`*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，提示符会根据当前数据库的名称而改变。最后，我们可以使用 `\dt` 列出可用的表。*'
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*As you can see there are no tables yet. This is no surprise as we didn''t
    do anything to make Postres aware of the models that we created. Please remember
    that everything we are doing here is done in an external system and it is not
    directly connected with entities.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*正如你所见，还没有任何表。这并不奇怪，因为我们没有做任何使 Postres 了解我们创建的模型的事情。请记住，我们在这里所做的一切都是在外部系统中完成的，并且它并没有直接与实体相连。*'
- en: '*As you remember, we mapped entities to storage objects, and since we are using
    Postgres we leveraged SQLAlchemy classes, so now we need to create the database
    tables that correspond to them.*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*正如你所记得的，我们将实体映射到存储对象，因为我们使用的是 Postgres，所以我们利用了 SQLAlchemy 类，所以现在我们需要创建与它们相对应的数据库表。*'
- en: '*Migrations*'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*迁移*'
- en: '*We need a way to create the tables that correspond to the objects that we
    defined in `rentomatic/repository/postgres_objects.py`. The best strategy, when
    we use an ORM like SQLAlchemy, is to create and run migrations, and for this we
    can use [Alembic](https://alembic.sqlalchemy.org/).*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们需要一种方法来创建与我们在 `rentomatic/repository/postgres_objects.py` 中定义的对象相对应的表。当我们使用像
    SQLAlchemy 这样的 ORM 时，最佳策略是创建和运行迁移，为此我们可以使用 [Alembic](https://alembic.sqlalchemy.org/)。*'
- en: '*If you are still connected with `psql` please exit with `\q`, then edit `requirements/prod.txt`
    and add `alembic`*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你仍然通过 `psql` 连接，请使用 `\q` 退出，然后编辑 `requirements/prod.txt` 并添加 `alembic`。*'
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*As usual, remember to run `pip install -r requirements/dev.txt` to update
    the virtual environment.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*像往常一样，请记住运行 `pip install -r requirements/dev.txt` 来更新虚拟环境。*'
- en: '*Alembic is capable of connecting to the database and run Python scripts (called
    "migrations") to alter the tables according to the SQLAlchemy models. To do this,
    however, we need to give Alembic access to the database providing username, password,
    hostname, and the database name. We also need to give Alembic access to the Python
    classes that represent the models.*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*Alembic 能够连接到数据库并运行 Python 脚本（称为“迁移”），以根据 SQLAlchemy 模型更改表。然而，为了做到这一点，我们需要提供用户名、密码、主机名和数据库名称以供
    Alembic 访问数据库。我们还需要提供 Alembic 访问代表模型的 Python 类的权限。*'
- en: '*First of all let''s initialise Alembic. In the project''s main directory (where
    `manage.py` is stored) run*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*首先，让我们初始化 Alembic。在项目的主要目录（`manage.py` 存储的地方）运行*'
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*which creates a directory called `migrations` that contains Alembic''s configuration
    files, together with the migrations that will be created in `migrations/versions`.
    it will also create the file `alembic.ini` which contains the configuration values.
    The name `migrations` is completely arbitrary, so feel free to use a different
    one if you prefer.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*它将创建一个名为 `migrations` 的目录，该目录包含 Alembic 的配置文件，以及将在 `migrations/versions` 中创建的迁移。它还将创建一个名为
    `alembic.ini` 的文件，其中包含配置值。`migrations` 的名称完全是任意的，所以如果你更喜欢，可以自由使用不同的名称。*'
- en: '*The specific file we need to adjust to make Alembic aware of our models and
    our database is `migrations/env.py`. Add the highlighted lines*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们需要调整的特定文件是 `migrations/env.py`，以便 Alembic 了解我们的模型和数据库。添加高亮行*'
- en: '*migrations/env.py*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*migrations/env.py*'
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Through `config.set_section_option` we are adding relevant configuration values
    to the main Alembic INI file section (`config.config_ini_section`), extracting
    them from the environment variables. We are also importing the file that contains
    the SQLAlchemy objects. You can find documentation on this procedure at [https://alembic.sqlalchemy.org/en/latest/api/config.html](https://alembic.sqlalchemy.org/en/latest/api/config.html).*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过 `config.set_section_option` 我们将相关的配置值添加到主 Alembic INI 文件部分 (`config.config_ini_section`)，并从环境变量中提取它们。我们还在导入包含
    SQLAlchemy 对象的文件。您可以在 [https://alembic.sqlalchemy.org/en/latest/api/config.html](https://alembic.sqlalchemy.org/en/latest/api/config.html)
    找到有关此过程的文档。*'
- en: '*Once this is done we need to change the INI file to use the new variables*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*完成此操作后，我们需要将 INI 文件更改为使用新变量*'
- en: '*alembic.ini*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*alembic.ini*'
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*The syntax `%(VARNAME)s` is the basic variable interpolation used by `ConfigParser`
    (see [the documentation](https://docs.python.org/3.8/library/configparser.html#configparser.BasicInterpolation)).*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*`%(VARNAME)s` 语法是 `ConfigParser`（见 [文档](https://docs.python.org/3.8/library/configparser.html#configparser.BasicInterpolation)）使用的基本变量插值。*'
- en: '*At this point we can run Alembic to migrate our database. In many cases, you
    can rely on Alembic''s autogeneration functionality to generate the migrations,
    and this is what we can do to create the initial models. The Alembic command is
    `revision` with the `--autogenerate` flag, but we need to pass the environment
    variables on the command line. This is clearly a job for `migrate.py` but let''s
    first run it to see what happens to the database. Later we will create a better
    setup to avoid passing variables manually*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*此时，我们可以运行 Alembic 来迁移我们的数据库。在许多情况下，您可以使用 Alembic 的自动生成功能来生成迁移，这就是我们创建初始模型的方法。Alembic
    命令是带有 `--autogenerate` 标志的 `revision`，但我们需要在命令行中传递环境变量。这显然是 `migrate.py` 的工作，但让我们首先运行它看看数据库会发生什么。稍后我们将创建一个更好的设置来避免手动传递变量。*'
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*This will generate the file `migrations/versions/4d4c19952a36_initial.py`.
    Pay attention that the initial hash will be different for you. If you want you
    can open that file and see how Alembic generates the table and creates the columns.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*这将生成文件 `migrations/versions/4d4c19952a36_initial.py`。请注意，您的初始哈希值将不同。如果您想，您可以打开该文件，看看
    Alembic 如何生成表和创建列。*'
- en: '*So far we created the migration but we still need to apply it to the database.
    Make sure you are running the Docker containers (run `./manage.py compose up -d`
    otherwise) as Alembic is going to connect to the database, and run*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*到目前为止，我们已经创建了迁移，但我们仍然需要将其应用到数据库中。确保您正在运行 Docker 容器（否则运行 `./manage.py compose
    up -d`），因为 Alembic 将连接到数据库，并运行*'
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*At this point we can connect to the database and check the existing tables*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*此时，我们可以连接到数据库并检查现有的表*'
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Please note that I used the option `-d` of `psql` to connect directly to the
    database `application`. As you can see, now we have two tables. The first, `alembic_version`
    is a simple one that Alembic uses to keep track of the state of the db, while
    `room` is the one that will contain our `Room` entities.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，我使用了 `psql` 的 `-d` 选项直接连接到数据库 `application`。如您所见，现在我们有两个表。第一个 `alembic_version`
    是一个简单的表，Alembic 使用它来跟踪数据库的状态，而 `room` 是将包含我们的 `Room` 实体的表。*'
- en: '*We can double-check the Alembic version*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们可以再次检查 Alembic 版本*'
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*As I mentioned before, the hash given to the migration will be different in
    your case, but that value that you see in this table should be consistent with
    the name of the migration script.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*如我之前提到的，分配给迁移的哈希值在您的案例中将是不同的，但您在这个表中看到的价值应该与迁移脚本的名称一致。*'
- en: '*We can also see the structure of the table `room`*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们还可以看到 `room` 表的结构*'
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Clearly, there are still no rows contained in that table*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*显然，该表中还没有包含任何行*'
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*And indeed, if you open [http://localhost:8080/rooms](http://localhost:8080/rooms)
    with your browser you will see a successful response, but no data.*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*确实，如果您用浏览器打开 [http://localhost:8080/rooms](http://localhost:8080/rooms)，您将看到一个成功的响应，但没有数据。*'
- en: '*To see some data we need to write something into the database. This is normally
    done through a form in the web application and a specific endpoint, but for the
    sake of simplicity in this case we can just add data manually to the database.*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了查看一些数据，我们需要将一些内容写入数据库。这通常是通过网页应用程序中的表单和特定端点来完成的，但为了简化，在这种情况下，我们只需手动将数据添加到数据库中。*'
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*You can verify that the table contains the new room with a `SELECT`*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*您可以通过 `SELECT` 验证表中是否包含新的房间*'
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*and open or refresh [http://localhost:8080/rooms](http://localhost:8080/rooms)
    with the browser to see the value returned by our use case.*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用浏览器打开或刷新[http://localhost:8080/rooms](http://localhost:8080/rooms)以查看我们用例返回的值。*'
- en: '**Source code'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码**'
- en: '[https://github.com/pycabook/rentomatic/tree/ed2-c08-s02](https://github.com/pycabook/rentomatic/tree/ed2-c08-s02)**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pycabook/rentomatic/tree/ed2-c08-s02](https://github.com/pycabook/rentomatic/tree/ed2-c08-s02)'
- en: '* * *'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**This chapter concludes the overview of the clean architecture example. Starting
    from scratch, we created domain models, serializers, use cases, an in-memory storage
    system, a command-line interface and an HTTP endpoint. We then improved the whole
    system with a very generic request/response management code, that provides robust
    support for errors. Last, we implemented two new storage systems, using both a
    relational and a NoSQL database.**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章总结了清洁架构示例的概述。我们从零开始，创建了领域模型、序列化器、用例、内存存储系统、命令行界面和HTTP端点。然后，我们通过一个非常通用的请求/响应管理代码改进了整个系统，该代码为错误提供了健壮的支持。最后，我们实现了两个新的存储系统，使用了关系型数据库和非关系型数据库。**'
- en: '**This is by no means a little achievement. Our architecture covers a very
    small use case, but is robust and fully tested. Whatever error we might find in
    the way we dealt with data, databases, requests, and so on, can be isolated and
    tamed much faster than in a system which doesn''t have tests. Moreover, the decoupling
    philosophy not only allows us to provide support for multiple storage systems,
    but also to quickly implement new access protocols, or new serialisations for
    our objects.**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**这绝对不是一个小成就。我们的架构覆盖了一个非常小的用例，但它是健壮的并且经过了全面测试。无论我们在处理数据、数据库、请求等方面可能发现的任何错误，都可以比没有测试的系统更快地隔离和驯服。此外，解耦哲学不仅使我们能够为多个存储系统提供支持，而且能够快速实现新的访问协议，或为我们对象实现新的序列化方式。**'
