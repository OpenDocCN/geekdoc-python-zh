- en: Chapter 6 - Integration with a real external system - Postgres
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 - 与真实外部系统的集成 - Postgres
- en: 原文：[https://www.thedigitalcatbooks.com/pycabook-chapter-06/](https://www.thedigitalcatbooks.com/pycabook-chapter-06/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://www.thedigitalcatbooks.com/pycabook-chapter-06/](https://www.thedigitalcatbooks.com/pycabook-chapter-06/)
- en: Ooooh, I'm very sorry Hans. I didn't get that memo.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哎哟，非常抱歉，汉斯。我没有收到那份备忘录。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Maybe you should've put it on the bulletin board.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 也许你应该把它贴在公告板上。
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Die Hard, 1988
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 《虎胆龙威》，1988
- en: The basic in-memory repository I implemented for the project is enough to show
    the concept of the repository layer abstraction. It is not enough to run a production
    system, though, so we need to implement a connection with a real storage like
    a database. Whenever we use an external system and we want to test the interface
    we can use mocks, but at a certain point we need to ensure that the two systems
    actually work together, and this is when we need to start creating integration
    tests.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个项目实现的基本内存存储库足以展示存储层抽象的概念。然而，这还不足以运行一个生产系统，因此我们需要实现与真实存储（如数据库）的连接。每当使用外部系统并希望测试接口时，我们可以使用模拟，但在某个时刻我们需要确保两个系统实际上可以协同工作，这就是我们需要开始创建集成测试的时候。
- en: In this chapter I will show how to set up and run integration tests between
    our application and a real database. At the end of the chapter I will have a repository
    that allows the application to interface with PostgreSQL, and a battery of tests
    that run using a real database instance running in Docker.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将展示如何设置和运行我们的应用程序与真实数据库之间的集成测试。在本章结束时，我将有一个允许应用程序与PostgreSQL接口的存储库，以及一系列在Docker中运行的实时数据库实例上运行的测试。
- en: This chapter will show you one of the biggest advantages of a clean architecture,
    namely the simplicity with which you can replace existing components with others,
    possibly based on a completely different technology.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示干净架构的最大优势之一，即您可以用其他组件替换现有组件的简单性，这些组件可能基于完全不同的技术。
- en: Decoupling with interfaces
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过接口解耦
- en: The clean architecture we devised in the previous chapters defines a use case
    that receives a repository instance as an argument and uses its `list` method
    to retrieve the contained entries. This allows the use case to form a very loose
    coupling with the repository, being connected only through the API exposed by
    the object and not to the real implementation. In other words, the use cases are
    polymorphic with respect to the method `list`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中设计的干净架构定义了一个使用案例，它接收一个存储库实例作为参数，并使用其`list`方法检索包含的条目。这允许使用案例与存储库形成非常松散的耦合，仅通过对象公开的API连接，而不是与真实实现连接。换句话说，使用案例相对于`list`方法来说是多态的。
- en: This is very important and it is the core of the clean architecture design.
    Being connected through an API, the use case and the repository can be replaced
    by different implementations at any time, given that the new implementation provides
    the requested interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要，它是干净架构设计的核心。通过API连接，使用案例和存储库可以在任何时间被不同的实现所替换，前提是新实现提供了请求的接口。
- en: It is worth noting, for example, that the initialisation of the object is not
    part of the API that the use cases are using since the repository is initialised
    in the main script and not in each use case. The method `__init__`, thus, doesn't
    need to be the same among the repository implementations, which gives us a great
    deal of flexibility, as different storage systems may need different initialisation
    values.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，值得注意的一点是，对象的初始化不是使用案例所使用的API的一部分，因为存储库是在主脚本中初始化的，而不是在每个使用案例中。因此，`__init__`方法在存储库实现之间不需要相同，这为我们提供了很大的灵活性，因为不同的存储系统可能需要不同的初始化值。
- en: The simple repository we implemented in one of the previous chapters is
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中实现的一个简单存储库是
- en: '`rentomatic/repository/memrepo.py`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`rentomatic/repository/memrepo.py`'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'whose interface is made of two parts: the initialisation and the method `list`.
    The method `__init__` accepts values because this specific object doesn''t act
    as long-term storage, so we are forced to pass some data every time we instantiate
    the class.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 其接口由两部分组成：初始化和方法`list`。`__init__`方法接受值，因为这个特定的对象并不作为长期存储，所以我们每次实例化类时都必须传递一些数据。
- en: A repository based on a proper database will not need to be filled with data
    when initialised, its main job being that of storing data between sessions, but
    will nevertheless need to be initialised at least with the database address and
    access credentials.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基于适当数据库的存储库在初始化时不需要填充数据，其主要任务是存储会话之间的数据，但仍然至少需要使用数据库地址和访问凭证进行初始化。
- en: Furthermore, we have to deal with a proper external system, so we have to devise
    a strategy to test it, as this might require a running database engine in the
    background. Remember that we are creating a specific implementation of a repository,
    so everything will be tailored to the actual database system that we will choose.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们必须处理一个适当的外部系统，因此我们必须制定一个测试它的策略，因为这可能需要一个在后台运行的数据库引擎。记住，我们正在创建一个特定实现的数据存储库，所以一切都将根据我们将选择的实际数据库系统进行定制。
- en: A repository based on PostgreSQL
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于PostgreSQL的存储库
- en: Let's start with a repository based on a popular SQL database, [PostgreSQL](https://www.postgresql.org).
    It can be accessed from Python in many ways, but the best one is probably through
    the [SQLAlchemy](https://www.sqlalchemy.org) interface. SQLAlchemy is an ORM,
    a package that maps objects (as in object-oriented) to a relational database.
    ORMs can normally be found in web frameworks like Django or in standalone packages
    like the one we are considering.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基于流行的SQL数据库[PostgreSQL](https://www.postgresql.org)的存储库开始。它可以通过多种方式从Python访问，但最好的可能还是通过[SQLAlchemy](https://www.sqlalchemy.org)接口。SQLAlchemy是一个ORM，一个将对象（如面向对象）映射到关系数据库的包。ORM通常可以在像Django这样的Web框架或像我们正在考虑的这样的独立包中找到。
- en: The important thing about ORMs is that they are very good examples of something
    you shouldn't try to mock. Properly mocking the SQLAlchemy structures that are
    used when querying the DB results in very complex code that is difficult to write
    and almost impossible to maintain, as every single change in the queries results
    in a series of mocks that have to be written again^([[1](#fd--4605098)]).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于ORMs的重要之处在于，它们是你不应该尝试模拟的很好的例子。正确模拟查询数据库时使用的SQLAlchemy结构会导致非常复杂的代码，难以编写且几乎无法维护，因为查询的每一个变化都会导致一系列需要重新编写的模拟^([[1](#fd--4605098)]).
- en: We need therefore to set up an integration test. The idea is to create the DB,
    set up the connection with SQLAlchemy, test the condition we need to check, and
    destroy the database. Since the action of creating and destroying the DB can be
    expensive in terms of time, we might want to do it just at the beginning and at
    the end of the whole test suite, but even with this change, the tests will be
    slow. This is why we will also need to use labels to avoid running them every
    time we run the suite. Let's face this complex task one step at a time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要设置一个集成测试。想法是创建数据库，使用SQLAlchemy建立连接，测试我们需要检查的条件，然后销毁数据库。由于创建和销毁数据库的动作在时间上可能很昂贵，我们可能只想在整个测试套件的开头和结尾执行这些操作，但即使有这个改变，测试仍然会很慢。这就是为什么我们还需要使用标签来避免每次运行套件时都运行它们。让我们一步一步面对这个复杂任务。
- en: Label integration tests
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记集成测试
- en: The first thing we need to do is to label integration tests, exclude them by
    default and create a way to run them. Since pytest supports labels, called *marks*,
    we can use this feature to add a global mark to a whole module. Create the file
    `tests/repository/postgres/test_postgresrepo.py` and put in it this code
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是标记集成测试，默认排除它们，并创建一种运行它们的方法。由于pytest支持标签，称为*标记*，我们可以使用这个特性为一个整个模块添加全局标记。创建文件`tests/repository/postgres/test_postgresrepo.py`并在其中放入以下代码
- en: '`tests/repository/postgres/test_postgresrepo.py`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/repository/postgres/test_postgresrepo.py`'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The module attribute `pytestmark` labels every test in the module with the tag
    `integration`. To verify that this works I added a `test_dummy` test function
    which always passes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模块属性`pytestmark`将模块中的每个测试标记为`integration`标签。为了验证这一点，我添加了一个总是通过的`test_dummy`测试函数。
- en: The marker should be registered in `pytest.ini`
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 标记应该在`pytest.ini`中注册
- en: '`pytest.ini`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest.ini`'
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can now run `pytest -svv -m integration` to ask pytest to run only the tests
    marked with that label. The option `-m` supports a rich syntax that you can learn
    by reading the [documentation](https://docs.pytest.org/en/latest/example/markers.html).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行`pytest -svv -m integration`来请求pytest只运行带有该标签的测试。选项`-m`支持丰富的语法，你可以通过阅读[文档](https://docs.pytest.org/en/latest/example/markers.html)来学习。
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While this is enough to run integration tests selectively, it is not enough
    to skip them by default. To do this, we can alter the pytest setup to label all
    those tests as skipped, but this will give us no means to run them. The standard
    way to implement this is to define a new command-line option and to process each
    marked test according to the value of this option.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这足以有选择地运行集成测试，但不足以默认跳过它们。为了做到这一点，我们可以修改 pytest 设置，将这些测试标记为跳过，但这将给我们没有运行它们的方法。实现这一标准的方法是定义一个新的命令行选项，并根据此选项的值处理每个标记的测试。
- en: To do it open the file `tests/conftest.py` that we already created and add the
    following code
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，请打开我们已创建的 `tests/conftest.py` 文件，并添加以下代码
- en: '`tests/conftest.py`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/conftest.py`'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first function is a hook into the pytest CLI parser that adds the option
    `--integration`. When this option is specified on the command line the pytest
    setup will contain the key `integration` with value `True`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数是 pytest CLI 解析器的钩子，它添加了 `--integration` 选项。当在命令行上指定此选项时，pytest 设置将包含键
    `integration`，其值为 `True`。
- en: The second function is a hook into the pytest setup of every single test. The
    variable `item` contains the test itself (actually a `_pytest.python.Function`
    object), which in turn contains two useful pieces of information. The first is
    the attribute `item.keywords`, that contains the test marks, alongside many other
    interesting things like the name of the test, the file, the module, and also information
    about the patches that happen inside the test. The second is the attribute `item.config`
    that contains the parsed pytest command line.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数是每个测试的 pytest 设置的钩子。变量 `item` 包含测试本身（实际上是一个 `_pytest.python.Function` 对象），它反过来包含两个有用的信息。第一个是属性
    `item.keywords`，它包含测试标记，以及许多其他有趣的事情，如测试名称、文件、模块，以及测试内部发生的补丁信息。第二个是属性 `item.config`，它包含解析后的
    pytest 命令行。
- en: So, if the test is marked with `integration` (`'integration' in item.keywords`)
    and the option `--integration` is not present (`not item.config.getvalue("integration")`)
    the test is skipped.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果测试被标记为 `integration`（`'integration' in item.keywords`）且没有指定 `--integration`
    选项（`not item.config.getvalue("integration")`），则测试将被跳过。
- en: This is the output with `--integration`
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有 `--integration` 的输出
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: and this is the output without the custom option
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在没有自定义选项时的输出
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Source code'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码*'
- en: '[https://github.com/pycabook/rentomatic/tree/ed2-c06-s01](https://github.com/pycabook/rentomatic/tree/ed2-c06-s01)*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pycabook/rentomatic/tree/ed2-c06-s01](https://github.com/pycabook/rentomatic/tree/ed2-c06-s01)*'
- en: '*Create SQLAlchemy classes*'
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*创建 SQLAlchemy 类*'
- en: '*Creating and populating the test database with initial data will be part of
    the test suite, but we need to define somewhere the tables that will be contained
    in the database. This is where SQLAlchemy''s ORM comes into play, as we will define
    those tables in terms of Python objects.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建和填充测试数据库的初始数据将是测试套件的一部分，但我们需要定义数据库中将包含的表。这正是 SQLAlchemy 的 ORM 发挥作用的地方，我们将用
    Python 对象来定义这些表。*'
- en: '*Add the packages `SQLAlchemy` and `psycopg2` to the requirements file `prod.txt`*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*将包 `SQLAlchemy` 和 `psycopg2` 添加到需求文件 `prod.txt` 中*'
- en: '*`requirements/prod.txt`*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*`requirements/prod.txt`*'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*and update the installed packages with*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*并更新已安装的包*'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Create the file `rentomatic/repository/postgres_objects.py` with the following
    content*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建一个名为 `rentomatic/repository/postgres_objects.py` 的文件，并包含以下内容*'
- en: '*`rentomatic/repository/postgres_objects.py`*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*`rentomatic/repository/postgres_objects.py`*'
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Let''s comment it section by section*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*让我们逐节注释它*'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*We need to import many things from the SQLAlchemy package to set up the database
    and to create the table. Remember that SQLAlchemy has a declarative approach,
    so we need to instantiate the object `Base` and then use it as a starting point
    to declare the tables/objects.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们需要从 SQLAlchemy 包导入许多内容来设置数据库和创建表。记住，SQLAlchemy 有一个声明式方法，因此我们需要实例化对象 `Base`，然后使用它作为声明表/对象的起点。*'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*This is the class that represents the room in the database. It is important
    to understand that this is not the class we are using in the business logic, but
    the class that defines the table in the SQL database that we will use to map the
    `Room` entity. The structure of this class is thus dictated by the needs of the
    storage layer, and not by the use cases. You might want for instance to store
    `longitude` and `latitude` in a JSON field, to allow for easier extendibility,
    without changing the definition of the domain model. In the simple case of the
    Rent-o-matic project, the two classes almost overlap, but this is not the case
    generally speaking.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是代表数据库中房间的类。重要的是要理解这并不是我们在业务逻辑中使用的类，而是定义我们将用于映射`Room`实体的SQL数据库中的表的类。因此，这个类的结构是由存储层的需要决定的，而不是由用例决定的。例如，你可能希望将`longitude`和`latitude`存储在JSON字段中，以便更容易地扩展，而不改变域模型的定义。在Rent-o-matic项目的简单情况下，这两个类几乎重叠，但一般来说并不是这样。*'
- en: '*Obviously, this means that you have to keep the storage and the domain levels
    in sync and that you need to manage migrations on your own. You can use tools
    like Alembic, but the migrations will not come directly from domain model changes.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*显然，这意味着你必须保持存储层和域层的一致性，并且你需要自己管理迁移。你可以使用像Alembic这样的工具，但迁移不会直接来自域模型的变化。*'
- en: '**Source code'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码'
- en: '[https://github.com/pycabook/rentomatic/tree/ed2-c06-s02](https://github.com/pycabook/rentomatic/tree/ed2-c06-s02)**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pycabook/rentomatic/tree/ed2-c06-s02](https://github.com/pycabook/rentomatic/tree/ed2-c06-s02)**'
- en: '**Orchestration management**'
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**编排管理**'
- en: '**When we run the integration tests the Postgres database engine must be already
    running in the background, and it must be already configured, for example, with
    a pristine database ready to be used. Moreover, when all the tests have been executed
    the database should be removed and the database engine stopped.**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**当我们运行集成测试时，Postgres数据库引擎必须在后台已经运行并配置好，例如，使用一个干净的数据库，准备好使用。此外，当所有测试执行完毕后，数据库应该被删除，数据库引擎应该停止。**'
- en: '**This is a perfect job for Docker, which can run complex systems in isolation
    with minimal configuration. We have a choice here: we might want to orchestrate
    the creation and destruction of the database with an external script or try to
    implement everything in the test suite. The first solution is what many frameworks
    use, and what I explored in my series of posts [Flask Project Setup: TDD, Docker,
    Postgres and more](https://www.thedigitalcatonline.com/blog/2020/07/05/flask-project-setup-tdd-docker-postgres-and-more-part-1/),
    so in this chapter I will show an implementation of that solution.**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**这对于Docker来说是一个完美的任务，它可以在最小配置的情况下独立运行复杂的系统。在这里我们有选择：我们可能希望使用外部脚本来编排数据库的创建和销毁，或者尝试在测试套件中实现一切。第一种解决方案是许多框架所使用的，也是我在一系列文章[Flask项目设置：TDD、Docker、Postgres等](https://www.thedigitalcatonline.com/blog/2020/07/05/flask-project-setup-tdd-docker-postgres-and-more-part-1/)中探索的，因此在本章中，我将展示该解决方案的实现。**'
- en: '**As I explained in the posts I mentioned the plan is to create a management
    script that spins up and tears down the required containers, runs the tests in
    between. The management script can be used also to run the application itself,
    or to create development setups, but in this case I will simplify it to manage
    only the tests. I highly recommend that you read those posts if you want to get
    the big picture behind the setup I will use.**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**正如我在提到的文章中解释的那样，计划是创建一个管理脚本，该脚本启动和关闭所需的容器，并在其中运行测试。管理脚本也可以用来运行应用程序本身，或者创建开发环境，但在这个例子中，我将简化它，只管理测试。我强烈建议你阅读那些文章，如果你想了解我将使用的设置背后的整体情况。**'
- en: '**The first thing we have to do if we plan to use Docker Compose is to add
    the requirement to `requirements/test.txt`**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果我们计划使用Docker Compose，我们首先要做的是将需求添加到`requirements/test.txt`中**'
- en: '**`requirements/test.txt`**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**`requirements/test.txt`**'
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**and install it running `pip install -r requirements/dev.txt`. The management
    script is the following**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**并运行`pip install -r requirements/dev.txt`来安装它。管理脚本如下**'
- en: '**`manage.py`**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**`manage.py`**'
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Let''s see what it does block by block.**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**让我们逐块看看它做了什么。**'
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Some Docker containers (like the PostgreSQL one that we will use shortly)
    depend on environment variables to perform the initial setup, so we need to define
    a function to set environment variables if they are not already initialised. We
    also define a couple of paths for configuration files.**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**一些Docker容器（例如我们很快将要使用的PostgreSQL容器）依赖于环境变量来进行初始设置，因此如果它们尚未初始化，我们需要定义一个函数来设置环境变量。我们还定义了一些配置文件的路径。**'
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**As in principle I expect to have a different configuration at least for development,
    testing, and production, I introduced `app_config_file` and `docker_compose_file`
    that return the specific file for the environment we are working in. The function
    `read_json_configuration` has been isolated from `configure_app` as it will be
    imported by the tests to initialise the database repository.**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**由于原则上我预计至少会有开发、测试和生产不同的配置，我引入了`app_config_file`和`docker_compose_file`，它们会返回我们正在工作的特定环境的文件。函数`read_json_configuration`已被从`configure_app`中分离出来，因为它将被测试导入以初始化数据库存储库。**'
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**This is a simple function that creates the Docker Compose command line that
    avoids repeating long lists of options whenever we need to orchestrate the containers.**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**这是一个简单的函数，它创建Docker Compose命令行，这样我们就不需要在编排容器时重复长列表的选项。**'
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**The function `run_sql` allows us to run SQL commands on a running Postgres
    database, and will come in handy when we will create the empty test database.
    The second function, `wait_for_logs` is a simple way to monitor the Postgres container
    and to be sure it''s ready to be used. Whenever you spin up containers programmatically
    you need to be aware that they have a certain startup time before they are ready,
    and act accordingly.**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数`run_sql`允许我们在运行的Postgres数据库上运行SQL命令，当我们要创建空测试数据库时将非常有用。第二个函数`wait_for_logs`是一种简单的方式来监控Postgres容器，并确保它已准备好使用。每次你以编程方式启动容器时，你都需要意识到它们在准备好使用之前有一个启动时间，并相应地行动。**'
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**This function is the last that we define, and the only command provided by
    our management script. First of all the application is configured with the name
    `testing`, which means that we will use the configuration file `config/testing.json`
    and the Docker Compose file `docker/testing.yml`. All these names and paths are
    just conventions that comes from the arbitrary setup of this management script,
    so you are clearly free to structure your project in a different way.**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**这是我们定义的最后一个函数，也是我们管理脚本提供的唯一命令。首先，应用程序使用名称`testing`进行配置，这意味着我们将使用`config/testing.json`配置文件和`docker/testing.yml`Docker
    Compose文件。所有这些名称和路径都只是来自这个管理脚本任意设置的惯例，因此你显然可以以不同的方式组织你的项目。**'
- en: '**The function then spins up the containers according to the Docker Compose
    file, running `docker-compose up -d`. It waits for the log message that communicates
    the database is ready to accept connections and runs the SQL command that creates
    the testing database.**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**该函数随后根据Docker Compose文件启动容器，运行`docker-compose up -d`。它等待日志消息表明数据库已准备好接受连接，并运行创建测试数据库的SQL命令。**'
- en: '**After this it runs Pytest with a default set of options, adding all the options
    that we will provide on the command line, and eventually tears down the Docker
    Compose containers.**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**之后，它使用默认选项运行Pytest，并添加我们将在命令行上提供的所有选项，最后拆除Docker Compose容器。**'
- en: '**To complete the setup we need to define a configuration file for Docker Compose**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**为了完成设置，我们需要为Docker Compose定义一个配置文件**'
- en: '**`docker/testing.yml`**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**`docker/testing.yml`**'
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**And finally a JSON configuration file**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**最后是一个JSON配置文件**'
- en: '**`config/testing.json`**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**`config/testing.json`**'
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**A couple of notes about this configuration. First of all it defines both
    `FLASK_ENV` and `FLASK_CONFIG`. The first is, as you might remember, and internal
    Flask variable that can only be `development` or `production`, and is connected
    with the internal debugger. The second is the variable that we use to configure
    our Flask application with the objects in `application/config.py`. For testing
    purposes we set `FLASK_ENV` to `production` as we don''t need the internal debugger,
    and `FLASK_CONFIG` to `testing`, which will resul in the application being configured
    with the class `TestingConfig`. This class sets the internal Flask parameter `TESTING`
    to `True`.**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于此配置的一些注意事项。首先，它定义了`FLASK_ENV`和`FLASK_CONFIG`。第一个，你可能还记得，是一个内部Flask变量，它只能是`development`或`production`，并且与内部调试器相关联。第二个是我们用来使用`application/config.py`中的对象配置Flask应用程序的变量。为了测试目的，我们将`FLASK_ENV`设置为`production`，因为我们不需要内部调试器，并将`FLASK_CONFIG`设置为`testing`，这将导致应用程序使用`TestingConfig`类进行配置。这个类将内部Flask参数`TESTING`设置为`True`。**'
- en: '**The rest of the JSON configuration initialises variables whose names start
    with the prefix `POSTGRES_`. These are variables required by the Postgres Docker
    container. When the container is run, it automatically creates a database with
    the name specified by `POSTGRES_DB`. It also creates a user with a password, using
    the values specified in `POSTGRES_USER` and `POSTGRES_PASSWORD`.**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**其余的JSON配置初始化了以`POSTGRES_`为前缀的变量。这些是Postgres Docker容器所需的变量。当容器运行时，它将自动创建一个名为`POSTGRES_DB`指定的数据库。它还创建了一个用户和密码，使用`POSTGRES_USER`和`POSTGRES_PASSWORD`中指定的值。**'
- en: '**Last, I introduced the variable `APPLICATION_DB` because I want to create
    a specific database which is not the one the default one. The default port `POSTGRES_PORT`
    has been changed from the standard value 5432 to 5433 to avoid clashing with any
    database already running on the machine (either natively or containerised). As
    you can see in the Docker Compose configuration file this changes only the external
    mapping of the container and not the actual port the database engine is using
    inside the container.**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**最后，我引入了`APPLICATION_DB`变量，因为我想要创建一个特定的数据库，而不是默认的数据库。默认端口`POSTGRES_PORT`已从标准值5432更改为5433，以避免与机器上已运行的任何数据库（无论是本地还是容器化）冲突。如您在Docker
    Compose配置文件中所见，这仅更改了容器的外部映射，而不是数据库引擎在容器内部实际使用的端口。**'
- en: '**With all these files in place we are ready to start designing our tests.**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**有了所有这些文件，我们就准备好开始设计我们的测试了。**'
- en: '***Source code'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '***源代码'
- en: '[https://github.com/pycabook/rentomatic/tree/ed2-c06-s03](https://github.com/pycabook/rentomatic/tree/ed2-c06-s03)***'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pycabook/rentomatic/tree/ed2-c06-s03](https://github.com/pycabook/rentomatic/tree/ed2-c06-s03)*'
- en: '***Database fixtures***'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '***数据库固定值***'
- en: '***As we defined the configuration of the database in a JSON file we need a
    fixture that loads that same configuration, so that we can connect to the database
    during the tests. As we already have the function `read_json_configuration` in
    the management script we just need to wrap that. This is a fixture that is not
    specific to the Postgres repository, so I will introduce it in `tests/conftest.py`***'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '***由于我们在JSON文件中定义了数据库的配置，我们需要一个固定值来加载相同的配置，这样我们就可以在测试期间连接到数据库。由于我们已经在管理脚本中有了`read_json_configuration`函数，我们只需要将其包装起来。这是一个不是特定于Postgres存储库的固定值，所以我将在`tests/conftest.py`中介绍它***'
- en: '***`tests/conftest.py`***'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '***`tests/conftest.py`***'
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***As you can see I hardcoded the name of the configuration file for simplicity''s
    sake. Another solution might be to create an environment variable with the application
    configuration in the management script and to read it from here.***'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '***如您所见，为了简单起见，我硬编码了配置文件的名称。另一种解决方案可能是在管理脚本中创建一个包含应用程序配置的环境变量，并从这里读取它。***'
- en: '***The rest of the fixtures contains code that is specific to Postgres, so
    it is better to keep the code separated in a more specific file `conftest.py`***'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '***其余的固定值包含特定于Postgres的代码，因此最好将这些代码分离到更具体的文件`conftest.py`中***'
- en: '***`tests/repository/postgres/conftest.py`***'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '***`tests/repository/postgres/conftest.py`***'
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***The first fixture `pg_session_empty` creates a session to the empty initial
    database, while `pg_test_data` defines the values that we will load into the database.
    As we are not mutating this set of values we don''t need to create a fixture,
    but this is the easier way to make it available both to the other fixtures and
    to the tests. The last fixture `pg_session` fills the database with Postgres objects
    created with the test data. Pay attention that these are not entities, but the
    Postgres objects we created to map them.***'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '***第一个测试固定项`pg_session_empty`创建了一个到空初始数据库的会话，而`pg_test_data`定义了我们将要加载到数据库中的值。由于我们不会修改这组值，我们不需要创建测试固定项，但这是使其对其他测试固定项和测试都可用的一种更简单的方法。最后一个测试固定项`pg_session`使用测试数据填充数据库，这些数据是Postgres对象，我们创建了它们来映射这些对象。请注意，这些不是实体，而是我们创建来映射它们的Postgres对象。***'
- en: '***Note that this last fixture has a `function` scope, thus it is run for every
    test. Therefore, we delete all rooms after the yield returns, leaving the database
    exactly as it was before the test. Generally speaking you should always clean
    up after tests. The endpoint we are testing does not write to the database so
    in this specific case there is no real need to clean up, but I prefer to implement
    a complete solution from step zero.***'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '***请注意，最后一个测试固定项具有`function`作用域，因此它对每个测试都会运行。因此，在`yield`返回后，我们删除所有房间，使数据库的状态与测试之前完全相同。一般来说，你应该总是在测试后进行清理。我们正在测试的端点不会写入数据库，所以在这个特定情况下，实际上没有必要进行清理，但我更喜欢从零开始实现一个完整的解决方案。***'
- en: '***We can test this whole setup changing the function `test_dummy` so that
    it fetches all the rows of the table `Room` and verifying that the query returns
    4 values.***'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '***我们可以通过更改`test_dummy`函数，使其获取`Room`表的全部行，并验证查询返回4个值来测试整个设置。***'
- en: '***The new version of `tests/repository/postgres/test_postgresrepo.py` is***'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '***`tests/repository/postgres/test_postgresrepo.py`的新版本是***'
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***At this point you can run the test suite with integration tests. You should
    notice a clear delay when pytest executes the function `test_dummy` as Docker
    will take some time to spin up the database container and prepare the data***'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '***在这个阶段，你可以运行带有集成测试的测试套件。你应该会注意到当pytest执行`test_dummy`函数时会有明显的延迟，因为Docker需要一些时间来启动数据库容器并准备数据***'
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***Note that to pass the option `--integration` we need to use `--` otherwise
    Click would consider the option as belonging to the script `./manage.py` instead
    of passing it as a pytest argument.***'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '***请注意，要传递`--integration`选项，我们需要使用`--`，否则Click会将该选项视为属于脚本`./manage.py`的一部分，而不是将其作为pytest参数传递。***'
- en: '****Source code'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '****源代码'
- en: '[https://github.com/pycabook/rentomatic/tree/ed2-c06-s04](https://github.com/pycabook/rentomatic/tree/ed2-c06-s04)****'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pycabook/rentomatic/tree/ed2-c06-s04](https://github.com/pycabook/rentomatic/tree/ed2-c06-s04)****'
- en: '***Integration tests***'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '***集成测试***'
- en: '***At this point we can create the real tests in the file `test_postgresrepo.py`,
    replacing the function `test_dummy`. All test receive the fixtures `app_configuration`,
    `pg_session`, and `pg_test_data`. The first fixture allows us to initialise the
    class `PostgresRepo` using the proper parameters. The second creates the database
    using the test data that is then contained in the third fixture.***'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '***在这个阶段，我们可以在`test_postgresrepo.py`文件中创建真正的测试，替换`test_dummy`函数。所有测试都接收`app_configuration`、`pg_session`和`pg_test_data`测试固定项。第一个测试固定项允许我们使用适当的参数初始化`PostgresRepo`类。第二个使用测试数据创建数据库，这些数据随后包含在第三个测试固定项中。***'
- en: '***The tests for this repository are basically a copy of the ones created for
    `MemRepo`, which is not surprising. Usually, you want to test the very same conditions,
    whatever the storage system. Towards the end of the chapter we will see, however,
    that while these files are initially the same, they can evolve differently as
    we find bugs or corner cases that come from the specific implementation (in-memory
    storage, PostgreSQL, and so on).***'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '***这个存储库的测试基本上是创建用于`MemRepo`的测试的副本，这并不奇怪。通常，你想要测试完全相同的条件，无论存储系统是什么。然而，在章节的末尾，我们将看到，尽管这些文件最初是相同的，但当我们发现来自特定实现（内存存储、PostgreSQL等）的bug或边缘情况时，它们可以以不同的方式发展。***'
- en: '***`tests/repository/postgres/test_postgresrepo.py`***'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '***`tests/repository/postgres/test_postgresrepo.py`***'
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***Remember that I introduced these tests one at a time and that I''m not showing
    you the full TDD workflow only for brevity''s sake. The code of the class `PostgresRepo`
    has been developed following a strict TDD approach, and I recommend you to do
    the same. The resulting code goes in `rentomatic/repository/postgresrepo.py`,
    the same directory where we created the file `postgres_objects.py`.***'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '***记住，我是一次介绍一个这些测试的，并且我没有展示完整的TDD工作流程，只是为了简洁起见。`PostgresRepo`类的代码是按照严格的TDD方法开发的，我建议你也这样做。生成的代码放在`rentomatic/repository/postgresrepo.py`，与我们在其中创建了`postgres_objects.py`文件的同一个目录中。***'
- en: '***`rentomatic/repository/postgresrepo.py`***'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '***`rentomatic/repository/postgresrepo.py`***'
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '****Source code'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '****源代码'
- en: '[https://github.com/pycabook/rentomatic/tree/ed2-c06-s05](https://github.com/pycabook/rentomatic/tree/ed2-c06-s05)****'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pycabook/rentomatic/tree/ed2-c06-s05](https://github.com/pycabook/rentomatic/tree/ed2-c06-s05)****'
- en: '***You might notice that `PostgresRepo` is very similar to `MemRepo`. This
    is the case because the case we are dealing with here, the list of `Room` objects,
    is pretty simple, so I don''t expect great differences between an in-memory database
    an a production-ready relational one. As the use cases get more complex you will
    need to start leveraging the features provided by the engine that you are using,
    and methods such as `list` might evolve to become very different.***'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '***你可能注意到`PostgresRepo`与`MemRepo`非常相似。这是因为我们在这里处理的案例，即`Room`对象列表，相当简单，所以我不会期望内存数据库和现成的生产级关系型数据库之间有太大的差异。随着用例变得更加复杂，你将需要开始利用你使用的引擎提供的功能，例如`list`方法可能会演变成非常不同的形式。***'
- en: '***Note that the method `list` returns domain models, which is allowed as the
    repository is implemented in one of the outer layers of the architecture.***'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '***请注意，`list`方法返回领域模型，这是允许的，因为存储库是在架构的外层之一实现的。***'
- en: '* * *'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '***As you can see, while setting up a proper integration testing environment
    is not trivial, the changes that our architecture required to work with a real
    repository are very limited. I think this is a good demonstration of the flexibility
    of a layered approach such as the one at the core of the clean architecture.***'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '***正如你所见，虽然设置一个合适的集成测试环境并不简单，但我们的架构为了与真实存储库一起工作所需要的变化非常有限。我认为这是清洁架构核心分层方法灵活性的良好证明。***'
- en: '***Since this chapter mixed the setup of the integration testing with the introduction
    of a new repository, I will dedicate the next chapter purely to introduce a repository
    based on MongoDB, using the same structure that I created in this chapter. Supporting
    multiple databases (in this case even relational and non-relational) is not an
    uncommon pattern, as it allows you to use the approach that best suits each use
    case.***'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '***由于本章将集成测试的设置与引入新的存储库结合起来，所以我将在下一章专门介绍一个基于MongoDB的存储库，使用与本章相同的结构。支持多个数据库（在这种情况下甚至包括关系型和非关系型）并不是一个不常见的模式，因为它允许你使用最适合每个用例的方法。***'
- en: '***[1](#fr--4605098)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '***[1](#fr--4605098)'
- en: Unless you consider things like `sessionmaker_mock()().query.assert_called_with(Room)`
    something attractive. And this was by far the simplest mock I had to write.***
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你认为像`sessionmaker_mock()().query.assert_called_with(Room)`这样的东西很有吸引力。这绝对是我必须写的最简单的模拟之一。***
