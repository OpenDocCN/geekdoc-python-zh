- en: Web Browser Engineering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络浏览器工程
- en: 来源：[http://browser.engineering/onepage.html#invalidation](http://browser.engineering/onepage.html#invalidation)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[http://browser.engineering/onepage.html#invalidation](http://browser.engineering/onepage.html#invalidation)
- en: Pavel Panchekha & Chris Harrelson; one page edition
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Pavel Panchekha & Chris Harrelson；单页版
- en: '[Twitter](https://twitter.com/browserbook) · [Blog](https://browserbook.substack.com/)
    · [Discussions](https://github.com/browserengineering/book/discussions)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[Twitter](https://twitter.com/browserbook) · [博客](https://browserbook.substack.com/)
    · [讨论](https://github.com/browserengineering/book/discussions)'
- en: Preface
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前言
- en: The Preface to [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[《网络浏览器工程》前言](./index.html "目录")'
- en: '[Reading This Book](#reading-this-book)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何阅读这本书](#reading-this-book)'
- en: '[Acknowledgments](#acknowledgments)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[致谢](#acknowledgments)'
- en: '[A final note](#a-final-note)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[最后的笔记](#a-final-note)'
- en: 'A computer science degree traditionally includes courses in operating systems,
    compilers, and databases that replace mystery with code. These courses transform
    Linux, Postgres, and LLVM into improvements, additions, and optimizations of an
    understandable core architecture. The lesson transcends the specific system studied:
    *all* computer systems, no matter how big and seemingly complex, can be studied
    and understood.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学学位传统上包括操作系统、编译器和数据库等课程，用代码取代了神秘感。这些课程将Linux、Postgres和LLVM转化为可理解的核心架构的改进、添加和优化。这个教训超越了所研究的特定系统：*所有*计算机系统，无论大小和看似多么复杂，都可以被研究和理解。
- en: But web browsers are still opaque, not just to students but to industry programmers
    and even to researchers. This book dissipates that mystery by systematically explaining
    all major components of a modern web browser.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，网络浏览器仍然是不透明的，不仅对学生，对行业程序员甚至对研究人员也是如此。这本书通过系统地解释现代网络浏览器的主要组成部分来消解这种神秘感。
- en: Reading This Book
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何阅读这本书
- en: Parts 1–3 of this book construct a basic browser weighing in at around 1000
    lines of code, twice that after exercises. The average chapter takes 4–6 hours
    to read, implement, and debug for someone with a few years’ programming experience.
    Part 4 of this book covers advanced topics; those chapters are longer and have
    more code. The final browser weighs in at about 3000 lines.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一部分到第三部分构建了一个基本的浏览器，大约有1000行代码，练习后是两倍。对于有几年编程经验的人来说，平均每章需要4-6小时来阅读、实现和调试。本书的第四部分涵盖了高级主题；这些章节更长，代码更多。最终的浏览器大约有3000行。
- en: Your browserThis book assumes that you will be building a web browser along
    the way while reading it. However, it does present nearly all the code—inlined
    into the book—for a working browser for every chapter. So most of the time, the
    book uses the term “our browser”, which refers to the conceptual browser we (you
    and us, the authors) have built so far. In cases where the book is referring specifically
    to the implementation you have built, the book says “your browser”. will “work”
    at each step of the way, and every chapter will build upon the last.This idea
    is from [J. R. Wilcox](https://jamesrwilcox.com), inspired in turn by [S. Zdancewic’s](https://www.cis.upenn.edu/~stevez/)
    course on compilers. That way, you will also practice growing and improving complex
    software. If you feel particularly interested in some component, please do flesh
    it out, complete the exercises, and add missing features. We’ve tried to arrange
    it so that this doesn’t make later chapters more difficult.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你的浏览器这本书假设你在阅读的过程中会构建一个网络浏览器。然而，它几乎展示了每一章中用于工作浏览器的所有代码——直接内嵌在书中。所以，大多数时候，这本书使用“我们的浏览器”这个术语，指的是我们（你和我们，作者）迄今为止构建的概念性浏览器。在书中具体提到你构建的实现时，会说“你的浏览器”。它将在每个步骤中“工作”，并且每一章都将建立在上一章的基础上。这个想法来自[J.
    R. Wilcox](https://jamesrwilcox.com)，他反过来又受到了[S. Zdancewic的](https://www.cis.upenn.edu/~stevez/)编译器课程的影响。这样，你也将练习增长和改进复杂软件。如果你对某个组件特别感兴趣，请务必完善它，完成练习，并添加缺失的功能。我们尽量安排得让这不会使后面的章节更难。
- en: The code in this book uses [Python 3](https://browserbook.substack.com/p/why-python),
    and we recommend you follow along in the same. When the book shows Python command
    lines, it calls the Python binary `python3`.This is for clarity. On some operating
    systems, `python` means Python 3, but on others that means Python 2\. Check which
    version you have! That said, the text avoids dependencies where possible and you
    can try to follow along in another language. Make sure your language has libraries
    for TLS connections (Python has one built in), graphics (the text uses Tk, Skia,
    and SDL), and JavaScript evaluation (the text uses DukPy).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码使用[Python 3](https://browserbook.substack.com/p/why-python)，我们建议你跟随同样的版本。当本书展示Python命令行时，它调用Python的二进制文件`python3`。这样做是为了清晰。在某些操作系统上，`python`意味着Python
    3，但在其他操作系统上则意味着Python 2。检查你拥有哪个版本！尽管如此，文本尽可能避免依赖，你可以尝试用另一种语言跟随。确保你的语言有TLS连接（Python内置了一个）、图形（文本使用Tk、Skia和SDL）和JavaScript评估（文本使用DukPy）的库。
- en: 'This book’s browser is irreverent toward standards: it handles only a sliver
    of the full HTML, CSS, and JavaScript languages, mishandles errors, and isn’t
    resilient to malicious inputs. It is also quite slow. Despite that, its architecture
    matches that of real browsers, providing insight into those 10 million line of
    code behemoths.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的浏览器对标准不敬：它只处理一小部分完整的HTML、CSS和JavaScript语言，错误处理不当，且对恶意输入缺乏抵抗力。它也相当慢。尽管如此，其架构与真实浏览器相匹配，为那些一千万行代码的巨兽提供了洞察。
- en: That said, we’ve tried to explicitly note when the book’s browser simplifies
    or diverges from standards. If you’re not sure how your browser should behave
    in some edge case, fire up your favorite web browser and try it out.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们已尽力明确指出本书的浏览器在简化或偏离标准时的行为。如果你不确定你的浏览器在某些边缘情况下应该如何表现，请打开你最喜欢的网络浏览器并尝试一下。
- en: Acknowledgments
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 致谢
- en: We’d like to recognize the countless people who built the web and the various
    web browsers. They are wonders of the modern world. Thank you! We learned a lot
    from the books and articles listed in this book’s [bibliography](bibliography.html)—thank
    you to their authors. And we’re especially grateful to the many contributors to
    articles on Wikipedia (especially those on historic software, formats, and protocols).
    We are grateful for this amazing resource, one which in turn was made possible
    by the very thing this book is about.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想感谢那些构建了网络和各种网络浏览器的人们。他们是现代世界的奇迹。谢谢！我们从这本书的[参考文献](bibliography.html)中列出的书籍和文章中学到了很多——感谢这些文章的作者。我们还特别感谢为维基百科上的文章（尤其是关于历史软件、格式和协议的文章）做出贡献的许多人。我们对这个惊人的资源感到感激，而这个资源正是这本书所讨论的东西使得这一切成为可能。
- en: '*Pavel*: [James R. Wilcox](https://jamesrwilcox.com) and I dreamed up this
    book during a late-night chat at ICFP 2018\. [Max Willsey](https://www.mwillsey.com/)
    proofread and helped sequence the chapters. [Zach Tatlock](https://homes.cs.washington.edu/~ztatlock/)
    encouraged me to develop the book into a course. And the students of CS 6968,
    CS 4962, and CS 4560 at the University of Utah found countless errors and suggested
    important simplifications. I am thankful to all of them. Most of all, I am thankful
    to my wife [Sara](https://www.sscharmingds.com/), who supported my writing and
    gave me the strength to finish this many-year-long project.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pavel*: [James R. Wilcox](https://jamesrwilcox.com)和我是在2018年ICFP的深夜聊天中构思这本书的。[Max
    Willsey](https://www.mwillsey.com/)校对了书籍并帮助编排章节。[Zach Tatlock](https://homes.cs.washington.edu/~ztatlock/)鼓励我把这本书发展成一门课程。犹他大学的CS
    6968、CS 4962和CS 4560的学生发现了无数错误，并提出了重要的简化建议。我要感谢他们所有人。最重要的是，我要感谢我的妻子[Sara](https://www.sscharmingds.com/)，她支持我的写作，给了我完成这个多年项目的力量。'
- en: '*Chris*: I am eternally grateful to my wife Sara for patiently listening to
    my endless musings about the web, and encouraging me to turn my idea for a browser
    book into reality. I am also grateful to [Dan Gildea](https://www.cs.rochester.edu/u/gildea/)
    for providing feedback on my browser-book concept on multiple occasions. Finally,
    I’m grateful to Pavel for doing the hard work of getting this project off the
    ground and allowing me to join the adventure. (Turns out Pavel and I had the same
    idea!)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chris*: 我永远感激我的妻子Sara，她耐心地倾听我关于网络的无限遐想，并鼓励我把浏览器书籍的想法变成现实。我也感激[Dan Gildea](https://www.cs.rochester.edu/u/gildea/)在多个场合对我的浏览器书籍概念提供反馈。最后，我要感谢Pavel，他做了艰苦的工作，使这个项目得以启动，并让我加入这次冒险。（结果发现Pavel和我有同样的想法！）'
- en: A final note
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的备注
- en: This book is, and will remain, a work in progress. Please leave comments and
    mark typos; the book has built-in feedback tools, which you can enable with `Ctrl-E`
    (or `Cmd-E` on a Mac). The full source code is also available [on GitHub](https://github.com/browserengineering/book),
    though we prefer to receive comments through the built-in tools.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书现在是这样，将来也将继续是正在进行中的作品。请留下评论并标记错别字；这本书内置了反馈工具，您可以通过`Ctrl-E`（或在Mac上为`Cmd-E`）启用它们。完整的源代码也可在[GitHub](https://github.com/browserengineering/book)上找到，尽管我们更喜欢通过内置工具接收评论。
- en: Browsers and the Web
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器与互联网
- en: The Introduction to [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[网络浏览器工程导论](./index.html "目录")'
- en: '[The Browser and Me](#the-browser-and-me)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[浏览器与我](#the-browser-and-me)'
- en: '[The Web in History](#the-web-in-history)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[互联网的历史](#the-web-in-history)'
- en: '[Real Browser Codebases](#real-browser-codebases)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[真实浏览器代码库](#real-browser-codebases)'
- en: '[Browser Code Concepts](#browser-code-concepts)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[浏览器代码概念](#browser-code-concepts)'
- en: '[The Role of the Browser](#the-role-of-the-browser)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[浏览器的作用](#the-role-of-the-browser)'
- en: '[Browsers and You](#browsers-and-you)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[浏览器与您](#browsers-and-you)'
- en: I—this is Chris speaking—have known the webBroadly defined, the web is the interlinked
    network (“web”) of [web pages](https://en.wikipedia.org/wiki/Web_page) on the
    internet. If you’ve never made a web page, I recommend MDN’s [Learn Web Development](https://developer.mozilla.org/en-US/docs/Learn)
    series, especially the [Getting Started](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web)
    guide. This book will be easier to read if you’re familiar with the core technologies.
    for all of my adult life. The web for me is something of a technological companion,
    and I’ve never been far from it in my studies or my work. Perhaps it’s been the
    same for you. And using the web means using a browser. I hope, as you read this
    book, that you fall in love with web browsers, just like I did.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我——这是克里斯在说话——从我成年以来一直了解互联网。广义上讲，互联网是互联网上[网页](https://en.wikipedia.org/wiki/Web_page)的相互链接的网络（“互联网”）。如果您从未制作过网页，我推荐MDN的[学习网络开发](https://developer.mozilla.org/en-US/docs/Learn)系列，特别是[入门指南](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web)。如果您熟悉核心技术，这本书将更容易阅读。对我来说，互联网是一种技术伴侣，我在学习和工作中从未远离它。也许对您来说也是如此。使用互联网意味着使用浏览器。我希望，当您阅读这本书时，您会像我一样爱上网络浏览器。
- en: The Browser and Me
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器与我
- en: Since I first encountered the web and its predecessors,For me, [bulletin board
    systems (BBSs)](https://en.wikipedia.org/wiki/Bulletin_board_system) over a dial-up
    modem connection. A BBS, like a browser, is a window into dynamic content somewhere
    else on the internet. in the early 1990s, I’ve been fascinated by browsers and
    the concept of networked user interfaces. When I [surfed](https://www.pcmag.com/encyclopedia/term/web-surfing)
    the web, even in its earliest form, I felt I was seeing the future of computing.
    In some ways, the web and I grew together—for example, 1994, the year the web
    went commercial, was the same year I started college; while there I spent a fair
    amount of time surfing the web, and by the time I graduated in 1999, the browser
    had fueled the famous dot-com speculation gold rush. Not only that, but the company
    for which I now work, Google, is a child of the web and was founded during that
    time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我第一次接触到互联网及其前身以来，对我来说，通过拨号调制解调器连接的[公告板系统（BBS）](https://en.wikipedia.org/wiki/Bulletin_board_system)就像浏览器的窗口一样，是通向互联网上其他动态内容的窗口。在20世纪90年代初，我对浏览器和网络用户界面的概念着迷。当我[冲浪](https://www.pcmag.com/encyclopedia/term/web-surfing)互联网，即使在其最早的形式中，我也觉得我正在看到计算的未来。在某种程度上，互联网和我一起成长——例如，1994年，互联网开始商业化的那一年，也是我上大学的那一年；在那里，我花了很多时间冲浪互联网，到1999年我毕业时，浏览器已经推动了著名的互联网泡沫投机热潮。不仅如此，我现在工作的公司，谷歌，也是互联网的孩子，它是在那个时期成立的。
- en: 'In my freshman year at college, I attended a presentation by a RedHat salesman.
    The presentation was of course aimed at selling RedHat Linux, probably calling
    it the “operating system of the future” and speculating about the “year of the
    Linux desktop”. But when asked about challenges RedHat faced, the salesman mentioned
    not Linux but *the web*: he said that someone “needs to make a good browser for
    Linux”.Netscape Navigator was available for Linux at that time, but it wasn’t
    viewed as especially fast or featureful compared to its implementation on other
    operating systems. Even back then, in the first years of the web, the browser
    was already a necessary component of every computer. He even threw out a challenge:
    “How hard could it be to build a better browser?” Indeed, how hard could it be?
    What makes it so hard? That question stuck with me for a long time.Meanwhile,
    the “better Linux browser than Netscape” took a long time to appear…'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我大学一年级的时候，我参加了一场RedHat销售员的演讲。当然，这次演讲的目的是推销RedHat Linux，可能称之为“未来的操作系统”，并对“Linux桌面年”进行猜测。但当被问及RedHat面临的挑战时，销售员提到的是不是Linux，而是*网络*：他说“需要有人为Linux开发一个优秀的浏览器”。当时，Netscape
    Navigator已经可以在Linux上使用，但与在其他操作系统上的实现相比，它并不被视为特别快速或功能丰富。即使在那时，在网络的早期几年，浏览器已经是每台电脑的必要组件。他甚至提出了一个挑战：“构建一个更好的浏览器有多难？”的确，这能有多难呢？是什么让它如此困难？这个问题困扰了我很长时间。与此同时，“比Netscape更好的Linux浏览器”出现得花了很长时间…
- en: 'How hard indeed! After eleven years in the trenches working on Chrome, I now
    know the answer to his question: building a browser is both easy and incredibly
    hard, both intentional and accidental. And everywhere you look, you see the evolution
    and history of the web wrapped up in one codebase. It’s fun and endlessly interesting.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 确实很难！在Chrome的战场上工作了十一年之后，我现在知道他问题的答案：构建一个浏览器既简单又极其困难，既有意为之，也有偶然因素。无论你往哪里看，你都能看到网络的演变和历史被包裹在一个代码库中。这很有趣，而且永远都充满趣味。
- en: So that’s how I fell in love with web browsers. Now let me tell you why you
    will, too.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是我爱上网络浏览器的原因。现在，让我告诉你为什么你也会爱上它。
- en: The Web in History
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 历史上的网络
- en: The web is a grand, crazy experiment. It’s natural, nowadays, to watch videos,
    read news, and connect with friends on the web. That can make the web seem simple
    and obvious, finished, already built. But the web is neither simple nor obvious
    (and is certainly not finished). It is the result of experiments and research,
    reaching back to nearly the beginning of computing,And the web *also* needed rich
    computer displays, powerful user-interface-building libraries, fast networks,
    and sufficient computing power and information storage capacity. As so often happens
    with technology, the web had many similar predecessors, but only took its modern
    form once all the pieces came together. about how to help people connect and learn
    from each other.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是一个宏伟而疯狂的实验。如今，在网上观看视频、阅读新闻和与朋友联系是自然而然的事情。这可能会让网络看起来简单而明显，已经完成，已经建成。但网络既不简单也不明显（当然，也远未完成）。它是实验和研究的结果，追溯到计算机的几乎开始，网络*还需要丰富的计算机显示、强大的用户界面构建库、快速的网络、足够的计算能力和信息存储容量。正如技术经常发生的那样，网络有许多类似的前驱，但只有在所有部件都集齐之后，才采取了现代的形式。关于如何帮助人们相互连接和学习的想法。
- en: In the early days, the internet was a world-wide network of computers, largely
    at universities, labs, and major corporations, linked by physical cables and communicating
    over application-specific protocols. The (very) early web mostly built on this
    foundation. Web pages were files in a specific format stored on specific computers.
    The addresses for web pages named the computer and the file, and early servers
    did little besides read files from a disk. The logical structure of the web mirrored
    its physical structure.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，互联网是一个全球性的计算机网络，主要由大学、实验室和大型企业组成，通过物理电缆连接，并通过特定应用程序的协议进行通信。非常早期的网络主要建立在这样一个基础上。网页是以特定格式存储在特定计算机上的文件。网页的地址命名了计算机和文件，早期的服务器除了从磁盘读取文件外，几乎不做其他事情。网络的逻辑结构反映了其物理结构。
- en: A lot has changed. The HyperText Markup Language (HTML) for web pages is now
    usually dynamically assembled on the fly“Server-side rendering” is the process
    of assembling HTML on the server when loading a web page. Server-side rendering
    can use web technologies like JavaScript and even [headless browsers](https://en.wikipedia.org/wiki/Headless_browser).
    Yet one more place browsers are taking over! and sent on demand to your browser.
    The pieces being assembled are themselves filled with dynamic content—news, inbox
    contents, and advertisements adjusted to your particular tastes. Even the addresses
    no longer identify a specific computer—content distribution networks route requests
    to any of thousands of computers all around the world. At a higher level, most
    web pages are served not from someone’s home computerPeople actually did this!
    And when their website became popular, it often ran out of bandwidth or computing
    power and became inaccessible. but from a major corporation’s social media platform
    or cloud computing service.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 变化很大。网页的**超文本标记语言 (HTML**)现在通常是在线动态组装的，“服务器端渲染”是在加载网页时在服务器上组装 HTML 的过程。服务器端渲染可以使用像
    JavaScript 这样的网络技术，甚至可以使用[无头浏览器](https://en.wikipedia.org/wiki/Headless_browser)。浏览器接管的地方又多了一个！并且根据需求发送到您的浏览器。正在组装的组件本身也充满了动态内容——新闻、收件箱内容以及根据您的特定口味调整的广告。甚至地址也不再标识特定的计算机——内容分发网络将请求路由到世界上成千上万的任何一台计算机。在更高层次上，大多数网页不是从某个人的家用计算机上提供服务——人们确实这样做了！当他们的网站变得流行时，它们经常因为带宽或计算能力不足而变得无法访问，但通常是从大型企业的社交媒体平台或云计算服务上提供。
- en: 'With all that’s changed, some things have stayed the same, the core building
    blocks that are the essence of the web:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管发生了所有这些变化，有些东西仍然保持不变，那就是构成网络本质的核心构建块：
- en: The web is a *network of information* linked by *hyperlinks*.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络是一个由**超链接**连接的**信息网络**。
- en: The user uses a *user agent*, called a *browser*, to navigate the web.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户使用一个称为**浏览器**的**用户代理**来浏览网络。
- en: Information is requested with the *HyperText Transfer Protocol (HTTP)* and structured
    with the *HTML document format*.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息是通过**超文本传输协议 (HTTP**)请求的，并以**HTML 文档格式**进行结构化。
- en: Documents are identified by Uniform Resource Locators (URLs), *not* by their
    content, and may be dynamically generated.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档是通过统一资源定位符 (URLs) 来标识的，**不是**通过其内容，并且可能是动态生成的。
- en: Web pages can link to auxiliary assets in different formats, including images,
    videos, Cascading Style Sheets (CSS), and JavaScript.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页可以链接到不同格式的辅助资产，包括图片、视频、层叠样式表 (CSS) 和 JavaScript。
- en: All these building blocks are open, standardized, and free to use or reuse.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些构建块都是开放的、标准化的，并且可以免费使用或重复使用。
- en: As a philosophical matter, perhaps one or another of these principles is secondary.
    One could try to distinguish between the networking and rendering aspects of the
    web. One could abstract linking and networking from the particular choice of protocol
    and data format. One could ask whether the browser is necessary in theory, or
    argue that HTTP, URLs, and hyperlinking are the only truly essential parts of
    the web.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为哲学问题，或许这些原则中的某一个或另一个是次要的。可以尝试区分网络的联网和渲染方面。可以抽象出链接和网络与特定协议和数据格式的选择。可以询问浏览器在理论上是否是必要的，或者争论
    HTTP、URL 和超链接是网络唯一真正必要的部分。
- en: Perhaps.It is indeed true that one or more of the implementation choices could
    be replaced, and perhaps that will happen over time. For example, JavaScript might
    eventually be replaced by another language or technology, HTTP by some other protocol,
    or HTML by a successor. Yet the web will stay the web, because any successor format
    is sure to support a *superset* of functionality, and have the same fundamental
    structure. The web is, after all, an experiment; the core technologies evolve
    and grow. But the web is not an accident; its original design reflects truths
    not just about computing, but about how human beings can connect and interact.
    The web not only survived but thrived during the virtualization of hosting and
    content, specifically due to the elegance and effectiveness of this original design.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 或许，确实有可能用其他的选择来替换一个或多个实现选项，也许随着时间的推移这会发生。例如，JavaScript 最终可能会被另一种语言或技术所取代，HTTP
    可能会被其他协议所取代，或者 HTML 可能会被一个后继者所取代。然而，网络将仍然是网络，因为任何后继格式都肯定支持功能**超集**，并且具有相同的根本结构。毕竟，网络是一个实验；核心技术不断发展和演变。但网络并非偶然；其原始设计不仅反映了关于计算的真实情况，还反映了人类如何连接和互动的真实情况。网络不仅在虚拟化托管和内容的过程中幸存下来，而且由于这种原始设计的优雅和有效性，它还繁荣起来。
- en: The key thing to understand is that this grand experiment is not over. The essence
    of the web will stay, but by building web browsers you have the chance to shape
    its future.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的关键是，这个伟大的实验还没有结束。网络的本质将保持不变，但通过构建网络浏览器，你有机会塑造其未来。
- en: Real Browser Codebases
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器对性能的敏感性如此之高，以至于在许多地方，仅仅引入一个抽象——一个函数调用或分支开销——就可能产生不可接受的性能成本！
- en: So let me tell you what it’s like to contribute to a browser. Some time during
    my first few months of working on Chrome, I came across the code implementing
    the[`<br>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/br) tag—look
    at that, the good old `<br>` tag, which I’ve used many times to insert newlines
    into web pages! And the implementation turns out to be barely any code at all,
    both in Chrome and in this book’s simple browser.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我告诉你为浏览器做贡献的感觉。在我开始为Chrome工作的前几个月里，我遇到了实现`<br>`标签的代码——看看那个，那个好老好的`<br>`标签，我多次用它来在网页中插入换行符！而且，实现起来几乎不需要任何代码，无论是在Chrome中还是在本书的简单浏览器中。
- en: But Chrome as a whole—its features, speed, security, reliability—*wow*. *Thousands*
    of person-years went into it. There is constant pressure to do more—to add more
    features, to improve performance, to keep up with the “web ecosystem”—for the
    thousands of businesses, millions of developers,I usually prefer “engineer”—hence
    the title of this book—but “developer” or “web developer” is much more common
    on the web. One important reason is that anyone can build a web page—not just
    trained software engineers and computer scientists. “Web developer” also is more
    inclusive of additional, critical roles like designers, authors, editors, and
    photographers. A web developer is anyone who makes web pages, regardless of how.
    and billions of users on the web.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但整体而言，Chrome——它的功能、速度、安全性、可靠性——真是令人惊叹。*数千*人年投入其中。始终有压力要做更多——添加更多功能、提高性能、跟上“网络生态系统”——对于成千上万的商业公司、数百万的开发者（我通常更喜欢“工程师”——因此这本书的标题是“工程师”——但在网络上“开发者”或“网页开发者”更为常见。一个重要原因是任何人都可以构建网页——而不仅仅是受过训练的软件工程师和计算机科学家。“网页开发者”也涵盖了其他一些关键角色，如设计师、作者、编辑和摄影师。网页开发者是指任何创建网页的人，无论其方式如何，以及网络上的数十亿用户。
- en: Working on such a codebase can feel daunting. I often find lines of code last
    touched 15 years ago by someone I’ve never met; or even now discover files and
    classes that I never knew existed; or see lines of code that don’t look necessary,
    yet turn out to be important. What does that 15-year-old code do? What is the
    purpose of these new-to-me files? Is that code there for a reason?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的代码库上工作可能会感到令人畏惧。我经常发现代码是15年前由我从未见过的人修改的；或者现在甚至发现了一些我从未知道存在的文件和类；或者看到一些看起来并不必要的代码行，但最终证明它们是重要的。那个15年前的代码做了什么？这些对我来说是新的文件有什么目的？这些代码的存在是否有原因？
- en: Every browser has thousands of unfixed bugs, from the smallest of mistakes to
    myriad mix ups and mismatches. Every browser must be endlessly tuned and optimized
    to squeeze out that last bit of performance. Every browser requires painstaking
    work to continuously refactor the code to reduce its complexity, often through
    the carefulBrowsers are so performance-sensitive that, in many places, merely
    the introduction of an abstraction—a function call or branching overhead—can have
    an unacceptable performance cost! introduction of modularization and abstraction.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个浏览器都有数千个未修复的错误，从小错误到无数的混淆和匹配错误。每个浏览器都必须不断调整和优化，以榨取最后一丝性能。每个浏览器都需要进行艰苦的工作，不断重构代码以降低其复杂性，通常是通过仔细的模块化和抽象化。
- en: What makes a browser different from most massive code bases is their *urgency*.
    Browsers are nearly as old as any “legacy” codebase, but are *not* legacy, not
    abandoned or half-deprecated, not slated for replacement. On the contrary, they
    are vital to the world’s economy. Browser engineers must therefore fix and improve
    rather than abandon and replace. And since the character of the web itself is
    highly decentralized, the use cases met by browsers are to a significant extent
    *not determined* by the companies “owning” or “controlling” a particular browser.
    Other people—including you—can and do contribute ideas, proposals, and implementations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使浏览器与大多数大型代码库不同的特点是它们的*紧迫性*。浏览器几乎和任何“遗留”代码库一样古老，但它们*不是*遗留的，没有被遗弃或半废弃，也没有计划被替换。相反，它们对世界经济至关重要。因此，浏览器工程师必须修复和改进，而不是遗弃和替换。而且，由于网络的本质高度去中心化，浏览器遇到的使用案例在很大程度上*不是*由“拥有”或“控制”特定浏览器的公司“决定”。其他人——包括你——可以并且确实在贡献想法、提案和实现。
- en: What’s amazing is that, despite the scale and the pace and the complexity, there
    is still plenty of room to contribute. Every browser today is open source, which
    opens up its implementation to the whole community of web developers. Browsers
    evolve like giant research projects, where new ideas are constantly being proposed
    and tested out. As you would expect, some features fail and some succeed. The
    ones that succeed end up in specifications and are implemented by other browsers.
    Every web browser is open to contributions—whether fixing bugs or proposing new
    features or implementing promising optimizations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，尽管规模、速度和复杂性很大，但仍有很大的贡献空间。今天每个浏览器都是开源的，这向整个网页开发者社区开放了其实现。浏览器像巨大的研究项目一样发展，新想法不断被提出和测试。正如你所期望的，一些功能失败了，而一些成功了。成功的那些建立在规范中，并由其他浏览器实现。每个网页浏览器都欢迎贡献——无论是修复错误还是提出新功能或实现有希望的优化。
- en: And it’s worth contributing, because working on web browsers is a lot of fun.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 值得贡献，因为从事网页浏览器开发是一件很有趣的事情。
- en: Browser Code Concepts
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器代码概念
- en: HTML and CSS are meant to be black boxes—declarative application programming
    interfaces (APIs)—where one specifies *what* outcome to achieve, and the *browser
    itself* is responsible for figuring out *how* to achieve it. Web developers don’t,
    and mostly can’t, draw their web pages’ pixels on their own.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 和 CSS 被设计成黑盒——声明性应用程序编程接口 (API)——在这里，你指定要达到的 *结果*，而 *浏览器本身* 负责找出 *如何* 实现它。网页开发者无法，也大多不能，自己绘制网页的像素。
- en: That can make the browser magical or frustrating—depending on whether it is
    doing the right thing! But that also makes a browser a pretty unusual piece of
    software, with unique challenges, interesting algorithms, and clever optimizations.
    Browsers are worth studying for the pure pleasure of it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以使浏览器变得神奇或令人沮丧——这取决于它是否在做正确的事情！但这也使浏览器成为一款相当不寻常的软件，具有独特的挑战、有趣的算法和巧妙的优化。浏览器值得研究，纯粹是为了乐趣。
- en: 'What makes that all work is the web browser’s implementations of [inversion
    of control](https://en.wikipedia.org/wiki/Inversion_of_control), [constraint programming](https://en.wikipedia.org/wiki/Constraint_programming),
    and [declarative programming](https://en.wikipedia.org/wiki/Declarative_programming).
    The web *inverts control*, with an intermediary—the browser—handling most of the
    rendering, and the web developer specifying rendering parameters and content to
    this intermediary. For example, in HTML there are many built-in [form control
    elements](https://developer.mozilla.org/en-US/docs/Learn/Forms/Basic_native_form_controls)
    that take care of the various ways the user of a web page can provide input. The
    developer need only specify parameters such as button names, sizing, and look-and-feel,
    or JavaScript extension points to handle form submission to the server. The rest
    of the implementation is taken care of by the browser. Further, these parameters
    usually take the form of *constraints* between the relative sizes and positions
    of on-screen elements instead of specifying their values directly;Constraint programming
    is clearest during web page layout, where font and window sizes, desired positions
    and sizes, and the relative arrangement of widgets is rarely specified directly.
    the browser solves the constraints to find those values. The same idea applies
    for actions: web pages mostly require *that* actions take place without specifying
    *when* they do. This *declarative* style means that from the point of view of
    a developer, changes “apply immediately”, but under the hood, the browser can
    be [lazy](https://en.wikipedia.org/wiki/Lazy_evaluation) and delay applying the
    changes until they become externally visible, either due to subsequent API calls
    or because the page has to be displayed to the user.For example, when exactly
    does the browser compute HTML element styles? Any change to the styles is visible
    to all subsequent API calls, so in that sense it applies “immediately”. But it
    is better for the browser to delay style recalculation, avoiding redundant work
    if styles change twice in quick succession. Maximally exploiting the opportunities
    afforded by declarative programming makes real-world browsers very complex.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那一切之所以能够运作，是因为网络浏览器的实现采用了[控制反转](https://en.wikipedia.org/wiki/Inversion_of_control)、[约束编程](https://en.wikipedia.org/wiki/Constraint_programming)和[声明式编程](https://en.wikipedia.org/wiki/Declarative_programming)。网络浏览器实现了*控制反转*，通过一个中介——浏览器——处理大部分的渲染工作，而网络开发者则向这个中介指定渲染参数和内容。例如，在HTML中，有许多内置的[表单控件元素](https://developer.mozilla.org/en-US/docs/Learn/Forms/Basic_native_form_controls)，它们负责处理网页用户可以提供的各种输入方式。开发者只需指定按钮名称、尺寸和外观等参数，或者JavaScript扩展点来处理表单提交到服务器。其余的实现工作由浏览器完成。此外，这些参数通常以屏幕元素相对大小和位置的*约束*形式存在，而不是直接指定它们的值；在网页布局中，约束编程最为清晰，字体和窗口大小、期望的位置和尺寸，以及小部件的相对排列很少直接指定。浏览器通过解决这些约束来找到相应的值。同样的理念也适用于动作：网页大多需要*执行*动作，而不需要指定*何时*执行。这种*声明式*风格意味着从开发者的角度来看，更改“立即”生效，但在底层，浏览器可以是[惰性评估](https://en.wikipedia.org/wiki/Lazy_evaluation)的，并延迟应用更改，直到它们对外部可见，无论是由于后续的API调用，还是因为页面需要显示给用户。例如，浏览器何时计算HTML元素的样式？任何样式的更改都会对所有后续的API调用可见，所以在某种程度上它“立即”生效。但浏览器延迟样式重新计算，避免在样式连续两次快速更改时进行冗余工作。最大限度地利用声明式编程带来的机会，使得现实世界的浏览器非常复杂。
- en: There are practical reasons for the unusual design of a browser. Yes, developers
    lose some control and agency—when pixels are wrong, developers cannot fix them
    directly.Loss of control is not necessarily specific to the web—much of computing
    these days relies on mountains of other people’s code. But they gain the ability
    to deploy content on the web without worrying about the details, to make that
    content instantly available on almost every computing device in existence, and
    to keep it accessible in the future, mostly avoiding software’s inevitable obsolescence.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器设计的不寻常之处有实际原因。是的，开发者失去了一些控制和能动性——当像素错误时，开发者无法直接修复它们。失去控制并不一定只针对网络——如今的大部分计算都依赖于其他人堆积如山的代码。但他们获得了在网络上部署内容的能力，无需担心细节，使内容几乎可以立即在现有的几乎所有计算设备上可用，并保持其未来的可访问性，主要避免了软件不可避免的过时。
- en: To me, browsers are where algorithms *come to life*. A browser contains a rendering
    engine more complex and powerful than any computer game; a full networking stack;
    clever data structures and parallel programming techniques; a virtual machine,
    an interpreted language, and a just-in-time compiler; a world-class security sandbox;
    and a uniquely dynamic system for storing data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，浏览器是算法**变得生动**的地方。浏览器包含的渲染引擎比任何电脑游戏都要复杂和强大；一个完整的网络堆栈；巧妙的数据结构和并行编程技术；一个虚拟机，一个解释型语言和一个即时编译器；一个世界级的沙盒；以及一个独特动态的数据存储系统。
- en: And the truth is—you use a browser all the time, maybe for reading this book!
    That makes the algorithms more approachable in a browser than almost anywhere
    else, because the web is already familiar.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上——你一直在使用浏览器，可能就是为了阅读这本书！这使得算法在浏览器中的可接近性比其他任何地方都要高，因为网络已经非常熟悉了。
- en: The Role of the Browser
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器的作用
- en: 'The web is at the center of modern computing. Every year the web expands its
    reach to more and more of what we do with computers. It now goes far beyond its
    original use for document-based information sharing: many people now spend their
    entire day in a browser, not using a single other application! Moreover, desktop
    applications are now often built and delivered as *web apps*: web pages loaded
    by a browser but used like installed applications.Related to the notion of a web
    app is a Progressive Web App, which is a web app that becomes indistinguishable
    from a native app through [progressive enhancement](https://en.wikipedia.org/wiki/Progressive_enhancement).
    Even on mobile devices, apps often embed a browser to render parts of the application
    user interface (UI).The fraction of such “hybrid” apps that are shown via a “web
    view” is likely increasing over time. In some markets like China, “super-apps”
    act like a mobile web browser for web-view-based games and widgets. Perhaps in
    the future both desktop and mobile devices will largely be containers for web
    apps. Already, browsers are a critical and indispensable part of computing.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是现代计算的中心。每年，网络都在扩展其覆盖范围，涵盖我们用计算机做的更多事情。它现在远远超出了最初用于基于文档的信息共享的使用：现在许多人整天都在浏览器中度过，不使用任何其他应用程序！此外，桌面应用程序现在通常被构建和交付为**网络应用程序**：浏览器加载的网页，但像已安装的应用程序一样使用。与网络应用程序的概念相关的是渐进式网络应用程序，它是一种通过[渐进式增强](https://en.wikipedia.org/wiki/Progressive_enhancement)变得与原生应用程序无法区分的网络应用程序。即使在移动设备上，应用程序也经常嵌入浏览器来渲染应用程序用户界面（UI）的一部分。这种“混合”应用程序中通过“网页视图”显示的比例可能随着时间的推移而增加。在一些市场，如中国，“超级应用程序”充当基于网页视图的游戏和小部件的移动网络浏览器。也许在未来，桌面和移动设备将主要成为网络应用程序的容器。已经，浏览器是计算中不可或缺的关键部分。
- en: 'So given this centrality, it’s worth knowing how the web works. And in particular,
    it’s worth focusing on the browser, which is the user agentThe user agent concept
    views a computer, or software within the computer, as a trusted assistant and
    advocate of the human user. and the mediator of the web’s interactions, which
    ultimately is what makes the web’s principles real. The browser is also the *implementer*
    of the web: its sandbox keeps web browsing safe; its algorithms implement the
    declarative document model; its UI navigates links. Web pages load fast and react
    smoothly only when the browser is hyper-efficient.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，鉴于这种中心地位，了解网络的工作原理是值得的。特别是，关注浏览器是值得的，浏览器是用户代理（用户代理概念将计算机或计算机内的软件视为人类用户的受信任助手和倡导者，以及网络交互的中介，这最终使得网络的原则变得真实。浏览器也是网络的**实施者**：它的沙盒使网络浏览安全；它的算法实现了声明性文档模型；它的用户界面导航链接。只有当浏览器超级高效时，网页才能快速加载并平滑地响应。
- en: Browsers and You
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器与您
- en: This book explains how to build a simple browser, one that can—despite its simplicity—display
    interesting-looking web pages and support many interesting behaviors. As you’ll
    see, it’s surprisingly easy, and it demonstrates all the core concepts you need
    to understand a real-world browser. The browser stops being a mystery when it
    becomes code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本书解释了如何构建一个简单的浏览器，一个尽管简单，但可以显示看起来有趣的网页并支持许多有趣行为的浏览器。正如您将看到的，这出奇地简单，它展示了您需要了解真实世界浏览器的所有核心概念。当浏览器成为代码时，它就不再是神秘的了。
- en: The intention is for you to build your own browser as you work through the early
    chapters. Once it is up and running, there are endless opportunities to improve
    performance or add features, some of which are suggested as exercises. Many of
    these exercises are features implemented in real browsers, and I encourage you
    to try them—adding features is one of the best parts of browser development!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目的是让你在阅读早期章节的过程中构建自己的浏览器。一旦它运行起来，就有无数的机会来提升性能或添加功能，其中一些作为练习被提出。许多这些练习都是真实浏览器中实现的功能，我鼓励你尝试它们——添加功能是浏览器开发中最有趣的部分之一！
- en: The book then moves on to details and advanced features that flesh out the architecture
    of a real browser’s rendering engine, based on my experiences with Chrome. After
    finishing the book, you should be able to dig into the source code of Chromium,
    Gecko, or WebKit and understand it without too much trouble.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 书接着详细介绍了基于我使用Chrome的经验，对真实浏览器渲染引擎架构的详细和高级特性进行了阐述。读完这本书后，你应该能够深入挖掘Chromium、Gecko或WebKit的源代码，而不会遇到太多麻烦。
- en: I hope the book lets you appreciate a browser’s depth, complexity, and power.
    I hope the book passes along a browser’s beauty—its clever algorithms and data
    structures, its co-evolution with the culture and history of computing, its centrality
    in our world. But most of all, I hope the book lets you see in yourself someone
    building the browser of the future.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这本书能让你欣赏浏览器的深度、复杂性和强大功能。我希望这本书能传递浏览器的美——它巧妙算法和数据结构，它与计算文化和历史的共同进化，它在我们的世界中的核心地位。但最重要的是，我希望这本书能让你看到自己正在构建未来的浏览器。
- en: History of the Web
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络历史
- en: The Background to [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[网络浏览器工程背景](./index.html "目录")。'
- en: '[The Memex Concept](#the-memex-concept)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[memex概念](#the-memex-concept)'
- en: '[The Web Emerges](#the-web-emerges)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[网络的兴起](#the-web-emerges)'
- en: '[Browsers](#browsers)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[浏览器](#browsers)'
- en: '[Web Standards](#web-standards)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Web 标准](#web-standards)'
- en: '[Open Source](#open-source)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[开源](#open-source)'
- en: '[Summary](#summary)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summary)'
- en: '[Exercises](#exercises)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: 'This chapter dives into the history of the web itself: where it came from,
    and how the web and browsers have evolved to date. This history is not exhaustive;For
    example, there is nothing much about Standard Generalized Markup Language ( [SGML](https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language))
    or other predecessors to HTML. (Except in this footnote!) the focus is the key
    events and ideas that led to the web, and the goals and motivations of its inventors.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了网络的本身历史：它的起源，以及网络和浏览器至今是如何演变的。这个历史不是详尽的；例如，关于标准通用标记语言（[SGML](https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language)）或HTML的前驱者几乎没有内容。（除了这个脚注！）重点是导致网络的关键事件和思想，以及其发明者的目标和动机。
- en: The Memex Concept
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: memex概念
- en: '![Figure 1: The original publication of “As We May Think”. (Dunkoman from Wikipedia,
    CC BY 2.0.)](img/1ccc3b3b28488a246b85ad1c92d8fff8.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图1：“我们如何思考”的原始出版物。（来自维基百科的Dunkoman，CC BY 2.0。）](img/1ccc3b3b28488a246b85ad1c92d8fff8.png)'
- en: 'Figure 1: The original publication of “As We May Think”. ([Dunkoman](https://www.flickr.com/people/79255326@N00)
    from [Wikipedia](https://commons.wikimedia.org/wiki/File:The_Memex_(3002477109).jpg),
    [CC BY 2.0](https://creativecommons.org/licenses/by/2.0/legalcode).)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：“我们如何思考”的原始出版物。（[Flickr的Dunkoman](https://www.flickr.com/people/79255326@N00)来自[Wikipedia](https://commons.wikimedia.org/wiki/File:The_Memex_(3002477109).jpg)，[CC
    BY 2.0](https://creativecommons.org/licenses/by/2.0/legalcode)。）
- en: An influential early exploration of how computers might revolutionize information
    is a 1945 essay by Vannevar Bush entitled “[As We May Think](https://en.wikipedia.org/wiki/As_We_May_Think)”.
    This essay envisioned a machine called a [memex](https://en.wikipedia.org/wiki/Memex)
    that helps an individual human see and explore all the information in the world
    (see Figure 1). It was described in terms of the microfilm screen technology of
    the time, but its purpose and concept has some clear similarities to the web as
    we know it today, even if the user interface and technology details differ.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 早在1945年，Vannevar Bush发表了一篇题为“[我们如何思考](https://en.wikipedia.org/wiki/As_We_May_Think)”的论文，这篇论文探讨了计算机可能如何革命性地改变信息。这篇论文设想了一种名为[memex](https://en.wikipedia.org/wiki/Memex)的机器，它可以帮助个人看到并探索世界上所有的信息（见图1）。它用当时缩微胶片屏幕技术的术语来描述，但其目的和概念与今天我们所知的网络有明显的相似之处，尽管用户界面和技术细节有所不同。
- en: 'The web is, at its core, organized around the Memex-like goal of *representing
    and displaying information*, providing a way for humans to effectively learn and
    explore. The collective knowledge and wisdom of the species long ago exceeded
    the capacity of a single mind, organization, library, country, culture, group
    or language. However, while we as humans cannot possibly know even a tiny fraction
    of what it is possible to know, we can use technology to learn more efficiently
    than before, and, *in particular*, to quickly access information we need to learn,
    remember, or recall. Consider this imagined research session described by Vannevar
    Bush—one that is remarkably similar to how we sometimes use the web:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的核心组织目标是类似于Memex的*表示和显示信息*，为人类提供一种有效学习和探索的方式。物种的集体知识和智慧早已超越了单个心智、组织、图书馆、国家、文化、群体或语言的容量。然而，尽管我们作为人类不可能知道可能知道的一小部分，但我们可以使用技术比以前更有效地学习，特别是快速获取我们需要学习、记忆或回忆的信息。考虑一下Vannevar
    Bush描述的这个想象中的研究会议——它与我们有时使用网络的方式惊人地相似：
- en: The owner of the memex, let us say, is interested in the origin and properties
    of the bow and arrow. […] He has dozens of possibly pertinent books and articles
    in his memex. First he runs through an encyclopedia, finds an interesting but
    sketchy article, leaves it projected. Next, in a history, he finds another pertinent
    item, and ties the two together. Thus he goes, building a trail of many items.
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设memex的所有者对弓箭的起源和特性感兴趣。[……]他在memex中有几十本可能相关的书籍和文章。首先，他查阅百科全书，发现一篇有趣但简略的文章，将其投影出来。接下来，在历史书中，他找到另一个相关项目，并将两者联系起来。就这样，他继续前进，构建了许多项目的轨迹。
- en: Computers, and the internet, allow us to *process and store* the information
    we want. But it is *the web* that helps us *organize and find* that information,
    that knowledge, making it useful.Google’s well-known [mission](https://about.google/)
    statement to “organize the world’s information and make it universally accessible
    and useful” is almost exactly the same. This is not a coincidence—the search engine
    concept is inherently connected to the web, and was inspired by the design of
    the web and its antecedents.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机、互联网使我们能够*处理和存储*我们想要的信息。但帮助我们*组织和找到*这些信息、这些知识的，是*网络*。谷歌著名的[使命](https://about.google/)声明“组织全球信息，使其普遍可访问和有用”几乎完全相同。这不是巧合——搜索引擎的概念与网络本质上是相连的，并且受到了网络及其前身设计的启发。
- en: '“As We May Think” highlighted two features of the memex: information record
    lookup, and associations between related records. In fact, the essay emphasizes
    the importance of the latter—we learn by making previously unknown *connections
    between known things*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: “我们如何思考”强调了memex的两个特点：信息记录查找和相关信息之间的关联。事实上，这篇文章强调了后者的重要性——我们通过在已知事物之间建立之前未知的*联系*来学习：
- en: When data of any sort are placed in storage, they are filed alphabetically or
    numerically. […] The human mind does not work that way. It operates by association.
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当任何类型的数据被存储时，它们按字母顺序或数字顺序归档。[……]人的思维并不是这样工作的。它是通过联想来运作的。
- en: By “association”, Bush meant a trail of thought leading from one record to the
    next via a human-curated link. He imagined not just a universal library, but a
    universal way to record the results of what we learn.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过“联想”，Bush指的是通过人类编辑的链接从一条记录到另一条记录的思维轨迹。他想象的不只是一个通用图书馆，而是一个记录我们所学内容的通用方式。
- en: The Web Emerges
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络的出现
- en: The concept of [hypertext](https://en.wikipedia.org/wiki/Hypertext) documents
    linked by [hyperlinks](https://en.wikipedia.org/wiki/Hyperlink#History) was invented
    in 1964–65 by [Project Xanadu](https://en.wikipedia.org/wiki/Project_Xanadu),
    led by Ted Nelson.He was inspired by the long tradition of citation and criticism
    in academic and literary communities. The Project Xanadu research papers were
    heavily motivated by this use case. Hypertext is text that is marked up with hyperlinks
    to other text.A successor called the [Hypertext Editing System](https://en.wikipedia.org/wiki/Hypertext_Editing_System)
    was the first to introduce the back button, which all browsers now have. Since
    the system only had text, the “button” was itself text. Sound familiar? A web
    page is hypertext, and links between web pages are hyperlinks. The format for
    writing web pages is HTML and the protocol for loading web pages is HTTP, both
    of which abbreviations contain “HyperText”. See Figure 2 for an example of the
    early Hypertext Editing System.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本文档的概念，通过 [hyperlinks](https://en.wikipedia.org/wiki/Hyperlink#History) 链接，是在1964-65年由
    [Project Xanadu](https://en.wikipedia.org/wiki/Project_Xanadu) 发明的，该项目由Ted Nelson领导。他受到了学术界和文学界长期引用和批评传统的启发。Xanadu项目的研究论文受到了这一用例的强烈推动。超文本是带有指向其他文本的超链接的文本。其继任者
    [Hypertext Editing System](https://en.wikipedia.org/wiki/Hypertext_Editing_System)
    首次引入了回退按钮，现在所有浏览器都有这个按钮。由于该系统只有文本，所以“按钮”本身也是文本。听起来熟悉吗？网页是超文本，网页之间的链接是超链接。编写网页的格式是HTML，加载网页的协议是HTTP，这两个缩写都包含“HyperText”。见图2，这是早期超文本编辑系统的一个示例。
- en: '![Figure 2: A computer operator using the Hypertext Editing System in 1969\.
    (Gregory Lloyd from Wikipedia, CC BY-SA 4.0 International.)](img/2c74993962642fa5738c4f8060cb4fe3.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2: 1969年使用超文本编辑系统的计算机操作员。（来自Wikipedia的Gregory Lloyd，CC BY-SA 4.0国际。）](img/2c74993962642fa5738c4f8060cb4fe3.png)'
- en: 'Figure 2: A computer operator using the Hypertext Editing System in 1969\.
    (Gregory Lloyd from [Wikipedia](https://commons.wikimedia.org/wiki/File:HES_IBM_2250_Console_grlloyd_Oct1969.png),
    [CC BY-SA 4.0 International](https://creativecommons.org/licenses/by-sa/4.0/deed.en).)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 2: 1969年使用超文本编辑系统的计算机操作员。（来自Wikipedia的Gregory Lloyd，[CC BY-SA 4.0国际](https://creativecommons.org/licenses/by-sa/4.0/deed.en)。）'
- en: 'Independently of Project Xanadu, the first hyperlink system appeared for scrolling
    within a single document; it was later generalized to linking between multiple
    documents. And just like those original systems, the web has linking within documents
    as well as between them. For example, the URL `http://browser.engineering/history.html#the-web-emerges`
    refers to a document called “`history.html`”, and specifically to the element
    in it with the name “`the-web-emerges`”: this section. Visiting that URL will
    load this chapter and scroll to this section.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于Xanadu项目，第一个超链接系统是为了在单个文档内进行滚动而出现的；它后来被推广到多个文档之间的链接。就像那些原始系统一样，网络在文档内部以及文档之间都有链接。例如，URL
    `http://browser.engineering/history.html#the-web-emerges` 指的是名为“`history.html`”的文档，以及其中名为“`the-web-emerges`”的元素：这一部分。访问该URL将加载这一章节并滚动到这一部分。
- en: This work also formed and inspired one of the key parts of Douglas Engelbart’s
    [mother of all demos](https://en.wikipedia.org/wiki/The_Mother_of_All_Demos),
    perhaps the most influential technology demonstration in the history of computing
    (see Figure 3). That demo not only showcased the key concepts of the web, but
    also introduced the computer mouse and graphical user interface, both of which
    are central components of a browser UI.That demo went beyond even this. There
    are some parts of it that have not yet been realized in any computer system. Watch
    it!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这项工作也形成了Douglas Engelbart的“所有演示之母” [mother of all demos](https://en.wikipedia.org/wiki/The_Mother_of_All_Demos)
    的一个关键部分，可能是计算历史上最具影响力的技术演示（见图3）。那次演示不仅展示了网络的核心理念，还介绍了计算机鼠标和图形用户界面，这两者都是浏览器UI的核心组件。那次演示甚至超越了这一点。其中一些部分在任何一个计算机系统中都尚未实现。看看它吧！
- en: '![Figure 3: Doug Engelbart presenting the mother of all demos. (SRI International,
    via the Doug Engelbart Institute.)](img/ded1873399633cfe7398f85be7c38fd8.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 3: Doug Engelbart展示所有演示之母。（SRI International，通过Doug Engelbart研究所。）](img/ded1873399633cfe7398f85be7c38fd8.png)'
- en: 'Figure 3: Doug Engelbart presenting the mother of all demos. (SRI International,
    via the [Doug Engelbart Institute](https://www.dougengelbart.org/content/view/374/464/).)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 3: Doug Engelbart展示所有演示之母。（SRI International，通过[Doug Engelbart研究所](https://www.dougengelbart.org/content/view/374/464/)。）'
- en: There is of course a very direct connection between this research and the document–URL–hyperlink
    setup of the web, which built on the hypertext idea and applied it in practice.
    The [HyperTIES](http://www.cs.umd.edu/hcil/hyperties/) system, for example, had
    highlighted hyperlinks and was used to develop the world’s first electronically
    published academic journal, the 1988 issue of the [*Communications of the ACM*](https://cacm.acm.org/).
    Tim Berners-Lee cites that 1988 issue as inspiration for the World Wide Web,Nowadays
    the World Wide Web is called just “the web”, or “the web ecosystem”—ecosystem
    being another way to capture the same concept as “World Wide”. The original wording
    lives on in the “www” in many website domain names. in which he joined the link
    concept with the availability of the internet, thus realizing many of the original
    goals of all this work from previous decades.Just as the web itself is a realization
    of previous ambitions and dreams, today we strive to realize the vision laid out
    by the web. (No, it’s not done yet!)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这项研究与网络中的文档-URL-超链接设置之间存在着非常直接的联系，这是基于超文本理念并在实践中应用的。例如，[HyperTIES](http://www.cs.umd.edu/hcil/hyperties/)系统就强调了超链接，并用于开发世界上第一份电子学术期刊，即1988年的[*《ACM通讯》*](https://cacm.acm.org/)。蒂姆·伯纳斯-李将1988年的这一期作为万维网的灵感来源。如今，万维网被称为“网络”或“网络生态系统”——生态系统是另一种捕捉“全球”这一概念的方式。原始的措辞在许多网站域名中的“www”中得以延续。他在其中将链接概念与互联网的可用性相结合，从而实现了之前几十年所有这些工作的许多原始目标。正如网络本身是之前抱负和梦想的实现一样，今天我们努力实现网络所描绘的愿景。（不，还没有完成！）
- en: The word “hyperlink” may have been coined in 1987, in connection with the [HyperCard](https://en.wikipedia.org/wiki/HyperCard)
    system on Apple computers. This system was also one of the first, or perhaps the
    first, to introduce the concept of augmenting hypertext with scripts that handle
    user events like clicks and perform actions that enhance the UI—just like JavaScript
    on a web page! It also had graphical UI elements, not just text, unlike most predecessors.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: “超链接”这个词可能是在1987年提出的，与苹果电脑上的[HyperCard](https://en.wikipedia.org/wiki/HyperCard)系统有关。这个系统也是最早引入之一，或者可能是第一个，将脚本的概念引入超文本中，以处理用户事件（如点击）并执行增强UI的动作——就像网页上的JavaScript一样！它还拥有图形用户界面元素，而不仅仅是文本，与大多数前辈不同。
- en: In 1989–1990, the first web browser (named WorldWideWeb, see Figure 4) and web
    server (named `httpd`, for HTTP Daemon, according to UNIX naming conventions)
    were born, written by Tim Berners-Lee. Interestingly, while that browser’s capabilities
    were in some ways inferior to the browser you will implement in this book,No CSS!
    No JS! Not even images! in other ways they go beyond the capabilities available
    even in modern browsers.For example, the first browser included the concept of
    an index page meant for searching within a site (vestiges of which exist today
    in the “index.html” convention when a URL path ends in /”), and had a WYSIWYG
    web page editor (the “contenteditable” HTML attribute on DOM elements (see [Chapter
    16](invalidation.html)) have similar semantic behavior, but built-in file saving
    is gone). Today, the index is replaced with a search engine, and web page editors
    as a concept are somewhat obsolete due to the highly dynamic nature of today’s
    web page rendering. On December 20, 1990 the [first web page](http://info.cern.ch/hypertext/WWW/TheProject.html)
    was created. The browser we will implement in this book is easily able to render
    this web page, even today.Also, as you can see clearly, that web page has not
    been updated in the meantime, and retains its original aesthetics! In 1991, Berners-Lee
    advertised his browser and the concept on the [`alt.hypertext` Usenet group](https://www.w3.org/People/Berners-Lee/1991/08/art-6484.txt).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在1989-1990年间，第一个网络浏览器（命名为WorldWideWeb，见图4）和网络服务器（命名为`httpd`，即HTTP守护进程，根据UNIX命名规范）诞生了，由蒂姆·伯纳斯-李编写。有趣的是，尽管在那个浏览器的一些方面能力不如你将在本书中实现的浏览器，没有CSS！没有JS！甚至没有图片！但在其他方面，它们超越了现代浏览器所具备的能力。例如，第一个浏览器包括了索引页面的概念，用于在站点内进行搜索（这些遗迹在今天“index.html”惯例中仍然存在，当URL路径以“/”结尾时），并且有一个所见即所得的网页编辑器（DOM元素上的“contenteditable”HTML属性（见[第16章](invalidation.html)）具有类似的语义行为，但内置的文件保存功能已经消失）。今天，索引已被搜索引擎所取代，由于今天网页渲染的高度动态性，网页编辑器作为一个概念已经有些过时。1990年12月20日，[第一个网页](http://info.cern.ch/hypertext/WWW/TheProject.html)被创建。我们将在本书中实现的浏览器能够轻松渲染这个网页，即使是在今天。此外，正如你可以清楚地看到的，这个网页在此期间没有更新，保留了其原始的美学！1991年，伯纳斯-李在[`alt.hypertext`
    Usenet组](https://www.w3.org/People/Berners-Lee/1991/08/art-6484.txt)上宣传了他的浏览器和这一概念。
- en: '![Figure 4: Screenshot of the WorldWideWeb browser. (Communications of the
    ACM, August 1994.)](img/7d4f5b7c774151c3eb0365ad9e516ee5.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图4：WorldWideWeb浏览器的截图。（ACM通讯，1994年8月。）](img/7d4f5b7c774151c3eb0365ad9e516ee5.png)'
- en: 'Figure 4: Screenshot of the WorldWideWeb browser. ([*Communications of the
    ACM*](https://dl.acm.org/doi/10.1145/179606.179671), August 1994.)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：WorldWideWeb浏览器的截图。[*《ACM通讯》](https://dl.acm.org/doi/10.1145/179606.179671)，1994年8月。]
- en: 'Berners-Lee’s [Brief History of the Web](https://www.w3.org/DesignIssues/TimBook-old/History.html)
    highlights a number of other key factors that led to the World Wide Web becoming
    the web we know today. One key factor was its decentralized nature, which he describes
    as arising from the academic culture of [CERN](https://home.cern/), where he worked.
    The decentralized nature of the web is a key feature that distinguishes it from
    many systems that came before or after, and his explanation of it is worth quoting
    here (the italics are mine):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Berners-Lee的 [《互联网简史》](https://www.w3.org/DesignIssues/TimBook-old/History.html)
    强调了导致万维网成为我们今天所知道的万维网的一些其他关键因素。一个关键因素是其去中心化的性质，他将这种性质描述为起源于他工作的 [CERN](https://home.cern/)
    的学术文化。网络的去中心化性质是区分它与其他许多系统的一个关键特征，他的解释在这里值得引用（斜体为本人所加）：
- en: There was clearly a need for something like EnquireEnquire was a predecessor
    web-like database system, also written by Berners-Lee. but accessible to everyone.
    I wanted it to scale so that if two people started to use it independently, and
    later started to work together, *they could start linking together their information
    without making any other changes*. This was the concept of the web.
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 显然需要一种类似于Enquire的系统，Enquire是一个类似网络的数据库系统，也是由Berners-Lee编写的，但每个人都可以访问。我希望它能够扩展，以便如果两个人开始独立使用它，后来开始合作，*他们可以开始链接他们的信息，而不需要做任何其他改变*。这就是网络的概念。
- en: 'This quote captures one of the key value propositions of the web: its decentralized
    nature. The web was successful for several reasons, but they all had to do with
    decentralization:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段引言捕捉到了网络的一个关键价值主张：其去中心化的性质。网络之所以成功，有几个原因，但它们都与去中心化有关：
- en: Because there was no gatekeeper to doing anything, it was easy for anyone, even
    novices, to make simple web pages and publish them.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于没有守门人可以控制任何事情，任何人，即使是新手，都可以轻松制作简单的网页并发布它们。
- en: Because pages were identified simply by URLs, traffic could come to the web
    from outside sources like email, social networking, and search engines. Further,
    compatibility between sites and the power of hyperlinks created [network effects](https://en.wikipedia.org/wiki/Network_effect)
    that further strengthened the effect of hyperlinks from *within* the web.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于页面仅通过URL进行标识，流量可以从电子邮件、社交网络和搜索引擎等外部来源进入网络。此外，网站之间的兼容性和超链接的力量创造了 [网络效应](https://en.wikipedia.org/wiki/Network_effect)，这进一步增强了网络内部超链接的效果。
- en: Because the web was outside the control of any one entity—and kept that way
    via standards organizations—it avoided the problems of monopoly control and manipulation.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于网络不受任何单一实体的控制——并且通过标准组织保持这种状态——它避免了垄断控制和操纵的问题。
- en: Browsers
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器
- en: The first *widely distributed* browser may have been [ViolaWWW](https://en.wikipedia.org/wiki/ViolaWWW)
    (see Figure 5); this browser also pioneered multiple interesting features such
    as applets and images. It was in turn the inspiration for [NCSA Mosaic](https://en.wikipedia.org/wiki/Mosaic_(web_browser))
    (see Figure 6), which launched in 1993\. One of the two original authors of Mosaic
    went on to co-found Netscape, which built [Netscape Navigator](https://en.wikipedia.org/wiki/Netscape_Navigator)
    (see Figure 7), the first *commercial browser*,By commercial I mean built by a
    for-profit entity. Netscape’s early versions were also not free software—you had
    to buy them from a store. They cost about $50. which launched in 1994\. [Feeling
    threatened](https://lettersofnote.com/2011/07/22/the-internet-tidal-wave/), Microsoft
    launched Internet Explorer (see Figure 8) in 1995 and soon bundled it with Windows
    95.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个广泛分布的浏览器可能是 [ViolaWWW](https://en.wikipedia.org/wiki/ViolaWWW)（见图5）；这个浏览器还开创了多个有趣的功能，如小程序和图像。它后来又成为了
    [NCSA Mosaic](https://en.wikipedia.org/wiki/Mosaic_(web_browser))（见图6）的灵感来源，Mosaic于1993年推出。Mosaic的两个原始作者之一后来共同创立了Netscape，Netscape开发了
    [Netscape Navigator](https://en.wikipedia.org/wiki/Netscape_Navigator)（见图7），这是第一个
    *商业浏览器*，这里的“商业”是指由盈利实体开发的。Netscape的早期版本也不是免费软件——你必须从商店购买它们。它们的价格大约是50美元。Netscape于1994年推出。[感到威胁](https://lettersofnote.com/2011/07/22/the-internet-tidal-wave/)，微软于1995年推出了Internet
    Explorer（见图8），并很快将其捆绑到Windows 95中。
- en: '![Figure 5: ViolaWWW. (Viola in a Nutshell.)](img/1cd01145a1a14dd4846fb48bbf451700.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图5：ViolaWWW. (Viola in a Nutshell.)](img/1cd01145a1a14dd4846fb48bbf451700.png)'
- en: 'Figure 5: ViolaWWW. ([*Viola in a Nutshell*](https://web.archive.org/web/20200706084621/http://viola.org/viola/book/preface.html).)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：ViolaWWW. ([*Viola in a Nutshell*](https://web.archive.org/web/20200706084621/http://viola.org/viola/book/preface.html).)
- en: '![Figure 6: Mosaic. (Wikipedia, CC0 1.0.)](img/856d4950741026dd157ceb27d5926a01.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图6：Mosaic. (Wikipedia, CC0 1.0.)](img/856d4950741026dd157ceb27d5926a01.png)'
- en: 'Figure 6: Mosaic. ([Wikipedia](https://commons.wikimedia.org/wiki/File:NCSA_Mosaic_Browser_Screenshot.png),
    [CC0 1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode).)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：Mosaic. ([Wikipedia](https://commons.wikimedia.org/wiki/File:NCSA_Mosaic_Browser_Screenshot.png),
    [CC0 1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode).)
- en: '![Figure 7: Netscape Navigator 1.22\. (Wikipedia.)](img/9996ddec9887a4534d7869c9dc00c234.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图7：Netscape Navigator 1.22\. (Wikipedia.)](img/9996ddec9887a4534d7869c9dc00c234.png)'
- en: 'Figure 7: Netscape Navigator 1.22\. ([Wikipedia](https://en.wikipedia.org/wiki/File:Navigator_1-22.png#filehistory).)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：Netscape Navigator 1.22\. ([Wikipedia](https://en.wikipedia.org/wiki/File:Navigator_1-22.png#filehistory).)
- en: '![Figure 8: Internet Explorer 1.0\. (Wikipedia, used with permission from Microsoft.)](img/b2e108f3d487544b7f77017b8e78ab8f.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图8：Internet Explorer 1.0\. (Wikipedia, used with permission from Microsoft.)](img/b2e108f3d487544b7f77017b8e78ab8f.png)'
- en: 'Figure 8: Internet Explorer 1.0\. ([Wikipedia](https://en.wikipedia.org/wiki/File:Internet_Explorer_1.0.png),
    used with [permission from Microsoft](https://www.microsoft.com/en-us/legal/copyright/permissions).)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：Internet Explorer 1.0\. ([Wikipedia](https://en.wikipedia.org/wiki/File:Internet_Explorer_1.0.png),
    used with [permission from Microsoft](https://www.microsoft.com/en-us/legal/copyright/permissions).)
- en: 'The era of the [“first browser war”](https://en.wikipedia.org/wiki/Browser_wars#First_Browser_War_(1995%E2%80%932001))
    ensued: a competition between Netscape Navigator and [Internet Explorer](https://en.wikipedia.org/wiki/Internet_Explorer).
    There were also other browsers with smaller market shares; one notable example
    is [Opera](https://en.wikipedia.org/wiki/Opera_(web_browser)). The [WebKit](https://en.wikipedia.org/wiki/WebKit)
    project began in 1999; [Safari](https://en.wikipedia.org/wiki/Safari_(web_browser))
    and [Chromium](https://www.chromium.org/)-based browsers, such as Chrome and newer
    versions of [Edge](https://en.wikipedia.org/wiki/Microsoft_Edge), descend from
    this codebase. Likewise, the [Gecko](https://en.wikipedia.org/wiki/Gecko_(software))
    rendering engine was originally developed by Netscape starting in 1997; the [Firefox](https://en.wikipedia.org/wiki/Firefox)
    browser is descended from that codebase. During the first browser war, nearly
    all of the core features of this book’s simple browser were added, including CSS,
    DOM, and JavaScript.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 随后开始了[“第一次浏览器大战”](https://en.wikipedia.org/wiki/Browser_wars#First_Browser_War_(1995%E2%80%932001))：Netscape
    Navigator和[Internet Explorer](https://en.wikipedia.org/wiki/Internet_Explorer)之间的竞争。当时还有其他市场份额较小的浏览器；一个值得注意的例子是[Opera](https://en.wikipedia.org/wiki/Opera_(web_browser))。[WebKit](https://en.wikipedia.org/wiki/WebKit)项目始于1999年；基于[Safari](https://en.wikipedia.org/wiki/Safari_(web_browser))和[Chromium](https://www.chromium.org/)-的浏览器，如Chrome和Edge的新版本，都源自这个代码库。同样，[Gecko](https://en.wikipedia.org/wiki/Gecko_(software))渲染引擎最初由Netscape从1997年开始开发；[Firefox](https://en.wikipedia.org/wiki/Firefox)浏览器源自那个代码库。在第一次浏览器大战期间，这本书简单浏览器的几乎所有核心功能都被添加，包括CSS、DOM和JavaScript。
- en: The “second browser war”, which according to Wikipedia was [2004–2017](https://en.wikipedia.org/wiki/Browser_wars#Second_Browser_War_(2004%E2%80%932017)),
    was fought between a variety of browsers, in particular Internet Explorer, Firefox,
    Safari, and Chrome. Initially, Safari and Chrome used the same rendering engine,
    but Chrome forked into [Blink](https://en.wikipedia.org/wiki/Blink_(browser_engine))
    in 2013, which Microsoft Edge adopted by 2020\. The second browser war saw the
    development of many features of the modern web, including widespread use of AJAXAsynchronous
    JavaScript and XML, where XML stands for eXtensible Markup Language., HTML5 features
    like `<canvas>`, and a huge explosion in third-party JavaScript libraries and
    frameworks.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: “第二次浏览器大战”，根据维基百科的记载是[2004–2017](https://en.wikipedia.org/wiki/Browser_wars#Second_Browser_War_(2004%E2%80%932017))，这场战争在众多浏览器之间展开，特别是Internet
    Explorer、Firefox、Safari和Chrome。最初，Safari和Chrome使用相同的渲染引擎，但Chrome在2013年分叉为[Blink](https://en.wikipedia.org/wiki/Blink_(browser_engine))，到2020年，Microsoft
    Edge也开始采用。第二次浏览器大战见证了现代网络许多功能的开发，包括广泛使用AJAX（异步JavaScript和XML，其中XML代表可扩展标记语言），HTML5特性如`<canvas>`，以及第三方JavaScript库和框架的爆炸性增长。
- en: Web Standards
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络标准
- en: In parallel with these developments was another, equally important, one—the
    standardization of web APIs. In October 1994, the [World Wide Web Consortium](https://www.w3.org/Consortium/facts)
    (W3C) was founded to provide oversight and standards for web features. Prior to
    this point, browsers would often introduce new HTML elements or APIs, and competing
    browsers would have to copy them. With a standards organization, those elements
    and APIs could subsequently be agreed upon and documented in specifications. (These
    days, an initial discussion, design, and specification precedes any new feature.)
    Later on, the HTML specification ended up moving to a different standards body
    called the [WHATWG](https://whatwg.org/), but [CSS](https://drafts.csswg.org/)
    and other features are still standardized at the W3C. JavaScript is standardized
    at yet another standards body, TC39 ([Technical Committee 39](https://tc39.es/))
    at [ECMA](https://www.ecma-international.org/about-ecma/history/). [HTTP](https://tools.ietf.org/html/rfc2616)
    is standardized by the [IETF](https://www.ietf.org/about/). The important point
    is that the standards process set up in the mid-1990s is still with us.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些发展并行的是另一个同样重要的方面——网络API的标准化。1994年10月，[万维网联盟](https://www.w3.org/Consortium/facts)（W3C）成立，旨在提供对网络特性的监督和标准。在此之前，浏览器经常会引入新的HTML元素或API，而竞争的浏览器则必须复制它们。有了标准组织，这些元素和API随后可以在规范中得到认可并记录下来。（如今，任何新功能都会先进行初步讨论、设计和规范。）后来，HTML规范最终转移到了另一个名为[WHATWG](https://whatwg.org/)的标准机构，但[CSS](https://drafts.csswg.org/)和其他功能仍然在W3C进行标准化。JavaScript在另一个名为TC39（[技术委员会39](https://tc39.es/））的标准机构[ECMA](https://www.ecma-international.org/about-ecma/history/)进行标准化。[HTTP](https://tools.ietf.org/html/rfc2616)由[互联网工程任务组](https://www.ietf.org/about/)进行标准化。重要的是，1990年代中期建立的标准流程至今仍在使用。
- en: In the first years of the web, it was not so clear that browsers would remain
    standard and that one browser might not end up “winning” and becoming another
    proprietary software platform. There are multiple reasons this didn’t happen,
    among them the egalitarian ethos of the computing community and the presence and
    strength of the W3C. Another important reason was the networked nature of the
    web, and therefore the necessity for web developers to make sure their pages worked
    correctly in most or all of the browsers (otherwise they would lose customers),
    leading them to avoid proprietary extensions. On the contrary, browsers worked
    hard to carefully reproduce each other’s undocumented behaviors—even bugs—to make
    sure they continued supporting the whole web.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络的前几年，并不那么清楚浏览器是否会保持标准，或者一个浏览器可能不会最终“获胜”并成为另一个专有软件平台。这没有发生的原因有很多，其中之一是计算社区的平等主义精神以及W3C的存在和强大。另一个重要原因是网络的性质，因此网络开发者必须确保他们的页面在大多数或所有浏览器中都能正确工作（否则他们会失去客户），这促使他们避免专有扩展。相反，浏览器努力仔细复制彼此未记录的行为——甚至错误——以确保它们继续支持整个网络。
- en: There never really was a point where any browser openly attempted to break away
    from the standard, despite fears that that might happen.Perhaps the closest the
    web came to fragmenting was with the late-1990s introduction of features for [DHTML](https://en.wikipedia.org/wiki/Dynamic_HTML)—early
    versions of the Document Object Model you’ll learn about in this book. Netscape
    and Internet Explorer at first had incompatible implementations of these features,
    and it took years, the development of a common specification, and significant
    pressure campaigns on the browsers before standardization was achieved. You can
    read about this story in much more depth [from Jay Hoffman](https://css-tricks.com/chapter-7-standards/).
    Instead, intense competition for market share was channeled into very fast innovation
    and an ever-expanding set of APIs and capabilities for the web, which we nowadays
    refer to as *the web platform*, not just the “World Wide Web”. This recognizes
    the fact that the web is no longer a document viewing mechanism, but has evolved
    into a fully realized computing platform and ecosystem.There have even been operating
    systems built around the web! Examples include [webOS](https://en.wikipedia.org/wiki/WebOS),
    which powered some Palm smartphones, [Firefox OS](https://en.wikipedia.org/wiki/Firefox_OS)
    (that today lives on in [KaiOS](https://en.wikipedia.org/wiki/KaiOS)-based phones),
    and [ChromeOS](https://en.wikipedia.org/wiki/Chrome_OS), which is a desktop operating
    system. All of these operating systems are based on using the web as the UI layer
    for all applications, with some JavaScript-exposed APIs on top for system integration.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从来没有哪个浏览器公开尝试脱离标准，尽管人们担心这种情况可能发生。也许网络最接近分裂的时刻是在20世纪90年代末引入了[DHTML](https://en.wikipedia.org/wiki/Dynamic_HTML)功能——这本书中你将学习的文档对象模型的早期版本。最初，Netscape和Internet
    Explorer对这些功能的实现不兼容，并且需要多年的时间、共同规范的开发以及向浏览器施加的重大压力运动，才实现了标准化。你可以在[Jay Hoffman](https://css-tricks.com/chapter-7-standards/)的文章中更深入地了解这个故事。相反，对市场份额的激烈竞争被转化为快速的创新，以及网络API和功能的不断扩展，我们现在称之为*网络平台*，而不仅仅是“万维网”。这承认了这样一个事实，即网络不再是一个文档查看机制，而已经发展成为一个完全实现的计算平台和生态系统。甚至还有围绕网络构建的操作系统！例子包括[webOS](https://en.wikipedia.org/wiki/WebOS)，它为一些Palm智能手机供电，[Firefox
    OS](https://en.wikipedia.org/wiki/Firefox_OS)（今天在基于[KaiOS](https://en.wikipedia.org/wiki/KaiOS)的手机上继续存在），以及[ChromeOS](https://en.wikipedia.org/wiki/Chrome_OS)，这是一个桌面操作系统。所有这些操作系统都是基于使用网络作为所有应用的UI层，并在其上提供一些用于系统集成的JavaScript公开API。
- en: Given the outcomes—multiple competing browsers and well-developed standards—it
    is in retrospect not that relevant which browser “won” or “lost” each of the browser
    “wars”. In each case *the web* won, because it gained users and grew in capability.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到结果——多个竞争浏览器和成熟的标准——回顾起来，哪个浏览器“赢”或“输”每一场浏览器“战争”并不那么重要。在每种情况下，*网络*才是赢家，因为它获得了用户并增强了功能。
- en: Open Source
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开源
- en: 'Another important and interesting outcome of the *second* browser war was that
    all mainstream browsers todayExamples of Chromium-based browsers include Chrome,
    Edge, Opera (which switched to Chromium from the [Presto](https://en.wikipedia.org/wiki/Presto_(browser_engine))
    engine in 2013), Samsung Internet, Yandex Browser, UC Browser, and Brave. In addition,
    there are many “embedded” browsers, based on one or another of the three engines,
    for a wide variety of automobiles, phones, TVs, and other electronic devices.
    are based on *three open-source web rendering / JavaScript engines*: Chromium,
    Gecko, and WebKit.The JavaScript engines are actually in different repositories
    (as are various other subcomponents), and can and do get used outside the browser
    as JavaScript virtual machines. One important application is the use of [V8](https://en.wikipedia.org/wiki/V8_(JavaScript_engine))
    to power [node.js](https://en.wikipedia.org/wiki/Node.js). However, each of the
    three rendering engines does have a corresponding JavaScript implementation, so
    conflating the two is reasonable. Since Chromium and WebKit have a common ancestral
    codebase, while Gecko is an open-source descendant of Netscape, all three date
    back to the 1990s—almost to the beginning of the web.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次浏览器战争的一个重要且有趣的成果是，今天所有主流浏览器都基于 *三个开源网络渲染/JavaScript 引擎*：Chromium、Gecko 和
    WebKit。JavaScript 引擎实际上在不同的存储库中（以及其他各种子组件也是如此），并且可以在浏览器之外作为JavaScript虚拟机使用。一个重要应用是使用
    [V8](https://en.wikipedia.org/wiki/V8_(JavaScript_engine)) 为 [node.js](https://en.wikipedia.org/wiki/Node.js)
    提供动力。然而，这三个渲染引擎中的每一个都有一个相应的JavaScript实现，因此将两者混淆是合理的。由于Chromium和WebKit有一个共同的祖先代码库，而Gecko是Netscape的开源后代，所以它们都追溯到20世纪90年代——几乎回到了网络的开始。
- en: This is not an accident, and in fact tells us something quite interesting about
    the most cost-effective way to implement a rendering engine based on a commodity
    set of platform APIs. For example, it’s common for independent developers, not
    paid by the company nominally controlling the browser, to contribute code and
    features. There are even companies and individuals that specialize in implementing
    browser features! It’s also common for features in one browser to copy code from
    another. And every major browser being open source feeds back into the standards
    process, reinforcing the web’s decentralized nature.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是偶然的，实际上它告诉我们关于基于商品平台API集实现渲染引擎的最经济有效方式的一些相当有趣的事情。例如，独立开发者通常不会由名义上控制浏览器的公司支付，他们会贡献代码和功能。甚至还有专门实施浏览器功能的公司和个人！一个浏览器中的功能复制另一个浏览器的代码也是很常见的。而且，每个主要浏览器都是开源的，这会反馈到标准过程中，加强网络的去中心化特性。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In summary, the history went like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 总结起来，历史是这样的：
- en: Basic research was performed into ways to represent and explore information.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对表示和探索信息的方法进行了基本研究。
- en: Once the necessary technology became mature enough, the web proper was proposed
    and implemented.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦必要的技术足够成熟，网络本身就被提出并实施。
- en: The web became popular quite quickly, and many browsers appeared in order to
    capitalize on the web’s opportunity.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络迅速普及，许多浏览器出现以利用网络的机遇。
- en: Standards organizations were introduced in order to negotiate between the browsers
    and avoid proprietary control.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在浏览器之间进行协商并避免专有控制，引入了标准组织。
- en: Competition between browsers grew their power and complexity at a rapid pace.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器之间的竞争迅速增加了它们的功率和复杂性。
- en: Browsers appeared on all devices and operating systems, from desktop to mobile
    to embedded.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器出现在所有设备上和操作系统上，从桌面到移动再到嵌入式。
- en: Eventually, all web rendering engines became open source, as a recognition of
    their being a shared effort larger than any single entity.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，所有网络渲染引擎都变成了开源的，这是对其作为一个比任何单一实体更大的共享努力的认可。
- en: 'The web has come a long way! But one thing seems clear: it isn’t done yet.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 网络已经发展得很远！但有一点似乎很清楚：它还没有完成。
- en: Exercises
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '*iii*-1 *What comes next?* Based on what you learned about how the web came
    about and took its current form, what trends do you predict for its future evolution?
    For example, do you think it’ll compete effectively against other non-web technologies
    and platforms?'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*iii*-1 *接下来是什么？* 基于你对网络是如何产生并形成当前形式的了解，你预测其未来的发展趋势是什么？例如，你认为它将如何有效地与其他非网络技术和平台竞争？'
- en: '*iii*-2 *What became of the original ideas?* The way the web works in practice
    is significantly different than the memex; one key difference is that there is
    no built-in way for the *user* of the web to add links between pages or notate
    them. Why do you think this is? Can you think of other goals from the original
    work that remain unrealized?'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*iii*-2 *原始想法怎么了？* 实际上网络的工作方式与memex有显著不同；一个关键区别是，网络用户没有内置的方式在页面之间添加链接或进行标注。你认为这是为什么？你能想到原始工作中其他尚未实现的目标吗？'
- en: Downloading Web Pages
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载网页
- en: Chapter 1 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[Web浏览器工程](./index.html "目录")的第1章。'
- en: '[Connecting to a Server](#connecting-to-a-server)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[连接到服务器](#connecting-to-a-server)'
- en: '[Requesting Information](#requesting-information)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[请求信息](#requesting-information)'
- en: '[The Server’s Response](#the-servers-response)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[服务器的响应](#the-servers-response)'
- en: '[Telnet in Python](#telnet-in-python)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python中的Telnet](#telnet-in-python)'
- en: '[Request and Response](#request-and-response)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[请求和响应](#request-and-response)'
- en: '[Displaying the HTML](#displaying-the-html)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[显示HTML](#displaying-the-html)'
- en: '[Encrypted Connections](#encrypted-connections)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[加密连接](#encrypted-connections)'
- en: '[Summary](#summary)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summary)'
- en: '[Outline](#outline)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大纲](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: A web browser displays information identified by a URL. And the first step is
    to use that URL to connect to and download information from a server somewhere
    on the internet.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器显示由URL标识的信息。第一步是使用该URL连接到互联网上的某个服务器并下载信息。
- en: Connecting to a Server
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到服务器
- en: Browsing the internet starts with a URL,“URL” stands for “uniform resource locator”,
    meaning that it is a portable (uniform) way to identify web pages (resources)
    and also that it describes how to access those files (locator). a short string
    that identifies a particular web page that the browser should visit.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览互联网从URL开始，“URL”代表“统一资源定位符”，意味着它是一种便携的（统一的）识别网页（资源）的方式，同时也描述了如何访问这些文件（定位符）。这是一个简短字符串，用于标识浏览器应访问的特定网页。
- en: '[PRE0]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Figure 1: The syntax of URLs.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：URL的语法。
- en: 'A URL has three parts (see Figure 1): the scheme explains *how* to get the
    information; the host name explains *where* to get it; and the path explains *what*
    information to get. There are also optional parts to the URL, like ports, queries,
    and fragments, which we’ll see later.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个URL包含三个部分（见图1）：方案解释了*如何*获取信息；主机名解释了*在哪里*获取信息；路径解释了*要获取什么*信息。URL还有一些可选部分，如端口、查询和片段，我们将在后面看到。
- en: 'From a URL, the browser can start the process of downloading the web page.
    The browser first asks the local operating system (OS) to put it in touch with
    the *server* described by the *host name*. The OS then talks to a *Domain Name
    System* (DNS) server which convertsYou can use a DNS lookup tool like [nslookup.io](https://nslookup.io)
    or the `dig` command to do this conversion yourself. a host name like `example.org`
    into a *destination IP address* like `93.184.216.34`.Today there are two versions
    of IP (Internet Protocol): IPv4 and IPv6\. IPv6 addresses are a lot longer and
    are usually written in hexadecimal, but otherwise the differences don’t matter
    here. Then the OS decides which hardware is best for communicating with that destination
    IP address (say, wireless or wired) using what is called a *routing table*, and
    then uses device drivers to send signals over a wire or over the air.I’m skipping
    steps here. On wires you first have to wrap communications in ethernet frames,
    on wireless you have to do even more. I’m trying to be brief. Those signals are
    picked up and transmitted by a series of *routers*Or a switch, or an access point;
    there are a lot of possibilities, but eventually there is a router. which each
    choose the best direction to send your message so that it eventually gets to the
    destination.They may also record where the message came from so they can forward
    the reply back. When the message reaches the server, a connection is created.
    Anyway, the point of this is that the browser tells the OS, “Hey, put me in touch
    with `example.org`”, and it does.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个URL开始，浏览器可以启动下载网页的过程。浏览器首先请求本地操作系统（OS）将其与由*主机名*描述的*服务器*连接起来。然后，操作系统与一个*域名系统*（DNS）服务器通信，该服务器将像`example.org`这样的主机名转换为*目标IP地址*，例如`93.184.216.34`。现在有两个版本的IP（互联网协议）：IPv4和IPv6。IPv6地址要长得多，通常以十六进制形式书写，但在这里，其他差异并不重要。然后，操作系统决定使用什么硬件与该目标IP地址（例如，无线或有线）通信最好（称为*路由表*），然后使用设备驱动程序通过电线或无线发送信号。这里省略了一些步骤。在电线上，你首先必须在通信中包裹以太网帧，在无线中，你甚至需要做更多。我尽量简短。这些信号被一系列*路由器*（或交换机，或接入点；有很多可能性，但最终都会有一个路由器）接收并传输，每个路由器都会选择最佳方向发送你的消息，以便最终到达目的地。它们也可能记录消息的来源，以便它们可以将回复转发回去。当消息到达服务器时，就会建立一个连接。无论如何，重点是浏览器告诉操作系统，“嘿，让我与`example.org`连接起来”，然后它就做到了。
- en: On many systems, you can set up this kind of connection using the `telnet` program,
    like this:The “80” is the port, discussed below.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多系统中，您可以使用`telnet`程序设置此类连接，如下所示：“80”是端口号，下面将讨论。
- en: '[PRE1]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '(Note: When you see a gray outline, it means that the code in question is an
    example only, and *not* actually part of our browser’s code.)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: （注意：当你看到一个灰色轮廓时，这意味着相关的代码只是一个示例，*并不是*我们浏览器代码的一部分。）
- en: 'You might need to install `telnet`; it is often disabled by default. On Windows,
    [go to Programs and Features / Turn Windows features on or off](https://www.lifewire.com/what-is-telnet-2626026)
    in the Control Panel; you’ll need to reboot. When you run it, it’ll clear the
    screen instead of printing something, but other than that works normally. On macOS,
    you can use the `nc -v` command as a replacement for `telnet`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要安装`telnet`；它通常默认禁用。在Windows上，您可以在控制面板中转到“程序和功能/启用或关闭Windows功能”（[https://www.lifewire.com/what-is-telnet-2626026](https://www.lifewire.com/what-is-telnet-2626026)），您将需要重新启动。当你运行它时，它会清除屏幕而不是打印某些内容，但除此之外，它正常工作。在macOS上，您可以使用`nc
    -v`命令作为`telnet`的替代品：
- en: '[PRE2]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output is a little different but it works in the same way. On most Linux
    systems, you can install `telnet` or `nc` from the package manager, usually from
    packages called `telnet` and `netcat`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 输出略有不同，但工作方式相同。在大多数Linux系统上，您可以从包管理器安装`telnet`或`nc`，通常是从名为`telnet`和`netcat`的软件包中安装。
- en: 'You’ll get output that looks like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到如下所示的输出：
- en: '[PRE3]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This means that the OS converted the host name `example.org` into the IP address
    `93.184.216.34` and was able to connect to it.The line about escape characters
    is just instructions for using obscure `telnet` features. You can now talk to
    `example.org`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着操作系统已将主机名`example.org`转换为IP地址`93.184.216.34`并能够连接到它。关于转义字符的那一行只是使用神秘的`telnet`功能的说明。你现在可以与`example.org`通信了。
- en: The URL syntax is defined in [RFC 3987](https://tools.ietf.org/html/rfc3986),
    whose first author is Tim Berners-Lee—no surprise there! The second author is
    Roy Fielding, a key contributor to the design of HTTP and also well known for
    describing the Representational State Transfer (REST) architecture of the web
    in his [Ph.D. thesis](https://ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation_2up.pdf),
    which explains how REST allowed the web to grow in a decentralized way. Today,
    many services provide “RESTful APIs” that also follow these principles, though
    there does seem to be [some confusion](https://twobithistory.org/2020/06/28/rest.html)
    about it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: URL语法在[RFC 3987](https://tools.ietf.org/html/rfc3986)中定义，其第一作者是蒂姆·伯纳斯-李——这不足为奇！第二作者是罗伊·菲尔德，他是HTTP设计的关键贡献者，也因在其[博士论文](https://ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation_2up.pdf)中描述了Web的表示状态转换（REST）架构而闻名，该论文解释了REST如何使Web以去中心化的方式增长。今天，许多服务提供“RESTful
    API”，也遵循这些原则，尽管似乎存在[一些混淆](https://twobithistory.org/2020/06/28/rest.html)。
- en: Requesting Information
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求信息
- en: Once it’s connected, the browser requests information from the server by giving
    its *path*, the path being the part of a URL that comes after the host name, like
    `/index.html`. The structure of the request is shown in Figure 2\. Type this into
    `telnet` to try it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接成功，浏览器通过提供其*路径*来从服务器请求信息，路径是URL中主机名之后的部分，如`/index.html`。请求的结构如图2所示。在`telnet`中输入此信息以尝试它。
- en: '[PRE4]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Figure 2: An annotated HTTP GET request.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：注释的HTTP GET请求。
- en: Here, the word `GET` means that the browser would like to receive information,It
    could say `POST` if it intended to send information, plus there are some other,
    more obscure, options. then comes the path, and finally there is the word `HTTP/1.0`
    which tells the host that the browser speaks version 1.0 of [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP).
    There are several versions of HTTP ([0.9, 1.0, 1.1, 2.0, and 3.0](https://medium.com/platform-engineer/evolution-of-http-69cfe6531ba0)).
    The HTTP 1.1 standard adds a variety of useful features, like keep-alive, but
    in the interest of simplicity our browser won’t use them. We’re also not implementing
    HTTP 2.0; it is much more complex than the 1.*x* series, and is intended for large
    and complex web applications, which our browser can’t run anyway.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，单词`GET`意味着浏览器想要接收信息，如果它打算发送信息，则可以说`POST`，此外还有一些其他更不为人知的选项。然后是路径，最后是单词`HTTP/1.0`，它告诉主机浏览器使用的是[HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)的1.0版本。HTTP有几种版本（[0.9,
    1.0, 1.1, 2.0, 和 3.0](https://medium.com/platform-engineer/evolution-of-http-69cfe6531ba0)）。HTTP
    1.1标准增加了许多有用的功能，如持久连接，但为了简单起见，我们的浏览器不会使用它们。我们也没有实现HTTP 2.0；它比1.*x*系列复杂得多，并且是为大型和复杂的Web应用程序设计的，而我们的浏览器根本无法运行这些应用程序。
- en: After the first line, each line contains a *header*, which has a name (like
    `Host`) and a value (like `example.org`). Different headers mean different things;
    the `Host` header, for example, tells the server who you think it is.This is useful
    when the same IP address corresponds to multiple host names and hosts multiple
    websites (for example, `example.com` and `example.org`). The `Host` header tells
    the server which of multiple websites you want. These websites basically require
    the `Host` header to function properly. Hosting multiple domains on a single computer
    is very common. There are lots of other headers one could send, but let’s stick
    to just `Host` for now.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行之后，每一行都包含一个*标题*，它有一个名称（如`Host`）和一个值（如`example.org`）。不同的标题意味着不同的事情；例如，`Host`标题告诉服务器你认为它是谁。这在同一个IP地址对应多个主机名并且托管多个网站（例如，`example.com`和`example.org`）时非常有用。`Host`标题告诉服务器你想要哪个多个网站。这些网站基本上需要`Host`标题才能正常工作。在单台计算机上托管多个域名是非常常见的。还有许多其他可以发送的标题，但让我们现在就只关注`Host`。
- en: Finally, after the headers comes a single blank line; that tells the host that
    you are done with headers. So type a blank line into `telnet` (hit Enter twice
    after typing the two lines of the request) and you should get a response from
    `example.org`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在标题之后是一个单独的空白行；这告诉主机你已经完成了标题。因此，在`telnet`中输入一个空白行（在输入请求的两行后按两次Enter键）并应该从`example.org`获得响应。
- en: HTTP/1.0 is standardized in [RFC 1945](https://tools.ietf.org/html/rfc1945),
    and HTTP/1.1 in [RFC 2616](https://tools.ietf.org/html/rfc2616). HTTP was designed
    to be simple to understand and implement, making it easy for any kind of computer
    to adopt it. It’s no coincidence that you can type HTTP directly into `telnet`!
    Nor is it an accident that HTTP is a “line-based protocol”, using plain text and
    newlines, similar to the Simple Mail Transfer Protocol ([SMTP](https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol))
    for email. Ultimately, the whole pattern derives from early computers only having
    line-based text input. In fact, one of the first two browsers had a [line-mode
    UI](https://en.wikipedia.org/wiki/Line_Mode_Browser).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.0在[RFC 1945](https://tools.ietf.org/html/rfc1945)中标准化，HTTP/1.1在[RFC 2616](https://tools.ietf.org/html/rfc2616)中标准化。HTTP被设计成易于理解和实现，这使得任何类型的计算机都容易采用它。你可以在`telnet`中直接输入HTTP并不是巧合！HTTP是一个“基于行的协议”，使用纯文本和新行，类似于用于电子邮件的简单邮件传输协议([SMTP](https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol))。最终，整个模式源于早期计算机只有基于行的文本输入。事实上，最早的两个浏览器之一就有[行模式UI](https://en.wikipedia.org/wiki/Line_Mode_Browser)。
- en: The Server’s Response
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器响应
- en: The server’s response starts with the line in Figure 3.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应从图3中的行开始。
- en: '[PRE5]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Figure 3: Annotated first line of an HTTP response.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：HTTP响应的第一行注释。
- en: This tells you that the host confirms that it, too, speaks `HTTP/1.0`, and that
    it found your request to be “OK” (which has a numeric code of 200). You may be
    familiar with `404 Not Found`; that’s another numeric code and response, as are
    `403 Forbidden` or `500 Server Error`. There are lots of these codes, and they
    have a pretty neat organization scheme:The status text like `OK` can actually
    be anything and is just there for humans, not for machines.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你主机确认它也支持 `HTTP/1.0`，并且它认为你的请求是“OK”（其数字代码为200）。你可能熟悉 `404 Not Found`；这也是另一个数字代码和响应，就像
    `403 Forbidden` 或 `500 Server Error` 一样。这些代码有很多，并且它们有一个相当整洁的组织方案：状态文本如 `OK` 实际上可以是任何内容，只是供人类阅读，而不是供机器阅读。
- en: the 100s are informational messages;
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 100s是信息性消息；
- en: the 200s mean you were successful;
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 200s表示你成功了；
- en: the 300s request follow-up action (usually a redirect);
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 300s请求后续操作（通常是一个重定向）；
- en: the 400s mean you sent a bad request;
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 400s表示你发送了一个错误的请求；
- en: the 500s mean the server handled the request badly.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 500s表示服务器处理请求不当。
- en: Note the genius of having two sets of error codes (400s and 500s) to tell you
    who is at fault, the server or the browser.More precisely, who the server thinks
    is at fault. You can find a full list of the different codes [on Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes),
    and new ones do get added here and there.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到有两个错误代码集（400s和500s）的巧妙之处，它们可以告诉你谁有问题，是服务器还是浏览器。更确切地说，是服务器认为谁有问题。你可以在维基百科上找到不同代码的完整列表[在此](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)，并且确实会在这里和那里添加新的代码。
- en: 'After the `200 OK` line, the server sends its own headers. When I did this,
    I got these headers (but yours will differ):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在`200 OK`行之后，服务器发送它自己的头部。当我这样做的时候，我得到了这些头部（但你的可能会有所不同）：
- en: '[PRE6]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is *a lot* here, about the information you are requesting (`Content-Type`,
    `Content-Length`, and `Last-Modified`), about the server (`Server`, `X-Cache`),
    about how long the browser should cache this information (`Cache-Control`, `Expires`,
    `Etag`), and about all sorts of other stuff. Let’s move on for now.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多关于你请求的信息（`Content-Type`、`Content-Length`和`Last-Modified`），关于服务器（`Server`、`X-Cache`），关于浏览器应该缓存这些信息多长时间（`Cache-Control`、`Expires`、`Etag`），以及所有其他各种信息。现在让我们继续前进。
- en: After the headers there is a blank line followed by a bunch of [HTML](https://developer.mozilla.org/en-US/docs/Web/HTML)
    code. This is called the *body* of the server’s response, and your browser knows
    that it is HTML because of the `Content-Type` header, which says that it is `text/html`.
    It’s this HTML code that contains the content of the web page itself.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在头部之后是一个空白行，然后是一大堆[HTML](https://developer.mozilla.org/en-US/docs/Web/HTML)代码。这被称为服务器响应的*主体*，而你的浏览器知道它是HTML，是因为`Content-Type`头部表明它是`text/html`。正是这些HTML代码包含了网页本身的内容。
- en: The HTTP request/response transaction is summarized in Figure 4. Let’s now switch
    gears from making manual connections to Python.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求/响应事务总结在图4中。现在让我们从手动连接切换到Python。
- en: '![Figure 4: An HTTP request and response pair are how a web browser gets web
    pages from a web server.](img/82679443f3d5985ae05acdc1a1f6a243.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图4：一个HTTP请求和响应对是网页浏览器从网页服务器获取网页的方式。](img/82679443f3d5985ae05acdc1a1f6a243.png)'
- en: 'Figure 4: An HTTP request and response pair are how a web browser gets web
    pages from a web server.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：HTTP请求和响应对是网络浏览器从网络服务器获取网页的方式。
- en: Wikipedia has nice lists of HTTP [headers](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)
    and [response codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes).
    Some of the HTTP response codes are almost never used, like [402](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/402)
    “Payment Required”. This code was intended to be used for “digital cash or (micro)
    payment systems”. While e-commerce is alive and well without the response code
    402, [micropayments](https://en.wikipedia.org/wiki/Micropayment) have not (yet?)
    gained much traction, even though many people (including me!) think they are a
    good idea.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科有关于HTTP [头部](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)和[响应代码](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)的不错列表。一些HTTP响应代码几乎从未使用过，比如[402](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/402)
    “需要支付”。这个代码原本打算用于“数字现金或（微）支付系统”。尽管电子商务在没有响应代码402的情况下依然繁荣，[小额支付](https://en.wikipedia.org/wiki/Micropayment)（尚未？）并未获得太多关注，尽管许多人（包括我！）认为这是一个好主意。
- en: Telnet in Python
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的Telnet
- en: So far we’ve communicated with another computer using `telnet`. But it turns
    out that `telnet` is quite a simple program, and we can do the same programmatically.
    It’ll require extracting the host name and path from the URL, creating a *socket*,
    sending a request, and receiving a response.In Python, there’s a library called
    `urllib.parse` for parsing URLs, but I think implementing our own will be good
    for learning. Plus, it makes this book less Python-specific.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用`telnet`与另一台计算机进行了通信。但结果证明，`telnet`是一个非常简单的程序，我们可以通过编程来实现同样的功能。这需要从URL中提取主机名和路径，创建一个*套接字*，发送请求并接收响应。在Python中，有一个名为`urllib.parse`的库用于解析URL，但我认为实现自己的将有助于学习。此外，这使这本书不那么特定于Python。
- en: 'Let’s start with parsing the URL. I’m going to make parsing a URL return a
    `URL` object, and I’ll put the parsing code into the constructor:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从解析URL开始。我将使解析URL返回一个`URL`对象，并将解析代码放入构造函数中：
- en: '[PRE7]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `__init__` method is Python’s peculiar syntax for class constructors, and
    the `self` parameter, which you must always make the first parameter of any method,
    is Python’s analog of `this` in C++ or Java.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`方法是Python中类构造函数的特殊语法，而`self`参数，你必须始终将其作为任何方法的第一个参数，是Python中C++或Java中的`this`的对应物。'
- en: 'Let’s start with the scheme, which is separated from the rest of the URL by
    `://`. Our browser only supports `http`, so let’s check that, too:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从方案开始，它与URL的其余部分由`://`分隔。我们的浏览器只支持`http`，所以我们也检查一下：
- en: '[PRE8]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we must separate the host from the path. The host comes before the first
    `/`, while the path is that slash and everything after it:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须将主机名与路径分开。主机名在第一个`/`之前，而路径是那个斜杠及其之后的所有内容：
- en: '[PRE9]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: (When you see a code block with a `# ...`, like this one, that means you’re
    adding code to an existing method or block.) The `split(s, n)` method splits a
    string at the first `n` copies of `s`. Note that there’s some tricky logic here
    for handling the slash between the host name and the path. That (optional) slash
    is part of the path.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: （当你看到带有`# ...`的代码块，就像这样，这意味着你正在向现有方法或块中添加代码。）`split(s, n)`方法在第一个`n`个`s`的副本处拆分字符串。注意，这里有一些处理主机名和路径之间斜杠的复杂逻辑。那个（可选的）斜杠是路径的一部分。
- en: 'Now that the `URL` has the `host` and `path` fields, we can download the web
    page at that URL. We’ll do that in a new method, `request`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由于`URL`有了`host`和`path`字段，我们可以下载该URL的网页。我们将在一个新的方法`request`中这样做：
- en: '[PRE10]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that you always need to write the `self` parameter for methods in Python.
    In the future, I won’t always make such a big deal out of defining a method—if
    you see a code block with code in a method or function that doesn’t exist yet,
    that means we’re defining it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你总是需要在Python中的方法中编写`self`参数。在未来，我不会总是对定义方法如此大惊小怪——如果你看到一个代码块中包含尚未存在的方法或函数中的代码，这意味着我们正在定义它。
- en: 'The first step to downloading a web page is connecting to the host. The operating
    system provides a feature called “sockets” for this. When you want to talk to
    other computers (either to tell them something, or to wait for them to tell you
    something), you create a socket, and then that socket can be used to send information
    back and forth. Sockets come in a few different kinds, because there are multiple
    ways to talk to other computers:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下载网页的第一步是连接到主机。操作系统为此提供了一个名为“套接字”的功能。当你想与其他计算机（无论是告诉它们一些事情，还是等待它们告诉你一些事情）进行通信时，你创建一个套接字，然后可以使用该套接字来回发送信息。套接字有几种不同类型，因为与其他计算机通信有多种方式：
- en: A socket has an *address family*, which tells you how to find the other computer.
    Address families have names that begin with `AF`. We want `AF_INET`, but for example
    `AF_BLUETOOTH` is another.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字有一个*地址族*，它告诉你如何找到另一台计算机。地址族的名称以`AF`开头。我们想要`AF_INET`，但例如`AF_BLUETOOTH`是另一个。
- en: A socket has a *type*, which describes the sort of conversation that’s going
    to happen. Types have names that begin with `SOCK`. We want `SOCK_STREAM`, which
    means each computer can send arbitrary amounts of data, but there’s also `SOCK_DGRAM`,
    in which case they send each other packets of some fixed size.`DGRAM` stands for
    “datagram”, which I imagine to be like a postcard.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字有一个*类型*，它描述了将要发生的对话类型。类型的名称以`SOCK`开头。我们想要`SOCK_STREAM`，这意味着每台计算机可以发送任意数量的数据，但还有`SOCK_DGRAM`，在这种情况下，它们会发送固定大小的数据包。`DGRAM`代表“数据报”，我想象它就像一张明信片。
- en: A socket has a *protocol*, which describes the steps by which the two computers
    will establish a connection. Protocols have names that depend on the address family,
    but we want `IPPROTO_TCP`.Newer versions of HTTP use something called [QUIC](https://en.wikipedia.org/wiki/QUIC)
    instead of the Transmission Control Protocol (TCP), but our browser will stick
    to HTTP 1.0.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字有一个*协议*，它描述了两个计算机将如何建立连接的步骤。协议的名称取决于地址族，但我们想要`IPPROTO_TCP`。HTTP的新版本使用名为[QUIC](https://en.wikipedia.org/wiki/QUIC)的东西来代替传输控制协议（TCP），但我们的浏览器将坚持使用HTTP
    1.0。
- en: By picking all of these options, we can create a socket like so:While this code
    uses the Python `socket` library, your favorite language likely contains a very
    similar library; the API is basically standardized. In Python, the flags we pass
    are defaults, so you can actually call `socket.socket()`; I’m keeping the flags
    here in case you’re following along in another language.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择所有这些选项，我们可以创建一个像这样的套接字：虽然这段代码使用了Python的`socket`库，但你的语言很可能包含一个非常类似的库；API基本上是标准化的。在Python中，我们传递的标志是默认值，所以你实际上可以调用`socket.socket()`；我在这里保留标志，以防你在另一种语言中跟随。
- en: '[PRE11]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once you have a socket, you need to tell it to connect to the other computer.
    For that, you need the host and a *port*. The port depends on the protocol you
    are using; for now it should be 80.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了套接字，你需要告诉它连接到另一台计算机。为此，你需要主机和一个*端口*。端口取决于你使用的协议；现在应该是80。
- en: '[PRE12]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This talks to `example.org` to set up the connection and prepare both computers
    to exchange data.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`example.org`通信以设置连接并准备两台计算机交换数据。
- en: Naturally this won’t work if you’re offline. It also might not work if you’re
    behind a proxy, or in a variety of more complex networking environments. The workaround
    will depend on your setup—it might be as simple as disabling your proxy, or it
    could be much more complex.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，如果你离线，这不会起作用。如果你在代理后面，或者处于各种更复杂的网络环境中，这也可能不起作用。解决方案将取决于你的设置——它可能只是禁用你的代理，或者可能更加复杂。
- en: 'Note that there are two parentheses in the `connect` call: `connect` takes
    a single argument, and that argument is a pair of a host and a port. This is because
    different address families have different numbers of arguments.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`connect`调用中有两个括号：`connect`接受一个参数，该参数是一对主机和端口的组合。这是因为不同的地址族有不同的参数数量。
- en: The “sockets” API, which Python more or less implements directly, derives from
    the original “[Berkeley sockets](https://en.wikipedia.org/wiki/Berkeley_sockets)”
    API design for 4.2 BSD Unix in 1983\. Of course, Windows and Linux merely reimplement
    the API, but macOS and iOS actually do [still use](https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/BSD/BSD.html)
    large amounts of code descended from BSD Unix.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Python大致直接实现的“套接字”API源自1983年4.2 BSD Unix的原始“[伯克利套接字](https://en.wikipedia.org/wiki/Berkeley_sockets)”API设计。当然，Windows和Linux只是重新实现了API，但macOS和iOS实际上[仍然使用](https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/BSD/BSD.html)大量源自BSD
    Unix的代码。
- en: Request and Response
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求和响应
- en: 'Now that we have a connection, we make a request to the other server. To do
    so, we send it some data using the `send` method:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了连接，我们就向另一台服务器发送请求。为此，我们使用`send`方法向它发送一些数据：
- en: '[PRE13]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `send` method just sends the request to the server.`send` actually returns
    a number, in this case `47`. That tells you how many bytes of data you sent to
    the other computer; if, say, your network connection failed midway through sending
    the data, you might want to know how much you sent before the connection failed.
    There are a few things in this code that have to be exactly right. First, it’s
    very important to use `\r\n` instead of `\n` for newlines. It’s also essential
    that you put *two* `\r\n` newlines at the end, so that you send that blank line
    at the end of the request. If you forget that, the other computer will keep waiting
    on you to send that newline, and you’ll keep waiting on its response.Computers
    are endlessly literal-minded.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`send`方法只是将请求发送到服务器。`send`实际上返回一个数字，在这个例子中是`47`。这告诉你你向另一台计算机发送了多少字节的数据；如果你在发送数据的过程中网络连接失败，你可能想知道在连接失败之前你发送了多少数据。在这段代码中，有几处必须完全正确。首先，使用`\r\n`而不是`\n`作为换行符非常重要。同样，你必须在末尾放置两个`\r\n`换行符，以便发送请求末尾的空白行。如果你忘记了这一点，另一台计算机将一直等待你发送那个换行符，而你也会一直等待它的响应。计算机是永远字面意思的。'
- en: 'Also note the `encode` call. When you send data, it’s important to remember
    that you are sending raw bits and bytes; they could form text or an image or video.
    But a Python string is specifically for representing text. The `encode` method
    converts text into bytes, and there’s a corresponding `decode` method that goes
    the other way.When you call `encode` and `decode` you need to tell the computer
    what *character encoding* you want it to use. This is a complicated topic. I’m
    using `utf8` here, which is a common character encoding and will work on many
    pages, but in the real world you would need to be more careful. Python reminds
    you to be careful by giving different types to text and to bytes:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意`encode`调用。当你发送数据时，重要的是要记住你正在发送原始的比特和字节；它们可以形成文本、图像或视频。但Python字符串专门用于表示文本。`encode`方法将文本转换为字节，同时有一个相应的`decode`方法可以反向操作。当你调用`encode`和`decode`时，你需要告诉计算机你希望它使用哪种*字符编码*。这是一个复杂的话题。我在这里使用`utf8`，这是一种常见的字符编码，可以在许多页面上工作，但在现实生活中你需要更加小心。Python通过为文本和字节提供不同类型来提醒你要小心：
- en: '[PRE14]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you see an error about `str` versus `bytes`, it’s because you forgot to call
    `encode` or `decode` somewhere.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到关于`str`与`bytes`的错误，那是因为你忘记在某处调用`encode`或`decode`。
- en: To read the server’s response, you could use the `read` function on sockets,
    which gives whatever bits of the response have already arrived. Then you write
    a loop to collect those bits as they arrive. However, in Python you can use the
    `makefile` helper function, which hides the loop:If you’re in another language,
    you might only have `socket.read` available. You’ll need to write the loop, checking
    the socket status, yourself.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取服务器的响应，你可以使用套接字的`read`函数，它给出已经到达的响应的任何位。然后你编写一个循环来收集这些位，随着它们的到达。然而，在Python中，你可以使用`makefile`辅助函数，它隐藏了这个循环：如果你使用的是另一种语言，你可能只有`socket.read`可用。你需要自己编写循环，检查套接字状态。
- en: '[PRE15]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, `makefile` returns a file-like object containing every byte we receive
    from the server. I am instructing Python to turn those bytes into a string using
    the `utf8` *encoding*, or method of associating bytes to letters.Hard-coding `utf8`
    is not correct, but it’s a shortcut that will work alright on most English-language
    websites. In fact, the `Content-Type` header usually contains a `charset` declaration
    that specifies the encoding of the body. If it’s absent, browsers still won’t
    default to `utf8`; they’ll guess, based on letter frequencies, and you will see
    ugly � strange áççêñ£ß when they guess wrong. I’m also informing Python of HTTP’s
    weird line endings.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`makefile`返回一个包含我们从服务器接收到的每个字节的文件对象。我指示Python使用`utf8` *编码*，或者将字节与字母关联的方法，将这些字节转换为字符串。硬编码`utf8`是不正确的，但这是一个在大多数英文网站上都能正常工作的快捷方式。实际上，`Content-Type`头通常包含一个`charset`声明，指定了主体的编码。如果它不存在，浏览器仍然不会默认使用`utf8`；它们会根据字母频率进行猜测，如果猜错了，你会看到丑陋的�奇怪的áççêñ£ß。我还通知Python
    HTTP的奇怪行结束符。
- en: Let’s now split the response into pieces. The first line is the status line:I
    could have asserted that 200 is required, since that’s the only code our browser
    supports, but it’s better to just let the browser render the returned body, because
    servers will generally output a helpful and user-readable HTML error page even
    for error codes. This is another way in which the web is easy to implement incrementally.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将响应内容拆分成几个部分。第一行是状态行：我本可以断言需要 200 状态码，因为这是我们浏览器唯一支持的代码，但最好还是让浏览器渲染返回的体内容，因为服务器通常会为错误代码输出一个有用且用户可读的
    HTML 错误页面。这是网络易于逐步实现的一个例子。
- en: '[PRE16]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that I do *not* check that the server’s version of HTTP is the same as
    mine; this might sound like a good idea, but there are a lot of misconfigured
    servers out there that respond in HTTP 1.1 even when you talk to them in HTTP
    1.0.Luckily the protocols are similar enough to not cause confusion.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我没有检查服务器的 HTTP 版本是否与我的相同；这听起来可能是个好主意，但外面有很多配置不当的服务器，即使你用 HTTP 1.0 与它们通信，它们也会以
    HTTP 1.1 响应。幸运的是，协议足够相似，不会引起混淆。
- en: 'After the status line come the headers:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态行之后是头部信息：
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For the headers, I split each line at the first colon and fill in a map of header
    names to header values. Headers are case-insensitive, so I normalize them to lower
    case.I used [`casefold`](https://docs.python.org/3/library/stdtypes.html#str.casefold)
    instead of `lower`, because it works better for more languages. Also, whitespace
    is insignificant in HTTP header values, so I strip off extra whitespace at the
    beginning and end.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于头部信息，我将每一行在第一个冒号处拆分，并填充一个头部名称到头部值的映射。头部信息不区分大小写，因此我将它们规范为小写。我使用了 `casefold`（[casefold](https://docs.python.org/3/library/stdtypes.html#str.casefold)）而不是
    `lower`，因为它对更多语言更有效。此外，HTTP 头部值中的空白字符是不重要的，所以我移除了开头和结尾的额外空白字符。
- en: Headers can describe all sorts of information, but a couple of headers are especially
    important because they tell us that the data we’re trying to access is being sent
    in an unusual way. Let’s make sure none of those are present.Exercise 1-9 describes
    how your browser should handle these headers if they are present.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 头部信息可以描述各种信息，但有一些头部信息特别重要，因为它们告诉我们我们试图访问的数据是以一种不寻常的方式发送的。让我们确保这些信息中没有任何一个存在。练习
    1-9 描述了如果这些头部信息存在时，浏览器应该如何处理它们。
- en: '[PRE18]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The usual way to get the sent data, then, is everything after the headers:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通常获取发送数据的常用方法是头部信息之后的所有内容：
- en: '[PRE19]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It’s the body that we’re going to display, so let’s return that:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要显示的是体内容，所以让我们返回它：
- en: '[PRE20]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now let’s actually display the text in the response body.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实际显示响应体中的文本。
- en: The [`Content-Encoding`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding)
    header lets the server compress web pages before sending them. Large, text-heavy
    web pages compress well, and as a result the page loads faster. The browser needs
    to send an [`Accept-Encoding` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding)
    in its request to list the compression algorithms it supports. [`Transfer-Encoding`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding)
    is similar and also allows the data to be “chunked”, which many servers seem to
    use together with compression.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`Content-Encoding`（[内容编码](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding)）头允许服务器在发送之前压缩网页。大型、文本密集型的网页压缩效果很好，因此页面加载速度更快。浏览器需要在请求中发送一个
    `Accept-Encoding`（[接受编码](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding)）头来列出它支持的压缩算法。`Transfer-Encoding`（[传输编码](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding)）类似，也允许数据以“分块”的形式传输，许多服务器似乎会将它和压缩一起使用。'
- en: Displaying the HTML
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示 HTML
- en: The HTML code in the response body defines the content you see in your browser
    window when you go to `http://example.org/index.html`. I’ll be talking much, much
    more about HTML in future chapters, but for now let me keep it very simple.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 响应体中的 HTML 代码定义了当您访问 `http://example.org/index.html` 时在浏览器窗口中看到的页面内容。我将在未来的章节中详细讨论
    HTML，但现阶段我会尽量保持简单。
- en: 'In HTML, there are *tags* and *text*. Each tag starts with a `<` and ends with
    a `>`; generally speaking, tags tell you what kind of thing some content is, while
    text is the actual content.That said, some tags, like `img`, are content, not
    information about it. Most tags come in pairs of a start and an end tag; for example,
    the title of the page is enclosed in a pair of tags: `<title>` and `</title>`.
    Each tag, inside the angle brackets, has a tag name (like `title` here), and then
    optionally a space followed by *attributes*, and its pair has a `/` followed by
    the tag name (and no attributes).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 中，有 *标签* 和 *文本*。每个标签以 `<` 开头，以 `>` 结尾；一般来说，标签告诉您某些内容是什么类型，而文本是实际的内容。也就是说，一些标签，如
    `img`，本身就是内容，而不是关于它的信息。大多数标签以一对开始标签和结束标签的形式出现；例如，页面的标题被一对标签 `<title>` 和 `</title>`
    包围。每个标签，在尖括号内，都有一个标签名（如这里的 `title`），然后可选地跟一个空格，后面是 *属性*，其配对标签有一个 `/` 后跟标签名（没有属性）。
- en: So, to create our very, very simple web browser, let’s take the page HTML and
    print all the text, but not the tags, in it.If this example causes Python to produce
    a `SyntaxError` pointing to the `end` on the last line, it is likely because you
    are running Python 2 instead of Python 3\. Make sure you are using Python 3. I’ll
    do this in a new function, `show`:Note that this is a global function and not
    in the `URL` class.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了创建我们非常简单的网页浏览器，让我们取页面 HTML 并打印其中的所有文本，但不打印标签。如果这个例子导致 Python 产生一个指向最后一行
    `end` 的 `SyntaxError`，那么很可能是您正在运行 Python 2 而不是 Python 3。请确保您正在使用 Python 3。我将在一个新函数
    `show` 中做这件事：请注意，这是一个全局函数，不在 `URL` 类中。
- en: '[PRE21]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This code is pretty complex. It goes through the request body character by
    character, and it has two states: `in_tag`, when it is currently between a pair
    of angle brackets, and `not in_tag`. When the current character is an angle bracket,
    it changes between those states; normal characters, not inside a tag, are printed.The
    `end` argument tells Python not to print a newline after the character, which
    it otherwise would.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当复杂。它逐字符遍历请求体，并且有两个状态：`in_tag`，当它当前位于一对尖括号之间时，和 `not in_tag`。当当前字符是尖括号时，它在这两个状态之间切换；不在标签内的普通字符会被打印出来。《end`
    参数告诉 Python 不要在字符后打印换行符，否则它本会这样做。
- en: We can now load a web page just by stringing together `request` and `show`:Like
    `show`, this is a global function.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过将 `request` 和 `show` 连接起来加载一个网页：就像 `show` 一样，这是一个全局函数。
- en: '[PRE22]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following code to run `load` from the command line:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到命令行中运行 `load`：
- en: '[PRE23]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first line is Python’s version of a `main` function, run only when executing
    this script from the command line. The code reads the first argument (`sys.argv[1]`)
    from the command line and uses it as a URL. Try running this code on the URL `http://example.org/`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是 Python 的 `main` 函数版本，仅在从命令行执行此脚本时运行。代码从命令行读取第一个参数（`sys.argv[1]`）并将其用作 URL。尝试在
    URL `http://example.org/` 上运行此代码：
- en: '[PRE24]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You should see some short text welcoming you to the official example web page.
    You can also try using it on [this chapter](http://browser.engineering/http.html)!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一些简短的文本，欢迎您来到官方示例网页。您还可以尝试使用它在这个[章节](http://browser.engineering/http.html)中！
- en: HTML, just like URLs and HTTP, is designed to be very easy to parse and display
    at a basic level. And in the beginning there were very few features in HTML, so
    it was possible to code up something not so much more fancy than what you see
    here, yet still display the content in a usable way. Even our super simple and
    basic HTML parser can already print out the text of the [browser.engineering](https://browser.engineering/)
    website.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: HTML，就像 URL 和 HTTP 一样，被设计成非常容易解析和显示在基本级别。在开始的时候，HTML 中功能非常少，因此可以编写出一些不太复杂的东西，就像您在这里看到的那样，但仍以可用的方式显示内容。即使我们的超级简单和基本的
    HTML 解析器也能打印出 [browser.engineering](https://browser.engineering/) 网站的文本。
- en: Encrypted Connections
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密连接
- en: So far, our browser supports the `http` scheme. That’s a pretty common scheme.
    But more and more websites are migrating to the `https` scheme, and many websites
    require it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的浏览器支持 `http` 协议。这是一个相当常见的协议。但越来越多的网站正在迁移到 `https` 协议，许多网站要求使用它。
- en: 'The difference between `http` and `https` is that `https` is more secure—but
    let’s be a little more specific. The `https` scheme, or more formally HTTP over
    TLS (Transport Layer Security), is identical to the normal `http` scheme, except
    that all communication between the browser and the host is encrypted. There are
    quite a few details to how this works: which encryption algorithms are used, how
    a common encryption key is agreed to, and of course how to make sure that the
    browser is connecting to the correct host. The difference in the protocol layers
    involved is shown in Figure 5.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`http` 和 `https` 之间的区别在于 `https` 更安全——但让我们说得更具体一些。`https` 方案，或更正式地说，是 TLS（传输层安全性）上的
    HTTP，与正常的 `http` 方案完全相同，除了浏览器和主机之间的所有通信都是加密的。关于它是如何工作的有相当多的细节：使用了哪些加密算法，如何达成一个共同的加密密钥，当然还有如何确保浏览器连接到正确的服务器。涉及的协议层差异如图
    5 所示。'
- en: '![Figure 5: The difference between HTTP and HTTPS is the addition of a TLS
    layer.](img/5d8962051054b66db7cdcf1b51cf54f6.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 5：HTTP 和 HTTPS 之间的区别在于添加了 TLS 层。](img/5d8962051054b66db7cdcf1b51cf54f6.png)'
- en: 'Figure 5: The difference between HTTP and HTTPS is the addition of a TLS layer.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5：HTTP 和 HTTPS 之间的区别在于添加了 TLS 层。
- en: Luckily, the Python `ssl` library implements all of these details for us, so
    making an encrypted connection is almost as easy as making a regular connection.
    That ease of use comes with accepting some default settings which could be inappropriate
    for some situations, but for teaching purposes they are fine.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python 的 `ssl` 库为我们实现了所有这些细节，因此建立加密连接几乎和建立常规连接一样简单。这种易用性伴随着接受一些默认设置，这些设置可能不适合某些情况，但用于教学目的它们是合适的。
- en: 'Making an encrypted connection with `ssl` is pretty easy. Suppose you’ve already
    created a socket, `s`, and connected it to `example.org`. To encrypt the connection,
    you use `ssl.create_default_context` to create a *context* `ctx` and use that
    context to *wrap* the socket `s`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ssl` 建立加密连接相当简单。假设你已经创建了一个套接字 `s`，并将其连接到 `example.org`。为了加密连接，你使用 `ssl.create_default_context`
    创建一个 *上下文* `ctx`，并使用该上下文来 *包装* 套接字 `s`：
- en: '[PRE25]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that `wrap_socket` returns a new socket, which I save back into the `s`
    variable. That’s because you don’t want to send any data over the original socket;
    it would be unencrypted and also confusing. The `server_hostname` argument is
    used to check that you’ve connected to the right server. It should match the `Host`
    header.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`wrap_socket` 返回一个新的套接字，我将它保存回 `s` 变量。这是因为你不想通过原始套接字发送任何数据；这将是不加密的，也可能令人困惑。`server_hostname`
    参数用于检查你是否连接到了正确的服务器。它应该与 `Host` 头匹配。
- en: On macOS, you’ll need to [run a program called “Install Certificates”](https://stackoverflow.com/questions/52805115/certificate-verify-failed-unable-to-get-local-issuer-certificate)
    before you can use Python’s `ssl` package on most websites.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，你需要在大多数网站上使用 Python 的 `ssl` 包之前，先运行一个名为“安装证书”的程序。[运行程序](https://stackoverflow.com/questions/52805115/certificate-verify-failed-unable-to-get-local-issuer-certificate)。
- en: 'Let’s try to take this code and add it to `request`. First, we need to detect
    which scheme is being used:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将这段代码添加到 `request` 中。首先，我们需要检测正在使用哪种方案：
- en: '[PRE26]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: (Note that here you’re supposed to replace the existing scheme parsing code
    with this new code. It’s usually clear from context, and the code itself, what
    you need to replace.)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，这里你应该用这段新代码替换现有的方案解析代码。通常从上下文和代码本身就可以清楚地知道需要替换什么。）
- en: 'Encrypted HTTP connections usually use port 443 instead of port 80:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 加密的 HTTP 连接通常使用 443 端口而不是 80 端口：
- en: '[PRE27]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can use that port when creating the socket:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在创建套接字时使用该端口：
- en: '[PRE28]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we’ll wrap the socket with the `ssl` library:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `ssl` 库包装套接字：
- en: '[PRE29]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Your browser should now be able to connect to HTTPS sites.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你的浏览器现在应该能够连接到 HTTPS 网站。
- en: While we’re at it, let’s add support for custom ports, which are specified in
    a URL by putting a colon after the host name, as in Figure 6.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在此同时，让我们添加对自定义端口的支持，这些端口通过在主机名后放置冒号在 URL 中指定，如图 6 所示。
- en: '[PRE30]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Figure 6: Where the port goes in a URL.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6：URL 中端口号的位置。
- en: 'If the URL has a port we can parse it out and use it:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 URL 有端口号，我们可以解析它并使用它：
- en: '[PRE31]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Custom ports are handy for debugging. Python has a built-in web server you can
    use to serve files on your computer. For example, if you run
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义端口对于调试很有用。Python 有一个内置的 Web 服务器，你可以用它来在你的计算机上提供文件。例如，如果你运行
- en: '[PRE32]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: then going to `http://localhost:8000/` should show you all the files in that
    directory. This is a good way to test your browser.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后访问 `http://localhost:8000/` 应该会显示该目录中的所有文件。这是一种测试浏览器的好方法。
- en: TLS is pretty complicated. You can read the details in [RFC 8446](https://tools.ietf.org/html/rfc8446),
    but implementing your own is not recommended. It’s very difficult to write a custom
    TLS implementation that is not only correct but secure.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: TLS相当复杂。您可以在[RFC 8446](https://tools.ietf.org/html/rfc8446)中阅读详细信息，但实现自己的TLS不被推荐。编写一个不仅正确而且安全的自定义TLS实现非常困难。
- en: 'At this point you should be able to run your program on any web page. Here
    is what it should output for [a simple example](examples/example1-simple.html):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该能够在任何网页上运行您的程序。以下是对[一个简单示例](examples/example1-simple.html)的输出：
- en: '[PRE33]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter went from an empty file to a rudimentary web browser that can:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从空文件开始，变成了一个基本的网页浏览器，它可以：
- en: parse a URL into a scheme, host, port, and path;
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将URL解析为方案、主机、端口和路径；
- en: connect to that host using the `socket` and `ssl` libraries;
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`socket`和`ssl`库连接到该主机；
- en: send an HTTP request to that host, including a `Host` header;
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向该主机发送HTTP请求，包括`Host`头；
- en: split the HTTP response into a status line, headers, and a body;
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将HTTP响应拆分为状态行、头和正文；
- en: print the text (and not the tags) in the body.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印正文中的文本（而不是标签）。
- en: Yes, this is still more of a command-line tool than a web browser, but it already
    has some of the core capabilities of a browser.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这仍然更像是一个命令行工具而不是网页浏览器，但它已经具有了一些浏览器的基本功能。
- en: Outline
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should look
    something like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整函数、类和方法集应类似于以下内容：
- en: '`` class URL: `def __init__(url)` `def request()` `` `def show(body)` `def
    load(url)`'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`` class URL: `def __init__(url)` `def request()` `` `def show(body)` `def
    load(url)`'
- en: Exercises
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 1-1 *HTTP/1.1*. Along with `Host`, send the `Connection` header in the `request`
    function with the value `close`. Your browser can now declare that it is using
    `HTTP/1.1`. Also add a `User-Agent` header. Its value can be whatever you want—it
    identifies your browser to the host. Make it easy to add further headers in the
    future.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 1-1 *HTTP/1.1*. 除了`Host`之外，在`request`函数中发送`Connection`头，其值为`close`。您的浏览器现在可以声明它正在使用`HTTP/1.1`。还要添加一个`User-Agent`头。其值可以是您想要的任何内容——它将您的浏览器识别给主机。使其易于将来添加更多头信息。
- en: 1-2 *File URLs*. Add support for the `file` scheme, which allows the browser
    to open local files. For example, `file:///path/goes/here` should refer to the
    file on your computer at location `/path/goes/here`. Also make it so that, if
    your browser is started without a URL being given, some specific file on your
    computer is opened. You can use that file for quick testing.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 1-2 *文件URLs*. 添加对`file`方案的支持，允许浏览器打开本地文件。例如，`file:///path/goes/here`应指向您计算机上位于`/path/goes/here`位置的文件。还要确保，如果您的浏览器在没有提供URL的情况下启动，则打开您计算机上的某些特定文件。您可以使用该文件进行快速测试。
- en: 1-3 *`data`*. Yet another scheme is `data`, which allows inlining HTML content
    into the URL itself. Try navigating to `data:text/html,Hello world!` in a real
    browser to see what happens. Add support for this scheme to your browser. The
    `data` scheme is especially convenient for making tests without having to put
    them in separate files.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 1-3 *`数据`*. 另一种方案是`数据`，它允许将HTML内容内联到URL本身。尝试在一个真实的浏览器中导航到`data:text/html,Hello
    world!`以查看会发生什么。将对此方案的支持添加到您的浏览器中。`数据`方案特别方便，无需将测试放入单独的文件中即可进行测试。
- en: 1-4 *Entities*. Implement support for the less-than (`&lt;`) and greater-than
    (`&gt;`) entities. These should be printed as `<` and `>`, respectively. For example,
    if the HTML response was `&lt;div&gt;`, the `show` method of your browser should
    print `<div>`. Entities allow web pages to include these special characters without
    the browser interpreting them as tags.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 1-4 *实体*. 实现对小于（`&lt;`）和大于（`&gt;`）实体的支持。这些应分别打印为`<`和`>`。例如，如果HTML响应是`&lt;div&gt;`，则浏览器中的`show`方法应打印`<div>`。实体允许网页包含这些特殊字符，而浏览器不会将它们解释为标签。
- en: 1-5 *`view-source`*. Add support for the `view-source` scheme; navigating to
    `view-source:http://example.org/` should show the HTML source instead of the rendered
    page. Add support for this scheme. Your browser should print the entire HTML file
    as if it was text. You’ll want to have also implemented Exercise 1-4.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 1-5 *`view-source`*. 添加对`view-source`方案的支持；导航到`view-source:http://example.org/`应显示HTML源代码而不是渲染的页面。添加对此方案的支持。您的浏览器应打印整个HTML文件，就像它是文本一样。您还应该实现了练习1-4。
- en: '1-6 *Keep-alive*. Implement Exercise 1-1; however, do not send the `Connection:
    close` header (send `Connection: keep-alive` instead). When reading the body from
    the socket, only read as many bytes as given in the `Content-Length` header and
    don’t close the socket afterward. Instead, save the socket, and if another request
    is made to the same server reuse the same socket instead of creating a new one.
    (You’ll also need to pass the `"rb"` option to `makefile` or the value reported
    by `Content-Length` might not match the length of the string you’re reading.)
    This will speed up repeated requests to the same server, which are common.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '1-6 *Keep-alive*。实现练习1-1；然而，不要发送`Connection: close`头信息（发送`Connection: keep-alive`代替）。当从套接字读取正文时，只读取`Content-Length`头信息中给出的字节数，读取后不要关闭套接字。相反，保存套接字，如果对同一服务器有另一个请求，则重用相同的套接字而不是创建一个新的。
    （您还需要将`"rb"`选项传递给`makefile`或传递`Content-Length`报告的值，否则读取的字符串长度可能与长度不匹配。）这将加快对同一服务器的重复请求，这在实践中很常见。'
- en: 1-7 *Redirects*. Error codes in the 300 range request a redirect. When your
    browser encounters one, it should make a new request to the URL given in the `Location`
    header. Sometimes the `Location` header is a full URL, but sometimes it skips
    the host and scheme and just starts with a `/` (meaning the same host and scheme
    as the original request). The new URL might itself be a redirect, so make sure
    to handle that case. You don’t, however, want to get stuck in a redirect loop,
    so make sure to limit how many redirects your browser can follow in a row. You
    can test this with the URL [http://browser.engineering/redirect](http://browser.engineering/redirect),
    which redirects back to this page, and its [/redirect2](http://browser.engineering/redirect2)
    and [/redirect3](http://browser.engineering/redirect3) cousins which do more complicated
    redirect chains.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 1-7 *重定向*。300范围内的错误代码请求重定向。当您的浏览器遇到一个时，它应该向`Location`头信息中给出的URL发送一个新的请求。有时`Location`头信息是一个完整的URL，但有时它跳过主机和方案，只从`/`开始（意味着与原始请求相同的主机和方案）。新的URL本身可能也是一个重定向，所以请确保处理这种情况。然而，您不希望陷入重定向循环，所以请确保限制浏览器可以连续跟随的重定向数量。您可以通过URL
    [http://browser.engineering/redirect](http://browser.engineering/redirect) 进行测试，它将重定向回这个页面，以及它的
    [/redirect2](http://browser.engineering/redirect2) 和 [/redirect3](http://browser.engineering/redirect3)
    亲戚，它们执行更复杂的重定向链。
- en: 1-8 *Caching*. Typically, the same images, styles, and scripts are used on multiple
    pages; downloading them repeatedly is a waste. It’s generally valid to cache any
    HTTP response, as long as it was requested with `GET` and received a `200` response.Some
    other status codes like `301` and `404` can also be cached. Implement a cache
    in your browser and test it by requesting the same file multiple times. Servers
    control caches using the `Cache-Control` header. Add support for this header,
    specifically for the `no-store` and `max-age` values. If the `Cache-Control` header
    contains any value other than these two, it’s best not to cache the response.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 1-8 *缓存*。通常，相同的图像、样式和脚本在多个页面上使用；重复下载它们是浪费的。只要请求是用`GET`进行的并且收到了`200`响应，缓存任何HTTP响应通常是有效的。一些其他的状态代码，如`301`和`404`也可以缓存。在您的浏览器中实现缓存，并通过多次请求相同的文件来测试它。服务器使用`Cache-Control`头信息来控制缓存。添加对这个头信息的支持，特别是对`no-store`和`max-age`值的支持。如果`Cache-Control`头信息包含除这两个值之外的任何值，最好不要缓存响应。
- en: 1-9 *Compression*. Add support for HTTP compression, in which the browser [informs
    the server](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation)
    that compressed data is acceptable. Your browser must send the `Accept-Encoding`
    header with the value `gzip`. If the server supports compression, its response
    will have a `Content-Encoding` header with value `gzip`. The body is then compressed.
    Add support for this case. To decompress the data, you can use the `decompress`
    method in the `gzip` module. GZip data is not `utf8`-encoded, so pass `"rb"` to
    `makefile` to work with raw bytes instead. Most web servers send compressed data
    in a `Transfer-Encoding` called [`chunked`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding).There
    are also a couple of `Transfer-Encoding`s that compress the data. They aren’t
    commonly used. You’ll need to add support for that, too.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 1-9 *压缩*。添加对 HTTP 压缩的支持，其中浏览器 [通知服务器](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation)
    压缩数据是可以接受的。您的浏览器必须发送带有值 `gzip` 的 `Accept-Encoding` 头部。如果服务器支持压缩，其响应将包含带有值 `gzip`
    的 `Content-Encoding` 头部。然后对主体进行压缩。添加对这种情况的支持。要解压缩数据，您可以使用 `gzip` 模块中的 `decompress`
    方法。GZip 数据不是 `utf8` 编码的，所以将 `"rb"` 传递给 `makefile` 以处理原始字节。大多数 Web 服务器在名为 `chunked`
    的 `Transfer-Encoding` 中发送压缩数据。还有一些 `Transfer-Encoding` 也会压缩数据。它们并不常用。您还需要添加对这些的支持。
- en: Drawing to the Screen
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制到屏幕
- en: Chapter 2 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[Web 浏览器工程](./index.html "目录")的第二章。'
- en: '[Creating Windows](#creating-windows)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建窗口](#creating-windows)'
- en: '[Drawing to the Window](#drawing-to-the-window)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[绘制到窗口](#drawing-to-the-window)'
- en: '[Laying Out Text](#laying-out-text)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[布局文本](#laying-out-text)'
- en: '[Scrolling Text](#scrolling-text)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[滚动文本](#scrolling-text)'
- en: '[Faster Rendering](#faster-rendering)'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[更快渲染](#faster-rendering)'
- en: '[Summary](#summary)'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summary)'
- en: '[Outline](#outline)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大纲](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: 'A web browser doesn’t just download a web page; it also has to show that page
    to the user. In the twenty-first century, that means a graphical application.There
    are some obscure text-based browsers: I used `w3m` as my main browser for most
    of 2011\. I don’t anymore. So in this chapter we’ll equip our browser with a graphical
    user interface.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Web 浏览器不仅仅是下载网页；它还必须向用户展示该页面。在21世纪，这意味着一个图形应用程序。有一些基于文本的浏览器很神秘：我在2011年的大部分时间里使用
    `w3m` 作为我的主要浏览器。现在不再使用了。因此，在本章中，我们将为我们的浏览器配备一个图形用户界面。
- en: Creating Windows
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建窗口
- en: 'Desktop and laptop computers run operating systems that provide *desktop environments*:
    windows, buttons, and a mouse. So responsibility ends up split: programs control
    their windows, but the desktop environment controls the screen. Therefore:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面电脑和笔记本电脑运行提供 *桌面环境* 的操作系统：窗口、按钮和鼠标。因此，责任被分割：程序控制它们的窗口，但桌面环境控制屏幕。因此：
- en: The program asks for a new window and the desktop environment actually displays
    it.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序请求一个新的窗口，而桌面环境实际上显示了它。
- en: The program draws to its window and the desktop environment puts that on the
    screen.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序将其绘制到窗口中，而桌面环境将内容显示在屏幕上。
- en: The desktop environment tells the program about clicks and key presses, and
    the program responds and redraws its window.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面环境会告诉程序有关点击和按键的信息，然后程序会做出响应并重新绘制其窗口。
- en: 'Doing all of this by hand is a bit of a drag, so programs usually use a *graphical
    toolkit* to simplify these steps. Python comes with a graphical toolkit called
    Tk in the Python package `tkinter`.The library is called Tk, and it was originally
    written for a different language called Tcl. Python contains an interface to it,
    hence the name. Using it is quite simple:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 手动完成所有这些操作有些繁琐，所以程序通常使用 *图形工具包* 来简化这些步骤。Python 包含一个名为 Tk 的图形工具包，位于 Python 的
    `tkinter` 包中。这个库被称为 Tk，它最初是为一种名为 Tcl 的不同语言编写的。Python 包含了对其的接口，因此得名。使用它相当简单：
- en: '[PRE34]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, `tkinter.Tk()` asks the desktop environment to create a window and returns
    an object that you can use to draw to the window. The `tkinter.mainloop()` call
    enters a loop that looks like this:This pseudocode may look like an infinite loop
    that locks up the computer, but it’s not. Either the operating system will multitask
    among threads and processes, or the `pendingEvents` call will sleep until events
    are available, or both; in any case, other code will run and create events for
    the loop to respond to.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`tkinter.Tk()` 请求桌面环境创建一个窗口，并返回一个你可以用来在窗口上绘制的对象。`tkinter.mainloop()` 调用进入一个循环，其伪代码如下：这个伪代码看起来像是一个无限循环，会锁定计算机，但实际上并非如此。操作系统会在线程和进程之间进行多任务处理，或者`pendingEvents`
    调用会休眠直到有事件可用，或者两者都有；无论如何，其他代码将运行并为循环创建事件以响应。
- en: '[PRE35]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![Figure 1: Flowchart of an event-handling cycle.](img/1361125a9554c182a08d87d4cfaf3c56.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图1：事件处理周期流程图](img/1361125a9554c182a08d87d4cfaf3c56.png)'
- en: 'Figure 1: Flowchart of an event-handling cycle.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：事件处理周期流程图。
- en: Here, `pendingEvents` first asks the desktop environment for recent mouse clicks
    or key presses, then `handleEvent` calls your application to update state, and
    then `drawScreen` redraws the window. This *event loop* pattern (see Figure 1)
    is common in many applications, from web browsers to video games, because in complex
    graphical applications it ensures that all events are eventually handled and the
    screen is eventually updated.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`pendingEvents` 首先向桌面环境请求最近的鼠标点击或按键，然后 `handleEvent` 调用你的应用程序以更新状态，然后 `drawScreen`
    重新绘制窗口。这种 *事件循环* 模式（见图1）在许多应用程序中很常见，从网络浏览器到视频游戏，因为在复杂的图形应用程序中，它确保所有事件最终都会被处理，屏幕最终会被更新。
- en: Although you’re probably writing your browser on a desktop computer, many people
    access the web through mobile devices such as phones or tablets. On mobile devices
    there’s still a screen, a rendering loop, and most other things discussed in this
    book.For example, most real browsers have both desktop and mobile editions, and
    the rendering engine code is almost exactly the same for both.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能在一个桌面计算机上编写你的浏览器，但许多人通过手机或平板电脑等移动设备访问网络。在移动设备上，仍然有屏幕、渲染循环以及本书中讨论的几乎所有其他东西。例如，大多数真实浏览器都有桌面和移动版本，并且渲染引擎代码对于两者几乎完全相同。
- en: But there are several differences worth noting. Applications are usually full-screen,
    with only one application drawing to the screen at a time. There’s no mouse and
    only a virtual keyboard, so the main form of interaction is touch. There is the
    concept of a “visual viewport” that is not present on a desktop, to accommodate
    “desktop-only” and “mobile-ready” sites, as well as pinch zoom.Look at the source
    of [this chapter’s webpage](https://browser.engineering/graphics.html). In the
    `<head>` you’ll see a “viewport” `<meta>` tag. This tag tells the browser that
    the page supports mobile devices; without it, the browser assumes that the site
    is “desktop-only” and renders it differently, such as allowing the user to use
    a pinch-zoom or double-tap gesture to focus in on one part of the page. Once zoomed
    in, the part of the page visible on the screen is the “visual viewport” and the
    whole documents’ bounds are the “layout viewport”. This is kind of a mix between
    zooming and scrolling that’s usually absent on desktop. And screen pixel density
    is much higher, but the total screen resolution is usually lower. Supporting all
    of these differences is doable, but quite a bit of work. This book won’t go further
    into implementing them, except in some cases as exercises.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 但也有一些值得注意的差异。应用程序通常是全屏的，一次只有一个应用程序绘制到屏幕上。没有鼠标，只有一个虚拟键盘，因此主要的交互方式是触摸。有一个“视觉视口”的概念，这在桌面设备上不存在，以适应“仅桌面”和“移动准备”的网站，以及缩放手势。查看[本章网页的源代码](https://browser.engineering/graphics.html)。在
    `<head>` 中，你会看到一个“viewport” `<meta>` 标签。这个标签告诉浏览器该页面支持移动设备；如果没有它，浏览器会假设该网站是“仅桌面”的，并以不同的方式渲染，例如允许用户使用缩放手势或双击手势来聚焦页面的一部分。一旦放大，屏幕上可见的部分就是“视觉视口”，整个文档的边界是“布局视口”。这是一种介于缩放和滚动之间的混合，通常在桌面设备上不存在。并且屏幕像素密度要高得多，但总屏幕分辨率通常较低。支持所有这些差异是可行的，但需要相当多的工作。本书不会进一步深入实现它们，除非在某些情况下作为练习。
- en: Also, power efficiency is much more important, because the device runs on a
    battery, while at the same time the central processing unit (CPU) and memory are
    significantly slower and less capable. That makes it much more important to take
    advantage of any graphical processing unit (GPU)—the slow CPU makes good performance
    harder to achieve. Mobile browsers are challenging!
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，能效更为重要，因为设备是靠电池供电的，同时中央处理单元（CPU）和内存的运行速度显著较慢且能力不足。这使得充分利用任何图形处理单元（GPU）变得尤为重要——缓慢的CPU使得良好的性能更难实现。移动浏览器具有挑战性！
- en: Drawing to the Window
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在窗口中绘图
- en: 'Our browser will draw the web page text to a *canvas*, a rectangular Tk widget
    that you can draw circles, lines, and text on. For example, you can create a canvas
    with Tk like this:You may be familiar with the HTML `<canvas>` element, which
    is a similar idea: a two-dimensional rectangle in which you can draw shapes.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器将网页文本绘制到*画布*上，这是一个可以绘制圆形、线条和文本的矩形Tk小部件。例如，你可以用Tk创建一个画布如下：你可能熟悉HTML `<canvas>`元素，这是一个类似的概念：一个二维矩形，你可以在其中绘制形状。
- en: '[PRE36]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The first line creates the window, and the second creates the `Canvas` inside
    that window. We pass the window as an argument, so that Tk knows where to display
    the canvas. The other arguments define the canvas’s size; I chose 800 × 600 because
    that was a common old-timey monitor size.This size, called Super Video Graphics
    Array (SVGA), was standardized in 1987, and probably did seem super back then.
    The third line is a Tk peculiarity, which positions the canvas inside the window.
    Tk also has widgets like buttons and dialog boxes, but our browser won’t use them:
    we will need finer-grained control over appearance, which a canvas provides.This
    is why desktop applications are more uniform than web pages: desktop applications
    generally use widgets provided by a common graphical toolkit, which makes them
    look similar.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建窗口，第二行在窗口内创建`Canvas`。我们传递窗口作为参数，这样Tk就知道在哪里显示画布。其他参数定义了画布的大小；我选择了800 × 600，因为这曾是常见的旧式显示器尺寸。这个尺寸被称为超级视频图形阵列（SVGA），于1987年标准化，当时可能确实感觉非常出色。第三行是Tk的一个特性，它将画布定位在窗口内。Tk还有像按钮和对话框这样的小部件，但我们的浏览器不会使用它们：我们需要对外观有更精细的控制，而画布可以提供这种控制。这就是为什么桌面应用程序比网页更统一：桌面应用程序通常使用由通用图形工具包提供的控件，这使得它们看起来相似。
- en: 'To keep it all organized let’s put this code in a class:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持所有内容的组织，让我们将此代码放入一个类中：
- en: '[PRE37]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once you’ve made a canvas, you can call methods that draw shapes on the canvas.
    Let’s do that inside `load`, which we’ll move into the new `Browser` class:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个画布，你就可以调用在画布上绘制形状的方法。让我们在`load`方法中这样做，我们将将其移动到新的`Browser`类中：
- en: '[PRE38]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To run this code, create a `Browser`, call `load`, and then start the Tk `mainloop`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此代码，创建一个`Browser`对象，调用`load`方法，然后启动Tk的`mainloop`：
- en: '[PRE39]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You ought to see: a rectangle, starting near the top-left corner of the canvas
    and ending at its center; then a circle inside that rectangle; and then the text
    “Hi!” next to the circle, as in Figure 2.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到：一个矩形，从画布的左上角开始，延伸到中心；然后在该矩形内画一个圆形；接着在圆形旁边写上“Hi!”文本，如图2所示。
- en: '![Figure 2: The expected example output with a rectangle, circle, and text.](img/4b77def76b13347060a0e424c5537d81.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图2：预期示例输出，包含矩形、圆形和文本。](img/4b77def76b13347060a0e424c5537d81.png)'
- en: 'Figure 2: The expected example output with a rectangle, circle, and text.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：预期示例输出，包含矩形、圆形和文本。
- en: Coordinates in Tk refer to *x* positions from left to right and *y* positions
    from top to bottom. In other words, the bottom of the screen has *larger* *y*
    values, the opposite of what you might be used to from math. Play with the coordinates
    above to figure out what each argument refers to.The answers are in the [online
    documentation](https://anzeljg.github.io/rin2/book2/2405/docs/tkinter/canvas.html).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Tk中的坐标指的是从左到右的*x*位置和从上到下的*y*位置。换句话说，屏幕的底部具有更大的*y*值，这与你可能从数学中习惯的相反。通过调整上面的坐标来找出每个参数所指的内容。答案可以在[在线文档](https://anzeljg.github.io/rin2/book2/2405/docs/tkinter/canvas.html)中找到。
- en: The Tk canvas widget is quite a bit more powerful than what we’re using it for
    here. As you can see from [the tutorial](https://tkdocs.com/tutorial/canvas.html),
    you can move the individual things you’ve drawn to the canvas, listen to click
    events on each one, and so on. I’m not using those features in this book, because
    I want to teach you how to implement them yourself.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Tk画布小部件比我们在这里使用的功能强大得多。正如你从[教程](https://tkdocs.com/tutorial/canvas.html)中可以看到，你可以将你画在画布上的单个东西移动，监听每个东西的点击事件等等。我在这本书中不使用这些功能，因为我想要教你如何自己实现它们。
- en: Laying Out Text
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本布局
- en: Let’s draw a simple web page on this canvas. So far, our browser steps through
    the web page source code character by character and prints the text (but not the
    tags) to the console window. Now we want to draw the characters on the canvas
    instead.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在画布上绘制一个简单的网页。到目前为止，我们的浏览器逐个字符地遍历网页源代码，并将文本（但不包括标签）打印到控制台窗口中。现在我们想要在画布上绘制字符。
- en: 'To start, let’s change the `show` function from the previous chapter into a
    function that I’ll call `lex`Foreshadowing future developments… which just *returns*
    the textual content of an HTML document without printing it:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将上一章中的 `show` 函数改为一个我将称之为 `lex` 的函数……预示着未来的发展……它只是*返回*HTML文档的文本内容，而不打印它：
- en: '[PRE40]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, `load` will draw that text, character by character:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`load` 将逐个字符地绘制该文本：
- en: '[PRE41]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let’s test this code on a real web page. For reasons that might seem inscrutable,It’s
    to delay a discussion of basic typography to the next chapter. let’s test it on
    the [first chapter of 西游记 or *Journey to the West*](https://browser.engineering/examples/xiyouji.html),
    a classic Chinese novel about a monkey. Run this URLRight click on the link and
    "Copy URL". through `request`, `lex`, and `load`. You should see a window with
    a big blob of black pixels inset a little from the top left corner of the window.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个真实的网页上测试这段代码。由于可能看似难以理解的原因，我们推迟到下一章讨论基本的排版。让我们在[《西游记》或*《西天取经》*的第一章](https://browser.engineering/examples/xiyouji.html)上测试它，这是一部关于猴子的经典中国小说。通过
    `request`、`lex` 和 `load` 运行这个URL。你应该会看到一个窗口，其中有一个大块状的黑色像素，位于窗口的左上角稍微偏下。
- en: 'Why a blob instead of letters? Well, of course, because we are drawing every
    letter in the same place, so they all overlap! Let’s fix that:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是块状文本而不是字母？当然，因为我们是在相同的位置绘制每个字母，所以它们都重叠了！让我们来修复这个问题：
- en: '[PRE42]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The variables `cursor_x` and `cursor_y` point to where the next character will
    go, as if you were typing the text into a word processor. I picked the magic numbers—13
    and 18—by trying a few different values and picking one that looked most readable.In
    [Chapter 3](text.html), we’ll replace the magic numbers with font metrics.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `cursor_x` 和 `cursor_y` 指向下一个字符将要放置的位置，就像你在一个文字处理程序中输入文本一样。我通过尝试几个不同的值，并选择一个看起来最易读的数字——13和18。在[第3章](text.html)中，我们将用字体度量值替换这些魔法数字。
- en: 'The text now forms a line from left to right. But with an 800-pixel-wide canvas
    and 13 pixels per character, one line only fits about 60 characters. You need
    more than that to read a novel, so we also need to *wrap* the text once we reach
    the edge of the screen:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文本从左到右形成一行。但是，在一个800像素宽的画布上，每个字符13像素，一行只能容纳大约60个字符。阅读小说需要更多，所以当我们达到屏幕边缘时，我们还需要将文本*换行*：
- en: '[PRE43]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The code increases `cursor_y` and resets `cursor_x`In the olden days of typewriters,
    increasing *y* meant *feed*ing in a new *line*, and resetting *x* meant *return*ing
    the *carriage* that printed letters to the left edge of the page. So the American
    Standard Code for Information Interchange ([ASCII](https://en.wikipedia.org/wiki/ASCII))
    standardized two separate characters—“carriage return” and “line feed”—for these
    operations, so that ASCII could be directly executed by teletypewriters. That’s
    why headers in HTTP are separated by `\r\n`, even though modern computers have
    no mechanical carriage. once `cursor_x` goes past 787 pixels.Not 800, because
    we started at pixel 13 and I want to leave an even gap on both sides. The sequence
    is shown in Figure 3\. Wrapping the text this way makes it possible to read more
    than a single line.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 代码增加 `cursor_y` 并重置 `cursor_x`。在打字机的古老时代，增加 *y* 意味着*进纸*，重置 *x* 意味着*回车*，将打印字母的*打印头*返回到页面的左边缘。因此，美国信息交换标准代码([ASCII](https://en.wikipedia.org/wiki/ASCII))为这些操作标准化了两个单独的字符——“回车”和“换行”——这样ASCII就可以直接由电传打字机执行。这就是为什么HTTP中的标题由`\r\n`分隔，尽管现代计算机没有机械的打印头。一旦
    `cursor_x` 超过787像素。不是800，因为我们从像素13开始，我想在两边都留下一个均匀的间隙。这个序列在图3中显示。以这种方式换行可以使阅读超过单行成为可能。
- en: 'Here’s a widget demonstrating that concept:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个演示这个概念的部件：
- en: '[widgets/lab2-render.html](widgets/lab2-render.html)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[widgets/lab2-render.html](widgets/lab2-render.html)'
- en: At this point you should be able to load up [our example page](https://browser.engineering/examples/xiyouji.html)
    in your browser and have it look something like Figure 4.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该能够在浏览器中加载[我们的示例页面](https://browser.engineering/examples/xiyouji.html)，并且它看起来应该像图4所示。
- en: '![Figure 4: The first chapter of Journey to the West rendered in our browser.](img/990952a3f08a3129bba6c76d9d4fe751.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图4：在我们的浏览器中渲染的《西游记》的第一章。](img/990952a3f08a3129bba6c76d9d4fe751.png)'
- en: 'Figure 4: The first chapter of *Journey to the West* rendered in our browser.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：在我们的浏览器中渲染的《西游记》的第一章。
- en: 'Now we can read a lot of text, but still not all of it: if there’s enough text,
    not all of the lines will fit on the screen. We want users to *scroll* the page
    to look at different parts of it.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以读取很多文本，但还不是全部：如果文本足够多，不是所有的行都能显示在屏幕上。我们希望用户能够*滚动*页面来查看不同的部分。
- en: 'In English text, you can’t wrap to the next line in the middle of a word (without
    hyphenation at least), but in Chinese that’s the default, even for words made
    up of multiple characters. For example, 开关 meaning “switch” is composed of 开 “on”
    and 关 “off”, but it’s just fine to line-break after 开. You can change the default
    with the word-break CSS property: `break-all` allows line breaks anywhere, while
    `auto-phrase` prevents them inside even inside Chinese or Japanese words or phrases
    such as 开关. The “auto” part here refers to the fact that the words aren’t identified
    by the author but instead auto-detected, often [using dynamic programming](https://unicode-org.github.io/icu/userguide/boundaryanalysis/break-rules.html#details-about-dictionary-based-break-iteration)
    based on a [word frequency table](https://github.com/unicode-org/icu/blob/master/icu4c/source/data/brkitr/dictionaries/cjdict.txt).'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在英文文本中，你无法在单词中间换行（至少在没有连字符的情况下），但在中文中这是默认的，即使是多字符组成的单词也是如此。例如，开关意味着“开关”，由开“on”和关“off”组成，但在“开”之后换行是可以的。你可以使用word-break
    CSS属性来更改默认设置：`break-all`允许在任何地方换行，而`auto-phrase`则防止在中文或日文单词或短语（如开关）内部换行。这里的“auto”部分指的是单词不是由作者识别的，而是自动检测的，通常基于[词频表](https://github.com/unicode-org/icu/blob/master/icu4c/source/data/brkitr/dictionaries/cjdict.txt)通过[动态规划](https://unicode-org.github.io/icu/userguide/boundaryanalysis/break-rules.html#details-about-dictionary-based-break-iteration)实现的。
- en: Scrolling Text
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动文本
- en: Scrolling introduces a layer of indirection between page coordinates (this text
    is 132 pixels from the top of the *page*) and screen coordinates (since you’ve
    scrolled 60 pixels down, this text is 72 pixels from the top of the *screen*)—see
    Figure 5\. Generally speaking, a browser *lays out* the page—determines where
    everything on the page goes—in terms of page coordinates and then *rasters* the
    page—draws everything—in terms of screen coordinates.Sort of. What actually happens
    is that the page is first drawn into a bitmap or GPU texture, then that bitmap/texture
    is shifted according to the scroll, and the result is rendered to the screen.
    [Chapter 11](visual-effects.html) will have more on this topic.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动在页面坐标（这段文本距离页面顶部132像素）和屏幕坐标（由于你向下滚动了60像素，这段文本距离屏幕顶部72像素）之间引入了一层间接层——参见图5。一般来说，浏览器会*布局*页面——确定页面上所有元素的位置——以页面坐标为准，然后*光栅化*页面——绘制所有元素——以屏幕坐标为准。某种程度上是这样的。实际上发生的情况是页面首先被绘制到一个位图或GPU纹理中，然后根据滚动偏移这个位图/纹理，最后将结果渲染到屏幕上。[第11章](visual-effects.html)将更详细地介绍这个话题。
- en: '![Figure 5: The difference between page and screen coordinates.](img/eea722716ea491ae809a324c6a1fbc4d.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图5：页面坐标和屏幕坐标之间的差异。](img/eea722716ea491ae809a324c6a1fbc4d.png)'
- en: 'Figure 5: The difference between page and screen coordinates.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：页面坐标和屏幕坐标之间的差异。
- en: 'Our browser will have the same split. Right now `load` computes both the position
    of each character and draws it: layout and rendering. Let’s instead have a `layout`
    function to compute and store the position of each character, and a separate `draw`
    function to then draw each character based on the stored position. This way, `layout`
    can operate with page coordinates and only `draw` needs to think about screen
    coordinates.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器也会有同样的分割。目前`load`同时计算每个字符的位置并绘制它：布局和渲染。让我们有一个`layout`函数来计算并存储每个字符的位置，然后有一个单独的`draw`函数根据存储的位置绘制每个字符。这样，`layout`可以使用页面坐标，而只有`draw`需要考虑屏幕坐标。
- en: 'Let’s start with `layout`. Instead of calling `canvas.create_text` on each
    character, let’s add it to a list, together with its position. Since `layout`
    doesn’t need to access anything in `Browser`, it can be a standalone function:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `layout` 开始。而不是在每个字符上调用 `canvas.create_text`，让我们将其添加到一个列表中，连同其位置。由于 `layout`
    不需要访问 `Browser` 中的任何内容，它可以是一个独立的函数：
- en: '[PRE44]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The resulting list of things to display is called a *display list*.The term
    “display list” is standard. Since `layout` is all about page coordinates, we don’t
    need to change anything else about it to support scrolling.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示的项目列表称为 *显示列表*。术语“显示列表”是标准的。由于 `layout` 全部关于页面坐标，我们不需要对其做任何其他更改来支持滚动。
- en: 'Once the display list is computed, `draw` needs to loop through it and draw
    each character. Since `draw` does need access to the canvas, we make it a method
    on `Browser`:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算完显示列表，`draw` 需要遍历它并绘制每个字符。由于 `draw` 需要访问画布，我们将其作为 `Browser` 的一个方法：
- en: '[PRE45]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now `load` just needs to call `layout` followed by `draw`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `load` 只需调用 `layout` 然后是 `draw`：
- en: '[PRE46]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we can add scrolling. Let’s add a field for how far you’ve scrolled:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加滚动功能。让我们添加一个字段来记录你滚动的距离：
- en: '[PRE47]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The page coordinate `y` then has screen coordinate `y - self.scroll`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 页面坐标 `y` 然后是屏幕坐标 `y - self.scroll`：
- en: '[PRE48]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you change the value of `scroll` the page will now scroll up and down. But
    how does the *user* change `scroll`?
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改 `scroll` 的值，页面现在将上下滚动。但用户是如何更改 `scroll` 的呢？
- en: Most browsers scroll the page when you press the up and down keys, rotate the
    scroll wheel, drag the scroll bar, or apply a touch gesture to the screen. To
    keep things simple, let’s just implement the down key.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浏览器在按下上下键、旋转滚轮、拖动滚动条或向屏幕应用触摸手势时都会滚动页面。为了保持简单，让我们只实现向下键。
- en: 'Tk allows you to *bind* a function to a key, which instructs Tk to call that
    function when the key is pressed. For example, to bind to the down arrow key,
    write:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: Tk 允许你将一个函数绑定到一个键上，这会指示 Tk 在按键时调用该函数。例如，要绑定到向下箭头键，请编写：
- en: '[PRE49]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, `self.scrolldown` is an *event handler*, a function that Tk will call
    whenever the down arrow key is pressed.`scrolldown` is passed an *event object*
    as an argument by Tk, but since scrolling down doesn’t require any information
    about the key press besides the fact that it happened, `scrolldown` ignores that
    event object. All it needs to do is increment `scroll` and redraw the canvas:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`self.scrolldown` 是一个 *事件处理程序*，一个 Tk 在按下向下箭头键时将调用的函数。`scrolldown` 由 Tk 通过一个
    *事件对象* 作为参数传递，但由于向下滚动不需要关于按键的任何信息，除了它发生了之外，`scrolldown` 忽略了该事件对象。它需要做的只是增加 `scroll`
    并重新绘制画布：
- en: '[PRE50]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If you try this out, you’ll find that scrolling draws all the text a second
    time. That’s because we didn’t erase the old text before drawing the new text.
    Call `canvas.delete` to clear the old text:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试这样做，你会发现滚动会再次绘制所有文本。这是因为我们在绘制新文本之前没有擦除旧文本。调用 `canvas.delete` 来清除旧文本：
- en: '[PRE51]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Scrolling should now work!
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在滚动应该可以正常工作了！
- en: 'Storing the display list makes scrolling faster: the browser isn’t doing `layout`
    every time you scroll. Modern browsers [take this further](https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/),
    retaining much of the display list even when the web page changes due to JavaScript
    or user interaction.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 存储显示列表使滚动更快：浏览器在滚动时不需要每次都进行 `layout`。现代浏览器 [更进一步](https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/)，即使在网页由于
    JavaScript 或用户交互而更改时，也保留大部分显示列表。
- en: In general, scrolling is the most common user interaction with web pages. Real
    browsers have accordingly invested a *tremendous* amount of time making it fast;
    we’ll get to some more of the ways they do this later in the book.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，滚动是用户与网页最常见的交互方式。真实浏览器因此投入了大量的时间来使其快速；我们将在本书的后面部分了解到他们是如何做到这一点的。
- en: Faster Rendering
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快的渲染
- en: Applications have to redraw page contents quickly for interactions to feel fluid,On
    older systems, applications drew directly to the screen, and if they didn’t update,
    whatever was there last would stay in place, which is why in error conditions
    you’d often have one window leave “trails” on another. Modern systems use [compositing](https://en.wikipedia.org/wiki/Compositing_window_manager),
    which avoids trails and also improves performance and isolation. Applications
    still redraw their window contents, though, to change what is displayed. [Chapter
    13](animations.html) discusses compositing in more detail. and must respond quickly
    to clicks and key presses so the user doesn’t get frustrated. “Feel fluid” can
    be made more precise. Graphical applications such as browsers typically aim to
    redraw at a speed equal to the refresh rate, or *frame rate*, of the screen, and/or
    a fixed 60 Hz.Most screens today have a refresh rate of 60 Hz, and that is generally
    considered fast enough to look smooth. However, new hardware is increasingly appearing
    with higher refresh rates, such as 120 Hz. It’s not yet clear if browsers can
    be made that fast. Some rendering engines, games in particular, refresh at lower
    rates on purpose if they know the rendering speed can’t keep up. This means that
    the browser has to finish all its work in less than 1/60th of a second, or 16 ms,
    in order to keep up. For this reason, 16 ms is called the *animation frame budget*
    of the application.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序必须快速重绘页面内容，以便交互感觉流畅，在较旧的系统中，应用程序直接在屏幕上绘制，如果没有更新，之前的内容就会保持原位，这就是为什么在错误条件下，你经常会在一个窗口上看到另一个窗口留下的“痕迹”。现代系统使用[合成](https://en.wikipedia.org/wiki/Compositing_window_manager)，这避免了痕迹，同时也提高了性能和隔离。尽管如此，应用程序仍然需要重绘窗口内容以更改显示的内容。[第13章](animations.html)更详细地讨论了合成。并且必须快速响应用户的点击和按键，以免用户感到沮丧。“感觉流畅”可以更加精确。图形应用程序，如浏览器，通常旨在以与屏幕刷新率或固定60赫兹相同的速度重绘，或者两者兼而有之。如今，大多数屏幕的刷新率为60赫兹，这通常被认为足够快，看起来很平滑。然而，越来越多的新硬件出现了更高的刷新率，如120赫兹。目前尚不清楚浏览器能否达到这么快的速度。一些渲染引擎，尤其是游戏，如果知道渲染速度跟不上，会故意以较低的速率刷新。这意味着浏览器必须在不到1/60秒，即16毫秒内完成所有工作，才能保持同步。因此，16毫秒被称为应用程序的*动画帧预算*。
- en: But scrolling in our browser is pretty slow.How fast exactly seems to depend
    a lot on your operating system and default font. Why? It turns out that loading
    information about the shape of a character, inside `create_text`, takes a while.
    To speed up scrolling we need to make sure to do it only when necessary (while
    at the same time ensuring the pixels on the screen are always correct).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们浏览器中的滚动相当慢。具体有多快似乎很大程度上取决于你的操作系统和默认字体。为什么？结果是，在`create_text`内部加载关于字符形状的信息需要一些时间。为了加快滚动速度，我们需要确保只在必要时（同时确保屏幕上的像素始终正确）进行操作。
- en: 'Real browsers have a lot of quite tricky optimizations for this, but for our
    browser let’s limit ourselves to a simple improvement: skip drawing characters
    that are offscreen:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 实际浏览器为此做了很多相当复杂的优化，但对我们这个浏览器来说，让我们限制自己做一些简单的改进：跳过绘制屏幕外的字符：
- en: '[PRE52]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first `if` statement skips characters below the viewing window; the second
    skips characters above it. In that second `if` statement, `y + VSTEP` is the bottom
    edge of the character, because characters that are halfway inside the viewing
    window still have to be drawn.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`if`语句跳过了位于视窗下方的字符；第二个`if`语句跳过了位于视窗上方的字符。在第二个`if`语句中，`y + VSTEP`是字符的底部边缘，因为即使字符一半在视窗内，仍然需要绘制。
- en: Scrolling should now be pleasantly fast, and hopefully close to the 16 ms animation
    frame budget.On my computer, it was still about double that budget, so there is
    work to do—we’ll get to that in future chapters. And because we split `layout`
    and `draw`, we don’t need to change `layout` at all to implement this optimization.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在滚动应该会变得非常快，并且希望接近16毫秒的动画帧预算。在我的电脑上，它仍然大约是那个预算的两倍，所以还有工作要做——我们将在未来的章节中讨论。而且因为我们拆分了`layout`和`draw`，所以我们根本不需要改变`layout`来实现这个优化。
- en: You should also keep in mind that not all web page interactions are animations—there
    are also discrete actions such as mouse clicks. Research has shown that it usually
    suffices to respond to a discrete action in [100 ms]—below that threshold, most
    humans are not sensitive to discrete action speed. This is very different from
    interactions such as scroll, where a speed of less than 60 Hz or so is quite noticeable.
    The difference between the two has to do with the way the human mind processes
    movement (animation) versus discrete action, and the time it takes for the brain
    to decide upon such an action, execute it, and understand its result.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该记住，并非所有网页交互都是动画——还有诸如鼠标点击这样的离散动作。研究表明，通常在[100 ms]内响应离散动作就足够了——低于这个阈值，大多数人不会对离散动作速度敏感。这与滚动等交互方式非常不同，滚动速度低于60 Hz左右就非常明显。这两种方式之间的区别在于人类大脑处理运动（动画）与离散动作的方式，以及大脑决定此类动作、执行它并理解其结果所需的时间。
- en: Summary
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter went from a rudimentary command-line browser to a graphical user
    interface with text that can be scrolled. The browser now:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从基本的命令行浏览器发展到具有可滚动的文本的图形用户界面。现在浏览器：
- en: talks to your operating system to create a window;
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与你的操作系统通信以创建窗口；
- en: lays out the text and draws it to that window;
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本布局并绘制到该窗口中；
- en: listens for keyboard commands;
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听键盘命令；
- en: scrolls the window in response.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应滚动窗口。
- en: And here is our browser rendering this very web page (it’s fullly interactive—after
    clicking on it to focus, you should be able to scroll with the down arrow):This
    is the full browser source code, cross-compiled to JavaScript and running in an
    iframe. Click “restart” to choose a new web page to render, then “start” to render
    it. Subsequent chapters will include one of these at the end of the chapter so
    you can see how it improves.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的浏览器渲染的正是这个网页（它完全交互式——点击它以获取焦点后，你应该可以使用下箭头滚动）：这是完整的浏览器源代码，交叉编译成JavaScript并在iframe中运行。点击“重启”以选择要渲染的新网页，然后点击“开始”来渲染它。后续章节将在章节末尾包含其中之一，以便你可以看到它是如何改进的。
- en: '[widgets/lab2-browser.html](widgets/lab2-browser.html)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[widgets/lab2-browser.html](widgets/lab2-browser.html)'
- en: Next, we’ll make this browser work on English text, handling complexities like
    variable-width characters, line layout, and formatting.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使这个浏览器能够处理英文文本，并处理诸如可变宽度字符、行布局和格式化等复杂性。
- en: Outline
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should look
    something like this:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整功能集、类和方法应该看起来像这样：
- en: '`` class URL: `def __init__(url)` `def request()` `` `def lex(body)` `WIDTH,
    HEIGHT` `HSTEP, VSTEP` `def layout(text)` `SCROLL_STEP` `` class Browser: `def
    __init__()` `def draw()` `def load(url)` `def scrolldown(e)` ``'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`` class URL: `def __init__(url)` `def request()` `` `def lex(body)` `WIDTH,
    HEIGHT` `HSTEP, VSTEP` `def layout(text)` `SCROLL_STEP` `` class Browser: `def
    __init__()` `def draw()` `def load(url)` `def scrolldown(e)` ``'
- en: Exercises
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 2-1 *Line breaks*. Change `layout` to end the current line and start a new one
    when it sees a newline character. Increment *y* by more than `VSTEP` to give the
    illusion of paragraph breaks. There are poems embedded in *Journey to the West*;
    now you’ll be able to make them out.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 2-1 *换行符*。当它看到换行符时，将`layout`更改为结束当前行并开始新的一行。将*y*增加超过`VSTEP`以产生段落分隔的错觉。在《西游记》中嵌入了一些诗歌；现在你将能够辨认出来。
- en: 2-2 *Mouse wheel*. Add support for scrolling up when you hit the up arrow. Make
    sure you can’t scroll past the top of the page. Then bind the `<MouseWheel>` event,
    which triggers when you scroll with the mouse wheel.It will also trigger with
    touchpad gestures, if you don’t have a mouse. The associated event object has
    an `event.delta` value which tells you how far and in what direction to scroll.
    Unfortunately, macOS and Windows give the `event.delta` objects opposite sign
    and different scales, and on Linux scrolling instead uses the `<Button-4>` and
    `<Button-5>` events.The [Tk manual](https://wiki.tcl-lang.org/page/mousewheel)
    has more information about this. Cross-platform applications are much harder to
    write than cross-browser ones!
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 2-2 *鼠标滚轮*。当你按下上箭头时，添加向上滚动的支持。确保你不能滚动到页面的顶部。然后绑定`<MouseWheel>`事件，该事件在用鼠标滚轮滚动时触发。如果没有鼠标，它也会通过触摸板手势触发。相关的事件对象有一个`event.delta`值，它告诉你滚动多远以及滚动方向。不幸的是，macOS和Windows提供的`event.delta`对象具有相反的符号和不同的比例，而在Linux中滚动则使用`<Button-4>`和`<Button-5>`事件。《Tk手册》(https://wiki.tcl-lang.org/page/mousewheel)有更多关于这方面的信息。跨平台应用程序比跨浏览器应用程序更难编写！
- en: 2-3 *Resizing*. Make the browser resizable. To do so, [pass the `fill` and `expand`
    arguments](https://web.archive.org/web/20201111222645id_/http://effbot.org/tkinterbook/pack.htm)
    to `canvas.pack`, and call and bind to the `<Configure>` event, which happens
    when the window is resized. The window’s new width and height can be found in
    the `width` and `height` fields on the event object. Remember that when the window
    is resized, the line breaks must change, so you will need to call `layout` again.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 2-3 *调整大小*. 使浏览器可调整大小。要做到这一点，将`fill`和`expand`参数传递给`canvas.pack`，并调用并绑定到`<Configure>`事件，该事件在窗口调整大小时发生。窗口的新宽度和高度可以在事件对象的`width`和`height`字段中找到。记住，当窗口调整大小时，换行必须改变，因此你需要再次调用`layout`。
- en: 2-4 *Scrollbar*. Stop your browser from scrolling down past the last display
    list entry.This is not quite right in a real browser; the browser needs to account
    for extra whitespace at the bottom of the screen or the possibility of objects
    purposefully drawn offscreen. In [Chapter 5](layout.html), we’ll implement this
    correctly. At the right edge of the screen, draw a blue, rectangular scrollbar.
    Make sure the size and position of the scrollbar reflects what part of the full
    document the browser can see, as in Figure 5\. Hide the scrollbar if the whole
    document fits onscreen.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 2-4 *滚动条*. 阻止你的浏览器滚动到最后一项显示列表条目之后。在实际浏览器中，这并不完全正确；浏览器需要考虑屏幕底部的额外空白或对象故意绘制到屏幕之外的可能性。在第5章[布局](layout.html)中，我们将正确实现这一点。在屏幕的右侧绘制一个蓝色的矩形滚动条。确保滚动条的大小和位置反映了浏览器可以看到的整个文档的部分，如图5所示。如果整个文档适合屏幕，则隐藏滚动条。
- en: 2-5 *Emoji*. Add support for emoji to your browser 😀. Emoji are characters,
    and you can call `create_text` to draw them, but the results aren’t very good.
    Instead, head to [the OpenMoji project](https://openmoji.org), download the emoji
    for [“grinning face”](https://openmoji.org/library/#emoji=1F600) as a PNG file,
    resize it to 16 × 16 pixels, and save it to the same folder as the browser. Use
    Tk’s `PhotoImage` class to load the image and then the `create_image` method to
    draw it to the canvas. In fact, download the whole OpenMoji library (look for
    the “Get OpenMojis” button at the top right)—then your browser can look up whatever
    emoji is used in the page.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 2-5 *表情符号*. 为你的浏览器添加对表情符号的支持 😀。表情符号是字符，你可以调用`create_text`来绘制它们，但结果并不理想。相反，前往[OpenMoji项目](https://openmoji.org)，下载[“笑脸”](https://openmoji.org/library/#emoji=1F600)表情符号作为PNG文件，将其调整到16
    × 16像素大小，并将其保存到与浏览器相同的文件夹中。使用Tk的`PhotoImage`类来加载图像，然后使用`create_image`方法将其绘制到画布上。实际上，下载整个OpenMoji库（在右上角查找“获取OpenMojis”按钮）——然后你的浏览器可以查找页面中使用的任何表情符号。
- en: 2-6 *`about:blank`*. Currently, a malformed URL causes the browser to crash.
    It would be much better to have error recovery for that, and instead show a blank
    page, so that the user can fix the error. To do this, add support for the special
    `about:blank` URL, which should just render a blank page, and cause malformed
    URLs to automatically render as if they were `about:blank`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 2-6 *`about:blank`*. 目前，一个格式不正确的URL会导致浏览器崩溃。对于这种情况，有错误恢复会更好，并且显示一个空白页面，这样用户就可以修复错误。为此，添加对特殊`about:blank`
    URL的支持，它应该只渲染一个空白页面，并且使格式不正确的URL自动渲染为`about:blank`。
- en: 2-7 *Alternate text direction*. Not all languages read and lay out from left
    to right. Arabic, Persian, and Hebrew are good examples of right-to-left languages.
    Implement basic support for this with a command-line flag to your browser.Once
    we get to [Chapter 4](html.html) you could instead use the [`dir`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir)
    attribute on the `<body>` element. English sentences should still lay out left-to-right,
    but they should grow from the right side of the screen (load [this example](examples/example2-rtl.html)
    in your favorite browser to see what I mean).Sentences in an actual right-to-left
    language should do the opposite. And then there is vertical writing mode for some
    East Asian languages like Chinese and Japanese.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 2-7 *文本方向交替*. 并非所有语言都是从左到右阅读和布局的。阿拉伯语、波斯语和希伯来语就是从右到左语言的优秀例子。可以通过在浏览器中添加命令行标志来实现对这种基本支持。一旦我们进入[第4章](html.html)，你就可以在`<body>`元素上使用`dir`属性（[查看dir属性](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir)）。英文句子仍然应该从左到右布局，但它们应该从屏幕的右侧开始（在你的浏览器中加载[这个示例](examples/example2-rtl.html)以了解我的意思）。实际从右到左语言的句子应该相反。然后，对于一些东亚语言，如中文和日语，还有垂直书写模式。
- en: Formatting Text
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本格式化
- en: Chapter 3 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '[网络浏览器工程](./index.html "目录")的第三章。'
- en: '[What is a Font?](#what-is-a-font)'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[什么是字体？](#什么是字体)'
- en: '[Measuring Text](#measuring-text)'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[测量文本](#测量文本)'
- en: '[Word by Word](#word-by-word)'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[逐字显示](#逐字显示)'
- en: '[Styling Text](#styling-text)'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[设置文本样式](#设置文本样式)'
- en: '[A Layout Object](#a-layout-object)'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[布局对象](#布局对象)'
- en: '[Text of Different Sizes](#text-of-different-sizes)'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[不同大小的文本](#不同大小的文本)'
- en: '[Font Caching](#font-caching)'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字体缓存](#字体缓存)'
- en: '[Summary](#summary)'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[摘要](#摘要)'
- en: '[Outline](#outline)'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大纲](#大纲)'
- en: '[Exercises](#exercises)'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#练习)'
- en: In the last chapter, our browser created a graphical window and drew a grid
    of characters to it. That’s OK for Chinese, but English text features characters
    of different widths grouped into words that you can’t break across lines.There
    are lots of languages in the world, and lots of typographic conventions. A real
    web browser supports every language from Arabic to Zulu, but this book focuses
    on English. Text is near-infinitely complex, but this book cannot be infinitely
    long! In this chapter, we’ll add those capabilities. You’ll even be able to read
    [this chapter](https://browser.engineering/text.html) in your browser!
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们的浏览器创建了一个图形窗口，并在其中绘制了一个字符网格。这对中文来说是可以的，但英文文本具有不同宽度的字符，这些字符可以组成单词，不能跨行断开。世界上有无数种语言，以及无数种排版传统。真正的网络浏览器支持从阿拉伯语到祖鲁语的所有语言，但本书专注于英语。文本几乎无限复杂，但本书不能无限长！在这一章中，我们将添加这些功能。你甚至可以在你的浏览器中阅读[这一章](https://browser.engineering/text.html)！
- en: What is a Font?
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是字体？
- en: So far, we’ve called `create_text` with a character and two coordinates to write
    text to the screen. But we never specified its font, size, or style. To talk about
    those things, we need to create and use font objects.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用`create_text`函数时，只传递了一个字符和两个坐标来在屏幕上写入文本。但我们从未指定过它的字体、大小或样式。要谈论这些事情，我们需要创建并使用字体对象。
- en: What is a *font*, exactly? Well, in the olden days, printers arranged little
    metal slugs on rails, covered them with ink, and pressed them to a sheet of paper,
    creating a printed page (see Figure 1). The metal shapes came in boxes, one per
    letter, so you’d have a (large) box of e’s, a (small) box of x’s, and so on. The
    boxes came in cases (see Figure 2), one for upper-*case* and one for lower-*case*
    letters. The set of cases was called a font.The word is related to *foundry*,
    which would create the little metal shapes. Naturally, if you wanted to print
    larger text, you needed different (bigger) shapes, so those were a different font;
    a collection of fonts was called a *type*, which is why we call it typing. Variations—like
    bold or italic letters—were called that type’s “faces”.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是“字体”，确切地说？在古代，印刷工会把小金属字块排列在轨道上，用墨水覆盖它们，然后压在一张纸上，从而制作出印刷页面（见图1）。金属形状放在盒子里，每个字母一个盒子，所以你会有一个（大）e的盒子，一个（小）x的盒子，等等。盒子放在盒子里（见图2），一个用于大写字母，一个用于小写字母。这组盒子被称为“字体”。这个词与“铸造厂”有关，它会制作这些小金属形状。当然，如果你想打印更大的文本，你需要不同的（更大的）形状，所以这些是不同的字体；一组字体被称为“类型”，这就是为什么我们称之为打字。变化——如粗体或斜体字母——被称为该类型的“字体样式”。
- en: '![Figure 1: A drawing of printing press workers. (By Daniel Nikolaus Chodowiecki.
    Wikipedia, public domain.)](img/1662d0022d9dea81b9e04553d0c57761.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![图1：印刷工人的绘画。（由Daniel Nikolaus Chodowiecki创作。维基百科，公有领域。）](img/1662d0022d9dea81b9e04553d0c57761.png)'
- en: 'Figure 1: A drawing of printing press workers. (By [Daniel Nikolaus Chodowiecki](https://en.wikipedia.org/wiki/Daniel_Chodowiecki).
    [Wikipedia](https://commons.wikimedia.org/wiki/File:Chodowiecki_Basedow_Tafel_21_c.jpg),
    public domain.)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：印刷工人的绘画。（由[Daniel Nikolaus Chodowiecki](https://en.wikipedia.org/wiki/Daniel_Chodowiecki)创作。[维基百科](https://commons.wikimedia.org/wiki/File:Chodowiecki_Basedow_Tafel_21_c.jpg)，公有领域。）
- en: '![Figure 2: Metal types in letter cases and a composing stick. (By Willi Heidelbach.
    Wikipedia, CC BY 2.5.)](img/d44cc3499adb4db7bb421a56a481fbc2.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![图2：字母盒中的金属活字和排版棒。（由Willi Heidelbach创作。维基百科，CC BY 2.5。）](img/d44cc3499adb4db7bb421a56a481fbc2.png)'
- en: 'Figure 2: Metal types in letter cases and a composing stick. (By Willi Heidelbach.
    [Wikipedia](https://en.wikipedia.org/wiki/File:Metal_movable_type.jpg), [CC BY
    2.5](https://creativecommons.org/licenses/by/2.5/deed.en).)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：字母盒中的金属活字和排版棒。（由Willi Heidelbach创作。[维基百科](https://en.wikipedia.org/wiki/File:Metal_movable_type.jpg)，[CC
    BY 2.5](https://creativecommons.org/licenses/by/2.5/deed.en)。)
- en: 'This nomenclature reflects the world of the printing press: metal shapes in
    boxes in cases from different foundries. Our modern world instead has dropdown
    menus, and the old words no longer match it. “Font” can now mean font, typeface,
    or type,Let alone “font family”, which can refer to larger or smaller collections
    of types. and we say a font contains several different *weights* (like “bold”
    and “normal”),But sometimes other weights as well, like “light”, “semibold”, “black”,
    and “condensed”. Good fonts tend to come in many weights. several different *styles*
    (like “italic” and “roman”, which is what not-italic is called),Sometimes there
    are other options as well, like maybe there’s a small-caps version; these are
    sometimes called *options* as well. And don’t get me started on automatic versus
    manual italics. and arbitrary *sizes*.A font looks especially good at certain
    sizes where *hints* tell the computer how best to align it to the pixel grid.
    Welcome to the world of magic ink.This term comes from an [essay by Bret Victor](http://worrydream.com/MagicInk/)
    that discusses how the graphical possibilities of computers can make for better
    and easier-to-use applications.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命名法反映了印刷机的世界：来自不同铸字厂的盒子中的金属形状。我们的现代世界有下拉菜单，而旧词已经不再适用。“字体”现在可以指字体、字体族或字体样式，而“字体族”可以指更大的或更小的字体集合。我们说一个字体包含几个不同的*重量*（如“粗体”和“正常”），但有时还有其他重量，如“轻”、“半粗体”、“黑色”和“紧凑”。好的字体往往有多种重量。几种不同的*样式*（如“斜体”和“罗马”，即非斜体的称呼），有时还有其他选项，比如可能有一个小写字母版本；这些有时也被称为*选项*。而且不要开始讨论自动与手动斜体。还有任意*大小*。字体在特定大小下看起来特别漂亮，因为*提示*告诉电脑如何最好地将其对齐到像素网格。欢迎来到魔法墨水的世界。这个术语来自Bret
    Victor的一篇[论文](http://worrydream.com/MagicInk/)，讨论了计算机的图形可能性如何使应用程序更好、更易于使用。
- en: 'Yet Tk’s *font objects* correspond to the older meaning of font: a type at
    a fixed size, style, and weight. For example:You can only create `Font` objects,
    or any other kinds of Tk objects, after calling `tkinter.Tk()`, and you need to
    import `tkinter.font` separately.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Tk的*字体对象*对应于字体更古老的意义：一个固定大小、样式和重量的字体。例如：你只能在调用`tkinter.Tk()`之后创建`Font`对象，或者任何其他类型的Tk对象，并且你需要单独导入`tkinter.font`。
- en: '[PRE53]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Your computer might not have “Times” installed; you can list the available fonts
    with `tkinter.font.families()` and pick something else.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 你的电脑可能没有安装“Times”字体；你可以使用`tkinter.font.families()`列出可用的字体，然后选择其他字体。
- en: 'Font objects can be passed to `create_text`’s `font` argument:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 字体对象可以传递给`create_text`的`font`参数：
- en: '[PRE54]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the olden times, American typesetters kept their boxes of metal shapes arranged
    in a [California job case](http://www.alembicpress.co.uk/Typecases/CJCCASE.HTM),
    which combined lower- and upper-case letters side by side in one case, making
    typesetting easier. The upper-/lower-case nomenclature dates from centuries earlier.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在古代，美国排字工人将金属形状的盒子排列在[加州工作案](http://www.alembicpress.co.uk/Typecases/CJCCASE.HTM)中，这种盒子将大小写字母并排放在一个盒子中，使得排版更加容易。大小写字母的命名法可以追溯到几个世纪以前。
- en: Measuring Text
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量文本
- en: 'Text takes up space vertically and horizontally, and the font object’s `metrics`
    and `measure` methods measure that space:On your computer, you might get different
    numbers. That’s right—text rendering is OS-dependent, because it is complex enough
    that everyone uses one of a few libraries to do it, usually libraries that ship
    with the OS. That’s why macOS fonts tend to be “blurrier” than the same font on
    Windows: different libraries make different trade-offs.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 文本在垂直和水平方向上占据空间，字体对象的`metrics`和`measure`方法测量这个空间：在你的电脑上，你可能会得到不同的数字。没错——文本渲染是操作系统依赖的，因为它足够复杂，以至于每个人都会使用几个库中的一个来处理它，通常这些库是操作系统自带的。这就是为什么macOS字体往往比Windows上的相同字体“模糊”的原因：不同的库做出了不同的权衡。
- en: '[PRE55]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `metrics` call yields information about the vertical dimensions of the
    text (see Figure 3): the `linespace` is how tall the text is, which includes an
    `ascent` which goes “above the line” and a `descent` that goes “below the line”.The
    `fixed` parameter is actually a boolean and tells you whether all letters are
    the same *width*, so it doesn’t really fit here. The `ascent` and `descent` matter
    when words in different sizes sit on the same line: they ought to line up “along
    the line”, not along their tops or bottoms.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`metrics`调用提供了关于文本垂直维度的信息（见图3）：`linespace`是文本的高度，包括一个“超出行”的`ascent`和一个“低于行”的`descent`。《fixed》参数实际上是一个布尔值，告诉你所有字母是否具有相同的*宽度*，所以它实际上并不适合这里。《ascent》和`descent`在大小不同的单词位于同一行时很重要：它们应该“沿着行”对齐，而不是沿着它们的顶部或底部对齐。'
- en: '![Figure 3: The various vertical metrics of a font. All glyphs in a font share
    the same ascent, x-height, and descent, and are laid out on a shared baseline.
    However, the measure (or advance) of glyphs can differ.](img/aca67363f2d0e28a5575095c8391534c.png)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![图3：字体的各种垂直度量。字体中的所有符号共享相同的上升、x高度和下降，并且布局在共享的基线上。然而，符号的度量（或前进）可以不同。](img/aca67363f2d0e28a5575095c8391534c.png)'
- en: 'Figure 3: The various vertical metrics of a font. All glyphs in a font share
    the same ascent, *x*-height, and descent, and are laid out on a shared baseline.
    However, the measure (or advance) of glyphs can differ.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：字体的各种垂直度量。字体中的所有符号共享相同的上升、*x*高度和下降，并且布局在共享的基线上。然而，符号的度量（或前进）可以不同。
- en: 'Let’s dig deeper. Remember that `bi_times` is size-16 Times: why does `font.metrics`
    report that it is actually 19 pixels tall? Well, first of all, a size of 16 means
    16 *points*, which are defined as 72nds of an inch, not 16 *pixels*,Actually,
    the definition of a “point” is a total mess, with many different length units
    all called “point” around the world. The [Wikipedia page](https://en.wikipedia.org/wiki/Point_(typography))
    has the details, but a traditional American/British point is actually slightly
    less than 1/72 of an inch. The 1/72 standard comes from PostScript, but some systems
    predate it; TeX , for example, hews closer to the traditional point, approximating
    it as 1/72.27 of an inch. which your monitor probably has around 100 of per inch.Tk
    doesn’t use points anywhere else in its API. It’s supposed to use pixels if you
    pass it a negative number, but that doesn’t appear to work. Those 16 points measure
    not the individual letters but the metal blocks the letters were once carved from,
    so the letters themselves must be *less than* 16 points. In fact, different size-16
    fonts have letters of varying heights:You might even notice that Times has different
    metrics in this code block than in the earlier one where we specified a bold,
    italic Times font. The bold, italic Times font is taller, at least on my current
    macOS system!'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨。记住`bi_times`是16号的Times字体：为什么`font.metrics`报告它实际上有19像素高？好吧，首先，16号大小意味着16
    *points*，这些点是定义为英寸的72分之一，而不是16 *pixels*。实际上，“点”的定义非常混乱，世界各地有许多不同的长度单位都被称为“点”。[维基百科页面](https://en.wikipedia.org/wiki/Point_(typography))有详细信息，但传统的美国/英国点实际上略小于1/72英寸。1/72标准来自PostScript，但一些系统在它之前；例如，TeX更接近于传统的点，将其近似为1/72.27英寸。你的显示器每英寸可能有大约100个这样的点。Tk在其API的任何其他地方都不使用点。如果你传递一个负数，它应该使用像素，但看起来这似乎不起作用。这16个点测量的不是单个字母，而是字母曾经刻制的金属块，因此字母本身必须*小于*16点。实际上，不同大小的16号字体有不同的字母高度：你甚至可能会注意到，在这个代码块中，Times的垂直度量与我们在指定加粗、斜体的Times字体时使用的早期度量不同。加粗、斜体的Times字体更高，至少在我的当前macOS系统上是这样！
- en: '[PRE56]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `measure()` method is more direct: it tells you how much *horizontal* space
    text takes up, in pixels. This depends on the text, of course, since different
    letters have different widths:Note that the sum of the individual letters’ lengths
    is not the length of the word. Tk uses fractional pixels internally, but rounds
    up to return whole pixels in the `measure` call. Plus, some fonts use something
    called *kerning* to shift letters a little bit when particular pairs of letters
    are next to one another, or even *shaping* to make two letters look one glyph.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`measure()`方法更直接：它告诉你文本占据多少*水平*空间，以像素为单位。这当然取决于文本，因为不同的字母有不同的宽度：请注意，单个字母长度的总和不是单词的长度。Tk在内部使用分数像素，但在`measure`调用中向上舍入以返回整个像素。此外，一些字体使用称为*字距调整*的技术，在特定字母对相邻时稍微移动字母，或者甚至使用*形状*使两个字母看起来像一个符号。'
- en: '[PRE57]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can use this information to lay text out on the page. For example, suppose
    you want to draw the text “Hello, world!” in two pieces, so that “world!” is italic.
    Let’s use two fonts:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些信息在页面上布局文本。例如，假设你想要将文本“Hello, world!”分成两部分，使得“world!”是斜体。让我们使用两种字体：
- en: '[PRE58]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can now lay out the text, starting at `(200, 200)`:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以从`(200, 200)`开始布局文本：
- en: '[PRE59]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You should see “Hello,” and “world!”, correctly aligned and with the second
    word italicized.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到“Hello,”和“world!”，正确对齐，并且第二个单词是斜体的。
- en: 'Unfortunately, this code has a bug, though one masked by the choice of example
    text: replace “world!” with “overlapping!” and the two words will overlap. That’s
    because the coordinates `x` and `y` that you pass to `create_text` tell Tk where
    to put the *center* of the text. It only worked for “Hello, world!” because “Hello,”
    and “world!” are the same length!'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码有一个错误，尽管这个错误被示例文本的选择所掩盖：将“world!”替换为“overlapping!”，这两个单词就会重叠。这是因为你传递给`create_text`的坐标`x`和`y`告诉Tk文本的中心位置在哪里。它只对“Hello,
    world!”有效，因为“Hello,”和“world!”的长度相同！
- en: 'Luckily, the meaning of the coordinate you pass in is configurable. We can
    instruct Tk to treat the coordinate we gave as the top-left corner of the text
    by setting the `anchor` argument to `"nw"`, meaning the “northwest” corner of
    the text:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你传递的坐标的意义是可以配置的。我们可以指示Tk将我们给出的坐标视为文本的左上角，通过将`anchor`参数设置为`"nw"`，即文本的“西北角”：
- en: '[PRE60]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Modify the `draw` function to set `anchor` to `"nw"`; we didn’t need to do that
    in the previous chapter because all Chinese characters are the same width.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`draw`函数，将`anchor`设置为`"nw"`；在前一章中我们不需要这样做，因为所有中文字符的宽度都是相同的。
- en: If you find font metrics confusing, you’re not the only one! In 2012, the Michigan
    Supreme Court heard [Stand Up for Democracy v. Secretary of State](https://publicdocs.courts.mi.gov/opinions/final/sct/20120803_s145387_157_standup-op.pdf),
    a case ultimately about a ballot referendum’s validity that centered on the definition
    of font size. The court decided (correctly) that font size is the size of the
    metal blocks that letters were carved from and not the size of the letters themselves.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现字体度量很复杂，你不是唯一的一个！2012年，密歇根州最高法院审理了[Stand Up for Democracy v. Secretary
    of State](https://publicdocs.courts.mi.gov/opinions/final/sct/20120803_s145387_157_standup-op.pdf)一案，这是一个关于选票公投有效性的案件，其核心是字体大小的定义。法院决定（正确地）字体大小是字母刻制的金属块的尺寸，而不是字母本身的尺寸。
- en: Word by Word
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐字逐句
- en: In [Chapter 2](graphics.html), the `layout` function looped over the text character
    by character and moved to the next line whenever we ran out of space. That’s appropriate
    in Chinese, where each character more or less *is* a word. But in English you
    can’t move to the next line in the middle of a word. Instead, we need to lay out
    the text one word at a time:This code splits words on whitespace. It’ll thus break
    on Chinese, since there won’t be whitespace between words. Real browsers use language-dependent
    rules for laying out text, including for identifying word boundaries.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](graphics.html)中，`layout`函数逐个字符遍历文本，并在空间用尽时移动到下一行。这在中文中是合适的，因为每个字符或多或少就是一个词。但在英语中，你无法在单词的中间换行。相反，我们需要逐个单词地布局文本：此代码在空白处分割单词。因此，它会在中文中断裂，因为没有单词之间的空白。真正的浏览器使用基于语言的规则来布局文本，包括识别单词边界。
- en: '[PRE61]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Unlike Chinese characters, words are different sizes, so we need to measure
    the width of each word:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 与中文字符不同，单词的大小不同，因此我们需要测量每个单词的宽度：
- en: '[PRE62]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here I’ve chosen to use Tk’s default font. Now, if we draw the text at `cursor_x`,
    its right end would be at `cursor_x + w`. That might be past the right edge of
    the page, and in this case we need to make space by wrapping to the next line:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我选择使用Tk的默认字体。现在，如果我们把文本绘制在`cursor_x`位置，其右端会在`cursor_x + w`处。这可能会超出页面的右边缘，在这种情况下，我们需要通过换行来留出空间：
- en: '[PRE63]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Note that this code block only shows the insides of the `for` loop. The rest
    of `layout` should be left alone. Also, I call `metrics` with an argument; that
    just returns the named metric directly. Finally, note that I multiply the linespace
    by 1.25 when incrementing `y`. Try removing the multiplier: you’ll see that the
    text is harder to read because the lines are too close together.Designers say
    the text is too “tight”. Instead, it is common to add “line spacing” or “leading”So
    named because in metal type days, thin pieces of lead were placed between the
    lines to space them out. Lead is a softer metal than what the actual letter pieces
    were made of, so it could compress a little to keep pressure on the other pieces.
    Pronounce it “led-ing” not “leed-ing”. between lines. The 25% line spacing is
    a typical amount.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个代码块只显示了`for`循环的内部。`layout`的其余部分应该保持不变。此外，我用参数调用`metrics`；这只会直接返回命名的度量。最后，请注意，我在增加`y`时将行间距乘以1.25。尝试移除乘数：你会发现文本更难阅读，因为行距太近。设计师们说文本太“紧凑”。相反，通常会在文本之间添加“行间距”或“行高”。之所以这样命名，是因为在金属活字时代，会在行之间放置薄铅片来调整间距。铅是一种比实际字母部件所用的金属软的金属，因此它可以稍微压缩以保持对其他部件的压力。发音为“led-ing”，而不是“leed-ing”。行间距为25%是典型值。
- en: 'So now `cursor_x` and `cursor_y` have the location to the *start* of the word,
    so we add to the display list and update `cursor_x` to point to the end of the
    word:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 因此现在`cursor_x`和`cursor_y`有了单词的起始位置，所以我们将其添加到显示列表中，并更新`cursor_x`以指向单词的末尾：
- en: '[PRE64]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'I increment `cursor_x` by `w + font.measure(" ")` instead of `w` because I
    want to have spaces between the words: the call to `split()` removed all of the
    whitespace, and this adds it back. I don’t add the space to `w` in the `if` condition,
    though, because you don’t need a space after the last word on a line.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`cursor_x`增加`w + font.measure(" ")`而不是`w`，因为我想要在单词之间有间距：`split()`调用移除了所有的空白，这又将其添加回来。然而，在`if`条件中，我没有添加空格，因为在行的最后一个单词后面不需要空格。
- en: Breaking lines in the middle of a word is called hyphenation, and can be turned
    on via the [`hyphens` CSS property](https://drafts.csswg.org/css-text-3/#hyphens-property).
    The state of the art is the [Knuth–Liang hyphenation algorithm](http://www.tug.org/docs/liang/liang-thesis.pdf),
    which uses a dictionary of word fragments to prioritize possible hyphenation points.
    At first, the CSS specification [was incompatible](https://news.ycombinator.com/item?id=19472922)
    with this algorithm, but the recent [`text-wrap-style` property](https://drafts.csswg.org/css-text-4/#propdef-text-wrap-style)
    fixed that.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在单词中间断行称为连字符化，可以通过`hyphens` CSS属性（[hyphens CSS property](https://drafts.csswg.org/css-text-3/#hyphens-property)）来开启。当前最先进的是[Knuth–Liang连字符化算法](http://www.tug.org/docs/liang/liang-thesis.pdf)，它使用单词片段的字典来优先考虑可能的连字符化点。最初，CSS规范[与该算法不兼容](https://news.ycombinator.com/item?id=19472922)，但最近的`text-wrap-style`属性（[text-wrap-style
    property](https://drafts.csswg.org/css-text-4/#propdef-text-wrap-style)）解决了这个问题。
- en: Styling Text
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本样式
- en: 'Right now, all of the text on the page is drawn with one font. But web pages
    sometimes specify that text should be **bold** or *italic* using the `<b>` and
    `<i>` tags. It’d be nice to support that, but right now, the code resists this:
    the `layout` function only receives the text of the page as input, and so has
    no idea where the bold and italics tags are.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，页面上所有的文本都使用一种字体绘制。但网页有时会指定文本应该使用`<b>`和`<i>`标签来显示**粗体**或*斜体*。支持这一点会很棒，但目前的代码对此有所抗拒：`layout`函数只接收页面的文本作为输入，因此不知道粗体和斜体标签的位置。
- en: Let’s change `lex` to return a list of *tokens*, where a token is either a `Text`
    object (for a run of characters outside a tag) or a `Tag` object (for the contents
    of a tag). You’ll need to write the `Text` and `Tag` classes:If you’re familiar
    with Python, you might want to use the `dataclass` library, which makes it easier
    to define these sorts of utility classes.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`lex`改为返回一个*标记*列表，其中标记可以是`Text`对象（用于标签外的字符序列）或`Tag`对象（用于标签的内容）。你需要编写`Text`和`Tag`类：如果你熟悉Python，你可能想使用`dataclass`库，它使得定义这类实用类变得更容易。
- en: '[PRE65]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`lex` must now gather text into `Text` and `Tag` objects:If you’ve done some
    or all of the exercises in prior chapters, your code will look different. Code
    snippets in the book always assume you haven’t done the exercises, so you’ll need
    to port your modifications.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '`lex`现在必须将文本收集到`Text`和`Tag`对象中：如果你已经完成了一些或所有前几章的练习，你的代码将有所不同。书中的代码片段总是假设你没有完成练习，所以你需要将你的修改移植过来。'
- en: '[PRE66]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here I’ve renamed the `text` variable to `buffer`, since it now stores either
    text or tag contents before they can be used. The name also reminds us that, at
    the end of the loop, we need to check whether there’s buffered text and what we
    should do with it. Here, `lex` dumps any accumulated text as a `Text` object.
    Otherwise, if you never saw an angle bracket, you’d return an empty list of tokens.
    But unfinished tags, like in `Hi!<hr`, are thrown out.This may strike you as an
    odd decision: why not finish up the tag for the author? I don’t know, but dropping
    the tag is what browsers do.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将 `text` 变量重命名为 `buffer`，因为它现在在可以使用之前存储文本或标签内容。这个名字也提醒我们，在循环结束时，我们需要检查是否有缓冲的文本以及我们应该如何处理它。在这里，`lex`
    将累积的任何文本作为 `Text` 对象输出。否则，如果你从未看到过尖括号，你会返回一个空的标记列表。但是未完成的标签，如 `Hi!<hr`，会被丢弃。这可能会让你觉得这是一个奇怪的决定：为什么不完成作者标签？我不知道，但浏览器会丢弃标签。
- en: 'Note that `Text` and `Tag` are asymmetric: `lex` avoids empty `Text` objects,
    but not empty `Tag` objects. That’s because an empty `Tag` object represents the
    HTML code `<>`, while an empty `Text` object represents no content at all.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Text` 和 `Tag` 是不对称的：`lex` 避免空的 `Text` 对象，但不避免空的 `Tag` 对象。这是因为空的 `Tag` 对象代表
    HTML 代码 `<>`，而空的 `Text` 对象代表完全没有内容。
- en: 'Since we’ve modified `lex`, we are now passing `layout` not just the text of
    the page, but also the tags in it. So `layout` must loop over tokens, not text:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经修改了 `lex`，我们现在不仅传递页面的文本，还传递其中的标签给 `layout`。因此，`layout` 必须遍历标记，而不是文本：
- en: '[PRE67]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '`layout` can also examine tag tokens to change font when directed by the page.
    Let’s start with support for weights and styles, with two corresponding variables:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`layout` 还可以检查标签标记以在页面指示下更改字体。让我们从对权重和样式的支持开始，对应两个变量：'
- en: '[PRE68]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Those variables must change when the bold and italics open and close tags are
    seen:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 当看到加粗和斜体打开和关闭标签时，这些变量必须改变：
- en: '[PRE69]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note that this code correctly handles not only `<b>bold</b>` and `<i>italic</i>`
    text, but also `<b><i>bold italic</i></b>` text.It even handles incorrectly nested
    tags like `<b>b<i>bi</b>i</i>`, but it does not handle `<b><b>twice</b>bolded</b>`
    text. We’ll return to this in [Chapter 6](styles.html).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此代码不仅正确处理了 `<b>bold</b>` 和 `<i>italic</i>` 文本，还处理了 `<b><i>bold italic</i></b>`
    文本。它甚至处理了不正确嵌套的标签，如 `<b>b<i>bi</b>i</i>`，但它不处理 `<b><b>twice</b>bolded</b>` 文本。我们将在
    [第 6 章](styles.html) 中回到这个问题。
- en: 'The `style` and `weight` variables are used to select the font:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`style` 和 `weight` 变量用于选择字体：'
- en: '[PRE70]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Since the font is computed in `layout` but used in `draw`, we’ll need to add
    the font used to each entry in the display list:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字体是在 `layout` 中计算的，但在 `draw` 中使用，因此我们需要将使用的字体添加到显示列表的每个条目中：
- en: '[PRE71]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Make sure to update `draw` to expect and use this extra font field in display
    list entries.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 确保更新 `draw` 以期望并使用显示列表条目中的这个额外字体字段。
- en: '*Italic* fonts were developed in Italy (hence the name) to mimic a cursive
    handwriting style called “[chancery hand](https://en.wikipedia.org/wiki/Chancery_hand)”.
    Non-italic fonts are called *roman* because they mimic text on Roman monuments.
    There is an obscure third option: [oblique fonts](https://en.wikipedia.org/wiki/Oblique_type),
    which look like roman fonts but are slanted.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '*斜体* 字体是在意大利发展起来的（因此得名），以模仿一种被称为“[chancery hand](https://en.wikipedia.org/wiki/Chancery_hand)”的草书书写风格。非斜体字体被称为
    *罗马体*，因为它们模仿罗马纪念碑上的文字。还有一个不为人知的第三种选择：[斜体字体](https://en.wikipedia.org/wiki/Oblique_type)，它们看起来像罗马字体，但却是斜的。'
- en: A Layout Object
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局对象
- en: 'With all of these tags, `layout` has become quite large, with lots of local
    variables and some complicated control flow. That is one sign that something deserves
    to be a class, not a function:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了所有这些标签，`layout` 已经变得相当庞大，拥有许多局部变量和一些复杂的控制流。这是表明某事物应该成为一个类而不是一个函数的一个迹象：
- en: '[PRE72]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Every local variable in `layout` then becomes a field of `Layout`:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`layout` 中的每个局部变量都成为 `Layout` 的一个字段：
- en: '[PRE73]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The core of the old `layout` is a loop over tokens, and we can move the body
    of that loop to a method on `Layout`:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 旧 `layout` 的核心是遍历标记的循环，我们可以将这个循环的主体移动到 `Layout` 的一个方法上：
- en: '[PRE74]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In fact, the body of the `isinstance(tok, Text)` branch can be moved to its
    own method:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`isinstance(tok, Text)` 分支的主体可以移动到它自己的方法中：
- en: '[PRE75]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now that everything has moved out of `Browser`’s old `layout` function, it
    can be replaced with calls into `Layout`:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有内容都已从 `Browser` 的旧 `layout` 函数中移出，它可以被 `Layout` 的调用所替代：
- en: '[PRE76]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'When you do big refactors like this, it’s important to work incrementally.
    It might seem more efficient to change everything at once, but that efficiency
    brings with it a risk of failure: trying to do so much that you get confused and
    have to abandon the whole refactor. So take a moment to test that your browser
    still works before you move on.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行这样的大规模重构时，逐步工作是很重要的。虽然一次性改变所有内容看起来更有效率，但这种效率却伴随着失败的风险：试图做太多以至于你感到困惑，不得不放弃整个重构。所以，在你继续之前，花点时间测试一下你的浏览器是否仍然正常工作。
- en: Anyway, this refactor isolated all of the text-handling code into its own method,
    with the main `token` function just branching on the tag name. Let’s take advantage
    of the new, cleaner organization to add more tags. With font weights and styles
    working, size is the next frontier in typographic sophistication. One simple way
    to change font size is the `<small>` tag and its deprecated sister tag `<big>`.In
    your web design projects, use the CSS `font-size` property to change text size
    instead of `<big>` and `<small>`. But since we haven’t yet implemented CSS for
    our browser (see [Chapter 6](styles.html)), we’re stuck using tags here.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这次重构将所有文本处理代码隔离到它自己的方法中，主要的`token`函数只是根据标签名进行分支。让我们利用这个新的、更整洁的组织结构来添加更多标签。随着字体粗细和样式的工作，大小是排版复杂性的下一个前沿。改变字体大小的一个简单方法就是使用`<small>`标签及其已弃用的姐妹标签`<big>`。在你的网页设计项目中，使用CSS的`font-size`属性来改变文本大小，而不是使用`<big>`和`<small>`。但由于我们还没有为我们的浏览器实现CSS（见[第6章](styles.html)），我们在这里仍然使用标签。
- en: 'Our experience with font styles and weights suggests a simple approach that
    customizes the `size` field in `Layout`. It starts out with:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在字体样式和粗细方面的经验表明，一个简单的方法是自定义`Layout`中的`size`字段。它从以下开始：
- en: '[PRE77]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'That variable is used to create the font object:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量用于创建字体对象：
- en: '[PRE78]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And we can change the size in `<big>` and `<small>` tags by updating this variable:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更新这个变量来改变`<big>`和`<small>`标签的大小：
- en: '[PRE79]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Try wrapping a whole paragraph in `<small>`, like you would a bit of fine print,
    and enjoy your newfound typographical freedom.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将整个段落包裹在`<small>`标签中，就像包裹一小段细印一样，享受你新发现的排版自由。
- en: All of `<b>`, `<i>`, `<big>`, and `<small>` date from an earlier, pre-CSS era
    of the web. Nowadays, CSS can change how an element appears, so visual tag names
    like `<b>` and `<small>` are out of favor. That said, `<b>`, `<i>`, and `<small>`
    still have some [appearance-independent meanings](https://html.spec.whatwg.org/multipage/text-level-semantics.html#the-small-element).
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`<b>`、`<i>`、`<big>`和`<small>`都源于更早的、CSS之前的网络时代。如今，CSS可以改变元素的外观，所以像`<b>`和`<small>`这样的视觉标签名不再受欢迎。尽管如此，`<b>`、`<i>`和`<small>`仍然有一些[与外观无关的含义](https://html.spec.whatwg.org/multipage/text-level-semantics.html#the-small-element)。'
- en: Text of Different Sizes
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同大小的文本
- en: 'Start mixing font sizes, like `<small>a</small><big>A</big>`, and you’ll quickly
    notice a problem with the font size code: the text is aligned along its top, as
    if it’s hanging from a clothes line. But you know that English text is typically
    written with all letters aligned at an invisible *baseline* instead.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 开始混合字体大小，比如 `<small>a</small><big>A</big>`，你很快就会注意到字体大小代码的问题：文本沿着其顶部对齐，就像是从晾衣绳上挂下来的。但你知道，英文文本通常都是所有字母对齐在不可见的*基线*上。
- en: 'Let’s think through how to fix this. If the bigger text is moved up, it would
    overlap with the previous line, so the smaller text has to be moved down. That
    means its vertical position has to be computed later, *after* the big text passes
    through `token`. But since the small text comes through the loop first, we need
    a *two-pass* algorithm for lines of text: the first pass identifies what words
    go in the line and computes their *x* positions, while the second pass vertically
    aligns the words and computes their *y* positions (see Figure 4).'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下如何解决这个问题。如果较大的文本向上移动，它将与上一行重叠，所以较小的文本必须向下移动。这意味着它的垂直位置必须在较大的文本通过`token`之后计算，*即之后*。但由于小文本首先通过循环，我们需要一个*两遍*的文本行算法：第一遍确定哪些单词进入该行并计算它们的*x*位置，而第二遍垂直对齐单词并计算它们的*y*位置（见图4）。
- en: '![Figure 4: How lines are laid out when multiple fonts are involved. All words
    are drawn using a shared baseline. The ascent and descent of the whole line is
    then determined by the maximum ascent and descent of all words in the line, and
    leading is added before and after the line.](img/cf161b8d7e4c39ecd4a6e8544e64af8f.png)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![图4：涉及多种字体时线条的布局。所有单词都使用共享基线绘制。整行的上升和下降由该行中所有单词的最大上升和下降决定，并在行前后添加行距。](img/cf161b8d7e4c39ecd4a6e8544e64af8f.png)'
- en: 'Figure 4: How lines are laid out when multiple fonts are involved. All words
    are drawn using a shared baseline. The ascent and descent of the whole line is
    then determined by the maximum ascent and descent of all words in the line, and
    leading is added before and after the line.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：涉及多种字体时线条的布局。所有单词都使用共同的基线绘制。整行的上升和下降由该行中所有单词的最大上升和下降决定，并在行前后添加行间距。
- en: 'Let’s start with phase one. Since one line contains text from many tags, we
    need a field on `Layout` to store the line-to-be. That field, `line`, will be
    a list, and `text` will add words to it instead of to the display list. Entries
    in `line` will have *x* but not *y* positions, since *y* positions aren’t computed
    in the first phase:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一阶段开始。由于一行包含来自许多标签的文本，我们需要在`Layout`上有一个字段来存储待处理的行。该字段，`line`，将是一个列表，`text`将向其中添加单词而不是显示列表。`line`中的条目将具有*x*位置但没有*y*位置，因为*y*位置在第一阶段没有计算：
- en: '[PRE80]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The new `line` field is essentially a buffer, where words are held temporarily
    before they can be placed. The second phase is that buffer being flushed when
    we’re finished with a line:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`line`字段本质上是一个缓冲区，其中单词在它们可以放置之前暂时存放。第二阶段是在我们完成一行后刷新该缓冲区：
- en: '[PRE81]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'As usual with buffers, we also need to make sure the buffer is flushed once
    all tokens are processed:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 如同缓冲区通常的做法，我们还需要确保在所有标记处理完毕后刷新缓冲区：
- en: '[PRE82]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This new `flush` function has three responsibilities:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`flush`函数有三个职责：
- en: it must align the words along the baseline (see Figure 5);
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它必须沿基线对齐单词（见图5）；
- en: it must add all those words to the display list; and
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它必须将所有这些单词添加到显示列表中；并且
- en: it must update the `cursor_x` and `cursor_y` fields.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它必须更新`cursor_x`和`cursor_y`字段。
- en: 'Here’s what it looks like, step by step:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这是逐步的样子：
- en: '[widgets/lab3-baselines.html](widgets/lab3-baselines.html)'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '[widgets/lab3-baselines.html](widgets/lab3-baselines.html)'
- en: '![Figure 5: Aligning the words on a line.](img/25a825df2e9f89a8372ca977669e9983.png)'
  id: totrans-551
  prefs: []
  type: TYPE_IMG
  zh: '![图5：在行上对齐单词。](img/25a825df2e9f89a8372ca977669e9983.png)'
- en: 'Figure 5: Aligning the words on a line.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：在行上对齐单词。
- en: 'Since we want words to line up “on the line”, let’s start by computing where
    that line should be. That depends on the tallest word on the line:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望单词“在行上”对齐，让我们首先计算该行应该在的位置。这取决于该行中最高的单词：
- en: '[PRE83]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The baseline is then `max_ascent` below `self.y`—or actually a little more to
    account for the leading:Actually, 25% leading doesn’t add 25% of the ascent above
    the ascender and 25% of the descent below the descender. Instead, it adds [12.5%
    of the line height in both places](https://www.w3.org/TR/CSS2/visudet.html#leading),
    which is subtly different when fonts are mixed. But let’s skip that subtlety here.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 基线是`self.y`以下`max_ascent`——或者实际上要稍微多一点，以考虑到行间距：实际上，25%的行间距不会在上升者上方增加25%的上升和在下降者下方增加25%的下降。相反，它在两个地方都增加了[12.5%的行高](https://www.w3.org/TR/CSS2/visudet.html#leading)，这在字体混合时略有不同。但在这里我们跳过这个细微差别。
- en: '[PRE84]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now that we know where the line is, we can place each word relative to that
    line and add it to the display list:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了行的位置，我们可以将每个单词相对于该行放置并添加到显示列表中：
- en: '[PRE85]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Note how `y` starts at the baseline, and moves *up* by just enough to accommodate
    that word’s ascent. Now `cursor_y` must move far enough down below `baseline`
    to account for the deepest descender:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`y`从基线开始，并且向上移动，刚好足够容纳那个单词的上升。现在`cursor_y`必须向下移动足够远，以考虑到最深下降者的位置：
- en: '[PRE86]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Finally, `flush` must update the `Layout`’s `cursor_x` and `line` fields:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`flush`必须更新`Layout`的`cursor_x`和`line`字段：
- en: '[PRE87]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now all the text is aligned along the line, even when text sizes are mixed.
    Plus, this new `flush` function is convenient for other line-breaking jobs. For
    example, in HTML the `<br>` tagWhich is a self-closing tag, so there’s no `</br>`.
    Many tags that *are* content, instead of annotating it, are like this. Some people
    like adding a final slash to self-closing tags, as in `<br/>`, but this is not
    required in HTML. ends the current line and starts a new one:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有文本都沿行对齐，即使文本大小混合。此外，这个新的`flush`函数对其他换行任务也很方便。例如，在HTML中，`<br>`标签是一个自闭合标签，因此没有`</br>`。许多*是内容而不是注释*的标签都是这样的。有些人喜欢在自闭合标签中添加一个最后的斜杠，例如`<br/>`，但在HTML中这不是必需的。它结束当前行并开始新的一行：
- en: '[PRE88]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Likewise, paragraphs are defined by the `<p>` and `</p>` tags, so `</p>` also
    ends the current line:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，段落由`<p>`和`</p>`标签定义，因此`</p>`也结束当前行：
- en: '[PRE89]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: I add a bit extra to `cursor_y` here to create a little gap between paragraphs.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里给`cursor_y`添加一点额外的空间，以在段落之间创建一个小间隙。
- en: By this point you should be able to load up your browser and display [an example
    page](examples/example3-sizes.html), which should look something like Figure 6.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够打开你的浏览器并显示[一个示例页面](examples/example3-sizes.html)，它应该看起来像图6。
- en: '![Figure 6: Screenshot of a web page demonstrating different text sizes.](img/40ebeea712b76b5f4e16219ade61fa87.png)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
  zh: '![图6：展示不同文本大小的网页截图。](img/40ebeea712b76b5f4e16219ade61fa87.png)'
- en: 'Figure 6: Screenshot of a web page demonstrating different text sizes.'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：展示不同文本大小的网页截图。
- en: Actually, browsers support not only *horizontal* but also [*vertical* writing
    systems](https://www.smashingmagazine.com/2019/08/writing-modes-layout/), like
    some traditional East Asian writing styles. A particular challenge is [Mongolian
    script](https://www.w3.org/TR/mlreq/), which is written in lines running top to
    bottom, left to right. Many Mongolian [government websites](https://president.mn/mng/)
    use the script.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，浏览器不仅支持*水平*书写系统，还支持[*垂直*书写系统](https://www.smashingmagazine.com/2019/08/writing-modes-layout/)，例如一些传统的东亚书写风格。一个特别的挑战是[蒙古文](https://www.w3.org/TR/mlreq/)，它从上到下、从左到右书写。许多蒙古[政府网站](https://president.mn/mng/)使用这种文字。
- en: Font Caching
  id: totrans-572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字体缓存
- en: Now that you’ve implemented styled text, you’ve probably noticed—unless you’re
    on macOSWhile we can’t confirm this in the documentation, it seems that the macOS
    “Core Text” APIs cache fonts more aggressively than Linux and Windows. The optimization
    described in this section won’t hurt any on macOS, but also won’t improve speed
    as much as on Windows and Linux.—that on a large web page like [this chapter](http://browser.engineering/text.html)
    our browser has slowed significantly from the [previous chapter](graphics.html).
    That’s because text layout, and specifically the part where you measure each word,
    is quite slow.You can profile Python programs by replacing your `python3` command
    with `python3 -m cProfile`. Look for the lines corresponding to the `measure`
    and `metrics` calls to see how much time is spent measuring text.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经实现了样式文本，你可能已经注意到——除非你在macOS上——虽然我们无法在文档中确认这一点，但似乎macOS的“Core Text”API比Linux和Windows更积极地缓存字体。本节中描述的优化在macOS上不会造成伤害，但也不会像在Windows和Linux上那样显著提高速度。——在一个像[这一章](http://browser.engineering/text.html)这样的大型网页上，我们的浏览器与[上一章](graphics.html)相比已经显著减慢。这是因为文本布局，特别是测量每个单词的部分，相当慢。你可以通过将`python3`命令替换为`python3
    -m cProfile`来分析Python程序。查找对应于`measure`和`metrics`调用的行，以查看在测量文本上花费了多少时间。
- en: Unfortunately, it’s hard to make text measurement much faster. With proportional
    fonts and complex font features like hinting and kerning, measuring text can require
    pretty complex computations. But on a large web page, some words likely appear
    a lot—for example, this chapter includes the word “the” over 200 times. Instead
    of measuring these words over and over again, we could measure them once, and
    then cache the results. On normal English text, this usually results in a substantial
    speedup.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，很难使文本测量速度变得更快。在使用比例字体和复杂的字体特性，如提示和字距调整时，测量文本可能需要相当复杂的计算。但在一个大型网页上，一些单词可能出现的频率很高——例如，这一章中“the”这个词出现了200多次。我们不必反复测量这些单词，可以测量一次，然后缓存结果。在正常的英文文本中，这通常会导致显著的加速。
- en: Caching is such a good idea that most text libraries already implement it, typically
    caching text measurements in each `Font` object. But since our `text` method creates
    a new `Font` object for each word, the caching is ineffective. To make caching
    work, we need to reuse `Font` objects when possible instead of making new ones.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是一个非常好的想法，大多数文本库已经实现了它，通常是在每个`Font`对象中缓存文本测量结果。但既然我们的`text`方法为每个单词创建一个新的`Font`对象，缓存就变得无效。为了使缓存有效，我们需要尽可能重用`Font`对象而不是创建新的。
- en: 'We’ll store our cache in a global `FONTS` dictionary:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的缓存存储在全局`FONTS`字典中：
- en: '[PRE90]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The keys to this dictionary will be size/weight/style triples, and the values
    will be `Font` objects.Actually, the values are a font object and a `tkinter.Label`
    object. This dramatically improves the performance of `metrics` for some reason,
    and is recommended by the [Python documentation](https://github.com/python/cpython/blob/main/Lib/tkinter/font.py#L163).
    We can put the caching logic itself in a new `get_font` function:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字典的键将是大小/重量/样式三元组，值将是`Font`对象。实际上，值是一个字体对象和一个`tkinter.Label`对象。由于某种原因，这大大提高了`metrics`的性能，并且被[Python文档](https://github.com/python/cpython/blob/main/Lib/tkinter/font.py#L163)推荐。我们可以将缓存逻辑本身放入一个新的`get_font`函数中：
- en: '[PRE91]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Then the `word` method can call `get_font` instead of creating a `Font` object
    directly:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`word`方法可以调用`get_font`而不是直接创建`Font`对象：
- en: '[PRE92]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now identical words will use identical fonts and text measurements will hit
    the cache.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，相同的单词将使用相同的字体，并且文本测量将命中缓存。
- en: Fonts for scripts like Chinese can be megabytes in size, so they are generally
    stored on disk and only loaded into memory on demand. That makes font loading
    slow and caching even more important. Browsers also have extensive caches for
    measuring, shaping, and rendering text. Because web pages have a lot of text,
    these caches turn out to be one of the most important parts of speeding up rendering.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像中文这样的脚本，字体可能达到兆字节大小，因此它们通常存储在磁盘上，并在需要时才加载到内存中。这使得字体加载缓慢，缓存变得更加重要。浏览器还有广泛的缓存用于测量、塑形和渲染文本。因为网页中有大量的文本，这些缓存最终成为加速渲染的最重要部分之一。
- en: Summary
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The previous chapter introduced a browser that laid out characters in a grid.
    Now it does standard English text layout, so:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了一个以网格形式布局字符的浏览器。现在它执行标准的英文文本布局，所以：
- en: text is laid out word by word;
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本是以单词为单位进行布局的；
- en: lines are split at word boundaries;
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行在单词边界处被分割；
- en: text can be bold or italic;
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本可以是粗体或斜体；
- en: text of different sizes can be mixed.
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以混合不同大小的文本。
- en: You can now use our browser to read an essay, a blog post, or even a book!
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用我们的浏览器来阅读文章、博客文章，甚至书籍！
- en: '[widgets/lab3-browser.html](widgets/lab3-browser.html)'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '[widgets/lab3-browser.html](widgets/lab3-browser.html)'
- en: Outline
  id: totrans-592
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: 'The complete set of functions, classes, and methods in our browser should look
    something like this:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整函数、类和方法集应该看起来像这样：
- en: '`` class URL: `def __init__(url)` `def request()` `` `` class Text: `def __init__(text)`
    `` `` class Tag: `def __init__(tag)` `` `def lex(body)` `FONTS` `def get_font(size,
    weight, style)` `WIDTH, HEIGHT` `HSTEP, VSTEP` `` class Layout: `def __init__(tokens)`
    `def token(tok)` `def flush()` `def word(word)` `` `SCROLL_STEP` `` class Browser:
    `def __init__()` `def draw()` `def load(url)` `def scrolldown(e)` ``'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '`` class URL: `def __init__(url)` `def request()` `` `` class Text: `def __init__(text)`
    `` `` class Tag: `def __init__(tag)` `` `def lex(body)` `FONTS` `def get_font(size,
    weight, style)` `WIDTH, HEIGHT` `HSTEP, VSTEP` `` class Layout: `def __init__(tokens)`
    `def token(tok)` `def flush()` `def word(word)` `` `SCROLL_STEP` `` class Browser:
    `def __init__()` `def draw()` `def load(url)` `def scrolldown(e)` ``'
- en: Exercises
  id: totrans-595
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 3-1 *Centered text*. The page titles on this [book’s website](https://browser.engineering/text.html)
    are centered; make your browser do the same for text between `<h1 class="title">`
    and `</h1>`. Each line has to be centered individually, because different lines
    will have different lengths.In early HTML there was a `<center>` tag that did
    exactly this, but nowadays centering is typically done in CSS, through the `text-align`
    property. The approach in this exercise is of course non-standard, and just for
    learning purposes.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 3-1 *居中文本*。在这个[本书的网站](https://browser.engineering/text.html)上的页面标题是居中的；让你的浏览器对`<h1
    class="title">`和`</h1>`之间的文本也这样做。每一行都必须单独居中，因为不同的行长度不同。在早期的HTML中有一个`<center>`标签可以做到这一点，但现在居中通常是通过CSS中的`text-align`属性来完成的。这个练习的方法当然是非标准的，只是为了学习目的。
- en: 3-2 *Superscripts*. Add support for the `<sup>` tag. Text in this tag should
    be smaller (perhaps half the normal text size) and be placed so that the top of
    a superscript lines up with the top of a normal letter.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 3-2 *上标*。添加对`<sup>`标签的支持。此标签中的文本应该更小（可能是正常文本大小的一半）并且放置得使上标顶部与正常字母顶部对齐。
- en: 3-3 *Soft hyphens*. The soft hyphen character, written `\N{soft hyphen}` in
    Python, represents a place where the text renderer can, but doesn’t have to, insert
    a hyphen and break the word across lines. Add support for it.If you’ve done [Exercise
    1-4](http.html#exercises) on HTML entities, you might also want to add support
    for the `&shy;` entity, which expands to a soft hyphen. If a word doesn’t fit
    at the end of a line, check if it has soft hyphens, and if so break the word across
    lines. Remember that a word can have multiple soft hyphens in it, and make sure
    to draw a hyphen when you break a word. The word “super­cali­fragi­listic­expi­ali­docious”
    is a good test case.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 3-3 *软连字符*。软连字符字符，在Python中写作`\N{soft hyphen}`，表示文本渲染器可以在此处插入连字符并跨行断开单词的位置，但不是必须的。添加对其的支持。如果你已经完成了[练习1-4](http.html#exercises)关于HTML实体的练习，你可能还想添加对`&shy;`实体的支持，它扩展为一个软连字符。如果一个单词在行尾处放不下，检查它是否有软连字符，如果有，就在行间断开单词。记住，一个单词中可以有多个软连字符，并且在断开单词时一定要画出连字符。单词“super－cali－fragi－listic－expi－ali－docious”是一个很好的测试案例。
- en: 3-4 *Small caps*. Make the `<abbr>` element render text in small caps, like
    this. Inside an `<abbr>` tag, lower-case letters should be small, capitalized,
    and bold, while all other characters (upper case, numbers, etc.) should be drawn
    in the normal font.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 3-4 *小写字母*。使`<abbr>`元素以小写字母形式显示文本，如下所示。在`<abbr>`标签内，小写字母应该以小写、大写和加粗的形式显示，而所有其他字符（大写字母、数字等）应以正常字体显示。
- en: '3-5 *Preformatted text*. Add support for the `<pre>` tag. Unlike normal paragraphs,
    text inside `<pre>` tags doesn’t automatically break lines, and whitespace like
    spaces and newlines are preserved. Use a fixed-width font like `Courier New` or
    `SFMono` as well. Make sure tags work normally inside `<pre>` tags: it should
    be possible to bold some text inside a `<pre>`. The results will look best if
    you also do [Exercise 1-4](http.html#exercises).'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 3-5 *预格式化文本*。添加对`<pre>`标签的支持。与正常段落不同，`<pre>`标签内的文本不会自动换行，空格和换行等空白字符会被保留。同时使用固定宽度的字体，如`Courier
    New`或`SFMono`。确保在`<pre>`标签内标签可以正常工作：应该可以在`<pre>`内加粗一些文本。如果还做了[练习1-4](http.html#exercises)，结果看起来会更好。
- en: Constructing an HTML Tree
  id: totrans-601
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建HTML树
- en: Chapter 4 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '[Web浏览器工程](./index.html "目录")的第四章。'
- en: '[A Tree of Nodes](#a-tree-of-nodes)'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[节点树](#a-tree-of-nodes)'
- en: '[Constructing the Tree](#constructing-the-tree)'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[构建树](#constructing-the-tree)'
- en: '[Debugging a Parser](#debugging-a-parser)'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[解析器调试](#debugging-a-parser)'
- en: '[Self-closing Tags](#self-closing-tags)'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自闭合标签](#self-closing-tags)'
- en: '[Using the Node Tree](#using-the-node-tree)'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用节点树](#using-the-node-tree)'
- en: '[Handling Author Errors](#handling-author-errors)'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[处理作者错误](#handling-author-errors)'
- en: '[Summary](#summary)'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summary)'
- en: '[Outline](#outline)'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大纲](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: So far, our browser sees web pages as a stream of open tags, close tags, and
    text. But HTML is actually a tree, and though the tree structure hasn’t been important
    yet, it will be central to later features like CSS, JavaScript, and visual effects.
    So this chapter adds a proper HTML parser and converts the layout engine to use
    it.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的浏览器将网页视为一系列打开的标签、关闭的标签和文本。但实际上，HTML是一个树形结构，尽管树形结构目前并不重要，但它将是CSS、JavaScript和视觉效果等后续功能的核心。因此，本章添加了一个合适的HTML解析器，并将布局引擎转换为使用它。
- en: A Tree of Nodes
  id: totrans-613
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点树
- en: The HTML treeThis is the tree that is usually called the DOM tree, for [Document
    Object Model](https://en.wikipedia.org/wiki/Document_Object_Model). I’ll keep
    calling it the HTML tree for now. has one node for each open and close tag pair
    and a node for each span of text.In reality there are other types of nodes too,
    like comments, doctypes, `CDATA` sections, and processing instructions. There
    are even some deprecated types! A simple HTML document showing the structure is
    shown in Figure 1.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: HTML树这是通常被称为DOM树的树，对于[文档对象模型](https://en.wikipedia.org/wiki/Document_Object_Model)。现在我会继续称它为HTML树。每个打开和关闭标签对都有一个节点，每个文本段也有一个节点。实际上，还有其他类型的节点，如注释、文档类型、`CDATA`部分和处理指令。甚至还有一些已弃用的类型！一个简单的HTML文档，显示了结构，如图1所示。
- en: '![Figure 1: An HTML document, showing tags, text, and the nesting structure.](img/42769ac6a233be39f2b7213d09b06b88.png)'
  id: totrans-615
  prefs: []
  type: TYPE_IMG
  zh: '![图1：一个HTML文档，显示了标签、文本和嵌套结构。](img/42769ac6a233be39f2b7213d09b06b88.png)'
- en: 'Figure 1: An HTML document, showing tags, text, and the nesting structure.'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：一个HTML文档，显示了标签、文本和嵌套结构。
- en: 'For our browser to use a tree, tokens need to evolve into nodes. That means
    adding a list of children and a parent pointer to each one. Here’s the new `Text`
    class, representing text at the leaf of the tree:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的浏览器使用树形结构，标记（tokens）需要演变成节点。这意味着需要为每个节点添加一个子节点列表和一个父指针。以下是新的`Text`类，它代表树叶处的文本：
- en: '[PRE93]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Since it takes two tags (the open and the close tag) to make a node, let’s
    rename the `Tag` class to `Element`, and make it look like this:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建一个节点需要两个标签（打开标签和关闭标签），因此让我们将`Tag`类重命名为`Element`，并使其看起来像这样：
- en: '[PRE94]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: I added a `children` field to both `Text` and `Element`, even though text nodes
    never have children, for consistency.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`Text`和`Element`两个类中都添加了一个`children`字段，即使文本节点永远不会拥有子节点，也是为了保持一致性。
- en: 'Constructing a tree of nodes from source code is called parsing. A parser builds
    a tree one element or text node at a time. But that means the parser needs to
    store an *incomplete* tree as it goes. For example, suppose the parser has so
    far read this bit of HTML:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码构建节点树的过程称为解析。解析器一次构建一个元素或文本节点。但这意味着解析器需要在其过程中存储一个*不完整*的树。例如，假设解析器到目前为止已经读取了以下HTML片段：
- en: '[PRE95]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The parser has seen five tags (and one text node). The rest of the HTML will
    contain more open tags, close tags, and text, but no matter which tokens it sees,
    no new nodes will be added to the `<video>` tag, which has already been closed.
    So that node is “finished”. But the other nodes are unfinished: more children
    can be added to the `<html>`, `<section>`, and `<h1>` nodes, depending on what
    HTML comes next—see Figure 2.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器已经看到了五个标签（以及一个文本节点）。HTML的其余部分将包含更多的开放标签、闭合标签和文本，但无论它看到哪个标记，都不会向已经关闭的`<video>`标签添加新的节点。因此，该节点是“完成”的。但其他节点尚未完成：可以添加更多子节点到`<html>`、`<section>`和`<h1>`节点，具体取决于接下来的HTML内容——见图2。
- en: '![Figure 2: The finished and unfinished nodes while parsing some HTML.](img/16bc678e0673b86d6f4854bc5f1ca542.png)'
  id: totrans-625
  prefs: []
  type: TYPE_IMG
  zh: '![图2：解析某些HTML时完成的和未完成的节点。](img/16bc678e0673b86d6f4854bc5f1ca542.png)'
- en: 'Figure 2: The finished and unfinished nodes while parsing some HTML.'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：解析某些HTML时完成的和未完成的节点。
- en: Since the parser reads the HTML file from beginning to end, these unfinished
    tags are always in a certain part of the tree. The unfinished tags have always
    been *opened* but not yet closed; they are always *later in the source* than the
    finished nodes; and they are always *children of other unfinished tags*. To leverage
    these facts, let’s represent an incomplete tree by storing a list of unfinished
    tags, ordered with parents before children. The first node in the list is the
    root of the HTML tree; the last node in the list is the most recent unfinished
    tag.In Python, and most other languages, it’s faster to add and remove from the
    end of a list, instead of the beginning.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解析器从文件开头到结尾读取HTML文件，这些未完成的标签始终位于树的某个部分。未完成的标签始终是*打开*但尚未关闭的；它们始终比完成的节点*在源代码中更晚*；并且它们始终是其他未完成标签的*子节点*。为了利用这些事实，让我们通过存储一个未完成标签的列表来表示一个不完整的树，该列表按父子顺序排列。列表中的第一个节点是HTML树的根节点；列表中的最后一个节点是最新的未完成标签。在Python和大多数其他语言中，从列表的末尾添加和删除比从开头添加和删除要快。
- en: 'Parsing is a little more complex than `lex`, so we’re going to want to break
    it into several functions, organized in a new `HTMLParser` class. That class can
    also store the source code it’s analyzing and the incomplete tree:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 解析比`lex`稍微复杂一些，因此我们希望将其分解为几个函数，组织在一个新的`HTMLParser`类中。该类还可以存储它正在分析的源代码和不完整的树：
- en: '[PRE96]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Before the parser starts, it hasn’t seen any tags at all, so the `unfinished`
    list storing the tree starts empty. But as the parser reads tokens, that list
    fills up. Let’s start that by aspirationally renaming the `lex` function we have
    now to `parse`:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析器开始之前，它还没有看到任何标签，因此存储树的`unfinished`列表是空的。但随着解析器读取标记，该列表会逐渐填满。让我们首先将我们现在拥有的`lex`函数有志地重命名为`parse`：
- en: '[PRE97]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We’ll need to do a bit of surgery on `parse`. Right now `parse` creates `Tag`
    and `Text` objects and appends them to the `out` array. We need it to create `Element`
    and `Text` objects and add them to the `unfinished` tree. Since a tree is a bit
    more complex than a list, I’ll move the adding-to-a-tree logic to two new methods,
    `add_text` and `add_tag`.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`parse`进行一些手术。目前`parse`创建`Tag`和`Text`对象并将它们追加到`out`数组中。我们需要它创建`Element`和`Text`对象并将它们添加到`unfinished`树中。由于树比列表复杂一些，我将添加到树的逻辑移动到两个新的方法，`add_text`和`add_tag`。
- en: '[PRE98]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The `out` variable is gone, and note that I’ve also moved the return value
    to a new `finish` method, which converts the incomplete tree to the final, complete
    tree. So: how do we add things to the tree?'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`变量已经消失，注意我还将返回值移动到了一个新的`finish`方法，该方法将不完整的树转换为最终的完整树。所以：我们如何向树中添加内容？'
- en: HTML derives from a long line of document processing systems. Its predecessor,
    [SGML](https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language), traces
    back to [RUNOFF](https://en.wikipedia.org/wiki/TYPSET_and_RUNOFF) and is a sibling
    to [troff](https://troff.org), now used for Linux manual pages. The [committee](https://www.iso.org/committee/45374.html)
    that standardized SGML now works on the `.odf`, `.docx`, and `.epub` formats.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: HTML源自一系列文档处理系统。其前身[SGML](https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language)可以追溯到[RUNOFF](https://en.wikipedia.org/wiki/TYPSET_and_RUNOFF)，并且是[troff](https://troff.org)的兄弟，现在用于Linux手册页。现在标准化SGML的[委员会](https://www.iso.org/committee/45374.html)正在处理`.odf`、`.docx`和`.epub`格式。
- en: Constructing the Tree
  id: totrans-636
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建树
- en: 'Let’s talk about adding nodes to a tree. To add a text node we add it as a
    child of the last unfinished node:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈向树中添加节点。要添加一个文本节点，我们将其添加为最后一个未完成节点的子节点：
- en: '[PRE99]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'On the other hand, tags are a little more complex since they might be an open
    *or* a close tag:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，标签稍微复杂一些，因为它们可能是一个开放标签*或*一个闭合标签：
- en: '[PRE100]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'An open tag adds an unfinished node to the end of the list:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 打开标签将一个未完成的节点添加到列表的末尾：
- en: '[PRE101]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'A close tag instead finishes the last unfinished node by adding it to the previous
    unfinished node in the list:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭标签通过将其添加到列表中的上一个未完成节点来结束最后一个未完成的节点：
- en: '[PRE102]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Once the parser is done, it turns our incomplete tree into a complete tree
    by just finishing any unfinished nodes:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解析器完成，它就会通过完成任何未完成的节点，将我们的不完整树转换成完整树：
- en: '[PRE103]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This is *almost* a complete parser, but it doesn’t quite work at the beginning
    and end of the document. The very first open tag is an edge case without a parent:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是一个完整的解析器，但在文档的开始和结束处并不完全工作。第一个打开标签是一个没有父元素的边缘情况：
- en: '[PRE104]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The very last tag is also an edge case, because there’s no unfinished node
    to add it to:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个标签也是一个边缘情况，因为没有未完成的节点可以添加：
- en: '[PRE105]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Ok, that’s all done. Let’s test our parser out and see how well it works!
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这些都完成了。让我们测试一下我们的解析器，看看它工作得怎么样！
- en: The ill-considered JavaScript `document.write` method allows JavaScript to modify
    the HTML source code while it’s being parsed! This is actually a [bad idea](https://developer.mozilla.org/en-US/docs/Web/API/Document/write).
    An implementation of `document.write` must have the HTML parser stop to execute
    JavaScript, but that slows down requests for images, CSS, and JavaScript used
    later in the page. To solve this, modern browsers use [speculative parsing](https://developer.mozilla.org/en-US/docs/Glossary/speculative_parsing)
    to start loading additional resources even before parsing is done.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑不周的JavaScript `document.write`方法允许JavaScript在解析时修改HTML源代码！这实际上是一个[坏主意](https://developer.mozilla.org/en-US/docs/Web/API/Document/write)。`document.write`的实现必须让HTML解析器停止执行JavaScript，但这会减慢页面后面使用的图像、CSS和JavaScript的请求。为了解决这个问题，现代浏览器使用[推测性解析](https://developer.mozilla.org/en-US/docs/Glossary/speculative_parsing)在解析完成之前就开始加载额外的资源。
- en: Debugging a Parser
  id: totrans-653
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试解析器
- en: 'How do we know our parser does the right thing—that it builds the right tree?
    Well the place to start is *seeing* the tree it produces. We can do that with
    a quick, recursive pretty-printer:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道我们的解析器做了正确的事情——它构建了正确的树？嗯，开始的地方是*看到*它产生的树。我们可以通过一个快速的递归美化打印器来完成：
- en: '[PRE106]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Here we’re printing each node in the tree, and using indentation to show the
    tree structure. Since we need to print each node, it’s worth taking the time to
    give them a nice printed form, which in Python means defining the `__repr__` function:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在树中打印每个节点，并使用缩进来显示树结构。由于我们需要打印每个节点，花时间给它们一个漂亮的打印形式是值得的，在Python中这意味着定义`__repr__`函数：
- en: '[PRE107]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: In general it’s a good idea to define `__repr__` methods for any data objects,
    and to have those `__repr__` methods print all the relevant fields.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为任何数据对象定义`__repr__`方法是件好事，并且让这些`__repr__`方法打印所有相关字段。
- en: 'Try this out on [the web page](https://browser.engineering/html.html) corresponding
    to this chapter, parsing the HTML source code and then calling `print_tree` to
    visualize it:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章对应的[网页](https://browser.engineering/html.html)上尝试这个操作，解析HTML源代码，然后调用`print_tree`来可视化它：
- en: '[PRE108]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'You’ll see something like this at the beginning:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在一开始看到类似这样的内容：
- en: '[PRE109]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Immediately a couple of things stand out. Let’s start at the top, with the `<!doctype
    html>` tag.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 立即有几个问题很突出。让我们从顶部开始，从`<!doctype html>`标签开始。
- en: This special tag, called a [doctype](https://html.spec.whatwg.org/multipage/syntax.html#the-doctype),
    is always the very first thing in an HTML document. But it’s not really an element
    at all, nor is it supposed to have a close tag. Our browser won’t be using the
    doctype for anything, so it’s best to throw it away:Real browsers use doctypes
    to switch between standards-compliant and legacy parsing and layout modes.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特殊标签，称为[doctype](https://html.spec.whatwg.org/multipage/syntax.html#the-doctype)，总是HTML文档中的第一件事。但它根本不是一个元素，也不应该有结束标签。我们的浏览器不会使用doctype做任何事情，所以最好把它扔掉：真实浏览器使用doctypes在标准兼容和遗留解析和布局模式之间切换。
- en: '[PRE110]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: This ignores all tags that start with an exclamation mark, which not only throws
    out doctype declarations but also comments, which in HTML are written `<!-- comment
    text -->`.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 这忽略了所有以感叹号开头的标签，这不仅丢弃了doctype声明，还丢弃了注释，在HTML中注释的写法是`<!-- comment text -->`。
- en: Just throwing out doctypes isn’t quite enough though—if you run your parser
    now, it will crash. That’s because after the doctype comes a newline, which our
    parser treats as text and tries to insert into the tree. Except there isn’t a
    tree, since the parser hasn’t seen any open tags. For simplicity, let’s just have
    our browser skip whitespace-only text nodes to side-step the problem:Real browsers
    retain whitespace to correctly render `make<span></span>up` as one word and `make<span>
    </span>up` as two. Our browser won’t. Plus, ignoring whitespace simplifies later
    chapters by avoiding a special case for whitespace-only text tags.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 但是仅仅丢弃 doctype 还远远不够——如果你现在运行你的解析器，它将会崩溃。这是因为 doctype 之后跟着一个换行符，我们的解析器将其视为文本并尝试将其插入到树中。但是没有树，因为解析器还没有看到任何打开的标签。为了简单起见，让我们让我们的浏览器跳过仅包含空白字符的文本节点，以绕过这个问题：真实浏览器会保留空白字符以正确渲染
    `make<span></span>up` 为一个单词和 `make<span> </span>up` 为两个单词。我们的浏览器不会这样做。此外，忽略空白字符简化了后面的章节，避免了为仅包含空白字符的文本标签设置特殊情况的必要。
- en: '[PRE111]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The first part of the parsed HTML tree for the `browser.engineering` home page
    now looks something like this:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 解析 `browser.engineering` 首页的 HTML 树的第一个部分现在看起来大致如下：
- en: '[PRE112]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Our next problem: why’s everything so deeply indented? Why aren’t these open
    elements ever closed?'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个问题是：为什么一切都被缩进得这么深？为什么这些打开的元素永远不会关闭？
- en: In SGML, document type declarations contained a URL which defined the valid
    tags, and in older versions of HTML that was also recommended. Browsers do use
    the absence of a document type declaration to [identify](https://developer.mozilla.org/en-US/docs/Web/HTML/Quirks_Mode_and_Standards_Mode)
    very old, pre-SGML versions of HTML,There’s also this crazy thing called “[almost
    standards](https://hsivonen.fi/doctype/)” or “limited quirks” mode, due to a backward-incompatible
    change in table cell vertical layout. Yes. I don’t need to make these up! but
    don’t use the URL, so `<!doctype html>` is the best document type declaration
    for modern HTML.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SGML 中，文档类型声明包含一个 URL，该 URL 定义了有效的标签，在 HTML 的早期版本中这也是推荐的。浏览器确实会使用缺少文档类型声明来[识别](https://developer.mozilla.org/en-US/docs/Web/HTML/Quirks_Mode_and_Standards_Mode)非常旧的、SGML
    之前的 HTML 版本。还有一个被称为“[几乎标准](https://hsivonen.fi/doctype/)”或“有限怪异”模式，这是由于表格单元格垂直布局中向后不兼容的更改。是的，我并不是在编造这些！但是不要使用
    URL，所以 `<!doctype html>` 是现代 HTML 的最佳文档类型声明。
- en: Self-closing Tags
  id: totrans-673
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自闭合标签
- en: 'Elements like `<meta>` and `<link>` are what are called self-closing: these
    tags don’t surround content, so you don’t ever write `</meta>` or `</link>`. Our
    parser needs special support for them. In HTML, there’s a [specific list](https://html.spec.whatwg.org/multipage/syntax.html#void-elements)
    of these self-closing tags (the specification calls them “void” tags):A lot of
    these tags are obscure. Browsers also support some additional, obsolete self-closing
    tags not listed here, like `keygen`.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '`<meta>` 和 `<link>` 这样的元素被称为自闭合：这些标签不包围内容，因此你永远不需要写 `</meta>` 或 `</link>`。我们的解析器需要为它们提供特殊支持。在
    HTML 中，有一个[特定列表](https://html.spec.whatwg.org/multipage/syntax.html#void-elements)的自闭合标签（规范称它们为“空”标签）：其中许多标签都很晦涩。浏览器还支持一些未在此列出的附加、过时的自闭合标签，如
    `keygen`。'
- en: '[PRE113]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Our parser needs to auto-close tags from this list:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解析器需要自动关闭以下列表中的标签：
- en: '[PRE114]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: This code looks right, but it doesn’t quite work right. Why not? Because our
    parser is looking for a tag named `meta`, but it’s finding a tag named “`meta
    name=...`”. The self-closing code isn’t triggered because the `<meta>` tag has
    attributes.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来是正确的，但它并不完全工作。为什么？因为我们的解析器正在寻找一个名为 `meta` 的标签，但它找到的是名为“`meta name=...`”的标签。自闭合代码没有被触发，因为
    `<meta>` 标签有属性。
- en: HTML attributes add information about an element; open tags can have any number
    of attributes. Attribute values can be quoted, unquoted, or omitted entirely.
    Let’s focus on basic attribute support, ignoring values that contain whitespace,
    which are a little complicated.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 属性为元素添加信息；打开标签可以有任意数量的属性。属性值可以是带引号的、不带引号的或完全省略。让我们专注于基本的属性支持，忽略包含空白字符的值，这些值稍微复杂一些。
- en: 'Since we’re not handling whitespace in values, we can split on whitespace to
    get the tag name and the attribute–value pairs:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不在值中处理空白字符，我们可以根据空白字符来分割，以获取标签名称和属性-值对：
- en: '[PRE115]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'HTML tag names are case insensitive, as by the way are attribute names, so
    I case-fold them.Lower-casing text is the [wrong way](https://www.b-list.org/weblog/2018/nov/26/case/)
    to do case-insensitive comparisons in languages like Cherokee. In HTML specifically,
    tag names only use the ASCII characters so lower-casing them would be sufficient,
    but I’m using Python’s `casefold` function because it’s a good habit to get into.
    Then, inside the loop, I split each attribute–value pair into a name and a value.
    The easiest case is an unquoted attribute, where an equal sign separates the two:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: HTML标签名不区分大小写，属性名也是如此，所以我会将它们转换为小写。在像切罗基语这样的语言中，将文本转换为小写是[错误的做法](https://www.b-list.org/weblog/2018/nov/26/case/)，因为在HTML中，标签名只使用ASCII字符，因此将它们转换为小写就足够了，但我使用Python的`casefold`函数，因为这是一个好习惯。然后，在循环内部，我将每个属性-值对拆分为一个名称和一个值。最简单的情况是未引用的属性，其中等号分隔两者：
- en: '[PRE116]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The value can also be omitted, like in `<input disabled>`, in which case the
    attribute value defaults to the empty string:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 值也可以省略，例如在`<input disabled>`中，在这种情况下，属性值默认为空字符串：
- en: '[PRE117]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Finally, the value can be quoted, in which case the quotes have to be stripped
    out:Quoted attributes allow whitespace between the quotes. Parsing that properly
    requires something like a finite state machine instead of just splitting on whitespace.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值可以是引用的，在这种情况下，必须删除引号：引用属性允许引号之间有空白。正确解析这需要类似有限状态机的东西，而不仅仅是按空白分割。
- en: '[PRE118]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We’ll store these attributes inside `Element`s:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些属性存储在`Element`中：
- en: '[PRE119]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: That means we’ll need to call `get_attributes` at the top of `add_tag` to get
    the `attributes` we need to construct an `Element`.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要在`add_tag`的顶部调用`get_attributes`以获取构建`Element`所需的`attributes`。
- en: '[PRE120]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Remember to use `tag` and `attribute` instead of `text` in `add_tag`, and try
    your parser again:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 记住要在`add_tag`中使用`tag`和`attribute`而不是`text`，并再次尝试你的解析器：
- en: '[PRE121]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: It’s close! Yes, if you print the attributes, you’ll see that attributes with
    whitespace (like `author` on one of the `meta` tags) are mis-parsed as multiple
    attributes, and the final slash on the self-closing tags is incorrectly treated
    as an extra attribute. A better parser would fix these issues. But let’s instead
    leave our parser as is—these issues aren’t going to be a problem for the browser
    we’re building—and move on to integrating it with our browser.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 它很接近了！是的，如果你打印属性，你会看到带有空白的属性（如`meta`标签中的一个`author`）被错误地解析为多个属性，并且自闭合标签上的最后一个斜杠被错误地处理为额外的属性。一个更好的解析器会修复这些问题。但让我们保持解析器不变——这些问题不会对我们正在构建的浏览器造成问题——并继续将其集成到我们的浏览器中。
- en: Putting a slash at the end of self-closing tags, like `<br/>`, became fashionable
    when [XHTML](https://www.w3.org/TR/xhtml1/) looked like it might replace HTML,
    and old-timers like me never broke the habit. But unlike in [XML](https://www.w3.org/TR/xml/#sec-starttags),
    in HTML self-closing tags are identified by name, not by some special syntax,
    so the slash is optional.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在自闭合标签的末尾放置一个斜杠，如`<br/>`，是在[XHTML](https://www.w3.org/TR/xhtml1/)看起来可能取代HTML时变得流行的，像我这样的老手从未改变习惯。但与[XML](https://www.w3.org/TR/xml/#sec-starttags)不同，在HTML中，自闭合标签是通过名称而不是某种特殊语法来识别的，所以斜杠是可选的。
- en: Using the Node Tree
  id: totrans-696
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用节点树
- en: 'Right now, the `Layout` class works token by token; we now want it to go node
    by node instead. So let’s separate the old `token` method into two parts: all
    the cases for open tags will go into a new `open_tag` method and all the cases
    for close tags will go into a new `close_tag` method:The case for text tokens
    is no longer needed because our browser can just call the existing `add_text`
    method directly.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`Layout`类按标记逐个处理；我们现在希望它按节点逐个处理。所以让我们将旧的`token`方法分成两部分：所有针对开放标签的情况将放入一个新的`open_tag`方法，所有针对关闭标签的情况将放入一个新的`close_tag`方法：文本标记的情况不再需要，因为我们的浏览器可以直接调用现有的`add_text`方法。
- en: '[PRE122]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Now we need the `Layout` object to walk the node tree, calling `open_tag`,
    `close_tag`, and `text` in the right order:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要`Layout`对象遍历节点树，以正确的顺序调用`open_tag`、`close_tag`和`text`：
- en: '[PRE123]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The `Layout` constructor can now call `recurse` instead of looping through
    the list of tokens. We’ll also need the browser to construct the node tree, like
    this:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '`Layout`构造函数现在可以调用`recurse`而不是遍历标记列表。我们还需要浏览器构建节点树，如下所示：'
- en: '[PRE124]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Run it—the browser should now use the parsed HTML tree.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它——浏览器现在应该使用解析后的HTML树。
- en: The `doctype` syntax is a form of versioning—declaring which version of HTML
    the web page is using. But in fact, the `html` value for `doctype` signals not
    just a particular version of HTML, but more generally the [*HTML living standard*](https://html.spec.whatwg.org/).It
    is not expected that any new `doctype` version for HTML will ever be added again.
    It’s called a “living standard” because it changes all the time as features are
    added. The mechanism for these changes is simply browsers shipping new features,
    not any change to the “version” of HTML. In general, the web is an *unversioned
    platform*—new features are often added as enhancements, but only so long as they
    don’t break existing ones.Features can be removed, but only if they stop being
    used by the vast majority of sites. This makes it very hard to remove web features
    compared with other platforms.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctype` 语法是一种版本形式——声明网页使用哪个 HTML 版本。但实际上，`doctype` 的 `html` 值不仅表示特定的 HTML
    版本，而且更普遍地表示 [*HTML 生活标准*](https://html.spec.whatwg.org/)。预计永远不会添加新的 HTML `doctype`
    版本。它被称为“生活标准”，因为它会随着新功能的添加而不断变化。这些变化的机制仅仅是浏览器推出新功能，而不是 HTML “版本”的任何变化。总的来说，网络是一个
    *无版本的平台*——新功能通常作为增强功能添加，但只要它们不破坏现有的功能。功能可以被删除，但只有当它们停止被绝大多数网站使用时。这使得与其它平台相比，删除网络功能变得非常困难。'
- en: Handling Author Errors
  id: totrans-705
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理作者错误
- en: The parser now handles HTML pages correctly—at least when the HTML is written
    by the sorts of goody-two-shoes programmers who remember the `<head>` tag, close
    every open tag, and make their bed in the morning. Mere mortals lack such discipline
    and so browsers also have to handle broken, confusing, `head`less HTML. In fact,
    modern HTML parsers are capable of transforming *any* string of characters into
    an HTML tree, no matter how confusing the markup.Yes, it’s crazy, and for a few
    years in the early 2000s the W3C tried to [do away with it](https://www.w3.org/TR/xhtml1/).
    They failed.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器现在可以正确处理 HTML 页面——至少当 HTML 是由那些记得 `<head>` 标签、关闭所有打开的标签并在早上整理床铺的乖孩子程序员编写时是这样。普通人缺乏这样的自律，因此浏览器也必须处理破碎、混乱的
    `head` 无 HTML。事实上，现代 HTML 解析器能够将任何字符序列转换为 HTML 树，无论标记多么混乱。是的，这很疯狂，在 2000 年代初的几年里，W3C
    试图 [废除它](https://www.w3.org/TR/xhtml1/)。他们失败了。
- en: 'The full algorithm is, as you might expect, complicated beyond belief, with
    dozens of ever-more-special cases forming a taxonomy of human error, but one of
    its nicer features is *implicit* tags. Normally, an HTML document starts with
    a familiar boilerplate:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的算法，正如你可能预料的那样，非常复杂，有成百上千个越来越特殊的案例构成了人类错误的分类学，但其中一项更好的特性是隐式标签。通常，HTML 文档从熟悉的样板开始：
- en: '[PRE125]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'In reality, *all six* of these tags, except the doctype, are optional: browsers
    insert them automatically when the web page omits them. Let’s insert implicit
    tags in our browser via a new `implicit_tags` function. We’ll want to call it
    in both `add_text` and `add_tag`:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，除了 doctype 之外，这六个标签都是可选的：当网页省略它们时，浏览器会自动插入。让我们通过一个新的 `implicit_tags` 函数在我们的浏览器中插入隐式标签。我们希望在
    `add_text` 和 `add_tag` 中都调用它：
- en: '[PRE126]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Note that `implicit_tags` isn’t called for the ignored whitespace and doctypes.
    Let’s also call it in `finish`, to make sure that an `<html>` and `<body>` tag
    are created even for empty strings:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`implicit_tags` 并不应用于被忽略的空白和文档类型。我们也在 `finish` 中调用它，以确保即使对于空字符串也会创建 `<html>`
    和 `<body>` 标签：
- en: '[PRE127]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The argument to `implicit_tags` is the tag name (or `None` for text nodes),
    which we’ll compare to the list of unfinished tags to determine what’s been omitted:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '`implicit_tags` 的参数是标签名（或对于文本节点为 `None`），我们将将其与未完成的标签列表进行比较，以确定哪些被省略了：'
- en: '[PRE128]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '`implicit_tags` has a loop because more than one tag could have been omitted
    in a row; every iteration around the loop will add just one. To determine which
    implicit tag to add, if any, requires examining the open tags and the tag being
    inserted.'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '`implicit_tags` 有一个循环，因为可能连续省略了多个标签；循环的每次迭代只会添加一个标签。要确定要添加哪个隐式标签（如果有），需要检查打开的标签和正在插入的标签。'
- en: 'Let’s start with the easiest case, the implicit `<html>` tag. An implicit `<html>`
    tag is necessary if the first tag in the document is something other than `<html>`:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的情况开始，隐式 `<html>` 标签。如果文档中的第一个标签不是 `<html>`，则需要隐式 `<html>` 标签：
- en: '[PRE129]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Both `<head>` and `<body>` can also be omitted, but to figure out which it
    is we need to look at which tag is being added:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '`<head>` 和 `<body>` 也可以省略，但为了确定是哪一个，我们需要查看正在添加的标签：'
- en: '[PRE130]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Here, `HEAD_TAGS` lists the tags that you’re supposed to put into the `<head>`
    element:The `<script>` tag can go in either the head or the body section, but
    it goes into the head by default.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`HEAD_TAGS` 列出了你应该放入 `<head>` 元素中的标签：`<script>` 标签可以放在头部或主体部分，但默认情况下它放在头部。
- en: '[PRE131]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Note that if both the `<html>` and `<head>` tags are omitted, `implicit_tags`
    is going to insert both of them by going around the loop twice. In the first iteration
    `open_tags` is `[]`, so the code adds an `<html>` tag; then, in the second iteration,
    `open_tags` is `["html"]`, so it adds a `<head>` tag.These `add_tag` methods themselves
    call `implicit_tags`, which means you can get into an infinite loop if you forget
    a case. I’ve been careful to make sure that every tag added by `implicit_tags`
    doesn’t itself trigger more implicit tags.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果同时省略了 `<html>` 和 `<head>` 标签，`implicit_tags` 将会通过两次遍历循环来插入这两个标签。在第一次迭代中，`open_tags`
    是 `[]`，所以代码会添加一个 `<html>` 标签；然后，在第二次迭代中，`open_tags` 是 `["html"]`，所以它会添加一个 `<head>`
    标签。这些 `add_tag` 方法本身会调用 `implicit_tags`，这意味着如果你忘记了一个情况，你可能会进入一个无限循环。我已经小心地确保 `implicit_tags`
    添加的每个标签本身不会触发更多的隐式标签。
- en: 'Finally, the `</head>` tag can also be implicit if the parser is inside the
    `<head>` and sees an element that’s supposed to go in the `<body>`:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果解析器在 `<head>` 内部并且看到一个应该放在 `<body>` 中的元素，`</head>` 标签也可以是隐式的：
- en: '[PRE132]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Technically, the `</body>` and `</html>` tags can also be implicit. But since
    our `finish` function already closes any unfinished tags, that doesn’t need any
    extra code. So all that’s left for `implicit_tags` is to exit out of the loop:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，`</body>` 和 `</html>` 标签也可以是隐式的。但由于我们的 `finish` 函数已经关闭了任何未完成的标签，所以不需要额外的代码。因此，`implicit_tags`
    剩下的只是退出循环：
- en: '[PRE133]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Of course, there are more rules for handling malformed HTML: formatting tags,
    nested paragraphs, embedded Scalable Vector Graphics (SVG) and MathML, and all
    sorts of other complexity. Each has complicated rules abounding with edge cases.
    But let’s end our discussion of handling author errors here.'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，处理不完整 HTML 的规则还有很多：格式化标签、嵌套段落、内嵌可缩放矢量图形 (SVG) 和 MathML，以及各种其他复杂性。每个都有复杂的规则，充满了边缘情况。但让我们在这里结束对处理作者错误的讨论。
- en: 'The rules for malformed HTML may seem arbitrary, and they are: they evolved
    over years of trying to guess what people “meant” when they wrote that HTML, and
    are now codified in the [HTML parsing standard](https://html.spec.whatwg.org/multipage/parsing.html).
    Of course, sometimes these rules “guess” wrong—but as so often happens on the
    web, it’s more important that every browser does the *same* thing, rather than
    each trying to guess what the *right* thing is.'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 处理不完整 HTML 的规则可能看起来是任意的，它们确实是：它们在多年的尝试中逐渐形成，试图猜测人们在编写 HTML 时“真正”想要表达的意思，现在这些规则被编码在
    [HTML 解析标准](https://html.spec.whatwg.org/multipage/parsing.html) 中。当然，有时这些规则“猜测”是错误的——但正如网络中经常发生的那样，更重要的是每个浏览器都做同样的事情，而不是每个浏览器都试图猜测“正确”的事情。
- en: And now for the payoff! Figure 3 shows a screenshot of [this book’s website](https://browser.engineering/),
    loaded in our own browser.To be fair, it actually looks about the same with the
    Chapter 3 browser.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是回报的时候了！图 3 展示了 [本书网站](https://browser.engineering/) 的截图，在我们的浏览器中加载。公平地说，它实际上看起来与第
    3 章浏览器中的看起来差不多。
- en: '![Figure 3: Screenshot of http://browser.engineering/ viewed in this chapter’s
    version of the browser.](img/ec99bda09eac4fbfbfb600ce10b060ad.png)'
  id: totrans-730
  prefs: []
  type: TYPE_IMG
  zh: '![图 3：本章浏览器中查看的 http://browser.engineering/ 的截图](img/ec99bda09eac4fbfbfb600ce10b060ad.png)'
- en: 'Thanks to implicit tags, you can mostly skip the `<html>`, `<body>`, and `<head>`
    elements, and they’ll be implicitly added back for you. In fact, the HTML parser’s
    [many states](https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-afterbody)
    guarantee something stricter than that: every HTML document has exactly one `<head>`
    and one `<body>`, in the expected order.At least, per document. An HTML file that
    uses frames or templates can have more than one `<head>` and `<body>`, but they
    correspond to different documents.'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 由于隐式标签的存在，你通常可以跳过 `<html>`、`<body>` 和 `<head>` 元素，它们会自动为你添加。实际上，HTML 解析器的 [许多状态](https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-afterbody)
    保证比这更严格：每个 HTML 文档恰好有一个 `<head>` 和一个 `<body>`，按照预期的顺序。至少，对于每个文档来说是这样。使用框架或模板的
    HTML 文件可以有多于一个的 `<head>` 和 `<body>`，但它们对应于不同的文档。
- en: Summary
  id: totrans-732
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter taught our browser that HTML is a tree, not just a flat list of
    tokens. We added:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章教会了我们的浏览器，HTML 是一棵树，而不仅仅是一个标记的扁平列表。我们添加了：
- en: a parser to transform HTML tokens to a tree;
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将 HTML 标记转换为树的解析器；
- en: code to recognize and handle attributes on elements;
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和处理元素属性上的代码；
- en: automatic fixes for some malformed HTML documents;
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对一些格式不正确的 HTML 文档进行自动修复；
- en: a recursive layout algorithm to lay out an HTML tree.
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个递归布局算法，用于布局 HTML 树。
- en: The tree structure of HTML is essential to display visually complex web pages,
    as we will see in the next chapter.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 的树结构对于显示视觉上复杂的网页至关重要，正如我们将在下一章中看到的。
- en: '[widgets/lab4-browser.html](widgets/lab4-browser.html)'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '[widgets/lab4-browser.html](widgets/lab4-browser.html)'
- en: Outline
  id: totrans-740
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should look
    something like this:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整函数、类和方法集合应该看起来像这样：
- en: '`` class URL: `def __init__(url)` `def request()` `` `` class Text: `def __init__(text,
    parent)` `def __repr__()` `` `` class Element: `def __init__(tag, attributes,
    parent)` `def __repr__()` `` `def print_tree(node, indent)` `` class HTMLParser:
    `SELF_CLOSING_TAGS` `HEAD_TAGS` `def __init__(body)` `def parse()` `def get_attributes(text)`
    `def add_text(text)` `def add_tag(tag)` `def implicit_tags(tag)` `def finish()`
    `` `FONTS` `def get_font(size, weight, style)` `WIDTH, HEIGHT` `HSTEP, VSTEP`
    `` class Layout: `def __init__(tree)` `def recurse(tree)` `def open_tag(tag)`
    `def close_tag(tag)` `def flush()` `def word(word)` `` `SCROLL_STEP` `` class
    Browser: `def __init__()` `def draw()` `def load(url)` `def scrolldown(e)` ``'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '`` class URL: `def __init__(url)` `def request()` `` `` class Text: `def __init__(text,
    parent)` `def __repr__()` `` `` class Element: `def __init__(tag, attributes,
    parent)` `def __repr__()` `` `def print_tree(node, indent)` `` class HTMLParser:
    `SELF_CLOSING_TAGS` `HEAD_TAGS` `def __init__(body)` `def parse()` `def get_attributes(text)`
    `def add_text(text)` `def add_tag(tag)` `def implicit_tags(tag)` `def finish()`
    `` `FONTS` `def get_font(size, weight, style)` `WIDTH, HEIGHT` `HSTEP, VSTEP`
    `` class Layout: `def __init__(tree)` `def recurse(tree)` `def open_tag(tag)`
    `def close_tag(tag)` `def flush()` `def word(word)` `` `SCROLL_STEP` `` class
    Browser: `def __init__()` `def draw()` `def load(url)` `def scrolldown(e)` ``'
- en: Exercises
  id: totrans-743
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '4-1 *Comments*. Update the HTML lexer to support comments. Comments in HTML
    begin with `<!--` and end with `-->`. However, comments aren’t the same as tags:
    they can contain any text, including left and right angle brackets. The lexer
    should skip comments, not generating any token at all. Check: is `<!-->` a comment,
    or does it just start one?'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 4-1 *注释*。更新 HTML 词法分析器以支持注释。HTML 中的注释从 `<!--` 开始，以 `-->` 结束。然而，注释与标签不同：它们可以包含任何文本，包括左右尖括号。词法分析器应跳过注释，不生成任何标记。检查：`<!-->`
    是注释，还是只是注释的开始？
- en: 4-2 *Paragraphs*. It’s not clear what it would mean for one paragraph to contain
    another. Change the parser so that a document like `<p>hello<p>world</p>` results
    in two sibling paragraphs instead of one paragraph inside another; real browsers
    do this too. Do the same for `<li>` elements, but make sure nested lists are still
    possible.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 4-2 *段落*。不清楚一个段落包含另一个段落意味着什么。修改解析器，使得像 `<p>hello<p>world</p>` 这样的文档结果为两个兄弟段落，而不是一个段落嵌套在另一个段落中；真正的浏览器也这样做。对
    `<li>` 元素也做同样的处理，但确保嵌套列表仍然可行。
- en: '4-3 *Scripts*. JavaScript code embedded in a `<script>` tag uses the left angle
    bracket to mean “less than”. Modify your lexer so that the contents of `<script>`
    tags are treated specially: no tags are allowed inside `<script>`, except the
    `</script>` close tag.Technically it’s just `</script` followed by a [space, tab,
    `\v`, `\r`, slash, or greater than sign](https://html.spec.whatwg.org/multipage/parsing.html#script-data-end-tag-name-state).
    If you need to talk about `</script>` tags inside JavaScript code, you have to
    split it into multiple strings.'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 4-3 *脚本*。嵌入在 `<script>` 标签中的 JavaScript 代码使用左尖括号表示“小于”。修改你的词法分析器，使得 `<script>`
    标签的内容被特别处理：不允许在 `<script>` 内部使用标签，除了 `</script>` 关闭标签。技术上，它只是 `</script` 后跟一个
    [空格、制表符、`\v`、`\r`、斜杠或大于号](https://html.spec.whatwg.org/multipage/parsing.html#script-data-end-tag-name-state)。如果你需要在
    JavaScript 代码中讨论 `</script>` 标签，你必须将其分成多个字符串。
- en: '4-4 *Quoted attributes*. Quoted attributes can contain spaces and right angle
    brackets. Fix the lexer so that this is supported properly. Hint: the current
    lexer is a finite state machine, with two states (determined by `in_tag`). You’ll
    need more states.'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 4-4 *引号属性*。引号属性可以包含空格和右尖括号。修复词法分析器，使其正确支持这一点。提示：当前的词法分析器是一个有限状态机，有两个状态（由 `in_tag`
    决定）。你需要更多的状态。
- en: '4-5 *Syntax highlighting*. Implement the `view-source` protocol as in [Exercise
    1-5](http.html#exercises), but make it syntax-highlight the source code of HTML
    pages. Keep source code for HTML tags in a normal font, but make text contents
    bold. If you’ve implemented it, wrap text in `<pre>` tags as well to preserve
    line breaks. Hint: subclass the HTML parser and use it to implement your syntax
    highlighter.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 4-5 *语法高亮显示*。实现与[练习1-5](http.html#exercises)中的`view-source`协议，但使其高亮显示HTML页面的源代码。将HTML标签的源代码以正常字体显示，但将文本内容加粗。如果你已经实现了它，还可以将文本包裹在`<pre>`标签中，以保留换行符。提示：从HTML解析器派生一个子类，并使用它来实现语法高亮器。
- en: 4-6 *Mis-nested formatting tags*. Extend your HTML parser to support markup
    like `<b>Bold <i>both</b> italic</i>`. This requires keeping track of the set
    of open text formatting elements and inserting implicit open and close tags when
    text formatting elements are closed in the wrong order. The bold/italic example,
    for example, should insert an implicit `</i>` before the `</b>` and an implicit
    `<i>` after it.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 4-6 *错误嵌套的格式化标签*。扩展你的HTML解析器以支持如下标记 `<b>Bold <i>both</i> italic</b>`。这需要跟踪打开的文本格式化元素集合，并在文本格式化元素以错误顺序关闭时插入隐式的打开和关闭标签。例如，粗体/斜体示例应该在`</b>`之前插入一个隐式的`</i>`，并在其后插入一个隐式的`<i>`。
- en: Laying Out Pages
  id: totrans-750
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面布局
- en: Chapter 5 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '[Web浏览器工程](./index.html "目录")的第5章。'
- en: '[The Layout Tree](#the-layout-tree)'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[布局树](#the-layout-tree)'
- en: '[Block Layout](#block-layout)'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[块布局](#block-layout)'
- en: '[Size and Position](#size-and-position)'
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大小和位置](#size-and-position)'
- en: '[Recursive Painting](#recursive-painting)'
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[递归绘制](#recursive-painting)'
- en: '[Backgrounds](#backgrounds)'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[背景](#backgrounds)'
- en: '[Summary](#summary)'
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summary)'
- en: '[Outline](#outline)'
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大纲](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: 'So far, layout has been a linear process that handles open tags and close tags
    independently. But web pages are trees, and look like them: borders and backgrounds
    visually nest inside one another. To support that, this chapter switches to *tree-based
    layout*, where the tree of elements is transformed into a tree of *layout objects*
    before drawing. In the process, we’ll make web pages more colorful with backgrounds.'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，布局一直是一个线性过程，独立处理打开标签和关闭标签。但网页是树状结构，看起来像这样：边框和背景在视觉上嵌套在一起。为了支持这一点，本章转向*基于树的布局*，在绘制之前，将元素的树转换为布局对象的树。在这个过程中，我们将使用背景使网页更加多彩。
- en: The Layout Tree
  id: totrans-761
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局树
- en: Right now, our browser lays out an element’s open and close tags separately.
    Both tags modify global state, like the `cursor_x` and `cursor_y` variables, but
    they aren’t otherwise connected, and information about the element as a whole,
    like its width and height, is never computed. That makes it pretty hard to draw
    a background behind an element, let alone more complicated visual effects. So
    web browsers structure layout differently.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的浏览器分别布局元素的开标签和闭标签。这两个标签都修改全局状态，如`cursor_x`和`cursor_y`变量，但它们之间没有其他联系，并且关于元素整体的信息，如其宽度和高度，从未被计算。这使得在元素后面绘制背景变得相当困难，更不用说更复杂的视觉效果了。因此，网络浏览器以不同的方式结构布局。
- en: In a browser, layout is about producing a *layout tree*, whose nodes are *layout
    objects*, each associated with an HTML elementElements like `<script>` don’t generate
    layout objects, and some elements generate multiple layout objects (`<li>` elements
    have an extra one for the bullet point!), but mostly it’s one layout object each.
    and each with a size and a position. The browser walks the HTML tree to produce
    the layout tree, then computes the size and position for each layout object, and
    finally draws each layout object to the screen.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，布局是关于生成一个*布局树*，其节点是*布局对象*，每个都与一个HTML元素相关联。例如，`<script>`标签不会生成布局对象，某些元素会生成多个布局对象（`<li>`元素有一个额外的布局对象用于项目符号），但大多数情况下每个元素只有一个布局对象。每个布局对象都有一个大小和位置。浏览器遍历HTML树以生成布局树，然后计算每个布局对象的大小和位置，最后将每个布局对象绘制到屏幕上。
- en: 'Let’s start by looking at how the existing `Layout` class is used:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看现有的`Layout`类是如何使用的：
- en: '[PRE134]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Here, a `Layout` object is created briefly and then thrown away. Let’s instead
    make it the beginning of our layout tree by storing it in a `Browser` field:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个`Layout`对象被简要创建然后丢弃。让我们将其作为布局树的开始，通过将其存储在`Browser`字段中来实现：
- en: '[PRE135]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Note that I’ve renamed the `Layout` constructor to a `layout` method, so that
    constructing a layout object and actually laying it out can be different steps.
    The constructor now just stores the node it was passed:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经将 `Layout` 构造函数重命名为 `layout` 方法，这样构建布局对象和实际布局就可以是不同的步骤。构造函数现在只存储传递给它的节点：
- en: '[PRE136]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'So far, we still don’t have a tree—we just have a single `Layout` object. To
    make it into a tree, we’ll need to add child and parent pointers. I’m also going
    to add a pointer to the previous sibling, because that’ll be useful for computing
    sizes and positions later:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仍然没有树——我们只有一个单独的 `Layout` 对象。为了将其变成树，我们需要添加子对象和父对象指针。我还会添加一个指向前一个兄弟对象的指针，因为这将有助于稍后计算大小和位置：
- en: '[PRE137]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'That said, requiring a `parent` and `previous` object now makes it tricky to
    construct a `Layout` object in `Browser`, since the root of the layout tree obviously
    can’t have a parent. To rectify that, let me add a second kind of layout object
    to serve as the root of the layout tree.I don’t want to just pass `None` for the
    parent, because the root layout object also computes its size and position differently,
    as we’ll see later in this chapter. I think of that root as the document itself,
    so let’s call it `DocumentLayout`:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，现在要求一个 `parent` 和 `previous` 对象，这使得在 `Browser` 中构造 `Layout` 对象变得复杂，因为布局树的根显然不能有父对象。为了纠正这一点，我将添加第二种布局对象，作为布局树的根。我不想只是传递
    `None` 作为父对象，因为根布局对象在计算大小和位置方面也有所不同，正如我们将在本章后面看到的那样。我认为这个根就是文档本身，所以让我们称它为 `DocumentLayout`：
- en: '[PRE138]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Note an interesting thing about this new `layout` method: its role is to *create*
    the child layout objects and then *recursively* call their `layout` methods. This
    is a common pattern for constructing trees; we’ll be seeing it a lot throughout
    this book.'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个新 `layout` 方法的有趣之处：它的作用是创建子布局对象，然后递归地调用它们的 `layout` 方法。这是构建树的一种常见模式；我们将在整本书中看到很多。
- en: Now when we construct a `DocumentLayout` object inside `load`, we’ll be building
    a tree; a very short tree, more of a stump (just the “document” and the HTML element
    below it), but a tree nonetheless!
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在 `load` 中构造 `DocumentLayout` 对象时，我们将构建一个树；一个非常短的树，更像是一根树桩（只是“文档”及其下面的
    HTML 元素），但毕竟是一个树！
- en: 'By the way, since we now have `DocumentLayout`, let’s rename `Layout` so it’s
    less ambiguous. I like `BlockLayout` as a name, because we ultimately want it
    to represent a block of text, like a paragraph or a heading:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，既然我们现在有了 `DocumentLayout`，让我们将 `Layout` 重命名，使其不那么含糊。我喜欢 `BlockLayout`
    这个名字，因为我们最终希望它代表一个文本块，如段落或标题：
- en: '[PRE139]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Make sure to rename the `Layout` constructor call in `DocumentLayout` as well.
    As always, test your browser and make sure that after all of these refactors,
    everything still works.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 `DocumentLayout` 中的 `Layout` 构造函数调用重命名。一如既往，测试你的浏览器并确保在所有这些重构之后，一切仍然正常工作。
- en: The layout tree isn’t accessible to web developers, so it hasn’t been standardized,
    and its structure differs between browsers. Even the names don’t match! Chrome
    calls it a [layout tree](https://developers.google.com/web/updates/2018/09/inside-browser-part3),
    Safari a [render tree](https://webkit.org/blog/114/webcore-rendering-i-the-basics/),
    and Firefox a [frame tree](https://wiki.mozilla.org/Gecko:Key_Gecko_Structures_And_Invariants).
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 布局树对网页开发者不可访问，因此尚未标准化，其结构在不同浏览器之间也有所不同。甚至名称都不一致！Chrome 称其为[布局树](https://developers.google.com/web/updates/2018/09/inside-browser-part3)，Safari
    称其为[渲染树](https://webkit.org/blog/114/webcore-rendering-i-the-basics/)，而 Firefox
    称其为[框架树](https://wiki.mozilla.org/Gecko:Key_Gecko_Structures_And_Invariants)。
- en: Block Layout
  id: totrans-780
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块布局
- en: So far, we’ve focused on text layout—and text is laid out horizontally in lines.In
    European languages, at least! But web pages are really constructed out of larger
    blocks, like headings, paragraphs, and menus, that stack vertically one after
    another. We need to add support for this kind of layout to our browser, and the
    way we’re going to do that involves expanding on the layout tree we’ve already
    built.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于文本布局——至少在欧洲语言中，文本是按行水平布局的。但网页实际上是由更大的块组成的，如标题、段落和菜单，它们一个接一个地垂直堆叠。我们需要在我们的浏览器中添加对这种布局的支持，而我们实现这一目标的方式将涉及扩展我们已构建的布局树。
- en: The core idea is that we’ll have a whole tree of `BlockLayout` objects (with
    a `DocumentLayout` at the root). Some will represent leaf blocks that contain
    text, and they’ll lay out their contents the way we’ve already implemented. But
    there will also be new, intermediate `BlockLayout`s with `BlockLayout` children,
    and they will stack their children vertically. (An example is shown in Figure
    1\. A widget above it lets you play with how block layout leads to different visual
    output.)
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想是我们将有一个整个 `BlockLayout` 对象树（根节点为 `DocumentLayout`）。其中一些将代表包含文本的叶块，它们将以我们已实现的方式布局其内容。但也会有新的、中间的
    `BlockLayout`，它们有 `BlockLayout` 子元素，并将它们的子元素垂直堆叠。（图 1 中展示了示例。上面的控件允许你玩转块布局如何导致不同的视觉输出。）
- en: '[widgets/layout-container-example.html?embed=true](widgets/layout-container-example.html?embed=true)'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '[widgets/layout-container-example.html?embed=true](widgets/layout-container-example.html?embed=true)'
- en: '![Figure 1: An example of an HTML tree and the corresponding layout tree.](img/e8910cf9051b757c55fa90b28e31315d.png)'
  id: totrans-784
  prefs: []
  type: TYPE_IMG
  zh: '![图 1：HTML 树和相应的布局树的示例](img/e8910cf9051b757c55fa90b28e31315d.png)'
- en: 'Figure 1: An example of an HTML tree and the corresponding layout tree.'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1：HTML 树和相应的布局树的示例。
- en: 'To create these intermediate `BlockLayout` children, we can use a loop like
    this:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这些中间的 `BlockLayout` 子元素，我们可以使用这样的循环：
- en: '[PRE140]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: I’ve called this method `layout_intermediate`, but only so you can add it to
    the code right away and then compare it with the existing `recurse` method.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 我把这个方法命名为 `layout_intermediate`，但只是为了让你能立即将其添加到代码中，然后与现有的 `recurse` 方法进行比较。
- en: 'This code is tricky, so read it carefully. It involves two trees: the HTML
    tree, which `node` and `child` point to; and the layout tree, which `self`, `previous`,
    and `next` point to. The two trees have similar structure, so it’s easy to get
    confused. But remember that this code constructs the layout tree from the HTML
    tree, so it reads from `node.children` (in the HTML tree) and writes to `self.children`
    (in the layout tree).'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比较复杂，所以请仔细阅读。它涉及两个树：HTML 树，`node` 和 `child` 指向它；以及布局树，`self`、`previous`
    和 `next` 指向它。这两个树有相似的结构，所以很容易混淆。但请记住，这段代码是从 HTML 树构建布局树的，所以它从 HTML 树中的 `node.children`
    读取，并写入布局树中的 `self.children`。
- en: 'So we have two ways to lay out an element: either calling `recurse` and `flush`,
    or this `layout_intermediate` function. To determine which one a layout object
    should use, we’ll need to know what kind of content its HTML node contains: *inline*
    text and text-related tags like `<b>`, or *blocks* like `<p>` and `<h1>`. Let’s
    add a `layout_mode` method that computes which is which:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们有两种方式来布局一个元素：要么调用 `recurse` 和 `flush`，要么调用这个 `layout_intermediate` 函数。为了确定布局对象应该使用哪一个，我们需要知道其
    HTML 节点包含的内容类型：*内联* 文本和与文本相关的标签，如 `<b>`，或者 *块*，如 `<p>` 和 `<h1>`。让我们添加一个 `layout_mode`
    方法来计算哪一个是哪一个：
- en: '[PRE141]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Here, the list of `BLOCK_ELEMENTS` is basically what you expect, a list of all
    the tags that describe blocks and containers:Taken from the [HTML living standard](https://html.spec.whatwg.org/multipage/#toc-semantics).
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`BLOCK_ELEMENTS` 的列表基本上是你所期望的，一个描述所有块和容器的标签的列表：取自 [HTML 生活标准](https://html.spec.whatwg.org/multipage/#toc-semantics)。
- en: '[PRE142]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Our `layout_mode` method has to handle one tricky case, where a node contains
    both block children like a `<p>` element and also text children like a text node
    or a `<b>` element. It’s probably best to think of this as a kind of error on
    the part of the web developer. And just like with implicit tags in [Chapter 4](html.html),
    we need a repair mechanism to make sense of the situation; I’ve chosen to use
    block mode in this case.In real browsers, that repair mechanism is called “[anonymous
    block boxes](https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model#anonymous_boxes)”
    and is more complex than what’s described here; see Exercise 5-5.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `layout_mode` 方法必须处理一个棘手的情况，即一个节点既包含类似 `<p>` 元素的块子元素，也包含类似文本节点或 `<b>` 元素的文本子元素。这可能最好被视为网页开发者的一部分错误。就像
    [第 4 章](html.html) 中的隐式标签一样，我们需要一个修复机制来理解这种情况；我选择在这种情况下使用块模式。在实际浏览器中，这个修复机制被称为“[匿名块框](https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model#anonymous_boxes)”并且比这里描述的更复杂；请参阅练习
    5-5。
- en: 'So now `BlockLayout` can determine what kind of layout to do based on the `layout_mode`
    of its HTML node:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 因此现在 `BlockLayout` 可以根据其 HTML 节点的 `layout_mode` 确定要执行哪种布局：
- en: '[PRE143]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Finally, since `BlockLayout`s can now have children, the `layout` method next
    needs to recursively call `layout` so those children can construct their children,
    and so on recursively:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于 `BlockLayout` 现在可以有子元素，下一个需要递归调用 `layout` 方法，以便这些子元素可以构建它们的子元素，依此类推：
- en: '[PRE144]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Our browser is now constructing a whole tree of `BlockLayout` objects; you can
    use `print_tree` to see this tree in the `Browser`’s `load` method. You’ll see
    that large web pages like this chapter produce large and complex layout trees!
    Now we need each of these `BlockLayout` objects to have a size and position somewhere
    on the page.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器现在正在构建一个`BlockLayout`对象的整个树；您可以使用`print_tree`在`Browser`的`load`方法中查看此树。您会看到像本章这样的大型网页会产生大型且复杂的布局树！现在我们需要每个`BlockLayout`对象在页面上都有大小和位置。
- en: In CSS, the layout mode is set by the [`display` property](https://developer.mozilla.org/en-US/docs/Web/CSS/display).
    The oldest CSS layout modes, like `inline` and `block`, are set on the children
    instead of the parent, which leads to hiccups like [anonymous block boxes](https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model#anonymous_boxes).
    Newer properties like `inline-block`, `flex`, and `grid` are set on the parent,
    which avoids this kind of error.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中，布局模式由`display`属性设置。[`display`属性](https://developer.mozilla.org/en-US/docs/Web/CSS/display)。最古老的CSS布局模式，如`inline`和`block`，是在子元素上设置的，而不是在父元素上设置，这导致了像[匿名块框](https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model#anonymous_boxes)这样的问题。较新的属性如`inline-block`、`flex`和`grid`是在父元素上设置的，这避免了这种错误。
- en: Size and Position
  id: totrans-801
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大小和位置
- en: In the [previous chapter](html.html), the `Layout` object was responsible for
    the whole web page, so it just laid out its content starting at the top of the
    page. Now that we have multiple `BlockLayout` objects each containing a different
    paragraph of text, we’re going to need to do things a little differently, computing
    a size and position for each layout object independently.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 在[上一章](html.html)中，`Layout`对象负责整个网页，因此它只是从页面顶部开始布局其内容。现在我们有多个`BlockLayout`对象，每个对象包含不同的文本段落，我们将需要做一些不同的操作，为每个布局对象独立计算大小和位置。
- en: 'Let’s add `x`, `y`, `width`, and `height` fields for each layout object type:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为每个布局对象类型添加`x`、`y`、`width`和`height`字段：
- en: '[PRE145]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Do the same for `DocumentLayout`. Now we need to update the `layout` method
    to use these fields.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`DocumentLayout`也做同样的操作。现在我们需要更新`layout`方法来使用这些字段。
- en: 'Let’s start with `cursor_x` and `cursor_y`. Instead of having them denote absolute
    positions on the page, let’s make them relative to the `BlockLayout`’s `x` and
    `y`. So they now need to start from `0` instead of `HSTEP` and `VSTEP`, in both
    `layout` and `flush`:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`cursor_x`和`cursor_y`开始。而不是让它们表示页面上的绝对位置，让我们让它们相对于`BlockLayout`的`x`和`y`是相对的。因此，它们现在需要从`0`开始，而不是`HSTEP`和`VSTEP`，在`layout`和`flush`中都是如此：
- en: '[PRE146]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Since these fields are now relative, we’ll need to add the block’s `x` and
    `y` position in `flush` when computing the display list:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些字段现在是相对的，我们在计算显示列表时需要在`flush`中添加块的`x`和`y`位置：
- en: '[PRE147]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Similarly, to wrap lines, we can’t compare `cursor_x` to `WIDTH`, because `cursor_x`
    is a relative position while `WIDTH` is an absolute position; instead, we’ll wrap
    lines when `cursor_x` reaches the block’s `width`:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了换行，我们不能将`cursor_x`与`WIDTH`比较，因为`cursor_x`是一个相对位置，而`WIDTH`是一个绝对位置；相反，当`cursor_x`达到块的`width`时，我们将换行：
- en: '[PRE148]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: So now that leaves us with the problem of computing these `x`, `y`, and `width`
    fields. Let’s recall that `BlockLayout`s represent blocks of text like paragraphs
    or headings, and are stacked vertically one atop another. That means each one
    starts at its parent’s left edge and goes all the way across its parent:In the
    [next chapter](styles.html), we’ll add support for author-defined styles, which
    in real browsers modify these layout rules by setting custom widths or changing
    how *x* and *y* positions are computed.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们面临的问题是计算这些`x`、`y`和`width`字段。让我们回忆一下，`BlockLayout`s代表文本块，如段落或标题，并且是垂直堆叠的。这意味着每个块都从其父元素的左侧边缘开始，一直延伸到其父元素：在[下一章](styles.html)中，我们将添加对作者定义样式的支持，在真实浏览器中，这些样式通过设置自定义宽度或更改计算*x*和*y*位置的方式来修改这些布局规则。
- en: '[PRE149]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'A layout object’s vertical position depends on whether there’s a previous sibling.
    If there is one, the layout object starts right after it; otherwise, it starts
    at its parent’s top edge:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 布局对象的垂直位置取决于是否有前一个兄弟元素。如果有，布局对象将紧随其后开始；如果没有，它将从其父元素的顶部边缘开始：
- en: '[PRE150]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Finally, height is a little tricky. A `BlockLayout` that contains other blocks
    should be tall enough to contain all of its children, so its height should be
    the sum of its children’s heights:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，高度有点棘手。包含其他块的`BlockLayout`应该足够高，以包含其所有子元素，因此其高度应该是其子元素高度的总和：
- en: '[PRE151]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: However, a `BlockLayout` that contains text doesn’t have children; instead,
    it needs to be tall enough to contain all its text, which we can conveniently
    read off from `cursor_y`:Since the height is just equal to `cursor_y`, why not
    rename `cursor_y` to `height` instead? You could, it would work fine, but I would
    rather not. As you can see from, say, the `y` computation, the `height` field
    is a public field, read by other layout objects to compute their positions. As
    such, I’d rather make sure it *always* has the right value, whereas `cursor_y`
    changes as we lay out a paragraph of text and therefore sometimes has the “wrong”
    value. Keeping these two fields separate avoids a whole class of nasty bugs where
    the `height` field is read “too soon” and therefore gets the wrong value.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，包含文本的 `BlockLayout` 没有子元素；相反，它需要足够高以容纳所有文本，我们可以方便地从 `cursor_y` 中读取：由于高度只是等于
    `cursor_y`，为什么不将 `cursor_y` 重命名为 `height` 呢？你可以这样做，它会正常工作，但我不太愿意这样做。正如你从，比如说，`y`
    计算中可以看到，`height` 字段是一个公共字段，被其他布局对象读取以计算它们的位置。因此，我更愿意确保它始终具有正确的值，而 `cursor_y` 随着我们布局一段文本而改变，因此有时会有“错误”的值。保持这两个字段分开可以避免一类很糟糕的
    bug，其中 `height` 字段被“过早”读取，因此得到错误的值。
- en: '[PRE152]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: These rules seem simple enough, but there’s a subtlety here I have to explain.
    Consider the `x` position. To compute a block’s `x` position, the `x` position
    of its parent block must *already* have been computed. So a block’s `x` must therefore
    be computed before its children’s `x`. That means the `x` computation has to go
    *before* the recursive `layout` call.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则看起来足够简单，但这里有一个我必须解释的微妙之处。考虑 `x` 位置。为了计算一个块的 `x` 位置，其父块的 `x` 位置必须已经计算过。因此，一个块的
    `x` 必须在它的子元素的 `x` 之前计算。这意味着 `x` 计算必须在递归 `layout` 调用之前进行。
- en: On the other hand, an element’s `height` field depends on its children’s heights.
    So while `x` must be computed *before* the recursive call, `height` has to be
    computed *after*. Similarly, since the `y` position of a block depends on its
    previous sibling’s `y` position, the recursive `layout` calls have to start at
    the first sibling and iterate through the list forward.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个元素的 `height` 字段依赖于其子元素的高度。因此，虽然 `x` 必须在递归调用之前计算，但 `height` 必须在之后计算。同样，由于一个块的
    `y` 位置依赖于其前一个兄弟的 `y` 位置，递归 `layout` 调用必须从第一个兄弟开始并向前迭代列表。
- en: 'That is, the `layout` method should perform its steps in this order (see Figure
    2):'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`layout` 方法应该按照这个顺序执行其步骤（见图 2）：
- en: When `layout` is called, it first computes the `width`, `x`, and `y` fields,
    reading from the `parent` and `previous` layout objects.
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用 `layout` 时，它首先计算 `width`、`x` 和 `y` 字段，从 `parent` 和 `previous` 布局对象中读取。
- en: Next, it creates a child layout object for each child element.
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，它为每个子元素创建一个子布局对象。
- en: Then, the child layout nodes are recursively laid out by calling their `layout`
    methods.
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，通过调用它们的 `layout` 方法递归地布局子布局节点。
- en: Finally, `layout` computes the `height` field, reading from the child layout
    objects.
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`layout` 计算高度字段，从子布局对象中读取。
- en: 'You can see these steps in action in this widget:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个小部件中看到这些步骤的实际操作：
- en: '[widgets/lab5-propagate.html](widgets/lab5-propagate.html)'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '[widgets/lab5-propagate.html](widgets/lab5-propagate.html)'
- en: '![Figure 2: A flowchart showing how widths are computed top-down, from parent
    to child, while heights are computed bottom-up, from child to parent.](img/cba8d6a294fabe5fc1ae95788c66767a.png)'
  id: totrans-829
  prefs: []
  type: TYPE_IMG
  zh: '![图 2：一个流程图，展示了宽度是如何从父元素到子元素自上而下计算的，而高度是如何从子元素到父元素自下而上计算的。](img/cba8d6a294fabe5fc1ae95788c66767a.png)'
- en: 'Figure 2: A flowchart showing how widths are computed top-down, from parent
    to child, while heights are computed bottom-up, from child to parent.'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：一个流程图，展示了宽度是如何从父元素到子元素自上而下计算的，而高度是如何从子元素到父元素自下而上计算的。
- en: This kind of dependency reasoning is crucial to layout and more broadly to any
    kind of computation on trees. If you get the order of operations wrong, some layout
    object will try to read a value that hasn’t been computed yet, and the browser
    will have a bug. We’ll come back to this issue of dependencies [in Chapter 16](invalidation.html),
    where it will become even more important.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 这种依赖推理对于布局以及更广泛地对于任何树上的计算都是至关重要的。如果你操作顺序错误，某些布局对象将尝试读取尚未计算出的值，浏览器将出现错误。我们将在第
    16 章（invalidation.html）中回到这个问题，那时它将变得更加重要。
- en: '`DocumentLayout` needs some layout code too, though since the document always
    starts in the same place it’s pretty simple:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '`DocumentLayout` 也需要一些布局代码，尽管由于文档总是从相同的位置开始，所以它相当简单：'
- en: '[PRE153]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Note that there’s some padding around the contents—`HSTEP` on the left and right,
    and `VSTEP` above and below. That’s so the text won’t run into the very edge of
    the window and get cut off.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，内容周围有一些填充——左侧和右侧的`HSTEP`，以及上方和下方的`VSTEP`。这样文本就不会跑到窗口的边缘并被截断。
- en: Anyway, with all of the sizes and positions now computed correctly, our browser
    should display all of the text on the page in the right places.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，现在所有的大小和位置都计算正确，我们的浏览器应该能够在页面的正确位置显示所有文本。
- en: Formally, computations on a tree like this can be described by an [attribute
    grammar](https://en.wikipedia.org/wiki/Attribute_grammar). Attribute grammar engines
    analyze dependencies between different attributes to determine the right order
    to traverse the tree and calculate each attribute.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 正式来说，这种树形结构的计算可以通过一个[属性文法](https://en.wikipedia.org/wiki/Attribute_grammar)来描述。属性文法引擎通过分析不同属性之间的依赖关系来确定遍历树和计算每个属性的合适顺序。
- en: Recursive Painting
  id: totrans-837
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归绘制
- en: 'Our `layout` method is now doing quite a bit of work: computing sizes and positions;
    creating child layout objects; recursively laying out those child layout objects;
    and aggregating the display lists so the text can be drawn to the screen. This
    is a bit messy, so let’s take a moment to extract just one part of this, the display
    list part. Along the way, we can stop copying the display list contents over and
    over again as we go up the layout tree.'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`layout`方法现在做了很多工作：计算大小和位置；创建子布局对象；递归地布局这些子布局对象；以及聚合显示列表，以便将文本绘制到屏幕上。这有点杂乱，所以让我们花点时间提取其中的一个部分，即显示列表部分。在这个过程中，我们可以停止在布局树上升时重复复制显示列表内容。
- en: 'I think it’s most convenient to do that by adding a `paint` function to each
    layout object, whose return value is the display list entries for that object.
    Then there is a separate function, `paint_tree`, that recursively calls `paint`
    on all layout objects:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为通过为每个布局对象添加一个`paint`函数来做这件事最为方便，该函数的返回值是那个对象的显示列表条目。然后有一个单独的函数`paint_tree`，它会递归地对所有布局对象调用`paint`：
- en: '[PRE154]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'For `DocumentLayout`, there is nothing to paint:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`DocumentLayout`，没有需要绘制的：
- en: '[PRE155]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: You can now delete the line that computes a `DocumentLayout`’s `display_list`
    field.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以删除计算`DocumentLayout`的`display_list`字段的行。
- en: For a `BlockLayout` object, we need to copy over the `display_list` field that
    it computes during `recurse` and `flush`:And again, delete the line that computes
    a `BlockLayout`’s `display_list` field by copying from child layout objects.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`BlockLayout`对象，我们需要复制它在`recurse`和`flush`期间计算的`display_list`字段：再次删除通过复制子布局对象来计算`BlockLayout`的`display_list`字段的行。
- en: '[PRE156]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Now the browser can use `paint_tree` to collect its own `display_list` variable:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 现在浏览器可以使用`paint_tree`来收集它自己的`display_list`变量：
- en: '[PRE157]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Check it out: our browser is now using fancy tree-based layout! I recommend
    pausing to test and debug. Tree-based layout is powerful but complex, and we’re
    about to add more features. Stable foundations make for comfortable houses.'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一下：我们的浏览器现在正在使用基于树的布局！我建议暂停以测试和调试。基于树的布局功能强大但复杂，我们即将添加更多功能。稳固的基础才能建造舒适的房屋。
- en: Layout trees are common [in graphical user interface (GUI) frameworks](https://book.huihoo.com/debian-gnu-linux-desktop-survival-guide/Widget_Tree.html),
    but there are other ways to structure layout, such as constraint-based layout.
    TeX’s [boxes and glue](https://www.overleaf.com/learn/latex/Articles/Boxes_and_Glue%3A_A_Brief%2C_but_Visual%2C_Introduction_Using_LuaTeX)
    and iOS’s [auto-layout](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html)
    are two examples of this alternative paradigm.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 布局树在图形用户界面（GUI）框架中很常见[在图形用户界面（GUI）框架](https://book.huihoo.com/debian-gnu-linux-desktop-survival-guide/Widget_Tree.html)，但还有其他布局结构的方法，例如基于约束的布局。TeX的[框和胶水](https://www.overleaf.com/learn/latex/Articles/Boxes_and_Glue%3A_A_Brief%2C_but_Visual%2C_Introduction_Using_LuaTeX)和iOS的[自动布局](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html)是这种替代范例的两个例子。
- en: Backgrounds
  id: totrans-850
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景
- en: Browsers use the layout tree a lot,For example, in [Chapter 7](chrome.html),
    we’ll use the size and position of each link to figure out which one the user
    clicked on. and one simple and visually compelling use case is drawing backgrounds.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器大量使用布局树，例如，在[第7章](chrome.html)中，我们将使用每个链接的大小和位置来确定用户点击的是哪一个。一个简单且视觉上吸引人的用例是绘制背景。
- en: 'Backgrounds are rectangles, so our first task is putting rectangles in the
    display list. Right now, the display list is a list of words to draw to the screen,
    but we can conceptualize it instead as a list of *commands*, of which there is
    currently only one type. We now want two types of commands:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 背景是矩形，所以我们的第一个任务是将在显示列表中放置矩形。目前，显示列表是绘制到屏幕上的单词列表，但我们可以将其概念化为命令列表，其中目前只有一种类型。我们现在想要两种类型的命令：
- en: '[PRE158]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Now `BlockLayout` must add `DrawText` objects for each word it wants to draw,
    but only in inline mode:Why not change the `display_list` field inside a `BlockLayout`
    to contain `DrawText` commands directly? I suppose you could, but I think it’s
    cleaner to create all of the draw commands in `paint`.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`BlockLayout`必须为它想要绘制的每个单词添加`DrawText`对象，但只在内联模式下：为什么不将`BlockLayout`内部的`display_list`字段改为直接包含`DrawText`命令呢？我想你可以这样做，但我认为在`paint`中创建所有绘制命令更干净。
- en: '[PRE159]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'But it can also add a `DrawRect` command to draw a background. Let’s add a
    gray background to `pre` tags (which are used for code examples):'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 但它也可以添加一个`DrawRect`命令来绘制背景。让我们给`pre`标签（用于代码示例）添加一个灰色背景：
- en: '[PRE160]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Make sure this code comes *before* the loop that adds `DrawText` objects: the
    background has to be drawn *below* that text. Note also that `paint_tree` calls
    `paint` before recursing into the subtree, so the subtree also paints on top of
    this background, as desired.'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 确保这段代码在添加`DrawText`对象的循环之前：背景必须在文本下方绘制。注意，`paint_tree`在递归到子树之前调用`paint`，因此子树也会在这个背景上绘制，正如预期的那样。
- en: 'With the display list filled out, we need to draw each graphics command. Let’s
    add an `execute` method for this. On `DrawText` it calls `create_text`:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示列表填写完毕后，我们需要绘制每个图形命令。让我们添加一个`execute`方法来完成这个任务。在`DrawText`中，它调用`create_text`：
- en: '[PRE161]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Note that `execute` takes the scroll amount as a parameter; this way, each
    graphics command does the relevant coordinate conversion itself. `DrawRect` does
    the same with `create_rectangle`:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`execute`方法接受滚动量作为参数；这样，每个图形命令都会自己执行相关的坐标转换。`DrawRect`使用`create_rectangle`做同样的事情：
- en: '[PRE162]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: By default, `create_rectangle` draws a one-pixel black border, which we don’t
    want for backgrounds, so make sure to pass `width=0`.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`create_rectangle`绘制一个一像素的黑色边框，这对于背景来说我们并不想要，所以请确保传递`width=0`。
- en: 'We still want to skip offscreen graphics commands, so let’s add a `bottom`
    field to `DrawText` so we know when to skip those:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然想要跳过屏幕外的图形命令，所以让我们给`DrawText`添加一个`bottom`字段，这样我们就可以知道何时跳过那些命令：
- en: '[PRE163]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The browser’s `draw` method now just uses `top` and `bottom` to decide which
    commands to `execute`:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的`draw`方法现在只使用`top`和`bottom`来决定要执行哪些命令：
- en: '[PRE164]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Try your browser on a page—maybe [this chapter’s](https://browser.engineering/layout.html)—with
    code snippets on it. You should see each code snippet set off with a gray background.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面上尝试你的浏览器——可能是[这一章的](https://browser.engineering/layout.html)——带有代码片段的页面。你应该看到每个代码片段都带有灰色背景。
- en: 'Here’s one more cute benefit of tree-based layout: we now record the height
    of the whole page. The browser can use that to avoid scrolling past the bottom:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 树状布局的一个额外好处是：我们现在记录了整个页面的高度。浏览器可以使用这个信息来避免滚动到底部：
- en: '[PRE165]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Note the `2*VSTEP`, to account for a `VSTEP` of whitespace at the top and bottom
    of the page. With layout the [browser.engineering homepage](https://browser.engineering/)
    now looks a bit better—see Figure 3.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`2*VSTEP`，这是为了考虑到页面顶部和底部的空白`VSTEP`。有了布局，[browser.engineering主页](https://browser.engineering/)现在看起来好一些——见图3。
- en: So those are the basics of tree-based layout! In fact, as we’ll see in the next
    two chapters, this is just one part of the layout tree’s central role in the browser.
    But before we get to that, we need to add some styling capabilities to our browser.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是树状布局的基本原理！实际上，正如我们将在下一章中看到的，这仅仅是布局树在浏览器中中心角色的一部分。但在我们到达那里之前，我们需要给我们的浏览器添加一些样式功能。
- en: '![Figure 3: https://browser.engineering/ viewed in this chapter’s version of
    the browser.](img/6e507bed699bc0a5f0826d45e78e0e78.png)'
  id: totrans-873
  prefs: []
  type: TYPE_IMG
  zh: '![图3：https://browser.engineering/ 在本章浏览器版本中查看](img/6e507bed699bc0a5f0826d45e78e0e78.png)'
- en: 'Figure 3: https://browser.engineering/ viewed in this chapter’s version of
    the browser.'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：https://browser.engineering/ 在本章浏览器版本中查看。
- en: The draft CSS [Painting API](https://developer.mozilla.org/en-US/docs/Web/API/CSS_Painting_API/Guide)
    allows pages to extend the display list with new types of commands, implemented
    in JavaScript. This makes it possible to use CSS for styling with visually complex
    styling provided by a library.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 草稿CSS [绘图API](https://developer.mozilla.org/en-US/docs/Web/API/CSS_Painting_API/Guide)
    允许页面通过在JavaScript中实现的新类型命令扩展显示列表。这使得可以使用CSS进行样式化，并使用由库提供的视觉复杂样式。
- en: Summary
  id: totrans-876
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter was a dramatic rewrite of our browser’s layout engine, so:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对我们浏览器布局引擎的彻底重写，因此：
- en: layout is now tree-based and produces a *layout tree*;
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局现在是基于树的，并生成一个*布局树*；
- en: each node in the tree has one of two different *layout modes*;
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树中的每个节点都有两种不同的*布局模式*之一；
- en: layout computes a size and position for each layout object;
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局计算每个布局对象的大小和位置；
- en: the display list now contains generic commands;
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示列表现在包含通用命令；
- en: source code snippets now have backgrounds.
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码片段现在有背景。
- en: Tree-based layout makes it possible to dramatically expand our browser’s styling
    capabilities. We’ll work on that in the [next chapter](styles.html).
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 基于树的布局使得可以显著扩展我们浏览器的样式化能力。我们将在[下一章](styles.html)中处理这个问题。
- en: '[widgets/lab5-browser.html](widgets/lab5-browser.html)'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '[widgets/lab5-browser.html](widgets/lab5-browser.html)'
- en: Outline
  id: totrans-885
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should look
    something like this:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整函数、类和方法集应该看起来像这样：
- en: '`` class URL: `def __init__(url)` `def request()` `` `` class Text: `def __init__(text,
    parent)` `def __repr__()` `` `` class Element: `def __init__(tag, attributes,
    parent)` `def __repr__()` `` `def print_tree(node, indent)` `` class HTMLParser:
    `SELF_CLOSING_TAGS` `HEAD_TAGS` `def __init__(body)` `def parse()` `def get_attributes(text)`
    `def add_text(text)` `def add_tag(tag)` `def implicit_tags(tag)` `def finish()`
    `` `FONTS` `def get_font(size, weight, style)` `WIDTH, HEIGHT` `HSTEP, VSTEP`
    `BLOCK_ELEMENTS` `` class DocumentLayout: `def __init__(node)` `def layout()`
    `def paint()` `` `` class BlockLayout: `def __init__(node, parent, previous)`
    `def layout_mode()` `def layout()` `def recurse(tree)` `def open_tag(tag)` `def
    close_tag(tag)` `def flush()` `def word(word)` `def paint()` `` `` class DrawText:
    `def __init__(x1, y1, text, font)` `def execute(scroll, canvas)` `` `` class DrawRect:
    `def __init__(x1, y1, x2, y2, color)` `def execute(scroll, canvas)` `` `def paint_tree(layout_object,
    display_list)` `SCROLL_STEP` `` class Browser: `def __init__()` `def draw()` `def
    load(url)` `def scrolldown(e)` ``'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '`` class URL: `def __init__(url)` `def request()` `` `` class Text: `def __init__(text,
    parent)` `def __repr__()` `` `` class Element: `def __init__(tag, attributes,
    parent)` `def __repr__()` `` `def print_tree(node, indent)` `` class HTMLParser:
    `SELF_CLOSING_TAGS` `HEAD_TAGS` `def __init__(body)` `def parse()` `def get_attributes(text)`
    `def add_text(text)` `def add_tag(tag)` `def implicit_tags(tag)` `def finish()`
    `` `FONTS` `def get_font(size, weight, style)` `WIDTH, HEIGHT` `HSTEP, VSTEP`
    `BLOCK_ELEMENTS` `` class DocumentLayout: `def __init__(node)` `def layout()`
    `def paint()` `` `` class BlockLayout: `def __init__(node, parent, previous)`
    `def layout_mode()` `def layout()` `def recurse(tree)` `def open_tag(tag)` `def
    close_tag(tag)` `def flush()` `def word(word)` `def paint()` `` `` class DrawText:
    `def __init__(x1, y1, text, font)` `def execute(scroll, canvas)` `` `` class DrawRect:
    `def __init__(x1, y1, x2, y2, color)` `def execute(scroll, canvas)` `` `def paint_tree(layout_object,
    display_list)` `SCROLL_STEP` `` class Browser: `def __init__()` `def draw()` `def
    load(url)` `def scrolldown(e)` ``'
- en: Exercises
  id: totrans-888
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 5-1 *Links bar*. At the top and bottom of the web version of each chapter of
    this book there is a gray bar naming the chapter and offering back and forward
    links. It is enclosed in a `<nav class="links">` tag. Have your browser give this
    links bar the light gray background a real browser would.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 5-1 *链接栏*. 在本书每一章的网页版顶部和底部都有一个灰色栏，标明章节并提供前后链接。它被`<nav class="links">`标签包围。让您的浏览器为这个链接栏提供浅灰色背景，就像真实浏览器一样。
- en: 5-2 *Hidden head*. There’s a good chance your browser is still showing scripts,
    styles, and page titles at the top of every page you visit. Make it so that the
    `<head>` element and its contents are never displayed. Those elements should still
    be in the HTML tree, but not in the layout tree.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 5-2 *隐藏头部*. 很有可能您的浏览器仍然在每个访问的页面的顶部显示脚本、样式和页面标题。让它这样，`<head>`元素及其内容永远不会显示。这些元素仍然在HTML树中，但不在布局树中。
- en: 5-3 *Bullets*. Add bullets to list items, which in HTML are `<li>` tags. You
    can make them little squares, located to the left of the list item itself. Also
    indent `<li>` elements so the text inside the element is to the right of the bullet
    point.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 5-3 *项目符号*. 向列表项添加项目符号，在HTML中是`<li>`标签。您可以将其设置为位于列表项本身左侧的小方块。同时缩进`<li>`元素，使元素内的文本位于项目符号右侧。
- en: 5-4 *Table of contents*. The web version of this book has a table of contents
    at the top of each chapter, enclosed in a `<nav id="toc">` tag, which contains
    a list of links. Add the text “Table of Contents”, with a gray background, above
    that list. Don’t modify the lexer or parser.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 5-4 *目录表*。这本书的网页版本在每个章节的顶部都有一个目录表，包含在`<nav id="toc">`标签中，其中包含一个链接列表。在该列表上方添加“目录表”，并带有灰色背景。不要修改词法分析器或解析器。
- en: 5-5 *Anonymous block boxes*. Sometimes, an element has a mix of text-like and
    container-like children. For example, in this HTML,
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 5-5 *匿名块级框*。有时，一个元素会有文本类和容器类子元素混合。例如，在这个HTML中，
- en: '[PRE166]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'the `<div>` element has three children: the `<i>`, `<b>`, and `<p>` elements.
    The first two are text-like; the last is container-like. This is supposed to look
    like two paragraphs, one for the `<i>` and `<b>` and the second for the `<p>`.
    Make your browser do that. Specifically, modify `BlockLayout` so it can be passed
    a sequence of sibling nodes, instead of a single node. Then, modify the algorithm
    that constructs the layout tree so that any sequence of text-like elements gets
    made into a single `BlockLayout`.'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div>`元素有三个子元素：`<i>`、`<b>`和`<p>`元素。前两个是文本类；最后一个是容器类。这应该看起来像两个段落，一个用于`<i>`和`<b>`，另一个用于`<p>`。让你的浏览器这样做。具体来说，修改`BlockLayout`使其可以传递一个兄弟节点序列，而不是单个节点。然后，修改构建布局树的算法，以便任何文本类元素的序列都被转换成一个单独的`BlockLayout`。'
- en: '5-6 *Run-ins*. A “run-in heading” is a heading that is drawn as part of the
    next paragraph’s text.The exercise names in this section could be considered run-in
    headings. But since browser support for the `display: run-in` property [is poor](https://caniuse.com/run-in),
    this book actually doesn’t use it; the headings are actually embedded in the next
    paragraph. Modify your browser to render `<h6>` elements as run-in headings. You’ll
    need to implement the previous exercise on anonymous block boxes, and then add
    a special case for `<h6>` elements.'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '5-6 *嵌入手*。一个“嵌入手标题”是一个作为下一个段落文本一部分绘制的标题。本节中的练习名称可以被认为是嵌入手标题。但由于浏览器对`display:
    run-in`属性的[支持度较低](https://caniuse.com/run-in)，这本书实际上没有使用它；标题实际上是嵌入在下一段落中的。修改你的浏览器以将`<h6>`元素渲染为嵌入手标题。你需要实现之前的匿名块级框练习，然后为`<h6>`元素添加一个特殊案例。'
- en: Applying Author Styles
  id: totrans-897
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用作者样式
- en: Chapter 6 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '[Web浏览器工程](./index.html "目录")的第六章。'
- en: '[Parsing with Functions](#parsing-with-functions)'
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用函数解析](#parsing-with-functions)'
- en: '[The `style` Attribute](#the-style-attribute)'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[样式属性](#the-style-attribute)'
- en: '[Selectors](#selectors)'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[选择器](#selectors)'
- en: '[Applying Style Sheets](#applying-style-sheets)'
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[应用样式表](#applying-style-sheets)'
- en: '[Cascading](#cascading)'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[层叠](#cascading)'
- en: '[Inherited styles](#inherited-styles)'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[继承样式](#inherited-styles)'
- en: '[Font Properties](#font-properties)'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字体属性](#font-properties)'
- en: '[Summary](#summary)'
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[摘要](#summary)'
- en: '[Outline](#outline)'
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大纲](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: In the [previous chapter](layout.html) we gave each `pre` element a gray background.
    It looks OK, and it *is* good to have defaults, but sites want a say in how they
    look. Websites do that with *Cascading Style Sheets* ([CSS](https://developer.mozilla.org/en-US/docs/Web/CSS)),
    which allow web authors (and, as we’ll see, browser developers) to define how
    a web page ought to look.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 在[上一章](layout.html)中，我们给每个`pre`元素添加了灰色背景。看起来不错，并且有默认值是好的，但网站希望有自己的外观。网站通过*层叠样式表*（[CSS](https://developer.mozilla.org/en-US/docs/Web/CSS)）来实现这一点，它允许网页作者（以及我们将看到的浏览器开发者）定义网页应该如何看起来。
- en: Parsing with Functions
  id: totrans-910
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数解析
- en: 'One way a web page can change its appearance is with the `style` attribute.
    For example, this changes an element’s background color:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 网页改变外观的一种方式是使用`style`属性。例如，这会改变元素的背景颜色：
- en: '[PRE167]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'And it renders like this:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 它渲染如下：
- en: Blue background
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色背景
- en: More generally, a `style` attribute contains property–value pairs separated
    by semicolons. The browser looks at those CSS property–value pairs to determine
    how an element looks, for example to determine its background color.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，一个`style`属性包含由分号分隔的属性-值对。浏览器查看这些CSS属性-值对以确定元素的外观，例如确定其背景颜色。
- en: 'To add this to our browser, we’ll need to start by parsing these property–value
    pairs. I’ll use recursive *parsing functions*, which are a good way to build a
    complex parser step by step. The idea is that each parsing function advances through
    the text being parsed and returns the data it parsed. We’ll have different functions
    for different types of data, and organize them in a `CSSParser` class that stores
    the text being parsed and the parser’s current position in it:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个添加到我们的浏览器中，我们首先需要解析这些属性-值对。我将使用递归解析函数，这是一种逐步构建复杂解析器的好方法。想法是每个解析函数都会通过正在解析的文本并返回它解析的数据。我们将有不同的函数来处理不同类型的数据，并将它们组织在一个`CSSParser`类中，该类存储正在解析的文本和解析器在其中的当前位置：
- en: '[PRE168]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Let’s start small and build up. A parsing function for whitespace increments
    the index `i` past every whitespace character:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单开始，逐步构建。一个解析空白字符的函数将索引`i`增加到每个空白字符之后：
- en: '[PRE169]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Whitespace is meaningless, so there’s no parsed data to return. But when we
    parse property names, we’ll want to return them:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 空白字符没有意义，所以没有解析后的数据可以返回。但是，当我们解析属性名时，我们希望返回它们：
- en: '[PRE170]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This function increments `i` through any word characters,I’ve chosen the set
    of word characters here to cover property names (which use letters and the dash),
    numbers (which use the minus sign, numbers, periods), units (the percent sign),
    and colors (which use the hash sign). Real CSS values have a more complex syntax
    but this is enough for our browser. much like `whitespace`. But to return the
    parsed data, it stores where it started and extracts the substring it moved through.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通过任何单词字符增加`i`，我在这里选择的单词字符集合是为了覆盖属性名（使用字母和破折号），数字（使用减号、数字、点），单位（百分号），以及颜色（使用井号）。真实的CSS值有更复杂的语法，但这对我们的浏览器来说已经足够了，就像`whitespace`。但是，为了返回解析后的数据，它存储了开始的位置并提取了它移动过的子字符串。
- en: 'Parsing functions can fail. The `word` function we just wrote raises an exception
    if `i` hasn’t advanced through at least one character—otherwise it didn’t point
    at a word to begin with.You can add error text to the exception-raising code,
    too; I recommend doing that to help you debug problems. Likewise, to check for
    a literal colon (or some other punctuation character) you’d do this:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 解析函数可能会失败。我们刚刚编写的`word`函数如果`i`没有至少前进一个字符，就会引发异常——否则它一开始就没有指向一个单词。你还可以在引发异常的代码中添加错误文本；我建议这样做以帮助你调试问题。同样，为了检查一个字面冒号（或某些其他标点符号），你会这样做：
- en: '[PRE171]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'The great thing about parsing functions is that they can build on one another.
    For example, property–value pairs are a property, a colon, and a value,In reality,
    properties and values have different syntaxes, so using `word` for both isn’t
    quite right, but for our browser’s limited CSS implementation this simplification
    will do. with whitespace in between:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 解析函数的伟大之处在于它们可以相互构建。例如，属性-值对是一个属性，一个冒号，和一个值，实际上属性和值有不同的语法，所以使用`word`对两者来说并不完全正确，但对我们浏览器有限的CSS实现来说，这种简化将足够。它们之间有空白：
- en: '[PRE172]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'We can parse sequences by calling parsing functions in a loop. For example,
    `style` attributes are a sequence of property–value pairs:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过循环调用解析函数来解析序列。例如，`style`属性是一系列属性-值对：
- en: '[PRE173]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Now, in a browser, we always have to think about handling errors. Sometimes
    a web page author makes a mistake; sometimes our browser doesn’t support a feature
    some other browser does. So we should skip property–value pairs that don’t parse,
    but keep the ones that do.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中，我们总是必须考虑处理错误。有时网页作者犯了一个错误；有时我们的浏览器不支持某些其他浏览器支持的功能。因此，我们应该跳过无法解析的属性-值对，但保留可以解析的。
- en: 'We can skip things with this little function; it stops at any one of a set
    of characters and returns that character (or `None` if it was stopped by the end
    of the file):'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个小程序跳过一些东西；它会在一组字符中的任何一个上停止并返回该字符（如果它被文件的末尾停止，则返回`None`）：
- en: '[PRE174]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'When we fail to parse a property–value pair, we skip either to the next semicolon
    or to the end of the string:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们无法解析属性-值对时，我们会跳到下一个分号或字符串的末尾：
- en: '[PRE175]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Skipping parse errors is a double-edged sword. It hides error messages, making
    it harder for authors to debug their style sheets; it also makes it harder to
    debug your parser.I suggest removing the `try` block when debugging. So in most
    programming situations this “catch-all” error handling is a code smell.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过解析错误是一把双刃剑。它隐藏了错误消息，使得作者更难调试他们的样式表；它也使得调试你的解析器更难。我建议在调试时移除`try`块。所以，在大多数编程情况下，这种“通用的”错误处理是一种代码异味。
- en: 'But “catch-all” error handling has an unusual benefit on the web. The web is
    an ecosystem of many browsers,And an ecosystem of many browser versions, some
    of which haven’t been written yet—but need to be supported as best we can. which
    (for example) support different kinds of property values.Our browser does not
    support parentheses in property values, for example, which real browsers use for
    things like the `calc` and `url` functions. CSS that parses in one browser might
    not parse in another. With silent parse errors, browsers just ignore stuff they
    don’t understand, and web pages mostly work in all of them. The principle (variously
    called “Postel’s Law”,After a line in the specification of TCP, written by Jon
    Postel. the “Digital Principle”,After a similar idea in circuit design, where
    transistors must be non-linear to reduce analog noise. or the “Robustness Principle”)
    is: produce maximally conformant output but accept even minimally conformant input.'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，“万能”的错误处理在网络上有一个不寻常的好处。网络是一个由许多浏览器组成的生态系统，以及许多浏览器版本组成的生态系统，其中一些尚未编写，但我们需要尽可能支持。例如，它们支持不同类型的属性值。我们的浏览器不支持属性值中的括号，例如，真实浏览器使用括号来处理`calc`和`url`函数等。在一种浏览器中解析的CSS可能在另一种浏览器中无法解析。这种原则（被称为“Postel定律”，源自TCP规范中的一行，由Jon
    Postel编写；“数字原则”，源自电路设计中的一个类似想法，在那里晶体管必须是非线性的以减少模拟噪声；“鲁棒性原则”）是：产生最大限度的符合性输出，但接受即使是最低限度的符合性输入。
- en: This parsing method is formally called recursive descent parsing for an [LL(1)](https://en.wikipedia.org/wiki/LL_parser)
    language. Parsers that use this method can be [really, really fast](https://simdjson.org/),
    at least if you put a lot of work into it. In a browser, faster parsing means
    pages load faster.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解析方法在形式上被称为LL(1)语言的递归下降解析。使用这种方法的解析器可以[真的，真的很快](https://simdjson.org/)，至少如果你投入大量工作的话。在浏览器中，更快的解析意味着页面加载更快。
- en: The `style` Attribute
  id: totrans-937
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`style`属性'
- en: 'Now that the `style` attribute is parsed, we can use that parsed information
    in the rest of the browser. Let’s do that inside a `style` function, which saves
    the parsed `style` attribute in the node’s `style` field:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然已经解析了`style`属性，我们就可以在浏览器中使用这些解析信息。让我们在一个`style`函数中这样做，它将解析的`style`属性存储在节点的`style`字段中：
- en: '[PRE176]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'The method can recurse through the HTML tree to make sure each element gets
    a style:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法可以通过HTML树递归，以确保每个元素都获得一个样式：
- en: '[PRE177]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Call `style` in the browser’s `load` method, after parsing the HTML but before
    doing layout. With the `style` information stored on each element, the browser
    can consult it for styling information during paint:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析HTML之后但在布局之前，在浏览器的`load`方法中调用`style`。有了存储在每个元素上的`style`信息，浏览器可以在绘制时咨询它以获取样式信息：
- en: '[PRE178]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: I’ve removed the default gray background from `pre` elements for now, but we’ll
    put it back soon.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在已经从`pre`元素中移除了默认的灰色背景，但我们很快会将其恢复。
- en: 'Open [the web version of this chapter](https://browser.engineering/styles.html)
    up in your browser to test your code: the code block at the start of the chapter
    should now have a light blue background.'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开[本章的网络版本](https://browser.engineering/styles.html)以测试你的代码：章节开头的代码块现在应该有一个浅蓝色背景。
- en: 'So this is one way web pages can change their appearance. And in the early
    days of the web,I’m talking Netscape 3\. The late 1990s. something like this was
    the *only* way. But honestly, it’s a pain—you need to set a `style` attribute
    on each element, and if you redesign the page, that’s a lot of attributes to edit.
    CSS was invented to improve on this state of affairs:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是网页可以改变外观的一种方式。在网络的早期，我指的是Netscape 3。20世纪90年代末。类似的东西是*唯一*的方式。但说实话，这很痛苦——你需要为每个元素设置`style`属性，如果你重新设计页面，那么需要编辑很多属性。CSS就是为了改进这种状况而发明的：
- en: One CSS file can consistently style many web pages at once.
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个CSS文件可以一次性持续地美化许多网页。
- en: One line of CSS can consistently style many elements at once.
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行CSS可以一次性持续地美化许多元素。
- en: CSS is future-proof and supports browsers with different features.
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS具有前瞻性，并支持具有不同功能的浏览器。
- en: 'To achieve these goals, CSS extends the `style` attribute with two related
    ideas: *selectors* and *cascading*. Selectors describe which HTML elements a list
    of property–value pairs apply to.CSS rules can also be guarded by “media queries”,
    which say that a rule should apply only in certain browsing environments (like
    only on mobile or only in landscape mode). Media queries are super-important for
    building sites that work across many devices, like reading this book on a phone.
    We’ll meet them in [Chapter 14](accessibility.html). The combination of the two
    is called a *rule*, as shown in Figure 1.'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些目标，CSS通过两个相关概念扩展了`style`属性：*选择器*和*层叠*。选择器描述了哪些HTML元素应用了一个属性值对的列表。CSS规则也可以通过“媒体查询”来保护，这意味着规则只应在某些浏览环境中应用（例如只在移动设备上或只在横屏模式下）。媒体查询对于构建适用于许多设备的网站非常重要，比如在手机上阅读这本书。我们将在[第14章](accessibility.html)中遇到它们。这两个的结合称为*规则*，如图1所示。
- en: '![Figure 1: An annotated CSS rule.](img/174f61515be12142cdda02c804c5da86.png)'
  id: totrans-951
  prefs: []
  type: TYPE_IMG
  zh: '![图1：一个注释的CSS规则。](img/174f61515be12142cdda02c804c5da86.png)'
- en: 'Figure 1: An annotated CSS rule.'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：一个注释的CSS规则。
- en: Let’s add support for CSS to our browser. We’ll need to parse CSS files into
    selectors and property–value pairs, figure out which elements on the page match
    each selector, and copy those property values to the elements’ `style` fields.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的浏览器添加对CSS的支持。我们需要将CSS文件解析为选择器和属性值对，找出页面上哪些元素匹配每个选择器，并将这些属性值复制到元素的`style`字段中。
- en: Actually, before CSS, you’d style pages with custom *presentational tags* like
    [`font`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/font) and [`center`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/center)
    (not to mention the `<b>` and `<i>` tags that we’ve already seen). This was easy
    to implement but made it hard to keep pages consistent. There were also properties
    on `<body>` like [`text` and `vlink`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body#attributes)
    that could consistently set text colors, mainly for links.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在CSS之前，你会用自定义的*表现性标签*来设置页面样式，比如`[font](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/font)`和`[center](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/center)`（更不用说我们已经见过的`<b>`和`<i>`标签了）。这很容易实现，但使得保持页面一致性变得困难。还有`<body>`上的属性，如`[text](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body#attributes)`和`[vlink](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body#attributes)`，可以一致地设置文本颜色，主要是用于链接。
- en: Selectors
  id: totrans-955
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择器
- en: 'Selectors come in lots of types, but in our browser we’ll support two: tag
    selectors (`p` selects all `<p>` elements, `ul` selects all `<ul>` elements) and
    descendant selectors (`article div` selects all `div` elements with an `article`
    ancestor).The descendant selector associates to the left; in other words, `a b
    c` means a `<c>` that descends from a `<b>` that descends from an `<a>`, which
    maybe you’d write `(a b) c` if CSS had parentheses.'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器有很多类型，但在我们的浏览器中我们将支持两种：标签选择器（`p`选择所有`<p>`元素，`ul`选择所有`<ul>`元素）和后代选择器（`article
    div`选择所有具有`article`祖先的`div`元素）。后代选择器与左侧关联；换句话说，`a b c`意味着一个从`<b>`派生出来的`<c>`，而`<b>`又从`<a>`派生出来，如果你用CSS有括号，你可能会写成`(a
    b) c`。
- en: 'We’ll have a class for each type of selector to store the selector’s contents,
    like the tag name for a tag selector:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每种选择器类型创建一个类来存储选择器的内容，比如标签名对于标签选择器：
- en: '[PRE179]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Each selector class will also test whether the selector matches an element:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选择器类也会测试选择器是否匹配一个元素：
- en: '[PRE180]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'A descendant selector works similarly. It has two parts, which are both themselves
    selectors:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 一个后代选择器的工作方式类似。它有两个部分，这两个部分本身也是选择器：
- en: '[PRE181]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Then the `matches` method is recursive:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`matches`方法也是递归的：
- en: '[PRE182]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Now, to create these selector objects, we need a parser. In this case, that’s
    just another parsing function:Once again, using `word` here for tag names is actually
    not quite right, but it’s close enough. One side effect of using `word` is that
    a class name selector (like `.main`) or an identifier selector (like `#signup`)
    is mis-parsed as a tag name selector. But, luckily, that won’t cause any harm
    since there aren’t any elements with those tags.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了创建这些选择器对象，我们需要一个解析器。在这种情况下，这只是一个另一个解析函数：再次使用`word`作为标签名实际上并不完全正确，但足够接近。使用`word`的一个副作用是，一个类名选择器（如`.main`）或一个标识符选择器（如`#signup`）会被错误地解析为标签名选择器。但幸运的是，这不会造成任何伤害，因为没有任何元素具有这些标签。
- en: '[PRE183]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'A CSS file is just a sequence of selectors and blocks:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 一个CSS文件只是一个选择器和块的序列：
- en: '[PRE184]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Once again, let’s pause to think about error handling. First, when we call
    `body` while parsing CSS, we need it to stop when it reaches a closing brace:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们停下来思考错误处理。首先，当我们解析CSS时调用`body`，我们需要它在遇到闭合括号时停止：
- en: '[PRE185]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Second, there might also be a parse error while parsing a selector. In that
    case, we want to skip the whole rule:'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，解析选择器时可能也会出现解析错误。在这种情况下，我们希望跳过整个规则：
- en: '[PRE186]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Error handling is hard to get right, so make sure to test your parser, just
    like the HTML parser in [Chapter 4](html.html). Here are some errors you might
    run into:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理很难做到正确，所以请确保测试你的解析器，就像第4章中的HTML解析器。以下是一些你可能遇到的错误：
- en: If the output is missing some rules or properties, it’s probably a bug being
    hidden by error handling. Remove some `try` blocks and see if the error in question
    can be fixed.
  id: totrans-974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输出中缺少一些规则或属性，这可能是被错误处理隐藏的漏洞。移除一些`try`块，看看是否可以修复相关错误。
- en: If you’re seeing extra rules or properties that are mangled versions of the
    correct ones, you probably forgot to update `i` somewhere.
  id: totrans-975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你看到额外的规则或属性，它们是正确版本的混乱版本，那么你可能忘记在某处更新了`i`。
- en: If you’re seeing an infinite loop, check whether the error-handling code always
    increases `i`. Each parsing function (except `whitespace`) should always increment
    `i`.
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你看到无限循环，检查错误处理代码是否总是增加`i`。每个解析函数（除了`whitespace`）都应该始终增加`i`。
- en: You can also add a `print` statement to the start and endIf you print an open
    parenthesis at the start of the function and a close parenthesis at the end, you
    can use your editor’s “jump to other parenthesis” feature to skip through output
    quickly. of each parsing function with the name of the parsing function,If you
    also add the right number of spaces to each line it’ll be a lot easier to read.
    Don’t neglect debugging niceties like this! the index `i`,It can be especially
    helpful to print, say, the 20 characters around index `i` from the string. and
    the parsed data. It’s a lot of output, but it’s a sure-fire way to find really
    complicated bugs.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在每个解析函数的开始和结束处添加一个`print`语句，用解析函数的名字命名，如果你也给每一行添加正确数量的空格，那么阅读起来会容易得多。不要忽视像这样的调试细节！索引`i`，它可能特别有助于打印，比如说，从字符串中索引`i`周围的20个字符。以及解析数据。这是一大堆输出，但这是找到真正复杂错误的有效方法。
- en: A parser receives arbitrary bytes as input, so parser bugs are usually easy
    for bad actors to exploit. Parser correctness is thus crucial to browser security,
    as [many](https://nvd.nist.gov/vuln/detail/CVE-2010-3971) [parser](https://nvd.nist.gov/vuln/detail/CVE-2007-0943)
    [bugs](https://nvd.nist.gov/vuln/detail/CVE-2010-1663) have demonstrated. Nowadays
    browser developers use [fuzzing](https://hacks.mozilla.org/2021/02/browser-fuzzing-at-mozilla/)
    to try to find and fix such bugs.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器接收任意字节作为输入，因此解析器漏洞通常容易被恶意行为者利用。因此，解析器的正确性对浏览器安全至关重要，正如许多[解析器漏洞](https://nvd.nist.gov/vuln/detail/CVE-2010-3971)、[解析器漏洞](https://nvd.nist.gov/vuln/detail/CVE-2007-0943)和[解析器漏洞](https://nvd.nist.gov/vuln/detail/CVE-2010-1663)所证明的那样。如今，浏览器开发者使用[fuzzing](https://hacks.mozilla.org/2021/02/browser-fuzzing-at-mozilla/)来尝试寻找和修复此类漏洞。
- en: Applying Style Sheets
  id: totrans-979
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用样式表
- en: 'With the parser debugged, the next step is applying the parsed style sheet
    to the web page. Since each CSS rule can style many elements on the page, this
    will require looping over all elements *and* all rules. When a rule applies, its
    property–value pairs are copied to the element’s style information:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析器调试完成后，下一步是将解析的样式表应用到网页上。由于每个CSS规则可以样式化页面上的许多元素，这将需要遍历所有元素和所有规则。当规则应用时，其属性-值对被复制到元素的样式信息中：
- en: '[PRE187]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Make sure to put this loop before the one that parses the `style` attribute:
    the `style` attribute should override style sheet values.'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将此循环放在解析`style`属性的循环之前：`style`属性应该覆盖样式表值。
- en: 'To try this out, we’ll need a style sheet. Every browser ships with a *browser
    style sheet*,Technically called a “user agent” style sheet. User agent, like the
    Memex. which defines its default styling for the various HTML elements. For our
    browser, it might look like this:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个，我们需要一个样式表。每个浏览器都附带一个*浏览器样式表*，技术上称为“用户代理”样式表。用户代理，就像Memex一样，为各种HTML元素定义了默认样式。对于我们浏览器来说，它可能看起来像这样：
- en: '[PRE188]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Let’s store that in a new file, `browser.css`, and have our browser read it
    when it starts:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将它存储在一个新文件中，名为`browser.css`，并在浏览器启动时读取它：
- en: '[PRE189]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Now, when the browser loads a web page, it can apply that default style sheet
    to set up its default styling for each element:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当浏览器加载网页时，它可以应用默认样式表来为每个元素设置其默认样式：
- en: '[PRE190]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'The browser style sheet is the default for the whole web. But each web site
    can also use CSS to set a consistent style for the whole site by referencing CSS
    files using `link` elements:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器样式表是整个网络的默认样式。但每个网站也可以通过使用`link`元素引用CSS文件来使用CSS设置整个站点的统一样式：
- en: '[PRE191]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: The mandatory `rel` attribute identifies this link as a style sheetFor browsers,
    `stylesheet` is the most important [kind of link](https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types),
    but there’s also `preload` for loading assets that a page will use later and `icon`
    for identifying favicons. Search engines also use these links; for example, `rel=canonical`
    names the “true name” of a page and search engines use it to track pages that
    appear at multiple URLs. and the `href` attribute has the style sheet URL. We
    need to find all these links, download their style sheets, and apply them, as
    in Figure 2.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 强制的`rel`属性将此链接标识为样式表。对于浏览器来说，`stylesheet`是最重要的[链接类型](https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types)，但还有`preload`用于加载页面稍后将要使用的资源，以及`icon`用于识别favicon。搜索引擎也会使用这些链接；例如，`rel=canonical`命名了页面的“真实名称”，搜索引擎使用它来跟踪出现在多个URL上的页面。`href`属性包含样式表的URL。我们需要找到所有这些链接，下载它们的样式表，并应用它们，如图2所示。
- en: '![Figure 2: A browser loading related assets, like a stylesheet, for a web
    page.](img/f95d426fcf0cf48e01aafe920fa6ff95.png)'
  id: totrans-992
  prefs: []
  type: TYPE_IMG
  zh: '![图2：浏览器为网页加载相关资源，如样式表。](img/f95d426fcf0cf48e01aafe920fa6ff95.png)'
- en: 'Figure 2: A browser loading related assets, like a stylesheet, for a web page.'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：浏览器为网页加载相关资源，如样式表。
- en: 'Since we’ll be doing similar tasks in the next few chapters, let’s generalize
    a bit and write a recursive function that turns a tree into a list of nodes:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在接下来的几章中执行类似的任务，让我们稍微泛化一下，并编写一个递归函数，将树转换为节点列表：
- en: '[PRE192]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: I’ve written this helper to work on both HTML and layout trees, for later. We
    can use `tree_to_list` with a Python list comprehension to grab the URL of each
    linked style sheet:It’s kind of crazy, honestly, that Python lets you write things
    like this—crazy, but very convenient!
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了这个辅助工具，以便将来在HTML和布局树上使用。我们可以使用`tree_to_list`和Python列表推导式来获取每个链接样式表的URL：坦白说，Python允许你编写这样的代码——虽然疯狂，但非常方便！
- en: '[PRE193]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Now, these style sheet URLs are usually not full URLs; they are something called
    *relative URLs*, which can be:There are other flavors, including query-relative,
    that I’m skipping.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些样式表URL通常是完整的URL；它们是被称为*相对URL*的东西，可以是：我跳过了其他一些口味。
- en: a normal URL, which specifies a scheme, host, path, and so on;
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常的URL，指定了方案、主机、路径等；
- en: a host-relative URL, which starts with a slash but reuses the existing scheme
    and host;
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个相对于主机的URL，以斜杠开头但重用现有的方案和主机；
- en: a path-relative URL, which doesn’t start with a slash and is resolved like a
    file name would be;
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个路径相关的URL，不以斜杠开头，就像文件名解析一样；
- en: a scheme-relative URL that starts with “`//`” followed by a full URL, which
    should use the existing scheme.
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个方案相关的URL，以“`//`”开头后跟一个完整URL，应该使用现有的方案。
- en: 'To download the style sheets, we’ll need to convert each relative URL into
    a full URL:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载样式表，我们需要将每个相对URL转换为完整URL：
- en: '[PRE194]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Also, because of the early web architecture, browsers are responsible for resolving
    parent directories (`..`) in relative URLs:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于早期网络架构，浏览器负责解析相对URL中的父目录（`..`）：
- en: '[PRE195]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Now the browser can request each linked style sheet and add its rules to the
    `rules` list:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 现在浏览器可以请求每个链接样式表，并将它的规则添加到`rules`列表中：
- en: '[PRE196]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The `try`/`except` ignores style sheets that fail to download, but it can also
    hide bugs in your code, so if something’s not right try removing it temporarily.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`except`会忽略下载失败的样式表，但它也可能隐藏你代码中的错误，所以如果有什么不对劲，尝试暂时移除它。'
- en: Each browser engine has its own browser style sheet ([Chromium](https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/html/resources/html.css),
    [WebKit](https://github.com/WebKit/WebKit/blob/main/Source/WebCore/css/html.css),
    [Gecko](https://searchfox.org/mozilla-central/source/layout/style/res/html.css)).
    [Reset style sheets](https://developer.mozilla.org/en-US/docs/Web/CSS/all) are
    often used to overcome any differences. This works because web page style sheets
    take precedence over the browser style sheet, just like in our browser, though
    real browsers [fiddle with priorities](https://www.w3.org/TR/2011/REC-CSS2-20110607/cascade.html#cascading-order)
    to make that happen.Our browser style sheet only has tag selectors in it, so just
    putting them first works well enough. But if the browser style sheet had any descendant
    selectors, we’d encounter bugs.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 每个浏览器引擎都有自己的浏览器样式表（[Chromium](https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/html/resources/html.css)，[WebKit](https://github.com/WebKit/WebKit/blob/main/Source/WebCore/css/html.css)，[Gecko](https://searchfox.org/mozilla-central/source/layout/style/res/html.css)）。[重置样式表](https://developer.mozilla.org/en-US/docs/Web/CSS/all)常用于克服任何差异。这之所以有效，是因为网页样式表优先于浏览器样式表，就像在我们的浏览器中一样，尽管真正的浏览器[调整优先级](https://www.w3.org/TR/2011/REC-CSS2-20110607/cascade.html#cascading-order)以实现这一点。我们的浏览器样式表只包含标签选择器，所以将它们放在前面就足够好了。但如果浏览器样式表有任何后代选择器，我们就会遇到错误。
- en: Cascading
  id: totrans-1011
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级联
- en: 'A web page can now have any number of style sheets applied to it. And since
    two rules can apply to the same element, rule order matters: it determines which
    rules take priority, and when one rule overrides another.'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 现在网页可以应用任意数量的样式表。由于两条规则可以应用于同一个元素，因此规则顺序很重要：它决定了哪些规则具有优先级，以及何时一条规则覆盖另一条。
- en: In CSS, the correct order is called *cascade order*, and it is based on the
    rule’s selector, with file order as a tie breaker. This system allows more specific
    rules to override more general ones, so that you can have a browser style sheet,
    a site-wide style sheet, and maybe a special style sheet for a specific web page,
    all co-existing.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中，正确的顺序被称为*级联顺序*，它基于规则的选择器，文件顺序作为决定性因素。这个系统允许更具体的规则覆盖更一般的规则，因此你可以有一个浏览器样式表、一个网站范围的样式表，也许还有一个特定网页的专用样式表，它们都可以共存。
- en: 'Since our browser only has tag selectors, cascade order just counts them:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的浏览器只有标签选择器，级联顺序只是计数：
- en: '[PRE197]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Then cascade order for rules is just those priorities:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，规则的级联顺序只是这些优先级：
- en: '[PRE198]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Now when we call `style`, we need to sort the rules, like this:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们调用`style`时，需要排序规则，如下所示：
- en: '[PRE199]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Note that before sorting `rules`, it is in file order. Python’s `sorted` function
    keeps the relative order of things with equal priority, so file order acts as
    a tie breaker, as it should.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在排序`rules`之前，它们是按文件顺序排列的。Python的`sorted`函数保持具有相同优先级的事物的相对顺序，因此文件顺序充当决定性因素，就像它应该做的那样。
- en: 'That’s it: we’ve added CSS to our web browser! I mean—for background colors.
    But there’s more to web design than that. For example, if you’re changing background
    colors you might want to change foreground colors as well—the CSS `color` property.
    But there’s a catch: `color` affects text, and there’s no way to select a text
    node. How can that work?'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：我们已经将CSS添加到我们的网络浏览器中！我的意思是——对于背景颜色。但网页设计不仅仅是这些。例如，如果你在更改背景颜色，你可能还想更改前景颜色——CSS的`color`属性。但是有一个问题：`color`影响文本，而且没有方法可以选中文本节点。这怎么可能工作？
- en: Web pages can also supply [alternative style sheets](https://developer.mozilla.org/en-US/docs/Web/CSS/Alternative_style_sheets),
    and some browsers provide (obscure) methods to switch from the default to an alternate
    style sheet. The CSS standard also allows for [user styles](https://userstyles.org)
    that set custom style sheets for websites, with a priority [between](https://www.w3.org/TR/css-cascade/#cascade-origin)
    browser and website-provided style sheets.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 网页还可以提供[备用样式表](https://developer.mozilla.org/en-US/docs/Web/CSS/Alternative_style_sheets)，并且一些浏览器提供了（不为人知的）方法从默认样式表切换到备用样式表。CSS标准还允许使用[用户样式](https://userstyles.org)，为网站设置自定义样式表，其优先级[介于](https://www.w3.org/TR/css-cascade/#cascade-origin)浏览器和网站提供的样式表之间。
- en: Inherited styles
  id: totrans-1023
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承样式
- en: The way text styles work in CSS is called *inheritance*. Inheritance means that
    if some node doesn’t have a value for a certain property, it uses its parent’s
    value instead. That includes text nodes. Some properties are inherited and some
    aren’t; it depends on the property. Background color isn’t inherited, but text
    color and other font properties are.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: CSS中文本样式的工作方式被称为*继承*。继承意味着如果一个节点没有某个属性的值，它将使用其父节点的值。这包括文本节点。某些属性是继承的，而某些属性不是；这取决于属性。背景颜色不继承，但文本颜色和其他字体属性是继承的。
- en: 'Let’s implement inheritance for four font properties: `font-size`, `font-style`
    (for `italic`), `font-weight` (for `bold`), and `color`:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现四个字体属性的继承：`font-size`、`font-style`（用于`italic`）、`font-weight`（用于`bold`）和`color`：
- en: '[PRE200]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'The values in this dictionary are each property’s defaults. We’ll then add
    the actual inheritance code to the `style` function. It has to come *before* the
    other loops, since explicit rules should override inheritance:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字典中的值是每个属性的默认值。然后我们将实际的继承代码添加到`style`函数中。它必须在其他循环之前进行，因为显式规则应该覆盖继承：
- en: '[PRE201]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Inheriting font size comes with a twist. Web pages can use percentages as font
    sizes: `h1 { font-size: 150% }` makes headings 50% bigger than the surrounding
    text. But what if you had, say, a `code` element inside an `h1` tag—would that
    inherit the `150%` value for `font-size`? Surely it shouldn’t be another 50% bigger
    than the rest of the heading text?'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '继承字体大小有一个小问题。网页可以使用百分比作为字体大小：`h1 { font-size: 150% }`会使标题比周围文本大50%。但如果你在`h1`标签内有一个`code`元素——它会继承`font-size`的`150%`值吗？显然，它不应该比标题文本的其他部分再大50%。'
- en: 'In fact, browsers resolve font size percentages to absolute pixel units before
    those values are inherited; it’s called a “computed style”.The full CSS standard
    is a bit more confusing: there are [specified, computed, used, and actual values](https://www.w3.org/TR/CSS2/cascade.html#value-stages),
    and they affect lots of CSS properties besides `font-size`. But we’re not implementing
    those other properties in this book.'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，浏览器在将这些值继承之前，会将字体大小百分比解析为绝对像素单位；这被称为“计算样式”。完整的CSS标准有点复杂：有[指定值、计算值、使用值和实际值](https://www.w3.org/TR/CSS2/cascade.html#value-stages)，并且它们会影响除了`font-size`之外的大量CSS属性。但我们在本书中不实现这些其他属性。
- en: '[PRE202]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Resolving percentage sizes has just one tricky edge case: percentage sizes
    for the root `html` element. In that case the percentage is relative to the default
    font size:This code has to parse and unparse font sizes because our `style` field
    stores strings; in a real browser the computed style is stored parsed so this
    doesn’t have to happen.'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 解析百分比大小只有一个棘手的边缘情况：根`html`元素的百分比大小。在这种情况下，百分比是相对于默认字体大小的：这段代码必须解析和解析字体大小，因为我们的`style`字段存储字符串；在真实浏览器中，计算样式是解析存储的，因此不需要发生这种情况。
- en: '[PRE203]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Note that this happens after all of the different sources of style values are
    handled (so we are working with the final `font-size` value) but before we recurse
    (so any children can assume that their parent’s `font-size` has been resolved
    to a pixel value).
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这发生在处理了所有不同来源的样式值之后（因此我们正在处理最终的`font-size`值），但在我们递归之前（因此任何子元素都可以假设其父元素的`font-size`已经被解析为像素值）。
- en: Styling a page can be slow, so real browsers apply tricks like [bloom filters](https://bugs.webkit.org/show_bug.cgi?id=53880)
    for descendant selectors, [indices](https://source.chromium.org/chromium/chromium/src/+/refs/tags/93.0.4532.3:third_party/blink/renderer/core/css/style-calculation.md)
    for simple selectors, and various forms of [sharing](https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/)
    and [parallelism](https://blog.rust-lang.org/2017/11/14/Fearless-Concurrency-In-Firefox-Quantum.html).
    Some types of sharing are also important to reduce memory usage—computed style
    sheets can be huge!
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 对页面进行样式化可能会很慢，因此真实浏览器会应用一些技巧，如对后代选择器使用[bloom filters](https://bugs.webkit.org/show_bug.cgi?id=53880)，对简单选择器使用[indices](https://source.chromium.org/chromium/chromium/src/+/refs/tags/93.0.4532.3:third_party/blink/renderer/core/css/style-calculation.md)，以及各种形式的[共享](https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/)和[并行处理](https://blog.rust-lang.org/2017/11/14/Fearless-Concurrency-In-Firefox-Quantum.html)。某些类型的共享对于减少内存使用也很重要——计算样式表可能非常大！
- en: Font Properties
  id: totrans-1036
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字体属性
- en: 'So now with all these font properties implemented, let’s change layout to use
    them! That will let us move our default text styles to the browser style sheet:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经实现了所有这些字体属性，让我们改变布局以使用它们！这将使我们能够将默认文本样式移动到浏览器样式表中：
- en: '[PRE204]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'The browser looks up font information in `BlockLayout`’s `word` method; we’ll
    need to change it to use the node’s `style` field, and for that, we’ll need to
    pass in the node itself:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器在`BlockLayout`的`word`方法中查找字体信息；我们需要将其更改为使用节点的`style`字段，为此，我们需要传递节点本身：
- en: '[PRE205]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Note that for `font-style` we need to translate CSS “normal” to Tk “roman” and
    for `font-size` we need to convert CSS pixels to Tk points.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于`font-style`，我们需要将CSS中的“normal”翻译为Tk中的“roman”，对于`font-size`，我们需要将CSS像素转换为Tk点。
- en: 'Text color requires a bit more plumbing. First, we have to read the color and
    store it in the current `line`:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 文本颜色需要一些额外的配置。首先，我们必须读取颜色并将其存储在当前的`line`中：
- en: '[PRE206]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'The `flush` method then copies it from `line` to `display_list`:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`flush`方法将其从`line`复制到`display_list`：
- en: '[PRE207]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'That `display_list` is converted to drawing commands in `paint`:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`display_list`在`paint`中转换为绘图命令：
- en: '[PRE208]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '`DrawText` now needs a `color` argument, and needs to pass it to `create_text`’s
    `fill` parameter:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawText`现在需要一个`color`参数，并且需要将其传递给`create_text`的`fill`参数：'
- en: '[PRE209]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Phew! That was a lot of coordinated changes, so test everything and make sure
    it works. You should now see links on the [web version of this chapter](https://browser.engineering/styles.html)
    appear in blue—and you might also notice that the rest of the text has become
    slightly lighter.The main body text on the web is colored `#333`, or roughly 97%
    black after [gamma correction](https://en.wikipedia.org/wiki/SRGB#From_sRGB_to_CIE_XYZ).
    Also, now that we’re explicitly setting the text color, we should explicitly set
    the background color as well:My Linux machine sets the default background color
    to a light gray, while my macOS laptop has a “Dark Mode” where the default background
    color becomes a dark gray. Setting the background color explicitly avoids the
    browser looking strange in these situations.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼！这是一系列协调的更改，所以测试一切并确保它们能正常工作。你现在应该能看到在[本章的网页版本](https://browser.engineering/styles.html)上的链接以蓝色显示——你可能也会注意到文本的其他部分变得稍微浅了一些。网页上的正文颜色为`#333`，或者经过[伽马校正](https://en.wikipedia.org/wiki/SRGB#From_sRGB_to_CIE_XYZ)后大约是97%的黑色。此外，既然我们已经明确设置了文本颜色，我们也应该明确设置背景颜色：我的Linux机器将默认背景颜色设置为浅灰色，而我的macOS笔记本电脑有“暗黑模式”，其中默认背景颜色变为深灰色。明确设置背景颜色可以避免在这些情况下浏览器看起来很奇怪。
- en: '[PRE210]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'These changes obsolete all the code in `BlockLayout` that handles specific
    tags, like the `style`, `weight`, and `size` properties and the `open_tag` and
    `close_tag` methods. Let’s refactor a bit to get rid of them:'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改使`BlockLayout`中处理特定标签的所有代码（如`style`、`weight`和`size`属性以及`open_tag`和`close_tag`方法）都过时了。让我们重构一下，以消除它们：
- en: '[PRE211]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Styling not only lets web page authors style their own web pages; it also moves
    browser code to a simple style sheet. And that’s a big improvement: the style
    sheet is simpler and easier to edit. Sometimes converting code to data like this
    means maintaining a new format, but browsers get to reuse a format, CSS, they
    need to support anyway.'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 样式化不仅让网页作者能够美化自己的网页；它还将浏览器代码移动到一个简单的样式表中。这是一个很大的改进：样式表更简单，更容易编辑。有时将代码转换为数据如这种方式意味着需要维护一个新的格式，但浏览器可以重用他们无论如何都需要支持的格式，CSS。
- en: But of course styling also has the nice benefit of nicely rendering this book’s
    homepage (Figure 3). Notice how the background is no longer gray, and the links
    have colors.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，样式化也有渲染这本书主页（图3）的额外好处。注意背景不再灰色，链接有了颜色。
- en: '![Figure 3: https://browser.engineering/ viewed in this chapter’s version of
    the browser.](img/dea7997486dfe40ca82ddef57baf6684.png)'
  id: totrans-1056
  prefs: []
  type: TYPE_IMG
  zh: '![图3：https://browser.engineering/ 在本章浏览器版本中查看](img/dea7997486dfe40ca82ddef57baf6684.png)'
- en: 'Figure 3: https://browser.engineering/ viewed in this chapter’s version of
    the browser.'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：https://browser.engineering/ 在本章浏览器版本中查看
- en: Usually a point is 1/72 of an inch while pixel size depends on the screen, but
    CSS instead [defines an inch](https://www.w3.org/TR/2011/REC-CSS2-20110607/syndata.html#length-units)
    as 96 pixels, because that was once a common screen resolution. And these CSS
    pixels [need not be](https://developer.mozilla.org/en-US/docs/Web/CSS/resolution)
    physical pixels! Seem weird? This complexity is the result of changes in browsers
    (zooming) and hardware (high-DPIDots per inch. screens) plus the need to be compatible
    with older web pages meant for the time when all screens had 96 pixels per inch.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 通常一个点等于1/72英寸，而像素大小取决于屏幕，但CSS将英寸定义为96像素，因为那曾经是一个常见的屏幕分辨率。而且这些CSS像素[不一定](https://developer.mozilla.org/en-US/docs/Web/CSS/resolution)是物理像素！看起来很奇怪？这种复杂性是浏览器（缩放）和硬件（高DPi，每英寸点数屏幕）的变化以及与为所有屏幕每英寸96像素的时代设计的旧网页兼容性的需要的结果。
- en: Summary
  id: totrans-1059
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter implemented a rudimentary but complete styling engine, including
    downloading, parsing, matching, sorting, and applying CSS files. That means we:'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 本章实现了一个基本的但完整的样式引擎，包括下载、解析、匹配、排序和应用CSS文件。这意味着我们：
- en: wrote a CSS parser;
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写了一个CSS解析器；
- en: added support for both `style` attributes and `link`ed CSS files;
  id: totrans-1062
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了对`style`属性和`linked` CSS文件的支持；
- en: implemented cascading and inheritance;
  id: totrans-1063
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了级联和继承；
- en: refactored `BlockLayout` to move the font properties to CSS;
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`BlockLayout`进行了重构，将字体属性移动到CSS中；
- en: moved most tag-specific reasoning to a browser style sheet.
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将大多数与标签相关的推理移动到浏览器样式表中。
- en: Our styling engine is also relatively easy to extend with properties and selectors.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的样式引擎也相对容易通过属性和选择器进行扩展。
- en: '[widgets/lab6-browser.html](widgets/lab6-browser.html)'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '[widgets/lab6-browser.html](widgets/lab6-browser.html)'
- en: Outline
  id: totrans-1068
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should now
    look something like this:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整函数、类和方法集现在看起来可能像这样：
- en: '`` class URL: `def __init__(url)` `def request()` `def resolve(url)` `` ``
    class Text: `def __init__(text, parent)` `def __repr__()` `` `` class Element:
    `def __init__(tag, attributes, parent)` `def __repr__()` `` `def print_tree(node,
    indent)` `def tree_to_list(tree, list)` `` class HTMLParser: `SELF_CLOSING_TAGS`
    `HEAD_TAGS` `def __init__(body)` `def parse()` `def get_attributes(text)` `def
    add_text(text)` `def add_tag(tag)` `def implicit_tags(tag)` `def finish()` ``
    `` class CSSParser: `def __init__(s)` `def whitespace()` `def literal(literal)`
    `def word()` `def ignore_until(chars)` `def pair()` `def selector()` `def body()`
    `def parse()` `` `` class TagSelector: `def __init__(tag)` `def matches(node)`
    `` `` class DescendantSelector: `def __init__(ancestor, descendant)` `def matches(node)`
    `` `FONTS` `def get_font(size, weight, style)` `DEFAULT_STYLE_SHEET` `INHERITED_PROPERTIES`
    `def style(node, rules)` `def cascade_priority(rule)` `WIDTH, HEIGHT` `HSTEP,
    VSTEP` `BLOCK_ELEMENTS` `` class DocumentLayout: `def __init__(node)` `def layout()`
    `def paint()` `` `` class BlockLayout: `def __init__(node, parent, previous)`
    `def layout_mode()` `def layout()` `def recurse(node)` `def flush()` `def word(node,
    word)` `def paint()` `` `` class DrawText: `def __init__(x1, y1, text, font, color)`
    `def execute(scroll, canvas)` `` `` class DrawRect: `def __init__(x1, y1, x2,
    y2, color)` `def execute(scroll, canvas)` `` `def paint_tree(layout_object, display_list)`
    `SCROLL_STEP` `` class Browser: `def __init__()` `def draw()` `def load(url)`
    `def scrolldown(e)` ``'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Exercises
  id: totrans-1071
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 6-1 *Fonts*. Implement the `font-family` property, an inheritable property that
    names which font should be used in an element. Make text inside `<code>` elements
    use a nice monospaced font like `Courier`. Beware the font cache.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 6-1 *字体*。实现 `font-family` 属性，这是一个可继承的属性，指定元素应使用哪个字体。使 `<code>` 元素内的文本使用像 `Courier`
    这样的美观等宽字体。注意字体缓存。
- en: 6-2 *Width/height*. Add support for the `width` and `height` properties to block
    layout. These can either be a pixel value, which directly sets the width or height
    of the layout object, or the word `auto`, in which case the existing layout algorithm
    is used.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 6-2 *宽度/高度*。为块布局添加对 `width` 和 `height` 属性的支持。这些可以是像素值，直接设置布局对象的宽度和高度，或者单词 `auto`，在这种情况下，使用现有的布局算法。
- en: 6-3 *Class selectors*. Any HTML element can have a `class` attribute, whose
    value is a space-separated list of that element’s classes. A CSS class selector,
    like `.main`, affects all elements with the `main` class. Implement class selectors;
    they should take precedence over tag selectors. If you’ve implemented them correctly,
    you should see syntax highlighting for the code blocks in this book.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 6-3 *类选择器*。任何 HTML 元素都可以有一个 `class` 属性，其值是该元素类的空格分隔列表。CSS 类选择器，如 `.main`，影响所有具有
    `main` 类的元素。实现类选择器；它们应该比标签选择器具有优先级。如果您正确实现了它们，您应该会看到这本书中代码块的语法高亮。
- en: 6-4 *`display`*. Right now, the `layout_mode` function relies on a hard-coded
    list of block elements. In a real browser, the `display` property controls this.
    Implement `display` with a default value of `inline`, and move the list of block
    elements to the browser style sheet.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 6-4 *`display`*。目前，`layout_mode` 函数依赖于一个硬编码的块元素列表。在真实浏览器中，`display` 属性控制这一点。实现
    `display`，默认值为 `inline`，并将块元素列表移动到浏览器样式表中。
- en: '6-5 *Shorthand properties* CSS “shorthand properties” set multiple related
    CSS properties at the same time; for example, `font: italic bold 100% Times` sets
    the `font-style`, `font-weight`, `font-size`, and `font-family` properties all
    at once. Add shorthand properties to your parser. (If you haven’t done Exercise
    6-1, just ignore the `font-family`.)'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '6-5 *缩写属性* CSS 的“缩写属性”可以同时设置多个相关 CSS 属性；例如，`font: italic bold 100% Times` 一次设置
    `font-style`、`font-weight`、`font-size` 和 `font-family` 属性。将缩写属性添加到您的解析器中。（如果您还没有完成
    6-1 练习，请忽略 `font-family`。）'
- en: 6-6 *Inline style sheets*. The `<link rel=stylesheet>` syntax allows importing
    an external style sheet (meaning one loaded via its own HTTP request). There is
    also a way to provide a style sheet inline, as part of the HTML, via the `<style>`
    tag—everything up to the following `</style>` tag is interpreted as a style sheet.Both
    inline and external stylesheet apply in the order of their appearance in the HTML,
    though it might be easier to first implement inline style sheets applying after
    external ones. Inline style sheets are useful for creating self-contained example
    web pages, but more importantly are a way that websites can load faster by reducing
    the number of round-trip network requests to the server. Since style sheets typically
    don’t contain left angle brackets, you can implement this feature without modifying
    the HTML parser.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 6-6 *内联样式表*。`<link rel=stylesheet>` 语法允许导入外部样式表（意味着通过其自己的 HTTP 请求加载）。也可以通过 `<style>`
    标签将样式表内联，作为 HTML 的一部分——从下一个 `</style>` 标签开始的所有内容都被解释为样式表。内联样式表和外部样式表按照它们在 HTML
    中出现的顺序应用，尽管可能更容易先实现外部样式表之后应用内联样式表。内联样式表对于创建自包含的示例网页很有用，但更重要的是，它是网站通过减少对服务器的往返网络请求次数来加快加载速度的一种方式。由于样式表通常不包含左尖括号，因此可以在不修改
    HTML 解析器的情况下实现此功能。
- en: 6-7 *Fast descendant selectors*. Right now, matching a selector like `div div
    div div div` can take a long time—it’s *O(nd)* in the worst case, where *n* is
    the length of the selector and *d* is the depth of the layout tree. Modify the
    descendant-selector matching code to run in *O(n + d)* time. It may help to have
    `DescendantSelector` store a list of base selectors instead of just two.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 6-7 *快速后代选择器*。目前，匹配像 `div div div div div` 这样的选择器可能需要很长时间——在最坏的情况下，其时间复杂度为 *O(nd)*，其中
    *n* 是选择器的长度，*d* 是布局树的深度。修改后代选择器匹配代码，使其在 *O(n + d)* 时间内运行。让 `DescendantSelector`
    存储一个基础选择器的列表而不是仅仅两个可能有所帮助。
- en: 6-8 *Selector sequences*. Sometimes you want to select an element by tag *and*
    class. You do this by concatenating the selectors without anything in between.Not
    even whitespace! For example, `span.announce` selects elements that match both
    `span` and `.announce`. Implement a new `SelectorSequence` class to represent
    these and modify the parser to parse them. Sum priorities.Priorities for `SelectorSequence`s
    are supposed to compare the number of ID, class, and tag selectors in lexicographic
    order, but summing the priorities of the selectors in the sequence will work fine
    as long as no one strings more than ten selectors together.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 6-8 *选择器序列*。有时你想要通过标签 *和* 类来选择一个元素。你可以通过连接选择器而不在它们之间添加任何内容来实现这一点。甚至不是空格！例如，`span.announce`
    选择同时匹配 `span` 和 `.announce` 的元素。实现一个新的 `SelectorSequence` 类来表示这些，并修改解析器以解析它们。求优先级。`SelectorSequence`
    的优先级应该按照 ID、类和标签选择器的字典顺序进行比较，但只要没有人将超过十个选择器连接在一起，求序列中选择器的优先级之和将工作得很好。
- en: '6-9 *`!important`*. A CSS property–value pair can be marked “important” using
    the `!important` syntax, like this:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 6-9 *`!important`*。CSS 属性-值对可以使用 `!important` 语法标记为“重要”，如下所示：
- en: '[PRE212]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: This gives that property–value pair (but not other pairs in the same block!)
    a higher priority than any other selector (except for other `!important` properties).
    Parse and implement `!important`, giving any property–value pairs marked this
    way a priority 10 000 higher than normal property–value pairs.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 这给那个属性-值对（但不是同一块中的其他对！）比任何其他选择器（除了其他 `!important` 属性）更高的优先级。解析并实现 `!important`，给标记为这种方式的属性-值对赋予比正常属性-值对高
    10,000 的优先级。
- en: 6-10 *`:has` selectors*. The [`:has` selector](https://drafts.csswg.org/selectors-4/#relational)
    is the inverse of a descendant selector—it styles an ancestor according to the
    presence of a descendant. Implement `:has` selectors. Analyze the asymptotic speed
    of your implementation. There is a clever implementation that is *O(1)* amortized
    per element—can you find it?In fact, browsers have to do something [even more
    complex](https://blogs.igalia.com/blee/posts/2022/04/12/how-blink-tests-has-pseudo-class.html)
    to implement `:has` efficiently.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 6-10 *`:has` 选择器*。`:has` 选择器是后代选择器的逆——根据后代的存在来样式化祖先。实现 `:has` 选择器。分析你实现的渐近速度。有一种聪明的实现方式是每个元素
    *O(1)* 摊销——你能找到它吗？实际上，浏览器必须做一些 [更复杂的事情](https://blogs.igalia.com/blee/posts/2022/04/12/how-blink-tests-has-pseudo-class.html)
    来有效地实现 `:has`。
- en: Handling Buttons and Links
  id: totrans-1084
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理按钮和链接
- en: Chapter 7 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '[网络浏览器工程](./index.html "目录")的第 7 章。'
- en: '[Where Are the Links?](#where-are-the-links)'
  id: totrans-1086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[链接在哪里？](#where-are-the-links)'
- en: '[Line Layout, Redux](#line-layout-redux)'
  id: totrans-1087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[行布局，重制](#line-layout-redux)'
- en: '[Click Handling](#click-handling)'
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[点击处理](#click-handling)'
- en: '[Multiple Pages](#multiple-pages)'
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[多页](#multiple-pages)'
- en: '[Browser Chrome](#browser-chrome)'
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[浏览器外观](#browser-chrome)'
- en: '[Navigation History](#navigation-history)'
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[导航历史](#navigation-history)'
- en: '[Editing the URL](#editing-the-url)'
  id: totrans-1092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编辑 URL](#editing-the-url)'
- en: '[Summary](#summary)'
  id: totrans-1093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[摘要](#summary)'
- en: '[Outline](#outline)'
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大纲](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: 'Our browser is still missing the key insight of *hypertext*: documents linked
    together by hyperlinks. It lets us watch the waves, but not surf the web. So in
    this chapter, we’ll implement hyperlinks, an address bar, and the rest of the
    browser interface—the part of the browser that decides *which* page we are looking
    at.'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器仍然缺少 *超文本* 的关键洞察：通过超链接链接在一起的文档。它让我们可以观看波浪，但不能上网冲浪。因此，在本章中，我们将实现超链接、地址栏以及浏览器界面的其余部分——浏览器决定我们正在查看
    *哪个* 页面的部分。
- en: Where Are the Links?
  id: totrans-1097
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接在哪里？
- en: 'The core of the web is the link, so the most important part of the browser
    interface is clicking on links. But before we can quite get to *clicking* on links,
    we first need to answer a more fundamental question: where on the screen *are*
    the links? Though paragraphs and headings have their sizes and positions recorded
    in the layout tree, formatted text (like links) does not. We need to fix that.'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 网页的核心是链接，因此浏览器界面的最重要部分是点击链接。但在我们能够完全点击链接之前，我们首先需要回答一个更基本的问题：链接在屏幕的 *哪里*？尽管段落和标题的大小和位置在布局树中有记录，但格式化文本（如链接）没有。我们需要解决这个问题。
- en: 'The big idea is to introduce two new types of layout objects: `LineLayout`
    and `TextLayout`. A `BlockLayout` will now have a `LineLayout` child for each
    line of text, which itself will contain a `TextLayout` for each word in that line.
    These new classes can make the layout tree look different from the HTML tree.
    So to avoid surprises, let’s look at a simple example:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的想法是引入两种新的布局对象类型：`LineLayout` 和 `TextLayout`。现在 `BlockLayout` 将为每行文本有一个 `LineLayout`
    子对象，它本身将包含该行中每个单词的 `TextLayout`。这些新类可以使布局树看起来与 HTML 树不同。为了避免意外，让我们看看一个简单的例子：
- en: '[PRE213]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'The text in the `body` element wraps across two lines (because of the `br`
    element), so the layout tree will have this structure:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '`body` 元素中的文本跨越了两行（因为 `br` 元素），所以布局树将具有以下结构：'
- en: '[PRE214]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Note how one `body` element corresponds to a `BlockLayout` with two `LineLayout`s
    inside, and how two text nodes turn into a total of ten `TextLayout`s!
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一个 `body` 元素如何对应于包含两个 `LineLayout` 的 `BlockLayout`，以及两个文本节点如何变成总共十个 `TextLayout`！
- en: 'Let’s get started. Defining `LineLayout` is straightforward:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始。定义 `LineLayout` 是直接的：
- en: '[PRE215]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '`TextLayout` is only a little more tricky. A single `TextLayout` refers not
    to a whole HTML node but to a specific word. That means `TextLayout` needs an
    extra argument to know which word that is:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextLayout` 只有一点复杂。单个 `TextLayout` 指的不是整个 HTML 节点，而是特定的单词。这意味着 `TextLayout`
    需要一个额外的参数来知道是哪个单词：'
- en: '[PRE216]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Like the other layout modes, `LineLayout` and `TextLayout` will need their own
    `layout` and `paint` methods, but before we get to those we need to think about
    how the `LineLayout` and `TextLayout` objects will be created. That has to happen
    during word wrapping.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他布局模式一样，`LineLayout` 和 `TextLayout` 也需要它们自己的 `layout` 和 `paint` 方法，但在我们深入这些之前，我们需要考虑
    `LineLayout` 和 `TextLayout` 对象是如何被创建的。这必须在换行时发生。
- en: 'Recall [how word wrapping (see Chapter 3)](text.html) inside `BlockLayout`’s
    `word` method works. That method updates a `line` field, which stores all the
    words in the current line:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 [如何在 `BlockLayout` 的 `word` 方法中实现单词换行（见第 3 章）](text.html)。该方法更新一个 `line`
    字段，该字段存储当前行中的所有单词：
- en: '[PRE217]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: When it’s time to go to the next line, `word` calls `flush`, which computes
    the location of the line and each word in it, and adds all the words to a `display_list`
    field, which stores all the words in the whole inline element. With `TextLayout`
    and `LineLayout`, a lot of this complexity goes away. The `LineLayout` can compute
    its own location in its `layout` method, and instead of a `display_list` field,
    each `TextLayout` can just `paint` itself like normal. So let’s get started on
    this refactor.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要转到下一行时，`word` 调用 `flush`，它计算行及其中的每个单词的位置，并将所有单词添加到 `display_list` 字段中，该字段存储整个内联元素中的所有单词。有了
    `TextLayout` 和 `LineLayout`，很多这种复杂性就消失了。`LineLayout` 可以在其 `layout` 方法中计算自己的位置，而不是
    `display_list` 字段，每个 `TextLayout` 只需像正常一样 `paint` 自己。所以让我们开始这个重构。
- en: 'Let’s start with adding a word to a line. Instead of a `line` field, we want
    to create `TextLayout` objects and add them to `LineLayout` objects. The `LineLayout`s
    are children of the `BlockLayout`, so the current line can be found at the end
    of the `children` array:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向一行添加一个单词开始。而不是 `line` 字段，我们想要创建 `TextLayout` 对象并将它们添加到 `LineLayout` 对象中。`LineLayout`
    是 `BlockLayout` 的子对象，所以当前行可以在 `children` 数组的末尾找到：
- en: '[PRE218]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Now let’s think about what happens when we reach the end of the line. The current
    code calls `flush`, which does stuff like positioning text and clearing the `line`
    field. We don’t want to do all that—we just want to create a new `LineLayout`
    object. So let’s use a different method for that:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来思考一下当我们到达行尾时会发生什么。当前的代码调用 `flush`，它执行诸如定位文本和清除 `line` 字段等操作。我们不想做所有这些——我们只想创建一个新的
    `LineLayout` 对象。所以让我们为这个目的使用一个不同的方法：
- en: '[PRE219]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'This `new_line` method just creates a new line and resets some fields:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `new_line` 方法只是创建一个新的行并重置一些字段：
- en: '[PRE220]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Now there are a lot of fields we’re not using. Let’s clean them up. In the
    core `layout` method, we don’t need to initialize the `display_list`, `cursor_y`
    or `line` fields, since we won’t be using any of those any more. Instead, we just
    need to call `new_line` and `recurse`:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有很多字段我们没有使用。让我们清理它们。在核心 `layout` 方法中，我们不需要初始化 `display_list`、`cursor_y` 或
    `line` 字段，因为我们不再使用它们中的任何一个。相反，我们只需要调用 `new_line` 和 `recurse`：
- en: '[PRE221]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'The `layout` method already recurses into its children to lay them out, so
    that part doesn’t need any change. And moreover, we can now compute the height
    of a paragraph of text by summing the height of its lines, so this part of the
    code no longer needs to be different depending on the layout mode:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '`layout` 方法已经递归到其子元素以进行布局，所以这部分不需要任何更改。而且，我们现在可以通过求和其行的长度来计算文本段落的长度，因此这部分代码不再需要根据布局模式而有所不同：'
- en: '[PRE222]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: You might also be tempted to delete the `flush` method, since it’s no longer
    called from anywhere. But keep it around for just a moment—we’ll need it to write
    the `layout` method for line and text objects.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能也会想删除 `flush` 方法，因为它不再被任何地方调用。但请保留它一会儿——我们需要它来编写行和文本对象的 `layout` 方法。
- en: The layout objects generated by a text node need not even be consecutive. English
    containing a Farsi quotation, for example, can flip from left-to-right to right-to-left
    in the middle of a line. The text layout objects end up in a [surprising order](https://www.w3.org/International/articles/inline-bidi-markup/uba-basics).
    And then there are languages laid out [vertically](https://en.wikipedia.org/wiki/Mongolian_script)…
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 由文本节点生成的布局对象甚至不需要是连续的。例如，包含波斯语引文的英语可以在行中从左到右翻转到右到左。文本布局对象最终以 [令人惊讶的顺序](https://www.w3.org/International/articles/inline-bidi-markup/uba-basics)
    结束。然后还有 [垂直](https://en.wikipedia.org/wiki/Mongolian_script) 布局的文字...
- en: Line Layout, Redux
  id: totrans-1124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行布局，重制
- en: We’re now creating line and text objects, but we still need to lay them out.
    Let’s start with lines. Lines stack vertically and take up their parent’s full
    width, so computing `x` and `y` and `width` looks the same as for our other boxes:You
    could reduce the duplication with some helper methods (or even something more
    elaborate, like mixin classes), but in a real browser different layout modes support
    different kinds of extra features (like text direction or margins) and the code
    looks quite different.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在创建行和文本对象，但我们仍然需要将它们布局。让我们从行开始。行垂直堆叠并占据其父级的完整宽度，因此计算 `x`、`y` 和 `width`
    的方式与我们的其他盒子相同：您可以使用一些辅助方法（甚至更复杂的方法，如混合类）来减少重复，但在实际的浏览器中，不同的布局模式支持不同类型的额外功能（如文本方向或边距），代码看起来相当不同。
- en: '[PRE223]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: Computing height, though, is different—this is where computing maximum ascents,
    maximum descents, and so on comes in. Before we do that, let’s look at laying
    out `TextLayout`s.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，计算高度是不同的——这就是计算最大上升、最大下降等的地方。在我们这样做之前，让我们看看如何布局 `TextLayout`。
- en: 'To lay out text we need font metrics, so let’s start by getting the relevant
    font using the same font-construction code as `BlockLayout`:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 要布局文本，我们需要字体度量，所以让我们首先使用与 `BlockLayout` 相同的字体构建代码来获取相关字体：
- en: '[PRE224]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Next, we need to compute the word’s size and `x` position. We use the font metrics
    to compute size, and stack words left to right to compute position.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要计算单词的大小和 `x` 位置。我们使用字体度量来计算大小，并从左到右堆叠单词来计算位置。
- en: '[PRE225]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: There’s no code here to compute the `y` position, however. The vertical position
    of one word depends on the other words in the same line, so we’ll compute that
    `y` position inside `LineLayout`’s `layout` method.The `y` position could have
    been computed in `TextLayout`’s `layout` method—but then that layout method would
    have to come *after* the baseline computation, not *before*. Yet `font` must be
    computed *before* the baseline computation. A real browser might resolve this
    paradox with multi-phase layout. There are many considerations and optimizations
    of this kind that are needed to make text layout super fast.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里没有代码来计算 `y` 位置。一个单词的垂直位置取决于同一行中的其他单词，因此我们将在 `LineLayout` 的 `layout` 方法中计算该
    `y` 位置。`y` 位置本可以在 `TextLayout` 的 `layout` 方法中计算——但那样的话，该布局方法就必须在基线计算之后，而不是之前。然而，`font`
    必须在基线计算之前计算。一个真正的浏览器可能会通过多阶段布局来解决这个问题。为了使文本布局超级快，需要考虑和优化许多此类问题。
- en: 'That method will pilfer code from the old `flush` method. First, let’s lay
    out each word:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 那个方法将从旧的 `flush` 方法中窃取代码。首先，让我们布局每个单词：
- en: '[PRE226]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'Next, we need to compute the line’s baseline based on the maximum ascent and
    descent, using basically the same code as the old `flush` method:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要根据最大上升和下降来计算行的基线，基本上使用与旧 `flush` 方法相同的代码：
- en: '[PRE227]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Note that this code is reading from a `font` field on each word and writing
    to each word’s `y` field. That means that inside `TextLayout`’s `layout` method
    we need to compute `x`, `width`, `height` , and `font`, but not `y`, exactly how
    we did it.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码是从每个单词的`font`字段读取并写入每个单词的`y`字段。这意味着在`TextLayout`的`layout`方法中，我们需要计算`x`、`width`、`height`和`font`，但不计算`y`，正好像我们之前做的那样。
- en: 'Finally, since each line is now a standalone layout object, it needs to have
    a height. We compute it from the maximum ascent and descent:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于现在每一行都是一个独立的布局对象，它需要有一个高度。我们是从最大上升和下降值来计算的：
- en: '[PRE228]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'So that’s `layout` for `LineLayout` and `TextLayout`. All that’s left is painting.
    For `LineLayout` there is nothing to paint:'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是`LineLayout`和`TextLayout`的`layout`。剩下要做的就是绘制。对于`LineLayout`，没有东西要绘制：
- en: '[PRE229]'
  id: totrans-1141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'And each `TextLayout` creates a single `DrawText` call:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`TextLayout`都创建一个单独的`DrawText`调用：
- en: '[PRE230]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Now we don’t need a `display_list` field in `BlockLayout`, and we can also remove
    the part of `BlockLayout`’s `paint` that handles it. Instead, `paint_tree` can
    just recurse into its children and paint them. So by adding `LineLayout` and `TextLayout`
    we made `BlockLayout` quite a bit simpler and shared more code between block and
    inline layout modes.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不需要在`BlockLayout`中有一个`display_list`字段，我们也可以移除`BlockLayout`的`paint`部分中处理它的部分。相反，`paint_tree`可以直接递归到其子节点并绘制它们。所以通过添加`LineLayout`和`TextLayout`，我们使`BlockLayout`变得更加简单，并在块和内联布局模式之间共享了更多的代码。
- en: 'So, oof, well, this was quite a bit of refactoring. Take a moment to test everything—it
    should look exactly identical to how it did before we started this refactor. But
    while you can’t see it, there’s a crucial difference: each blue link on the page
    now has an associated layout object and its own size and position.'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，哎呀，好吧，这次重构相当多。花点时间测试一下——它应该看起来与我们开始重构之前完全一样。但尽管你看不见，有一个关键的区别：页面上每个蓝色的链接现在都有一个相关的布局对象以及它自己的大小和位置。
- en: Actually, text rendering is [*way* more complex](https://gankra.github.io/blah/text-hates-you/)
    than this. [Letters](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6morx.html)
    can transform and overlap, and the user might want to color certain letters—or
    parts of letters—a different color. All of this is possible in HTML, and real
    browsers do implement support for it.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，文本渲染比这要复杂得多。[字母](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6morx.html)可以变换和重叠，用户可能想要将某些字母——或者字母的部分——染成不同的颜色。所有这些在HTML中都是可能的，并且真正的浏览器确实实现了对这些的支持。
- en: Click Handling
  id: totrans-1147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击处理
- en: 'Now that we know where the links are, we can work on clicking them. In Tk,
    click handling works just like key press handling: you bind an event handler to
    a certain event. For click handling that event is `<Button-1>`, button number
    1 being the left button on the mouse.Button 2 is the middle button; button 3 is
    the right-hand button.'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了链接的位置，我们可以开始处理点击它们。在Tk中，点击处理与按键处理一样工作：你将事件处理器绑定到特定的事件。对于点击处理，这个事件是`<Button-1>`，按钮1是鼠标的左键。按钮2是中间键；按钮3是右键。
- en: '[PRE231]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Inside `click`, we want to figure out what link the user has clicked on. Luckily,
    the event handler is passed an event object, whose `x` and `y` fields refer to
    where the click happened:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`click`内部，我们想要找出用户点击了哪个链接。幸运的是，事件处理器传递了一个事件对象，其`x`和`y`字段指的是点击发生的位置：
- en: '[PRE232]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'Now, here, we have to be careful with coordinate systems. Those *x* and *y*
    coordinates are relative to the browser window. Since the canvas is in the top-left
    corner of the window, those are also the *x* and *y* coordinates relative to the
    canvas. We want the coordinates relative to the web page, so we need to account
    for scrolling:'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这里，我们必须小心处理坐标系。那些*x*和*y*坐标是相对于浏览器窗口的。由于画布在窗口的左上角，这些也是相对于画布的*x*和*y*坐标。我们想要相对于网页的坐标，因此我们需要考虑滚动：
- en: '[PRE233]'
  id: totrans-1153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: More generally, handling events like clicks involves *reversing* the usual rendering
    pipeline. Normally, rendering goes from elements to layout objects to page coordinates
    to screen coordinates; click handling goes backward, starting with screen coordinates,
    then converting to page coordinates, and so on. The correspondence isn’t perfectly
    reversed in practiceThough see some exercises in this chapter and future ones
    on making it a closer match. but it’s a worthwhile analogy.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地说，处理像点击这样的事件涉及到*反转*通常的渲染管道。通常，渲染是从元素到布局对象到页面坐标到屏幕坐标；点击处理是反向的，从屏幕坐标开始，然后转换到页面坐标，等等。在实践中，这种对应关系并不是完美反转的——尽管在本章和未来的练习中，我们会看到如何使其更接近匹配。但这仍然是一个有价值的类比。
- en: So the next step is to go from page coordinates to a layout object:You could
    try to first find the paint command clicked on, and go from that to layout object,
    but in real browsers there are all sorts of reasons this won’t work, starting
    with invisible objects that can nonetheless be clicked on. See Exercise 7-11.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下一步是将页面坐标转换为布局对象：你可以尝试先找到被点击的绘制命令，然后从该命令到布局对象，但在实际浏览器中，有各种原因这不会工作，首先是不可见但可以点击的对象。参见练习7-11。
- en: '[PRE234]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: In principle there might be more than one layout object in this list.In real
    browsers there are all sorts of ways this could happen, like negative margins.
    But remember that click handling is the reverse of painting. When we paint, we
    paint the tree from front to back, so when hit testing we should start at the
    last element:Real browsers use the `z-index` property to control which sibling
    is on top. So real browsers have to compute [stacking contexts](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)
    to resolve what you actually clicked on.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 在原则上，这个列表中可能不止一个布局对象。在实际浏览器中，有各种方式可能导致这种情况，比如负边距。但记住，点击处理是绘制过程的逆过程。当我们绘制时，我们是从前到后绘制树，所以在点击测试时，我们应该从最后一个元素开始：实际浏览器使用`z-index`属性来控制哪个兄弟元素在顶部。因此，实际浏览器必须计算[堆叠上下文](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)来解决你实际点击的是什么。
- en: '[PRE235]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: This `elt` node is the most specific node that was clicked. With a link, that’s
    usually going to be a text node. But since we want to know the actual URL the
    user clicked on, we need to climb back up the HTML tree to find the link element:I
    wrote this in a kind of curious way so it’s easy to add other types of clickable
    things—like text boxes and buttons—in [Chapter 8](forms.html).
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`elt`节点是被点击的最具体节点。对于链接，这通常是一个文本节点。但因为我们想知道用户实际点击的URL，我们需要沿着HTML树向上爬，以找到链接元素：我以这种方式编写，以便于在[第8章](forms.html)中添加其他类型的可点击元素——比如文本框和按钮。
- en: '[PRE236]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Once we find the link element itself, we need to extract the URL and load it:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到链接元素本身，我们需要提取URL并加载它：
- en: '[PRE237]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'Note that this `resolve` call requires storing the current page’s URL:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个`resolve`调用需要存储当前页面的URL：
- en: '[PRE238]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: Try it out! You should now be able to click on links and navigate to new web
    pages.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下！现在你应该能够点击链接并导航到新的网页。
- en: On mobile devices, a “click” happens over an area, not just at a single point.
    This is because mobile “taps” are often pretty inaccurate, so clicks should [use
    area, not point information](http://www.chromium.org/developers/design-documents/views-rect-based-targeting)
    for “hit testing”. This can happen even with a [normal mouse click](https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/layout/hit_test_location.h)
    when the click is on a rotated or scaled element.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备上，点击发生在一个区域内，而不仅仅是单个点。这是因为移动设备的“轻触”通常非常不准确，因此点击应该[使用区域而不是点信息](http://www.chromium.org/developers/design-documents/views-rect-based-targeting)来进行“点击测试”。即使是在点击旋转或缩放元素时，普通的鼠标点击也可能发生这种情况。
- en: Multiple Pages
  id: totrans-1167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个页面
- en: If you’re anything like me, the next thing you tried after clicking on links
    is middle-clicking them to open in a new tab. Every browser now has tabbed browsing,
    and honestly it’s a little embarrassing that our browser doesn’t.Back in the day,
    browser tabs were the feature that would convince friends and relatives to switch
    from IE 6 to Firefox.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和我一样，点击链接后尝试的下一件事就是中间点击它们以在新标签页中打开。现在每个浏览器都有标签页浏览功能，老实说，我们的浏览器没有这个功能有点尴尬。在以前，浏览器标签页是说服朋友和亲戚从IE
    6切换到Firefox的功能。
- en: Fundamentally, implementing tabbed browsing requires us to distinguish between
    the browser itself and the tabs that show individual web pages. The canvas the
    browser draws to, for example, is shared by all web pages, but the layout tree
    and display list are specific to one page. We need to tease tabs and browsers
    apart.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '基本上，实现标签页浏览需要我们区分浏览器本身和显示单个网页的标签页。例如，浏览器绘制的画布是由所有网页共享的，但布局树和显示列表是特定于一个页面的。我们需要将标签页和浏览器分开。 '
- en: 'Here’s the plan: the `Browser` class will own the window and canvas and all
    related methods, such as event handling. And it’ll also contain a list of `Tab`
    objects and the browser chrome. But the web page itself and its associated methods
    will live in a new `Tab` class.'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是计划：`Browser`类将拥有窗口、画布以及所有相关方法，例如事件处理。它还将包含一个`Tab`对象列表和浏览器界面。但网页本身及其相关方法将存在于一个新的`Tab`类中。
- en: 'To start, rename your existing `Browser` class to be just `Tab`, since until
    now we’ve only handled a single web page:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将现有的 `Browser` 类重命名为 `Tab`，因为我们到目前为止只处理了一个网页：
- en: '[PRE239]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'Then we’ll need a new `Browser` class. It has to store a list of tabs and also
    which one is active:'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个新的 `Browser` 类。它必须存储一个标签页列表以及哪个是活动的：
- en: '[PRE240]'
  id: totrans-1174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'It also owns the window and handles all events:'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 它还拥有窗口并处理所有事件：
- en: '[PRE241]'
  id: totrans-1176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Remove these lines from `Tab`’s constructor.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Tab` 的构造函数中移除这些行。
- en: 'The `handle_down` and `handle_click` methods need page-specific information,
    so these handler methods just forward the event to the active tab:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_down` 和 `handle_click` 方法需要特定于页面的信息，因此这些处理方法只是将事件转发到活动标签：'
- en: '[PRE242]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'You’ll need to tweak the `Tab`’s `scrolldown` and `click` methods:'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要调整 `Tab` 的 `scrolldown` 和 `click` 方法：
- en: '`scrolldown` now takes no arguments (instead of an event object)'
  id: totrans-1181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scrolldown` 现在不接受任何参数（而不是事件对象）'
- en: '`click` now takes two coordinates (instead of an event object)'
  id: totrans-1182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`click` 现在接受两个坐标（而不是事件对象）'
- en: 'Finally, the `Browser`’s `draw` call also calls into the active tab:'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Browser` 的 `draw` 调用也会调用到活动标签：
- en: '[PRE243]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Note that clearing the screen is the `Browser`’s job, not the `Tab`’s. After
    that, we only draw the active tab, which is how tabs are supposed to work. `Tab`’s
    `draw` method needs to take the canvas in as an argument:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，清除屏幕是 `Browser` 的职责，而不是 `Tab` 的。之后，我们只绘制活动标签，这正是标签应该工作的方式。`Tab` 的 `draw`
    方法需要将画布作为参数传入：
- en: '[PRE244]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'Since the `Browser` controls the canvas and handles events, it decides when
    rendering happens and which tab does the drawing. So let’s also remove the `draw`
    calls from the `load` and `scrolldown` methods. More generally, the `Browser`
    is “active” and the `Tab` is “passive”: all user interactions start at the `Browser`,
    which then calls into the tabs as appropriate.'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Browser` 控制画布并处理事件，它决定何时进行渲染以及哪个标签页进行绘图。因此，让我们也从 `load` 和 `scrolldown` 方法中移除
    `draw` 调用。更普遍地说，`Browser` 是“活跃”的，而 `Tab` 是“被动”的：所有用户交互都从 `Browser` 开始，然后根据需要调用标签页。
- en: 'We’re basically done splitting `Tab` from `Browser`, and after a refactor like
    this we need to test things. To do that, we’ll need to create at least one tab,
    like this:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上已经将 `Tab` 从 `Browser` 中分离出来，在经过这样的重构之后，我们需要测试一下。为此，我们需要创建至少一个标签，如下所示：
- en: '[PRE245]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'On startup, you should now create a `Browser` with one tab:'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，您现在应该创建一个包含一个标签的 `Browser`：
- en: '[PRE246]'
  id: totrans-1191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: Of course, we need a way for *the user* to switch tabs, create new ones, and
    so on. Let’s turn to that next.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要一种方法让 *用户* 切换标签、创建新的标签等等。让我们转向下一个问题。
- en: Browser tabs first appeared in [SimulBrowse](https://en.wikipedia.org/wiki/NetCaptor),
    which was a kind of custom UI for the Internet Explorer engine.Some people instead
    attribute tabbed browsing to Booklink’s InternetWorks browser, a browser obscure
    enough that it doesn’t have a Wikipedia page, though you can see some screenshots
    [on Twitter](https://twitter.com/awesomekling/status/1694242398539264363). However,
    its tabs were slightly different from the modern conception, [more like bookmarks
    or history](https://ajstiles.wordpress.com/2005/02/11/tabbed_browser_/) than tabs.
    SimulBrowse instead used the modern notion of tabs. SimulBrowse (later renamed
    to NetCaptor) also had ad blocking and a private browsing mode. The [old advertisements](https://web.archive.org/web/20050701001923/http://www.netcaptor.com/)
    are a great read!
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器标签首次出现在 [SimulBrowse](https://en.wikipedia.org/wiki/NetCaptor) 中，这是一种针对 Internet
    Explorer 引擎的定制 UI。有些人将标签浏览归功于 Booklink 的 InternetWorks 浏览器，这是一个足够隐秘的浏览器，以至于没有维基百科页面，尽管你可以在
    [Twitter](https://twitter.com/awesomekling/status/1694242398539264363) 上看到一些截图。然而，它的标签与现代概念略有不同，[更像是书签或历史记录](https://ajstiles.wordpress.com/2005/02/11/tabbed_browser_/)
    而不是标签。SimulBrowse（后来更名为 NetCaptor）还提供了广告拦截和私密浏览模式。[旧广告](https://web.archive.org/web/20050701001923/http://www.netcaptor.com/)
    是一篇很好的阅读材料！
- en: Browser Chrome
  id: totrans-1194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器外观
- en: Real web browsers don’t just show web page contents—they’ve got labels and icons
    and buttons.Oh my! This is called the browser “chrome”;Yep, that predates and
    inspired the name of Google’s Chrome browser. all of this stuff is drawn by the
    browser to the same window as the page contents, and it requires information about
    the browser as a whole (like the list of all tabs), so it has to happen at the
    browser level, not per tab.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的网络浏览器不仅仅显示网页内容——它们有标签、图标和按钮。哦，这被称为浏览器的“外观”；是的，这比谷歌Chrome浏览器的名字还要早。所有这些内容都是由浏览器绘制到与页面内容相同的窗口中的，这需要关于浏览器整体的信息（如所有标签的列表），因此这必须在浏览器级别发生，而不是每个标签级别。
- en: 'However, a browser’s UI is quite complicated, so let’s put that code in a new
    `Chrome` helper class:'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，浏览器的用户界面相当复杂，所以让我们将这段代码放入一个新的`Chrome`辅助类中：
- en: '[PRE247]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'Let’s design the browser chrome. Ultimately, I think it should have two rows
    (see Figure 1):'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计浏览器界面。最终，我认为它应该有两行（见图1）：
- en: At the top, a list of tab names, separated by vertical lines, and a “`+`” button
    to add a new tab.
  id: totrans-1199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶部，一个由垂直线分隔的标签名称列表，以及一个用于添加新标签的“`+`”按钮。
- en: Underneath, the URL of the current web page, and a “`<`” button to represent
    the browser back button.
  id: totrans-1200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面，当前网页的URL，以及一个表示浏览器后退按钮的“`<`”按钮。
- en: '![Figure 1: The intended appearance of the browser chrome.](img/04cc12c061feca7725f27e3baf9c4cdf.png)'
  id: totrans-1201
  prefs: []
  type: TYPE_IMG
  zh: '![图1：浏览器界面的预期外观。](img/04cc12c061feca7725f27e3baf9c4cdf.png)'
- en: 'Figure 1: The intended appearance of the browser chrome.'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：浏览器界面的预期外观。
- en: 'A lot of this design involves text, so let’s start by picking a font:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 这项设计涉及很多文本，所以让我们先选择一个字体：
- en: '[PRE248]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: Because different operating systems draw fonts differently, we’ll need to adjust
    the exact design of the browser chrome based on font metrics. So we’ll need the
    `font_height` later.I chose `20px` as the font size, but that might be too large
    on your device. Feel free to adjust.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同的操作系统绘制字体的方式不同，我们需要根据字体度量来调整浏览器界面的具体设计。因此，我们稍后需要`font_height`。我选择了`20px`作为字体大小，但可能在你的设备上太大。请随意调整。
- en: 'Using that font height, we can now determine where the tab bar starts and ends:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用那个字体高度，我们现在可以确定标签栏的起始和结束位置：
- en: '[PRE249]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: Note that I’ve added some padding so that text doesn’t run into the edge of
    the window.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经添加了一些填充，以便文本不会跑到窗口的边缘。
- en: 'We will store rectangles representing the size of various elements in the browser
    chrome. For that, a new `Rect` class will be convenient:'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将存储表示浏览器界面中各种元素大小的矩形。为此，一个新的`Rect`类将很有用：
- en: '[PRE250]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Now, this tab row needs to contain a new-tab button and the tab names themselves.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个标签行需要包含一个新标签按钮以及标签名称本身。
- en: 'I’ll add padding around the new-tab button:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在新标签按钮周围添加填充：
- en: '[PRE251]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'Then the tabs will start `padding` past the end of the new-tab button. Because
    the number of tabs can change, I’m not going to store the location of each tab.
    Instead I’ll just compute their bounds on the fly:'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后标签将开始填充到新标签按钮的末端。因为标签的数量可能会变化，所以我不打算存储每个标签的位置。相反，我将在运行时计算它们的边界：
- en: '[PRE252]'
  id: totrans-1215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Note that I measure the text “Tab X” and use that for all of the tab widths.
    This is not quite right—in many fonts, numbers like 8 are wider than numbers like
    1—but it is close enough, and anyway, the letter X is typically as wide as the
    widest number.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我测量了文本“标签X”并使用它来计算所有标签的宽度。这并不完全正确——在许多字体中，数字如8比数字如1更宽——但这已经足够接近了，而且无论如何，字母X通常与最宽的数字一样宽。
- en: 'To actually draw the UI, we’ll first have the browser chrome paint a display
    list, which the `Browser` will then draw to the screen:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际绘制UI，我们首先让浏览器界面绘制一个显示列表，然后`Browser`将其绘制到屏幕上：
- en: '[PRE253]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'Let’s start by first painting the new-tab button:'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从绘制新标签按钮开始：
- en: '[PRE254]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'The `DrawOutline` command draws a rectangular border:'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawOutline`命令绘制矩形边框：'
- en: '[PRE255]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'Next up is drawing the tabs. Python’s `enumerate` function lets you iterate
    over both the indices and the contents of an array at the same time. For each
    tab, we need to create a border on the left and right and then draw the tab name:'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是绘制标签。Python的`enumerate`函数允许你同时迭代数组的索引和内容。对于每个标签，我们需要在左侧和右侧创建一个边框，然后绘制标签名称：
- en: '[PRE256]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'Finally, to identify which tab is the active tab, we’ve got to make that file
    folder shape with the current tab sticking up:'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了识别哪个标签是活动标签，我们需要绘制一个带有当前标签突出显示的文件夹形状：
- en: '[PRE257]'
  id: totrans-1226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'The `DrawLine` command draws a line of a given color and thickness. It’s defined
    like so:'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawLine`命令绘制给定颜色和厚度的线条。它定义如下：'
- en: '[PRE258]'
  id: totrans-1228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'One final thing: we want to make sure that the browser chrome is always drawn
    on top of the page contents. To guarantee that, we can draw a white rectangle
    behind the chrome:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情：我们想要确保浏览器界面始终绘制在页面内容之上。为了确保这一点，我们可以在界面后面绘制一个白色矩形：
- en: '[PRE259]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'Make sure the background is drawn before any other part of the chrome. I also
    added a line at the bottom of the chrome to separate it from the page. Note how
    I also changed `DrawRect` to pass a `Rect` instead of the four corners; this requires
    a change to `BlockLayout`:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在绘制浏览器界面的其他任何部分之前先绘制背景。我还添加了一条位于界面底部的线，以将其与页面内容分开。注意我如何将`DrawRect`改为传递一个`Rect`而不是四个角；这需要修改`BlockLayout`：
- en: '[PRE260]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: Add a `rect` field to `DrawText` and `DrawLine` too. (The width and height for
    `DrawText` should be the width and height of the text.)
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 给`DrawText`和`DrawLine`也添加一个`rect`字段。（对于`DrawText`，宽度和高度应该是文本的宽度和高度。）
- en: 'Drawing this chrome display list is now straightforward:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制这个铬显示列表现在变得简单直接：
- en: '[PRE261]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Note that this display list is always drawn at the top of the window, unlike
    the tab contents (which scroll). Make sure to draw the chrome *after* the main
    tab contents, so that the chrome is drawn over it.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个显示列表总是在窗口顶部绘制，与滚动的内容标签页不同。确保在绘制主要标签内容之后绘制铬，这样铬就会覆盖它。
- en: 'However, we also have to make some adjustments to tab drawing to account for
    the fact that the browser chrome takes up some vertical space. Let’s add a `tab_height`
    parameter to `Tab`s:'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也需要对标签绘制进行调整，以考虑浏览器铬占用了一些垂直空间。让我们给`Tab`添加一个`tab_height`参数：
- en: '[PRE262]'
  id: totrans-1238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'We can pass it to `new_tab`:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其传递给`new_tab`：
- en: '[PRE263]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'We can then adjust `scrolldown` to account for the height of the page content
    now being `tab_height`:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调整`scrolldown`以考虑页面内容现在的高度`tab_height`：
- en: '[PRE264]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'Finally, in `Tab`’s `draw` method we need to shift the drawing commands down
    by the chrome height. I’ll pass the chrome height in as an `offset` parameter:'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Tab`的`draw`方法中，我们需要将绘图命令向下移动铬的高度。我将通过`offset`参数传递铬的高度：
- en: '[PRE265]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'The `Browser`’s final `draw` method now looks like this:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Browser`的最终`draw`方法现在看起来是这样的：'
- en: '[PRE266]'
  id: totrans-1246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'One more thing: clicking on tabs to switch between them. The `Browser` handles
    the click and now needs to delegate clicks on the browser chrome to the `Chrome`
    object:'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事：点击标签来在它们之间切换。`Browser`处理点击，现在需要将浏览器铬的点击委托给`Chrome`对象：
- en: '[PRE267]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'Note that we need to subtract out the chrome size when clicking on tab contents.
    As for clicks on the browser chrome, inside `Chrome` we need to figure out what
    the user clicked on. To make that easier, let’s add a quick method to test whether
    a point is contained in a `Rect`:'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在点击标签内容时，我们需要减去铬的大小。至于浏览器铬的点击，在`Chrome`内部，我们需要确定用户点击了什么。为了使这更容易，让我们添加一个快速方法来测试一个点是否包含在`Rect`中：
- en: '[PRE268]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: We use this method to handle clicks inside `Chrome`, and then use it to choose
    between clicking to add a tab or select an open tab.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个方法来处理`Chrome`内部的点击，然后使用它来在添加标签或选择打开的标签之间进行选择。
- en: '[PRE269]'
  id: totrans-1252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: That’s an appropriate “new tab” page, don’t you think? Anyway, you should now
    be able to load multiple tabs, scroll and click around them independently, and
    switch tabs by clicking on them.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个合适的“新标签页”页面，你不这么认为吗？无论如何，你现在应该能够加载多个标签页，独立滚动和点击它们，并通过点击来切换标签页。
- en: Google Chrome 1.0 was accompanied by a [comic book](https://www.google.com/googlebooks/chrome/)
    to pitch its features. There’s a whole [chapter](https://www.google.com/googlebooks/chrome/big_18.html)
    about its design ideas and user interface features, many of which stuck around.
    Even this book’s browser has tabs on top, for example.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: Google Chrome 1.0 伴随着一本[漫画书](https://www.google.com/googlebooks/chrome/)来推广其功能。其中有一整章[章节](https://www.google.com/googlebooks/chrome/big_18.html)是关于其设计理念和用户界面特性，其中许多特性一直沿用至今。例如，这本书的浏览器顶部也有标签页。
- en: Navigation History
  id: totrans-1255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航历史
- en: 'Now that we are navigating between pages all the time, it’s easy to get a little
    lost and forget what web page you’re looking at. An address bar that shows the
    current URL would help a lot. Let’s make room for it in the chrome:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们经常在页面之间导航，很容易有点迷失方向，忘记正在查看的网页。一个显示当前URL的地址栏会非常有帮助。让我们在铬中为它腾出空间：
- en: '[PRE270]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'This “URL bar” will contain the back button and the address bar:'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“URL栏”将包含后退按钮和地址栏：
- en: '[PRE271]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'Painting the back button is straightforward:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制后退按钮是直接的：
- en: '[PRE272]'
  id: totrans-1261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'The address bar needs to get the current tab’s URL from the browser:'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 地址栏需要从浏览器中获取当前标签页的URL：
- en: '[PRE273]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'Here, `str` is a built-in Python function that we can override to correctly
    convert `URL` objects to strings:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`str`是一个内置的Python函数，我们可以覆盖它以正确地将`URL`对象转换为字符串：
- en: '[PRE274]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: I think the extra logic to hide port numbers is worth it to make the URLs more
    tidy.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为隐藏端口号的额外逻辑值得为了使URL更加整洁。
- en: 'What should happen when the back button is clicked? Well, *that tab* should
    go back. Other tabs are not affected. So the `Browser` has to invoke some method
    on the current tab to go back:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击后退按钮时，应该发生什么？嗯，*那个标签页*应该后退。其他标签页不受影响。因此，`Browser`必须对当前标签页调用一些方法来实现后退：
- en: '[PRE275]'
  id: totrans-1268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'For the active tab to “go back”, it needs to store a “history” of which pages
    it’s visited before:'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于活动标签要“后退”，它需要存储一个“历史”记录，记录它之前访问过的页面：
- en: '[PRE276]'
  id: totrans-1270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'The history grows every time we go to a new page:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们访问新页面时，历史都会增长：
- en: '[PRE277]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'Going back uses that history. You might think to write this:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 返回操作会使用历史记录。你可能认为可以这样写：
- en: '[PRE278]'
  id: totrans-1274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'That’s almost correct, but it doesn’t work if you click the back button twice,
    because `load` adds to the history. Instead, we need to do something more like
    this:'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是对的，但如果连续点击后退按钮两次，则不会工作，因为`load`会添加到历史记录中。相反，我们需要做更多像这样的事情：
- en: '[PRE279]'
  id: totrans-1276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: Now, going back shrinks the history and clicking on links grows it, as it should.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，返回操作会缩小历史记录，而点击链接则会扩展它，正如它应该做的那样。
- en: 'So we’ve now got a pretty good web browser for reading this very book: you
    can click links, browse around, and even have multiple chapters open simultaneously
    for cross-referencing things. But it’s a little hard to visit a website not linked
    to from the current one.'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个相当不错的网络浏览器来阅读这本书：你可以点击链接，四处浏览，甚至可以同时打开多个章节以进行交叉引用。但要从当前未链接的网站访问则有点困难。
- en: A browser’s navigation history can contain sensitive information about which
    websites a user likes visiting, so keeping it secure is important. Surprisingly,
    this is pretty hard, because CSS features like the [`:visited` selector](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
    can be used to [check](https://blog.mozilla.org/security/2010/03/31/plugging-the-css-history-leak/)
    whether a URL has been visited before. For this reason, there are [efforts](https://github.com/kyraseevers/Partitioning-visited-links-history)
    to restrict `:visited`.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的导航历史可能包含有关用户喜欢访问哪些网站等敏感信息，因此保持其安全至关重要。令人惊讶的是，这相当困难，因为CSS特性如`[:visited]`选择器（[https://developer.mozilla.org/en-US/docs/Web/CSS/:visited](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)）可以被用来[检查](https://blog.mozilla.org/security/2010/03/31/plugging-the-css-history-leak/)一个URL是否之前已被访问过。因此，有[努力](https://github.com/kyraseevers/Partitioning-visited-links-history)来限制`:visited`。
- en: Editing the URL
  id: totrans-1280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑URL
- en: One way to go to another page is by clicking on a link. But most browsers also
    allow you to type into the address bar to visit a new URL, if you happen to know
    the URL.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 去往另一个页面的方法之一是通过点击链接。但大多数浏览器也允许你将内容输入到地址栏以访问新的URL，如果你恰好知道该URL。
- en: 'Take a moment to notice the complex ritual of typing in an address (see Figure
    2):'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间注意输入地址的复杂仪式（见图2）：
- en: First, you have to click on the address bar to “focus” on it.
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你必须点击地址栏来“聚焦”它。
- en: That also selects the full address, so that it’s all deleted when you start
    typing.
  id: totrans-1284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这也会选择整个地址，这样当你开始输入时，它就会被全部删除。
- en: Then, letters you type go into the address bar.
  id: totrans-1285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，你输入的字母会进入地址栏。
- en: The address bar updates as you type, but the browser doesn’t yet navigate to
    the new page.
  id: totrans-1286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址栏在你输入时会更新，但浏览器尚未导航到新页面。
- en: Finally, you type the “Enter” key which navigates to a new page.
  id: totrans-1287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你按下“Enter”键，这将导航到新页面。
- en: '![Figure 2: Screenshots of editing in the address bar in Apple Safari 16.6.](img/53214ab03d33ed5df3fae792adf0198e.png)'
  id: totrans-1288
  prefs: []
  type: TYPE_IMG
  zh: '![图2：Apple Safari 16.6中地址栏编辑的截图](img/53214ab03d33ed5df3fae792adf0198e.png)'
- en: 'Figure 2: Screenshots of editing in the address bar in Apple Safari 16.6.'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：Apple Safari 16.6中地址栏编辑的截图
- en: 'These steps suggest that the browser stores the contents of the address bar
    separately from the `url` field, and also that there’s some state to say whether
    you’re currently typing into the address bar. Let’s call the contents `address_bar`
    and the state `focus`:'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤表明浏览器将地址栏的内容与`url`字段分开存储，并且还有一些状态来表示你是否正在地址栏中输入。让我们称内容为`address_bar`，状态为`focus`：
- en: '[PRE280]'
  id: totrans-1291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'Clicking on the address bar should set `focus` and clicking outside it should
    clear `focus`:'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 点击地址栏应该设置`focus`，而点击地址栏外部则应该清除`focus`：
- en: '[PRE281]'
  id: totrans-1293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: Note that clicking on the address bar also clears the address bar contents.
    That’s not quite what a real browser does, but it’s pretty close, and it lets
    us skip adding text selection.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，点击地址栏也会清除地址栏内容。这并不完全符合真实浏览器的行为，但相当接近，并且让我们可以跳过添加文本选择。
- en: 'Now, when we draw the address bar, we need to check whether to draw the current
    URL or the currently typed text:'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们绘制地址栏时，我们需要检查是绘制当前URL还是当前输入的文本：
- en: '[PRE282]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'When the user is typing in the address bar, let’s also draw a cursor. Making
    states (like focus) visible on the screen (like with the cursor) makes software
    easier to use:'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在地址栏中输入时，让我们也绘制一个光标。在屏幕上（如光标所示）使状态（如聚焦）可见可以使软件更容易使用：
- en: '[PRE283]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: Next, when the address bar is focused, we need to support typing in a URL. In
    Tk, you can bind to `<Key>` to capture all key presses. The event object’s `char`
    field contains the character the user typed.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当地址栏被聚焦时，我们需要支持在地址栏中输入URL。在Tk中，你可以绑定到`<Key>`来捕获所有按键。事件对象的`char`字段包含用户输入的字符。
- en: '[PRE284]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: 'This `handle_key` handler starts with some conditions: `<Key>` fires for every
    key press, not just regular letters, so we want to ignore cases where no character
    is typed (a modifier key is pressed) or the character is outside the ASCII range
    (which can represent the arrow keys or function keys). For now let’s have the
    `Browser` send all key presses to `Chrome` and then call `draw()` so that the
    new letters actually show up.'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `handle_key` 处理器从一些条件开始：`<Key>` 对每次按键都会触发，不仅仅是常规字母，所以我们想忽略没有字符输入的情况（按下了修饰键）或者字符在
    ASCII 范围之外（可以表示箭头键或功能键）。目前，让我们让 `Browser` 将所有按键发送到 `Chrome`，然后调用 `draw()`，这样新字母实际上就会显示出来。
- en: 'Then `Chrome` can check `focus` and add on to `address_bar`:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `Chrome` 可以检查 `focus` 并添加到 `address_bar`：
- en: '[PRE285]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 'Finally, once the new URL is entered, we need to handle the “Enter” key, which
    Tk calls `<Return>`, and actually send the browser to the new address:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦输入了新的 URL，我们需要处理“Enter”键，Tk 称为 `<Return>`，并将浏览器发送到新的地址：
- en: '[PRE286]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: So there—after a long chapter, you can now unwind a bit by surfing the web.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，经过漫长的章节，你现在可以通过上网放松一下。
- en: Text editing is [surprisingly complex](https://lord.io/text-editing-hates-you-too/),
    and can be pretty tricky to implement well, especially for languages other than
    English. And nowadays URLs can be written in [any language](https://en.wikipedia.org/wiki/Internationalized_domain_name),
    though modern browsers [restrict this somewhat](https://en.wikipedia.org/wiki/IDN_homograph_attack)
    for security reasons.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 文本编辑 [令人惊讶地复杂](https://lord.io/text-editing-hates-you-too/)，并且实现良好的文本编辑相当棘手，尤其是对于英语以外的语言。如今，URL
    可以用 [任何语言](https://en.wikipedia.org/wiki/Internationalized_domain_name) 编写，尽管出于安全考虑，现代浏览器
    [对此有所限制](https://en.wikipedia.org/wiki/IDN_homograph_attack)。
- en: Summary
  id: totrans-1308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'It’s been a lot of work just to handle links! We had to:'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 仅处理链接就花费了大量工作！我们不得不：
- en: give each word an explicit size and position;
  id: totrans-1310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个单词指定明确的大小和位置；
- en: determine which piece of text a user clicked on;
  id: totrans-1311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定用户点击的文本部分；
- en: split per-page from browser-wide information;
  id: totrans-1312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从浏览器全局信息中分离出每页信息；
- en: draw a tab bar, an address bar, and a back button;
  id: totrans-1313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制标签栏、地址栏和后退按钮；
- en: even implement text editing!
  id: totrans-1314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 甚至可以实施文本编辑！
- en: Now just imagine all the features you can add to your browser!
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下你可以添加到浏览器中的所有功能！
- en: 'And here’s the lab 7 browser. Try using the browser chrome—it works! Our browser
    is starting to look like a real one:'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实验室 7 的浏览器。尝试使用浏览器 chrome——它工作！我们的浏览器开始看起来像一个真正的浏览器：
- en: '[widgets/lab7-browser.html](widgets/lab7-browser.html)'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '[widgets/lab7-browser.html](widgets/lab7-browser.html)'
- en: Outline
  id: totrans-1318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should now
    look something like this:'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整函数、类和方法集现在看起来可能像这样：
- en: '`` class URL: `def __init__(url)` `def request()` `def resolve(url)` `def __str__()`
    `` `` class Text: `def __init__(text, parent)` `def __repr__()` `` `` class Element:
    `def __init__(tag, attributes, parent)` `def __repr__()` `` `def print_tree(node,
    indent)` `def tree_to_list(tree, list)` `` class HTMLParser: `SELF_CLOSING_TAGS`
    `HEAD_TAGS` `def __init__(body)` `def parse()` `def get_attributes(text)` `def
    add_text(text)` `def add_tag(tag)` `def implicit_tags(tag)` `def finish()` ``
    `` class CSSParser: `def __init__(s)` `def whitespace()` `def literal(literal)`
    `def word()` `def ignore_until(chars)` `def pair()` `def selector()` `def body()`
    `def parse()` `` `` class TagSelector: `def __init__(tag)` `def matches(node)`
    `` `` class DescendantSelector: `def __init__(ancestor, descendant)` `def matches(node)`
    `` `FONTS` `def get_font(size, weight, style)` `DEFAULT_STYLE_SHEET` `INHERITED_PROPERTIES`
    `def style(node, rules)` `def cascade_priority(rule)` `WIDTH, HEIGHT` `HSTEP,
    VSTEP` `` class Rect: `def __init__(left, top, right, bottom)` `def contains_point(x,
    y)` `` `BLOCK_ELEMENTS` `` class DocumentLayout: `def __init__(node)` `def layout()`
    `def paint()` `` `` class BlockLayout: `def __init__(node, parent, previous)`
    `def layout_mode()` `def layout()` `def recurse(node)` `def new_line()` `def word(node,
    word)` `def self_rect()` `def paint()` `` `` class LineLayout: `def __init__(node,
    parent, previous)` `def layout()` `def paint()` `` `` class TextLayout: `def __init__(node,
    word, parent, previous)` `def layout()` `def paint()` `` `` class DrawText: `def
    __init__(x1, y1, text, font, color)` `def execute(scroll, canvas)` `` `` class
    DrawRect: `def __init__(rect, color)` `def execute(scroll, canvas)` `` `` class
    DrawLine: `def __init__(x1, y1, x2, y2, color, thickness)` `def execute(scroll,
    canvas)` `` `` class DrawOutline: `def __init__(rect, color, thickness)` `def
    execute(scroll, canvas)` `` `def paint_tree(layout_object, display_list)` `SCROLL_STEP`
    `` class Tab: `def __init__(tab_height)` `def load(url)` `def draw(canvas, offset)`
    `def scrolldown()` `def click(x, y)` `def go_back()` `` `` class Chrome: `def
    __init__(browser)` `def tab_rect(i)` `def paint()` `def click(x, y)` `def keypress(char)`
    `def enter()` `` `` class Browser: `def __init__()` `def draw()` `def new_tab(url)`
    `def handle_down(e)` `def handle_click(e)` `def handle_key(e)` `def handle_enter(e)`
    ``'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: '`` class URL: `def __init__(url)` `def request()` `def resolve(url)` `def __str__()`
    `` `` class Text: `def __init__(text, parent)` `def __repr__()` `` `` class Element:
    `def __init__(tag, attributes, parent)` `def __repr__()` `` `def print_tree(node,
    indent)` `def tree_to_list(tree, list)` `` class HTMLParser: `SELF_CLOSING_TAGS`
    `HEAD_TAGS` `def __init__(body)` `def parse()` `def get_attributes(text)` `def
    add_text(text)` `def add_tag(tag)` `def implicit_tags(tag)` `def finish()` ``
    `` class CSSParser: `def __init__(s)` `def whitespace()` `def literal(literal)`
    `def word()` `def ignore_until(chars)` `def pair()` `def selector()` `def body()`
    `def parse()` `` `` class TagSelector: `def __init__(tag)` `def matches(node)`
    `` `` class DescendantSelector: `def __init__(ancestor, descendant)` `def matches(node)`
    `` `FONTS` `def get_font(size, weight, style)` `DEFAULT_STYLE_SHEET` `INHERITED_PROPERTIES`
    `def style(node, rules)` `def cascade_priority(rule)` `WIDTH, HEIGHT` `HSTEP,
    VSTEP` `` class Rect: `def __init__(left, top, right, bottom)` `def contains_point(x,
    y)` `` `BLOCK_ELEMENTS` `` class DocumentLayout: `def __init__(node)` `def layout()`
    `def paint()` `` `` class BlockLayout: `def __init__(node, parent, previous)`
    `def layout_mode()` `def layout()` `def recurse(node)` `def new_line()` `def word(node,
    word)` `def self_rect()` `def paint()` `` `` class LineLayout: `def __init__(node,
    parent, previous)` `def layout()` `def paint()` `` `` class TextLayout: `def __init__(node,
    word, parent, previous)` `def layout()` `def paint()` `` `` class DrawText: `def
    __init__(x1, y1, text, font, color)` `def execute(scroll, canvas)` `` `` class
    DrawRect: `def __init__(rect, color)` `def execute(scroll, canvas)` `` `` class
    DrawLine: `def __init__(x1, y1, x2, y2, color, thickness)` `def execute(scroll,
    canvas)` `` `` class DrawOutline: `def __init__(rect, color, thickness)` `def
    execute(scroll, canvas)` `` `def paint_tree(layout_object, display_list)` `SCROLL_STEP`
    `` class Tab: `def __init__(tab_height)` `def load(url)` `def draw(canvas, offset)`
    `def scrolldown()` `def click(x, y)` `def go_back()` `` `` class Chrome: `def
    __init__(browser)` `def tab_rect(i)` `def paint()` `def click(x, y)` `def keypress(char)`
    `def enter()` `` `` class Browser: `def __init__()` `def draw()` `def new_tab(url)`
    `def handle_down(e)` `def handle_click(e)` `def handle_key(e)` `def handle_enter(e)`
    ``'
- en: Exercises
  id: totrans-1321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 7-1 *Backspace*. Add support for the backspace key when typing in the address
    bar. Honestly, do this exercise just for your sanity.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 7-1 *退格键*. 在地址栏中输入时添加对退格键的支持。老实说，做这个练习只是为了你的精神健康。
- en: 7-2 *Middle-click*. Add support for middle-clicking on a link (`Button-2`) to
    open it in a new tab. You might want to use a mouse when testing.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 7-2 *中间点击*. 添加对链接（`Button-2`）中间点击以在新标签页中打开它的支持。你可能想在测试时使用鼠标。
- en: 7-3 *Window title*. Browsers set their window title to the contents of the current
    tab’s `<title>` element. Make your browser do the same. (You can call the `title`
    method of `Browser.window` to change the window title.)
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 7-3 *窗口标题*. 浏览器将窗口标题设置为当前标签页的`<title>`元素的内容。让你的浏览器也这样做。（你可以调用`Browser.window`的`title`方法来更改窗口标题。）
- en: 7-4 *Forward*. Add a forward button, which should undo the back button. If the
    most recent navigation action wasn’t a back button, the forward button shouldn’t
    do anything.To accomplish this, you’ll need to keep around history items when
    clicking the back button, and store an index into it for the current page, instead
    of removing them entirely from the array. Draw it in gray in that case, so the
    user isn’t stuck wondering why it doesn’t work. Also draw the back button in gray
    if there’s nowhere to go back to.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 7-4 **前进**. 添加一个前进按钮，它应该取消后退按钮的操作。如果最近的导航操作不是后退按钮，则前进按钮不应执行任何操作。为了实现这一点，你需要在点击后退按钮时保留历史记录项，并为当前页面存储一个索引，而不是将其完全从数组中删除。在这种情况下，将其以灰色绘制，以免用户困惑为什么它不起作用。如果没有可以返回的地方，也应将后退按钮以灰色绘制。
- en: '7-5 *Fragments*. URLs can contain a *fragment*, which comes at the end of a
    URL and is separated from the path by a hash sign `#`. When the browser navigates
    to a URL with a fragment, it should scroll the page so that the element with that
    identifier is at the top of the screen. Also, implement fragment links: relative
    URLs that begin with a `#` don’t load a new page, but instead scroll the element
    with that identifier to the top of the screen. The table of contents on [the web
    version of this chapter](https://browser.engineering/chrome.html) uses fragment
    links.'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 7-5 **片段**. URL可以包含一个**片段**，它位于URL的末尾，由一个哈希符号`#`与路径分开。当浏览器导航到包含片段的URL时，它应该滚动页面，使具有该标识符的元素位于屏幕顶部。此外，实现片段链接：以`#`开头的相对URL不会加载新页面，而是将具有该标识符的元素滚动到屏幕顶部。[该章节的网页版本](https://browser.engineering/chrome.html)中的目录表使用片段链接。
- en: 7-6 *Search*. If the user types something that’s *not* a URL into the address
    bar, make your browser automatically search for it with a search engine. This
    usually means going to a special URL. For example, you can search Google by going
    to `https://google.com/search?q=QUERY`, where `QUERY` is the search query with
    every space replaced by a `+` sign.Actually, you need to escape [lots of punctuation
    characters](https://en.wikipedia.org/wiki/Query_string#URL_encoding) in these
    “query strings”, but that’s kind of orthogonal to this address bar search feature.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 7-6 **搜索**. 如果用户在地址栏中输入的不是URL，让浏览器自动使用搜索引擎搜索它。这通常意味着访问一个特殊的URL。例如，你可以通过访问`https://google.com/search?q=QUERY`来搜索Google，其中`QUERY`是搜索查询，每个空格都被一个加号`+`替换。实际上，你需要在这些“查询字符串”中转义[许多标点符号](https://en.wikipedia.org/wiki/Query_string#URL_encoding)，但这与地址栏搜索功能有点不同。
- en: 7-7 *Visited links*. In real browsers, links you’ve visited before are usually
    purple. Implement that feature. You’ll need to store the set of visited URLs,
    annotate the corresponding HTML elements, and check those annotations when drawing
    the text.Real browsers support special [pseudo-class](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes)
    selectors that select all visited links, which you could implement if you want.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 7-7 **已访问链接**. 在真实浏览器中，之前访问过的链接通常是紫色。实现这个功能。你需要存储已访问URL的集合，注释相应的HTML元素，并在绘制文本时检查这些注释。真实浏览器支持特殊的[伪类选择器](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes)，它可以选择所有已访问链接，如果你愿意，可以实现这个功能。
- en: 7-8 *Bookmarks*. Implement basic *bookmarks*. Add a button to the browser chrome;
    clicking it should bookmark the page. When you’re looking at a bookmarked page,
    that bookmark button should look different (maybe yellow?) to remind the user
    that the page is bookmarked, and clicking it should un-bookmark it. Add a special
    web page, `about:bookmarks`, for viewing the list of bookmarks.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 7-8 **书签**. 实现基本**书签**功能。在浏览器工具栏中添加一个按钮；点击它应该将页面添加为书签。当你查看一个已书签的页面时，那个书签按钮应该看起来不同（可能是黄色？）以提醒用户该页面已被书签，点击它应该取消书签。添加一个特殊的网页，`about:bookmarks`，用于查看书签列表。
- en: 7-9 *Cursor*. Make the left and right arrow keys move the text cursor around
    the address bar when it is focused. Pressing the backspace key should delete the
    character before the cursor, and typing other keys should add characters at the
    cursor. (Remember that the cursor can be before the first character or after the
    last!)
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 7-9 **光标**. 当地址栏获得焦点时，使用左右箭头键移动文本光标。按下退格键应该删除光标前的字符，按下其他键应该在光标处添加字符。（记住，光标可以在第一个字符之前或最后一个字符之后！）
- en: 7-10 *Multiple windows*. Add support for multiple browser windows in addition
    to tabs. This will require keeping track of multiple Tk windows and canvases and
    grouping tabs by their containing window. You’ll also need some way to create
    a new window, perhaps with a keypress such as `Ctrl+N`.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 7-10 *多个窗口*。除了标签页外，还需要支持多个浏览器窗口。这将需要跟踪多个Tk窗口和画布，并按包含窗口对标签页进行分组。你还需要一种方法来创建新窗口，可能是一个按键，比如`Ctrl+N`。
- en: '7-11 *Clicks via the display list*. At the moment, our browser converts a click
    location to page coordinates and then finds the layout object at those coordinates.
    But you could instead first look up the draw command at that location, and then
    go from the draw command to the layout object that generated it. Implement this.
    You’ll need draw commands to know which layout object generated them.Real browsers
    don’t currently do this, but it’s an attractive possibility: display lists are
    pure data structures so access to them is easier to optimize or parallelize than
    the more complicated layout tree.'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 7-11 *通过显示列表进行点击*。目前，我们的浏览器将点击位置转换为页面坐标，然后在这些坐标处找到布局对象。但你可以首先查找该位置的绘制命令，然后从绘制命令到生成它的布局对象。实现这一点。你需要绘制命令来知道哪个布局对象生成了它们。真正的浏览器目前还没有这样做，但这是一个吸引人的可能性：显示列表是纯数据结构，因此对它们的访问更容易优化或并行化，比更复杂的布局树更简单。
- en: Sending Information to Servers
  id: totrans-1333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向服务器发送信息
- en: Chapter 8 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '[Web浏览器工程](./index.html "目录")的第8章。'
- en: '[How Forms Work](#how-forms-work)'
  id: totrans-1335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表单的工作原理](#how-forms-work)'
- en: '[Rendering Widgets](#rendering-widgets)'
  id: totrans-1336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[渲染小部件](#rendering-widgets)'
- en: '[Interacting with Widgets](#interacting-with-widgets)'
  id: totrans-1337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[与小部件交互](#interacting-with-widgets)'
- en: '[Submitting Forms](#submitting-forms)'
  id: totrans-1338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提交表单](#submitting-forms)'
- en: '[How web apps work](#how-web-apps-work)'
  id: totrans-1339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[网络应用程序的工作原理](#how-web-apps-work)'
- en: '[Receiving POST Requests](#receiving-post-requests)'
  id: totrans-1340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[接收POST请求](#receiving-post-requests)'
- en: '[Generating Web Pages](#generating-web-pages)'
  id: totrans-1341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[生成网页](#generating-web-pages)'
- en: '[Summary](#summary)'
  id: totrans-1342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summary)'
- en: '[Outline](#outline)'
  id: totrans-1343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大纲](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-1344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: So far, our browser has seen the web as read-only—but when you post on Facebook,
    fill out a survey, or search Google, you’re sending information *to* servers as
    well as receiving information *from* them. In this chapter, we’ll start to transform
    our browser into a platform for web applications by building out support for HTML
    forms, the simplest way for a browser to send information to a server.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的浏览器将网络视为只读——但是当你发布到Facebook、填写调查问卷或搜索Google时，你不仅从服务器接收信息，还会向服务器发送信息。在本章中，我们将通过构建对HTML表单的支持来开始将我们的浏览器转变为一个支持网络应用程序的平台，HTML表单是浏览器向服务器发送信息的简单方式。
- en: How Forms Work
  id: totrans-1346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单的工作原理
- en: HTML forms have a couple of moving parts.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: HTML表单有几个组成部分。
- en: 'First, in HTML there is a `form` element, which contains `input` elements,There
    are other elements similar to `input`, such as `select` and `textarea`. They work
    similarly enough; they just represent different kinds of user controls, like dropdowns
    and multi-line inputs. which in turn can be edited by the user. So a form might
    be written like this (see results in Figure 1):'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在HTML中有一个`form`元素，它包含`input`元素，还有其他类似`input`的元素，例如`select`和`textarea`。它们的工作方式足够相似；它们只是代表不同种类的用户控件，比如下拉菜单和多行输入框。用户可以编辑这些控件。因此，一个表单可能写成这样（见图1）：
- en: '[PRE287]'
  id: totrans-1349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '![Figure 1: The example form in our browser.](img/0fbc48b9af84530d70a31aacf05c8b72.png)'
  id: totrans-1350
  prefs: []
  type: TYPE_IMG
  zh: '![图1：浏览器中的示例表单](img/0fbc48b9af84530d70a31aacf05c8b72.png)'
- en: 'Figure 1: The example form in our browser.'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：浏览器中的示例表单。
- en: 'This form contains two text entry boxes called `name` and `comment`. When the
    user goes to this page, they can click on those boxes to edit their values. Then,
    when they click the button at the end of the form, the browser collects all of
    the name–value pairs and bundles them into an HTTP `POST` request (as indicated
    by the `method` attribute), sent to the URL given by the `form` element’s `action`
    attribute, with the usual rules of relative URLs—so in this case, `/submit`. The
    `POST` request looks like this:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单包含两个名为`name`和`comment`的文本输入框。当用户访问此页面时，他们可以点击这些框来编辑它们的值。然后，当他们在表单末尾点击按钮时，浏览器会收集所有的名称-值对并将它们打包成一个HTTP
    `POST`请求（如`method`属性所示），发送到由`form`元素的`action`属性指定的URL，遵循相对URL的常规规则——因此在这种情况下，`/submit`。`POST`请求看起来像这样：
- en: '[PRE288]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: In other words, it’s a lot like the regular `GET` requests we’ve already seen,
    except that it has a body—you’ve already seen HTTP responses with bodies, but
    requests can have them too. Note the `Content-Length` header; it’s mandatory for
    `POST` requests. The server responds to this request with a web page, just like
    normal, and the browser then does everything it normally does.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它和我们已经看到的常规`GET`请求非常相似，只是它有一个主体——你已经看到了带有主体的HTTP响应，但请求也可以有主体。注意`Content-Length`头；它是`POST`请求的强制要求。服务器以网页的形式响应这个请求，就像正常一样，然后浏览器执行它通常所做的所有操作。
- en: Implementing forms requires extending many parts of the browser, from implementing
    HTTP `POST` through new layout objects that draw `input` elements to handling
    buttons clicks. That makes it a great starting point for transforming our browser
    into an application platform, our goal for the next few chapters. Let’s get started
    implementing it all!
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 实现表单需要扩展浏览器的许多部分，从实现HTTP `POST`到绘制`input`元素的新布局对象，再到处理按钮点击。这使得它成为将我们的浏览器转变为应用平台的一个很好的起点，这是我们接下来几章的目标。让我们开始实现它吧！
- en: 'HTML forms were first standardized in [HTML+](https://www.w3.org/MarkUp/htmlplus_paper/htmlplus.html),
    which also proposed tables, mathematical equations, and text that wraps around
    images. Amazingly, all three of these technologies survive, but in totally different
    standards: tables in [RFC 1942](https://datatracker.ietf.org/doc/html/rfc1942),
    equations in [MathML](https://www.w3.org/Math/), and floating images in [CSS 1.0](https://www.w3.org/TR/REC-CSS1/#floating-elements).'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: HTML表单最初在[HTML+](https://www.w3.org/MarkUp/htmlplus_paper/htmlplus.html)中标准化，该规范还提出了表格、数学方程和围绕图像的文字环绕。令人惊讶的是，这三项技术都幸存了下来，但它们的标准完全不同：表格在[RFC
    1942](https://datatracker.ietf.org/doc/html/rfc1942)、方程在[MathML](https://www.w3.org/Math/)、浮动图像在[CSS
    1.0](https://www.w3.org/TR/REC-CSS1/#floating-elements)。
- en: Rendering Widgets
  id: totrans-1357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染小部件
- en: First, let’s draw the input areas that the user will type into.Most applications
    use OS libraries to draw input areas, so that those input areas look like other
    applications on that OS. But browsers need a lot of control over application styling,
    so they often draw their own input areas. Input areas are inline content, laid
    out in lines next to text. So to support inputs we’ll need a new kind of layout
    object, which I’ll call `InputLayout`. We can copy `TextLayout` and use it as
    a template, though we’ll need to make some quick edits.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们绘制用户将要输入的输入区域。大多数应用程序使用操作系统库来绘制输入区域，以便这些输入区域看起来像该操作系统上的其他应用程序。但是，浏览器需要对应用程序样式有更多的控制，因此它们通常会绘制自己的输入区域。输入区域是行内内容，布局在文本旁边。因此，为了支持输入，我们需要一种新的布局对象，我将称之为`InputLayout`。我们可以复制`TextLayout`并将其用作模板，尽管我们需要做一些快速编辑。
- en: 'First, there’s no `word` argument to `InputLayout`s:'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`InputLayout`没有`word`参数：
- en: '[PRE289]'
  id: totrans-1360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'Second, `input` elements usually have a fixed width:'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`input`元素通常具有固定的宽度：
- en: '[PRE290]'
  id: totrans-1362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: 'The `input` and `button` elements need to be visually distinct so the user
    can find them easily. Our browser’s styling capabilities are limited, so let’s
    use background color to do that:'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '`input`和`button`元素需要在视觉上明显区分，以便用户可以轻松找到它们。我们浏览器的样式功能有限，所以让我们使用背景颜色来实现这一点：'
- en: '[PRE291]'
  id: totrans-1364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'When the browser paints an `InputLayout` it needs to draw the background:'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器绘制`InputLayout`时，它需要绘制背景：
- en: '[PRE292]'
  id: totrans-1366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'It then needs to get the input element’s text contents:'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它需要获取输入元素的文本内容：
- en: '[PRE293]'
  id: totrans-1368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'Note that `<button>` elements can in principle contain complex HTML, not just
    a text node. That’s too complicated for this chapter, so I’m having the browser
    print a warning and skip the text in that case.See Exercise 8-8. Finally, we draw
    that text:'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`<button>`元素原则上可以包含复杂的HTML，而不仅仅是文本节点。这对于本章来说太复杂了，所以我让浏览器打印一个警告并跳过该文本。参见练习8-8。最后，我们绘制这段文本：
- en: '[PRE294]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: By this point in the book, you’ve seen many layout objects, so I’m glossing
    over these changes. The point is that new layout objects are one common way to
    extend the browser.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一部分，你已经看到了许多布局对象，所以我将略过这些变化。重点是新的布局对象是扩展浏览器的一种常见方式。
- en: 'We now need to create some `InputLayout`s, which we can do in `BlockLayout`:'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要创建一些`InputLayout`，我们可以在`BlockLayout`中完成这个任务：
- en: '[PRE295]'
  id: totrans-1373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: Finally, this new `input` method is similar to the `text` method, creating a
    new layout object and adding it to the current line:It’s so similar in fact that
    they only differ in how they compute `w`. I’ll resist the temptation to refactor
    this code until we get to [Chapter 15](embeds.html).
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这种新的`input`方法与`text`方法相似，创建一个新的布局对象并将其添加到当前行：事实上，它们如此相似，以至于它们仅在计算`w`的方式上有所不同。我将在我们到达[第15章](embeds.html)之前抵制重构这段代码的诱惑。
- en: '[PRE296]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: But actually, there are a couple more complications due to the way we decided
    to resolve the block-mixed-with-inline-siblings problem (see [Chapter 5](layout.html#layout-modes)).
    One is that if there are no children for a node, we assume it’s a block element.
    But `<input>` elements don’t have children, yet must have inline layout or else
    they won’t draw correctly. Likewise, a `<button>` does have children, but they
    are treated specially.This situation is specific to these elements in our browser,
    but only because they are the only elements with special painting behavior within
    an inline context. These are also two examples of [atomic inlines](https://www.w3.org/TR/CSS2/visuren.html#inline-boxes).
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，由于我们决定解决块级与内联兄弟元素混合的问题（见[第5章](layout.html#layout-modes)），还有一些额外的复杂性。一个是如果一个节点没有子节点，我们假设它是一个块级元素。但是
    `<input>` 元素没有子节点，但必须具有内联布局，否则它们将无法正确绘制。同样，一个 `<button>` 元素确实有子节点，但它们被特别处理。这种情况仅限于我们浏览器中的这些元素，但仅因为它们是内联上下文中唯一具有特殊绘制行为的元素。这些也是[原子内联](https://www.w3.org/TR/CSS2/visuren.html#inline-boxes)的两个例子。
- en: 'We can fix that with this change to `layout_mode` to add a second condition
    for returning “inline”:'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改 `layout_mode` 来修复这个问题，添加一个返回“内联”的第二个条件：
- en: '[PRE297]'
  id: totrans-1378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: The second problem is that, again due to having block siblings, sometimes an
    `<input>` or `<button>` element will create a `BlockLayout` (which will then create
    an `InputLayout` inside). In this case we don’t want to paint the background twice,
    so let’s add some simple logic to skip painting it in `BlockLayout` in this case,
    via a new `should_paint` method:Recall (see [Chapter 5](layout.html#block-layout))
    that we only get into this situation due to the presence of anonymous block boxes.
    Also, it’s worth noting that there are various other ways that our browser does
    not fully implement all the complexities of inline painting—one example is that
    it does not correctly paint nested inlines with different background colors. Inline
    layout and paint are very complicated in real browsers.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是，由于有块级兄弟元素，有时一个 `<input>` 或 `<button>` 元素将创建一个 `BlockLayout`（然后将在其中创建一个
    `InputLayout`）。在这种情况下，我们不希望绘制两次背景，所以让我们添加一些简单的逻辑来跳过在 `BlockLayout` 中的绘制，通过一个新的
    `should_paint` 方法：回想一下（见[第5章](layout.html#block-layout)），我们之所以进入这种情况，是因为存在匿名块级框。还值得注意的是，我们的浏览器没有完全实现内联绘制的各种复杂性——一个例子是它没有正确绘制具有不同背景颜色的嵌套内联元素。内联布局和绘制在真实浏览器中非常复杂。
- en: '[PRE298]'
  id: totrans-1380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'Add a trivial `should_paint` method that just returns `True` to all of the
    other layout object types. Now we can skip painting objects based on `should_paint`:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有其他布局对象类型添加一个简单的 `should_paint` 方法，它只返回 `True`。现在我们可以根据 `should_paint` 跳过绘制对象：
- en: '[PRE299]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: With these changes the browser should now draw `input` and `button` elements
    as blue and orange rectangles.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些更改后，浏览器现在应该将 `input` 和 `button` 元素绘制为蓝色和橙色的矩形。
- en: 'The reason buttons surround their contents but input areas don’t is that a
    button can contain images, styled text, or other content. In a real browser, that
    relies on the [`inline-block`](https://developer.mozilla.org/en-US/docs/Web/CSS/display)
    display mode: a way of putting a block element into a line of text. There’s also
    an older `<input type=button>` syntax more similar to text inputs.'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮包围其内容而输入区域不包围的原因是按钮可以包含图像、样式化文本或其他内容。在真实浏览器中，这依赖于 `inline-block` 显示模式：一种将块级元素放入文本行中的方法。还有一个更老的
    `<input type=button>` 语法，与文本输入更相似。
- en: Interacting with Widgets
  id: totrans-1385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与小部件交互
- en: We’ve got `input` elements rendering, but you can’t edit their contents yet.
    But of course that’s the whole point! So let’s make `input` elements work like
    the address bar does—clicking on one will clear it and let you type into it.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得到了渲染的 `input` 元素，但你还不能编辑它们的内联内容。但当然，这正是重点！所以让我们让 `input` 元素像地址栏一样工作——点击它将清除它并允许你输入。
- en: 'Clearing is easy, another case inside `Tab`’s `click` method:'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 清除很简单，另一个在 `Tab` 的 `click` 方法中的情况：
- en: '[PRE300]'
  id: totrans-1388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: However, if you try this, you’ll notice that clicking does not actually clear
    the `input` element. That’s because the code above updates the HTML tree—but we
    need to update the layout tree and then the display list for the change to appear
    on the screen.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试这样做，你会注意到点击实际上并没有清除 `input` 元素。这是因为上面的代码更新了 HTML 树，但我们还需要更新布局树和显示列表，以便更改出现在屏幕上。
- en: 'Right now, the layout tree and display list are computed in `load`, but we
    don’t want to reload the whole page; we just want to redo the styling, layout,
    paint and draw phases. Together these are called *rendering*. So let’s extract
    these phases into a new `Tab` method, `render`:'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，布局树和显示列表是在`load`方法中计算的，但我们不想重新加载整个页面；我们只想重新执行样式、布局、绘制和绘制阶段。这些阶段统称为*渲染*。因此，让我们将这些阶段提取到一个新的`Tab`方法`render`中：
- en: '[PRE301]'
  id: totrans-1391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: For this code to work, you’ll also need to change `nodes` and `rules` from local
    variables in the `load` method to new fields on a `Tab`. Note that styling moved
    from `load` to `render`, but downloading the style sheets didn’t—we don’t re-download
    the style sheetsActually, some changes to the web page could delete existing `link`
    nodes or create new ones. Real browsers respond to this correctly, either removing
    the rules corresponding to deleted `link` nodes or downloading new style sheets
    when new `link` nodes are created. This is tricky to get right, and typing into
    an input area definitely can’t make such changes, so let’s skip this in our browser.
    every time you type!
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此代码正常工作，你还需要将`nodes`和`rules`从`load`方法中的局部变量更改为`Tab`上的新字段。注意，样式已从`load`移动到`render`，但下载样式表没有——我们不重新下载样式表。实际上，对网页的一些更改可能会删除现有的`link`节点或创建新的节点。真实浏览器会正确响应这一点，要么删除与已删除的`link`节点对应的规则，要么在创建新的`link`节点时下载新的样式表。这很棘手，而且在输入区域中输入肯定不能做出这样的更改，所以让我们在我们的浏览器中跳过这一点！每次你输入时！
- en: 'Now when we click an `input` element and clear its contents, we can call `render`
    to redraw the page with the `input` cleared:'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们点击一个`input`元素并清除其内容时，我们可以调用`render`来重新绘制页面，其中`input`已被清除：
- en: '[PRE302]'
  id: totrans-1394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'So that’s clicking in an `input` area. But typing is harder. Think back to
    how we [implemented the address bar in Chapter 7](chrome.html): we added a `focus`
    field that remembered what we clicked on so we could later send it our key presses.
    We need something like that `focus` field for input areas, but it’s going to be
    more complex because the input areas live inside a `Tab`, not inside the `Browser`.'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是在`input`区域点击。但输入更复杂。回想一下我们在第7章中[实现地址栏的方式](chrome.html)：我们添加了一个`focus`字段来记住我们点击的内容，这样我们就可以稍后发送按键。我们需要为输入区域添加类似`focus`字段的东西，但它会更复杂，因为输入区域位于`Tab`内部，而不是`浏览器`内部。
- en: 'Naturally, we will need a `focus` field on each `Tab`, to remember which text
    entry (if any) we’ve recently clicked on:'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们将在每个`Tab`上需要一个`focus`字段，以记住我们最近点击的文本输入（如果有的话）：
- en: '[PRE303]'
  id: totrans-1397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: 'Now when we click on an input element, we need to set `focus` (and clear focus
    if nothing was found to focus on):'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们点击一个输入元素时，我们需要设置`focus`（如果找不到要聚焦的内容，则清除焦点）：
- en: '[PRE304]'
  id: totrans-1399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: But remember that keyboard input isn’t handled by the `Tab`—it’s handled by
    the `Browser`. So how does the `Browser` even know when keyboard events should
    be sent to the `Tab`? The `Browser` has to remember that in its own `focus` field!
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 但记住，键盘输入不是由`Tab`处理的——它是由`浏览器`处理的。那么`浏览器`是如何知道何时将键盘事件发送到`Tab`的呢？`浏览器`必须记住这一点在其自己的`focus`字段中！
- en: 'In other words, when you click on the web page, the `Browser` updates its `focus`
    field to remember that the user is interacting with the page, not the browser
    chrome. And if so, it should unfocus (“blur”) the browser chrome:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当你点击网页时，`浏览器`会更新其`focus`字段以记住用户正在与页面而不是浏览器界面进行交互。如果是这样，它应该取消焦点（“blur”）浏览器界面：
- en: '[PRE305]'
  id: totrans-1402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-1403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: The `if` branch that corresponds to clicks in the browser chrome unsets `focus`,
    meaning focus is no longer on the page contents, and key presses will thus be
    sent to the `Chrome`.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 对应于浏览器界面点击的`if`分支取消`focus`设置，这意味着焦点不再在页面内容上，因此按键将被发送到`Chrome`。
- en: 'When a key press happens, the `Browser` either sends it to the address bar
    or calls the active tab’s `keypress` method (or neither, if nothing is focused):'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生按键操作时，`浏览器`会将按键发送到地址栏或调用活动标签页的`keypress`方法（如果没有焦点，则两者都不做）：
- en: '[PRE307]'
  id: totrans-1406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: 'Here I’ve changed `keypress` to return true if the browser chrome consumed
    the key:'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将`keypress`修改为如果浏览器界面消耗了按键则返回`true`：
- en: '[PRE308]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: 'That `keypress` method then uses the tab’s `focus` field to put the character
    in the right text entry:'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`keypress`方法使用标签页的`focus`字段将字符放入正确的文本输入中：
- en: '[PRE309]'
  id: totrans-1410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: Note that here we call `render` instead of `draw`, because we’ve modified the
    web page and thus need to regenerate the display list instead of just redrawing
    it to the screen.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里我们调用`render`而不是`draw`，因为我们已经修改了网页，因此需要重新生成显示列表，而不是仅仅将其重绘到屏幕上。
- en: Hierarchical focus handling is an important pattern for combining graphical
    widgets; in a real browser, where web pages can be embedded into one another with
    `iframe`s,The `iframe` element allows you to embed one web page into another as
    a little window. We’ll talk about this more in [Chapter 15](embeds.html). the
    focus tree can be arbitrarily deep.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 层次化焦点处理是组合图形小部件的重要模式；在一个真实的浏览器中，网页可以通过`iframe`相互嵌入，`iframe`元素允许你将一个网页嵌入到另一个中作为一个小窗口。我们将在第15章[嵌入](embeds.html)中详细讨论这一点，焦点树可以任意深。
- en: 'So now we have user input working with `input` elements. Before we move on,
    there is one last tweak that we need to make: drawing the text cursor in the `Tab`’s
    `render` method. This turns out to be harder than expected: the cursor should
    be drawn by the `InputLayout` of the focused node, and that means that each node
    has to know whether or not it’s focused:'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让用户输入通过`input`元素工作。在我们继续之前，我们还需要进行最后一次调整：在`Tab`的`render`方法中绘制文本光标。这比预期的要困难：光标应该由焦点节点的`InputLayout`绘制，这意味着每个节点都必须知道它是否被聚焦：
- en: '[PRE310]'
  id: totrans-1414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: 'Add the same field to `Text` nodes; they’ll never be focused and never draw
    cursors, but it’s more convenient if `Text` and `Element` have the same fields.
    We’ll set this when we move focus to an input element:'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的字段添加到`Text`节点；它们永远不会被聚焦且永远不会绘制光标，但如果`Text`和`Element`有相同的字段会更方便。我们将在这个时候将焦点移动到输入元素：
- en: '[PRE311]'
  id: totrans-1416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: 'Note that we have to un-focus the currently focused element, lest it keep drawing
    its cursor. Anyway, now we can draw a cursor if an `input` element is focused:'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须取消当前聚焦元素的聚焦，以免它继续绘制其光标。无论如何，现在如果`input`元素被聚焦，我们就可以绘制光标：
- en: '[PRE312]'
  id: totrans-1418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: Now you can click on a text entry, type into it, and modify its value. The next
    step is submitting the now-filled-out form.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以点击一个文本输入框，在其中输入文本，并修改其值。下一步是提交现在已填写的表单。
- en: This approach to drawing the text cursor—having the `InputLayout` draw it—allows
    visual effects to apply to the cursor, as we’ll see in [Chapter 11](visual-effects.html).
    But not every browser does it this way. Chrome, for example, keeps track of a
    global [focused element](https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/document.h;l=881;drc=80def040657db16e79f59e7e3b27857014c0f58d)
    to make sure the cursor can be [globally styled](https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/frame_caret.h?q=framecaret&ss=chromium).
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 这种绘制文本光标的方法——让`InputLayout`绘制它——允许将视觉效果应用于光标，正如我们将在第11章[视觉效果](visual-effects.html)中看到的。但并非每个浏览器都这样做。例如，Chrome会跟踪一个全局[聚焦元素](https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/document.h;l=881;drc=80def040657db16e79f59e7e3b27857014c0f58d)，以确保光标可以被[全局样式化](https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/frame_caret.h?q=framecaret&ss=chromium)。
- en: Submitting Forms
  id: totrans-1421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交表单
- en: 'You submit a form by clicking on a `button`. So let’s add another condition
    to the big `while` loop in `click`:'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过点击一个`button`来提交表单。所以让我们在`click`中的大`while`循环中添加另一个条件：
- en: '[PRE313]'
  id: totrans-1423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: 'Once we’ve found the button, we need to find the form that it’s in by walking
    up the HTML tree:'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了按钮，我们需要通过遍历HTML树来找到它所在的表单：
- en: '[PRE314]'
  id: totrans-1425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: 'The `submit_form` method is then in charge of finding all of the input elements,
    encoding them in the right way, and sending the `POST` request. First, we look
    through all the descendents of the `form` to find `input` elements:'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`submit_form`方法负责找到所有的输入元素，以正确的方式编码它们，并发送`POST`请求。首先，我们遍历`form`的所有后代以找到`input`元素：
- en: '[PRE315]'
  id: totrans-1427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: 'For each of those `input` elements, we need to extract the `name` attribute
    and the `value` attribute, and *form encode* both of them. Form encoding is how
    the name–value pairs are formatted in the HTTP `POST` request. Basically, it is:
    name, then equal sign, then value; and name–value pairs are separated by ampersands:'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些`input`元素中的每一个，我们需要提取`name`属性和`value`属性，并将它们都进行表单编码。表单编码是HTTP `POST`请求中名称-值对格式化的方式。基本上，它是：名称，然后是等号，然后是值；名称-值对由和号分隔：
- en: '[PRE316]'
  id: totrans-1429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: Here, `body` initially has an extra `&` tacked on to the front, which is removed
    on the last line.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`body`最初在前面额外添加了一个`&`，这在最后一行被移除。
- en: 'Now, any time you see special syntax like this, you’ve got to ask: what if
    the name or the value has an equal sign or an ampersand in it? So in fact, “percent
    encoding” replaces all special characters with a percent sign followed by those
    characters’ hex codes. For example, a space becomes `%20` and a period becomes
    `%2e`. Python provides a percent-encoding function as `quote` in the `urllib.parse`
    module:You can write your own `percent_encode` function using Python’s `ord` and
    `hex` functions if you like. I’m using the standard function for expediency. [In
    Chapter 1](http.html), using these library functions would have obscured key concepts,
    but by this point percent encoding is necessary but not conceptually interesting.'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次你看到这样的特殊语法时，你都必须问自己：如果名称或值中包含等号或和号怎么办？所以实际上，“百分编码”将所有特殊字符替换为百分号后跟这些字符的十六进制代码。例如，空格变为`%20`，点号变为`%2e`。Python在`urllib.parse`模块中提供了一个百分编码函数，名为`quote`：如果你喜欢，你可以使用Python的`ord`和`hex`函数编写自己的`percent_encode`函数。我使用标准函数是为了方便。在[第一章](http.html)中，使用这些库函数会掩盖关键概念，但到这一点，百分编码是必要的，但概念上并不有趣。
- en: '[PRE317]'
  id: totrans-1432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: 'Now that `submit_form` has built a request body, it needs to make a `POST`
    request. I’m going to defer that responsibility to the `load` function, which
    handles making requests:'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`submit_form`已经构建了请求体，它需要发送一个`POST`请求。我将把这个责任推迟到`load`函数，它负责发送请求：
- en: '[PRE318]'
  id: totrans-1434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: 'The new `payload` argument to `load` is then passed through to `request`:'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '`load`的新`payload`参数随后传递给`request`：'
- en: '[PRE319]'
  id: totrans-1436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'In `request`, this new argument is used to decide between a `GET` and a `POST`
    request:'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 在`request`中，这个新参数用于在`GET`和`POST`请求之间进行选择：
- en: '[PRE320]'
  id: totrans-1438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: 'If it’s a `POST` request, the `Content-Length` header is mandatory:'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是`POST`请求，则`Content-Length`头是必需的：
- en: '[PRE321]'
  id: totrans-1440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'Note that the `Content-Length` is the length of the payload in bytes, which
    might not be equal to its length in letters.Because characters from many languages
    take up multiple bytes. Finally, after the headers, we send the payload itself:'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Content-Length`是有效载荷的字节长度，这可能与字母长度不相等。因为许多语言的字符占用多个字节。最后，在头部之后，我们发送有效载荷本身：
- en: '[PRE322]'
  id: totrans-1442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: So that’s how the `POST` request gets sent. Then the server responds with an
    HTML page and the browser will render it in the totally normal way.Actually, because
    browsers treat going “back” to a `POST`-requested page specially (see Exercise
    8-5), it’s common to respond to a `POST` request with a redirect. That’s basically
    it for forms!
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`POST`请求就被发送了。然后服务器响应一个HTML页面，浏览器将以完全正常的方式渲染它。实际上，因为浏览器特别对待“返回”到`POST`请求的页面（见练习8-5），所以通常会对`POST`请求进行重定向。这就是表单的全部内容！
- en: While most form submissions use the form encoding described here, forms with
    file uploads (using `<input type=file>`) use a [different encoding](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)
    that includes metadata for each key–value pair (like the file name or file type).
    There’s also an obscure [`text/plain` encoding](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#text/plain-encoding-algorithm)
    option, which uses no escaping and which even the standard warns against using.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数表单提交使用这里描述的表单编码，但带有文件上传（使用`<input type=file>`）的表单使用一种[不同的编码](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)，它包括每个键值对（如文件名或文件类型）的元数据。还有一个鲜为人知的[`text/plain`编码](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#text/plain-encoding-algorithm)选项，它不进行转义，甚至标准也警告不要使用它。
- en: How web apps work
  id: totrans-1445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用的工作原理
- en: 'So … how do web applications (web apps) use forms? When you use an application
    from your browser—whether you are registering to vote, looking at pictures of
    your baby cousin, or checking your email—there are typicallyHere I’m talking in
    general terms. There are some browser applications without a server, and others
    where the client code is exceptionally simple and almost all the code is on the
    server. two programs involved: client code that runs in the browser, and server
    code that runs on the server. When you click on things or take actions in the
    application, that runs client code, which then sends data to the server via HTTP
    requests.'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 那么……网络应用程序（网络应用）是如何使用表单的？当你从浏览器中使用一个应用程序——无论你是注册投票、查看你表亲的照片，还是检查你的电子邮件——通常有两个程序参与：运行在浏览器中的客户端代码和运行在服务器上的服务器代码。当你点击或采取应用程序中的操作时，它会运行客户端代码，然后通过HTTP请求将数据发送到服务器。
- en: For example, imagine a simple message board application. The server stores the
    state of the message board—who has posted what—and has logic for updating that
    state. But all the actual interaction with the page—drawing the posts, letting
    the user enter new ones—happens in the browser. Both components are necessary.
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个简单的留言板应用程序。服务器存储留言板的状态——谁发布了什么——并且有更新该状态的逻辑。但与页面的所有实际交互——绘制帖子、让用户输入新的帖子——都是在浏览器中发生的。这两个组件都是必要的。
- en: The browser and the server interact over HTTP. The browser first makes a `GET`
    request to the server to load the current message board. The user interacts with
    the browser to type a new post, and submits it to the server (say, via a form).
    That causes the browser to make a `POST` request to the server, which instructs
    the server to update the message board state. The server then needs the browser
    to update what the user sees; with forms, the server sends a new HTML page in
    its response to the `POST` request. This process is shown in Figure 2.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器和服务器通过HTTP进行交互。浏览器首先向服务器发送一个`GET`请求来加载当前留言板。用户与浏览器交互，输入新的帖子，并将其提交给服务器（例如，通过表单）。这导致浏览器向服务器发送一个`POST`请求，指示服务器更新留言板状态。然后服务器需要浏览器更新用户所看到的内容；通过表单，服务器在响应`POST`请求时发送一个新的HTML页面。这个过程如图2所示。
- en: '![Figure 2: The cycle of request and response for a multi-page application.](img/4962047e872602609aaf8402fbdd795a.png)'
  id: totrans-1449
  prefs: []
  type: TYPE_IMG
  zh: '![图2：多页应用程序的请求和响应循环](img/4962047e872602609aaf8402fbdd795a.png)'
- en: 'Figure 2: The cycle of request and response for a multi-page application.'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：多页应用程序的请求和响应循环。
- en: Forms are a simple, minimal introduction to this cycle of request and response
    and make a good introduction to how browser applications work. They’re also implemented
    in every browser and have been around for decades. These days many web applications
    use the form elements, but replace synchronous `POST` requests with asynchronous
    ones driven by Javascript,In the early 2000s, the adoption of asynchronous HTTP
    requests sparked the wave of innovative new web applications called [Web 2.0](https://en.wikipedia.org/wiki/Web_2.0).
    which makes applications snappier by hiding the time to make the HTTP request.
    In return for that snappiness, that JavaScript code must now handle errors, validate
    inputs, and indicate loading time. In any case, both synchronous and asynchronous
    uses of forms are based on the same principles of client and server code.
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是对请求和响应循环的简单、最小化介绍，也是了解浏览器应用程序工作原理的良好入门。它们在所有浏览器中都有实现，并且已经存在了几十年。如今，许多网络应用程序使用表单元素，但用由JavaScript驱动的异步`POST`请求替换了同步请求，通过隐藏HTTP请求的时间来使应用程序更加迅速。作为对这种迅速的回报，JavaScript代码现在必须处理错误、验证输入并指示加载时间。无论如何，表单的同步和异步使用都基于客户端和服务器代码的相同原则。
- en: There are request types besides `GET` and `POST`, like [`PUT`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT)
    (create if non-existent) and [`DELETE`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE),
    or the more obscure `CONNECT` and `TRACE`. In 2010 the [`PATCH` method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH)
    was standardized in [RFC 5789](https://datatracker.ietf.org/doc/html/rfc5789).
    New methods were intended as a standard extension mechanism for HTTP, and some
    protocols were built this way (like [WebDav](https://en.wikipedia.org/wiki/WebDAV)’s
    `PROPFIND`, `MOVE`, and `LOCK` methods), but this did not become an enduring way
    to extend the web itself, and HTTP 2.0 and 3.0 did not add any new methods.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`GET`和`POST`之外，还有其他请求类型，如`PUT`（如果不存在则创建）和`DELETE`，或者更不为人知的`CONNECT`和`TRACE`。2010年，`PATCH`方法在[RFC
    5789](https://datatracker.ietf.org/doc/html/rfc5789)中被标准化。新的方法被设计为HTTP的标准扩展机制，一些协议就是这样构建的（如[WebDav](https://en.wikipedia.org/wiki/WebDAV)的`PROPFIND`、`MOVE`和`LOCK`方法），但这并没有成为扩展网络本身的持久方式，HTTP
    2.0和3.0也没有添加任何新方法。
- en: Receiving POST Requests
  id: totrans-1453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收POST请求
- en: To better understand the request/response cycle, let’s write a simple web server.
    It’ll implement an online guest book,They were very hip in the 1990s—comment threads
    from before there was anything to comment on. kind of like an open, anonymous
    comment thread. Now, this is a book on web *browser* engineering, so I won’t discuss
    web server implementation that thoroughly. But I want you to see how the server
    side of an application works.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解请求/响应周期，让我们编写一个简单的网络服务器。它将实现一个在线留言簿，它们在20世纪90年代非常流行——在可以评论之前就已经存在的评论线程。有点像开放的、匿名的评论线程。现在，这是一本关于网络**浏览器**工程的书籍，所以我不打算详细讨论网络服务器的实现。但我希望你能看到应用程序的客户端是如何工作的。
- en: 'A web server is a separate program from the web browser, so let’s start a new
    file. The server will need to:'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器是独立于网络浏览器的程序，因此让我们开始创建一个新的文件。服务器需要执行以下操作：
- en: open a socket and listen for connections;
  id: totrans-1456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个套接字并监听连接；
- en: parse HTTP requests it receives;
  id: totrans-1457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析它接收到的HTTP请求；
- en: respond to those requests with an HTML web page.
  id: totrans-1458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML网页响应这些请求。
- en: 'Let’s start by opening a socket. Like for the browser, we need to create an
    internet streaming socket using TCP:'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开一个套接字开始。就像浏览器一样，我们需要使用TCP创建一个互联网流套接字：
- en: '[PRE323]'
  id: totrans-1460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: The `setsockopt` call is optional. Normally, when a program has a socket open
    and it crashes, your OS prevents that port from being reusedWhen your process
    crashes, the computer on the end of the connection won’t be informed immediately;
    if some other process opens the same port, it could receive data meant for the
    old, now-dead process. for a short period. That’s annoying when developing a server;
    calling `setsockopt` with the `SO_REUSEADDR` option allows the OS to immediately
    reuse the port.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: '`setsockopt`调用是可选的。通常，当一个程序打开套接字并崩溃时，你的操作系统会防止该端口在短时间内被重用。当你的进程崩溃时，连接另一端的计算机不会立即得到通知；如果其他进程打开了相同的端口，它可能会接收到原本为旧、现在已死进程的数据。这在开发服务器时很烦人；使用`SO_REUSEADDR`选项调用`setsockopt`允许操作系统立即重用端口。'
- en: 'Now, with this socket, instead of calling `connect` (to connect to some other
    server), we’ll call `bind`, which waits for other computers to connect:'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这个套接字，我们不是调用`connect`（连接到其他服务器），而是调用`bind`，它等待其他计算机连接：
- en: '[PRE324]'
  id: totrans-1463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: Let’s look at the `bind` call first. Its first argument says who should be allowed
    to make connections *to* the server; the empty string means that anyone can connect.
    The second argument is the port others must use to talk to our server; I’ve chosen
    `8000`. I can’t use 80, because ports below 1024 require administrator privileges,
    but you can pick something other than 8000 if, for whatever reason, port 8000
    is taken on your machine.
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看`bind`调用。它的第一个参数指定了谁应该被允许连接到服务器；空字符串意味着任何人都可以连接。第二个参数是其他计算机必须使用的端口号来与我们的服务器通信；我选择了`8000`。我不能使用80，因为低于1024的端口号需要管理员权限，但如果你机器上的端口8000已被占用，你可以选择其他端口号。
- en: Finally, after the `bind` call, the `listen` call tells the OS that we’re ready
    to accept connections.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`bind`调用之后，`listen`调用通知操作系统我们已经准备好接受连接。
- en: 'To actually accept those connections, we enter a loop that runs once per connection.
    At the top of the loop we call `s.accept` to wait for a new connection:'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际接受这些连接，我们进入一个循环，每次循环运行一次以处理一个连接。在循环的顶部，我们调用`s.accept`以等待新的连接：
- en: '[PRE325]'
  id: totrans-1467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'That connection object is, confusingly, also a socket: it is the socket corresponding
    to that one connection. We know what to do with those: we read the contents and
    parse the HTTP message. But it’s a little trickier in the server than in the browser,
    because the server can’t just read from the socket until the connection closes—the
    browser is waiting for the server and won’t close the connection.'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 那个连接对象，令人困惑的是，也是一个套接字：它是对应那个连接的套接字。我们知道如何处理这些：我们读取内容并解析HTTP消息。但在服务器中比在浏览器中要复杂一些，因为服务器不能只是从套接字中读取直到连接关闭——浏览器正在等待服务器，不会关闭连接。
- en: 'So, we’ve got to read from the socket line by line. First, we read the request
    line:'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须逐行从套接字中读取。首先，我们读取请求行：
- en: '[PRE326]'
  id: totrans-1470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'Then we read the headers until we get to a blank line, accumulating the headers
    in a dictionary:'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们读取头部信息，直到遇到空白行，将头部信息累积到一个字典中：
- en: '[PRE327]'
  id: totrans-1472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'Finally we read the body, but only when the `Content-Length` header tells us
    how much of it to read (that’s why that header is mandatory on `POST` requests):'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们读取正文，但只有当`Content-Length`头部告诉我们需要读取多少内容时才读取（这就是为什么在`POST`请求中这个头部是强制性的）：
- en: '[PRE328]'
  id: totrans-1474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: 'Now the server needs to generate a web page in response. We’ll get to that
    later; for now, just abstract that away behind a `do_request` call:'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器需要生成一个网页作为响应。我们稍后会讨论这个问题；现在，只需将这个抽象化到 `do_request` 调用之后即可：
- en: '[PRE329]'
  id: totrans-1476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'The server then sends this page back to the browser:'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器然后将这个页面发送回浏览器：
- en: '[PRE330]'
  id: totrans-1478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'The architecture is summarized in Figure 3\. Our implementation is all pretty
    bare-bones: our server doesn’t check that the browser is using HTTP 1.0 to talk
    to it, it doesn’t send back any headers at all except `Content-Length`, it doesn’t
    support TLS, and so on. Again: this is a web *browser* book—it’ll do.'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 架构总结在图3中。我们的实现非常基础：我们的服务器不会检查浏览器是否使用HTTP 1.0与之通信，它不会发送任何除了 `Content-Length`
    之外的头信息，它不支持TLS，等等。再次强调：这是一本关于网络浏览器的书——它会的。
- en: '![Figure 3: The architecture of the simple web server in this chapter.](img/bf7b6061222d22e6ad879312646e8031.png)'
  id: totrans-1480
  prefs: []
  type: TYPE_IMG
  zh: '![图3：本章简单网络服务器的架构](img/bf7b6061222d22e6ad879312646e8031.png)'
- en: 'Figure 3: The architecture of the simple web server in this chapter.'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：本章简单网络服务器的架构。
- en: Ilya Grigorik’s [*High Performance Browser Networking*](https://hpbn.co) is
    an excellent deep dive into networking and how to optimize for it in a web application.
    There are things the client can do (make fewer requests, avoid polling, reuse
    connections) and things the server can do (compression, protocol support, sharing
    domains).
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: Ilya Grigorik的[*高性能浏览器网络*](https://hpbn.co)是一本关于网络和如何在网络应用程序中对其进行优化的优秀深入探讨。客户端可以做一些事情（减少请求，避免轮询，重用连接），服务器也可以做一些事情（压缩，协议支持，共享域名）。
- en: Generating Web Pages
  id: totrans-1483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成网页
- en: So far, all of this server code is “boilerplate”—any web application will have
    similar code. What makes our server a guest book, on the other hand, depends on
    what happens inside `do_request`. It needs to store the guest book state, generate
    HTML pages, and respond to `POST` requests.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这个服务器的所有代码都是“样板代码”——任何网络应用程序都会有类似的代码。另一方面，我们的服务器成为留言簿的原因，取决于 `do_request`
    内部发生的事情。它需要存储留言簿状态，生成HTML页面，并响应 `POST` 请求。
- en: Let’s store guest book entries in a Python list. Usually web applications use
    *persistent* state, like a database, so that the server can be restarted without
    losing state, but our guest book need not be that resilient.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将留言簿条目存储在Python列表中。通常网络应用程序使用“持久”状态，如数据库，以便服务器可以重启而不会丢失状态，但我们的留言簿不需要那么有弹性。
- en: '[PRE331]'
  id: totrans-1486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'Next, `do_request` has to output HTML that shows those entries:'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`do_request` 必须输出显示这些条目的HTML：
- en: '[PRE332]'
  id: totrans-1488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: This is definitely “minimal” HTML, so it’s a good thing our browser will insert
    implicit tags and has some default styles! You can test it out by running this
    minimal web server and, while it’s running, direct your browser to `http://localhost:8000/`,
    where `localhost` is what your computer calls itself and `8000` is the port we
    chose earlier. You should see one guest book entry.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是“最小化”的HTML，所以很幸运我们的浏览器会插入隐式标签并有一些默认样式！你可以通过运行这个最小化网络服务器来测试它，当它运行时，将你的浏览器指向
    `http://localhost:8000/`，其中 `localhost` 是你的电脑对自己的称呼，`8000` 是我们之前选择的端口。你应该会看到一个留言簿条目。
- en: By the way, while you’re debugging this web server, it’s probably better to
    use a real web browser, instead of this book’s browser, to interact with it. That
    way you don’t have to worry about browser bugs while you work on server bugs.
    But this server does support both real and toy browsers.
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，当你调试这个网络服务器时，最好使用真正的网络浏览器，而不是这本书中的浏览器，来与之交互。这样，你在处理服务器错误时就不必担心浏览器错误了。但这个服务器确实支持真实和玩具浏览器。
- en: 'We’ll use forms to let visitors write in the guest book:'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用表单让访客在留言簿中留言：
- en: '[PRE333]'
  id: totrans-1492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'When this form is submitted, the browser will send a `POST` request to `http://localhost:8000/add`.
    So the server needs to react to these submissions. That means `do_request` will
    field two kinds of requests: regular browsing and form submissions. Let’s separate
    the two kinds of requests into different functions.'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个表单提交时，浏览器将向 `http://localhost:8000/add` 发送一个 `POST` 请求。因此，服务器需要对这些提交做出反应。这意味着
    `do_request` 将处理两种类型的请求：常规浏览和表单提交。让我们将两种类型的请求分开到不同的函数中。
- en: 'First rename the current `do_request` to `show_comments`:'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将当前的 `do_request` 重命名为 `show_comments`：
- en: '[PRE334]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: 'This then frees up the `do_request` function to figure out which function to
    call for which request:'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就释放了 `do_request` 函数来决定对哪种请求调用哪个函数：
- en: '[PRE335]'
  id: totrans-1497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'When a `POST` request to `/add` comes in, the first step is to decode the request
    body:'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 `POST` 请求到达 `/add` 时，第一步是解码请求体：
- en: '[PRE336]'
  id: totrans-1499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'Note that I use `unquote_plus` instead of `unquote`, because browsers may also
    use a plus sign to encode a space. The `add_entry` function then looks up the
    `guest` parameter and adds its content as a new guest book entry:'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我使用`unquote_plus`而不是`unquote`，因为浏览器也可能使用加号来编码空格。`add_entry`函数随后查找`guest`参数并将其内容添加为新的留言簿条目：
- en: '[PRE337]'
  id: totrans-1501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: 'I’ve also added a “404” response. Fitting the austere stylings of our guest
    book, here’s the 404 page:'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 我还添加了一个“404”响应。与我们的留言簿的简约风格相匹配，以下是404页面：
- en: '[PRE338]'
  id: totrans-1503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: Try it! You should be able to restart the server, open it in your browser, and
    update the guest book a few times. You should also be able to use the guest book
    from a real web browser.
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下！你应该能够重新启动服务器，在浏览器中打开它，并更新留言簿几次。你也应该能够从真实的网络浏览器中使用留言簿。
- en: Typically, connection handling and request routing is handled by a web framework;
    this book’s website, for example uses [bottle.py](https://bottlepy.org/docs/dev/).
    Frameworks parse requests into convenient data structures, route requests to the
    right handler, and can also provide tools like HTML templates, session handling,
    database access, input validation, and API generation.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，连接处理和请求路由由一个Web框架处理；例如，这本书的网站使用[bottle.py](https://bottlepy.org/docs/dev/)。框架将请求解析成方便的数据结构，将请求路由到正确的处理程序，还可以提供HTML模板、会话处理、数据库访问、输入验证和API生成等工具。
- en: Summary
  id: totrans-1506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'With this chapter we’re starting to transform our browser into an application
    platform. We’ve added:'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们开始将我们的浏览器转变为一个应用平台。我们添加了：
- en: layout objects for input areas and buttons;
  id: totrans-1508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入区域和按钮的布局对象；
- en: clicking on buttons and typing into input areas;
  id: totrans-1509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击按钮和在输入区域中输入；
- en: hierarchical focus handling;
  id: totrans-1510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次化焦点处理；
- en: form submission with HTTP `POST`.
  id: totrans-1511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP `POST`进行表单提交。
- en: Plus, our browser now has a little web server friend. That’s going to be handy
    as we add more interactive features to the browser.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的浏览器现在有一个小小的网络服务器朋友。当我们向浏览器添加更多交互功能时，这将非常方便。
- en: Since this chapter introduces a server, I’ve also added support for that in
    the browser widget below, by cross-compiling this chapter’s server code to JavaScript.
    Try submitting a comment through the form, it should work!
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章介绍了服务器，我还在下面的浏览器小部件中添加了对它的支持，通过交叉编译本章的服务器代码到JavaScript。尝试通过表单提交一个评论，它应该可以工作！
- en: '[widgets/lab8-browser.html](widgets/lab8-browser.html)'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: '[widgets/lab8-browser.html](widgets/lab8-browser.html)'
- en: Outline
  id: totrans-1515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should now
    look something like this:'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整函数、类和方法集现在看起来可能像这样：
- en: '`` class URL: `def __init__(url)` `def request(payload)` `def resolve(url)`
    `def __str__()` `` `` class Text: `def __init__(text, parent)` `def __repr__()`
    `` `` class Element: `def __init__(tag, attributes, parent)` `def __repr__()`
    `` `def print_tree(node, indent)` `def tree_to_list(tree, list)` `` class HTMLParser:
    `SELF_CLOSING_TAGS` `HEAD_TAGS` `def __init__(body)` `def parse()` `def get_attributes(text)`
    `def add_text(text)` `def add_tag(tag)` `def implicit_tags(tag)` `def finish()`
    `` `` class CSSParser: `def __init__(s)` `def whitespace()` `def literal(literal)`
    `def word()` `def ignore_until(chars)` `def pair()` `def selector()` `def body()`
    `def parse()` `` `` class TagSelector: `def __init__(tag)` `def matches(node)`
    `` `` class DescendantSelector: `def __init__(ancestor, descendant)` `def matches(node)`
    `` `FONTS` `def get_font(size, weight, style)` `DEFAULT_STYLE_SHEET` `INHERITED_PROPERTIES`
    `def style(node, rules)` `def cascade_priority(rule)` `WIDTH, HEIGHT` `HSTEP,
    VSTEP` `` class Rect: `def __init__(left, top, right, bottom)` `def contains_point(x,
    y)` `` `INPUT_WIDTH_PX` `BLOCK_ELEMENTS` `` class DocumentLayout: `def __init__(node)`
    `def layout()` `def should_paint()` `def paint()` `` `` class BlockLayout: `def
    __init__(node, parent, previous)` `def layout_mode()` `def layout()` `def recurse(node)`
    `def new_line()` `def word(node, word)` `def input(node)` `def self_rect()` `def
    should_paint()` `def paint()` `` `` class LineLayout: `def __init__(node, parent,
    previous)` `def layout()` `def should_paint()` `def paint()` `` `` class TextLayout:
    `def __init__(node, word, parent, previous)` `def layout()` `def should_paint()`
    `def paint()` `` `` class InputLayout: `def __init__(node, parent, previous)`
    `def layout()` `def should_paint()` `def paint()` `def self_rect()` `` `` class
    DrawText: `def __init__(x1, y1, text, font, color)` `def execute(scroll, canvas)`
    `` `` class DrawRect: `def __init__(rect, color)` `def execute(scroll, canvas)`
    `` `` class DrawLine: `def __init__(x1, y1, x2, y2, color, thickness)` `def execute(scroll,
    canvas)` `` `` class DrawOutline: `def __init__(rect, color, thickness)` `def
    execute(scroll, canvas)` `` `def paint_tree(layout_object, display_list)` `SCROLL_STEP`
    `` class Tab: `def __init__(tab_height)` `def load(url, payload)` `def render()`
    `def draw(canvas, offset)` `def scrolldown()` `def click(x, y)` `def go_back()`
    `def submit_form(elt)` `def keypress(char)` `` `` class Chrome: `def __init__(browser)`
    `def tab_rect(i)` `def paint()` `def click(x, y)` `def keypress(char)` `def enter()`
    `def blur()` `` `` class Browser: `def __init__()` `def draw()` `def new_tab(url)`
    `def handle_down(e)` `def handle_click(e)` `def handle_key(e)` `def handle_enter(e)`
    ``'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s also a server now, but it’s much simpler:'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: '`def handle_connection(conx)` `def do_request(method, url, headers, body)`
    `def form_decode(body)` `ENTRIES` `def show_comments()` `def not_found(url, method)`
    `def add_entry(params)`'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run it, it should look something like this:'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行它，它应该看起来像这样：
- en: '[widgets/lab8-browser.html](widgets/lab8-browser.html)'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: '[widgets/lab8-browser.html](widgets/lab8-browser.html)'
- en: Exercises
  id: totrans-1522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 8-1 *Enter key*. In most browsers, if you hit the “Enter” or “Return” key while
    inside a text entry, that submits the form that the text entry was in. Add this
    feature to your browser.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 8-1 **回车键**。在大多数浏览器中，如果你在文本输入框内按下“Enter”或“Return”键，那么会提交该文本输入框所在的表单。将此功能添加到你的浏览器中。
- en: 8-2 *`GET` forms*. Forms can be submitted via `GET` requests as well as `POST`
    requests. In `GET` requests, the form-encoded data is pasted onto the end of the
    URL, separated from the path by a question mark, like `/search?q=hi`; `GET` form
    submissions have no body. Implement `GET` form submissions.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 8-2 **`GET` 表单**。表单可以通过 `GET` 请求以及 `POST` 请求提交。在 `GET` 请求中，表单编码的数据粘贴到URL的末尾，由一个问号与路径分开，如
    `/search?q=hi`；`GET` 表单提交没有主体。实现 `GET` 表单提交。
- en: 8-3 *Blurring*. Right now, if you click inside a text entry, and then inside
    the address bar, two cursors will appear on the screen. To fix this, add a `blur`
    method to each `Tab` which unfocuses anything that is focused, and call it before
    changing focus.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 8-3 **模糊**。目前，如果你在文本输入框内点击，然后在内地址栏内点击，屏幕上会出现两个光标。为了解决这个问题，为每个 `Tab` 添加一个 `blur`
    方法，该方法取消任何已聚焦的元素的关注，并在更改焦点之前调用它。
- en: 8-4 *Check boxes*. In HTML, `input` elements have a `type` attribute. When set
    to `checkbox`, the `input` element looks like a checkbox; it’s checked if the
    `checked` attribute is set, and unchecked otherwise.Technically, the `checked`
    attribute [only affects the state of the checkbox when the page loads](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#attr-checked);
    checking and unchecking a checkbox does not affect this attribute but instead
    manipulates internal state. When the form is submitted, a checkbox’s `name=value`
    pair is included only if the checkbox is checked. (If the checkbox has no `value`
    attribute, the default is the string `on`.)
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 8-4 **复选框**。在HTML中，`input` 元素有一个 `type` 属性。当设置为 `checkbox` 时，`input` 元素看起来像一个复选框；如果设置了
    `checked` 属性，则选中，否则未选中。技术上讲，`checked` 属性 [仅在页面加载时影响复选框的状态](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#attr-checked)；选中或取消选中复选框不会影响此属性，而是操作内部状态。当表单提交时，只有当复选框被选中时，复选框的
    `name=value` 对才会包含在内。（如果复选框没有 `value` 属性，则默认为字符串 `on`。）
- en: 8-5 *Resubmit requests*. One reason to separate `GET` and `POST` requests is
    that `GET` requests are supposed to be *idempotent* (read-only, basically) while
    `POST` requests are assumed to change the web server state. That means that going
    “back” to a `GET` request (making the request again) is safe, while going “back”
    to a `POST` request is a bad idea. Change the browser history to record what method
    was used to access each URL, and the `POST` body if one was used. When you go
    back to a `POST`-ed URL, ask the user if they want to resubmit the form. Don’t
    go back if they say no; if they say yes, submit a `POST` request with the same
    body as before.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 8-5 **重新提交请求**。将 `GET` 和 `POST` 请求分开的一个原因是因为 `GET` 请求应该是 **幂等的**（只读，基本上）而 `POST`
    请求则假定会改变网络服务器状态。这意味着回到一个 `GET` 请求（再次发出请求）是安全的，而回到一个 `POST` 请求则是一个坏主意。更改浏览器历史记录以记录访问每个URL所使用的方法，以及如果有的话，`POST`
    请求体。当你回到一个 `POST`-ed URL时，询问用户是否想要重新提交表单。如果他们说不，不要回退；如果他们说好，提交一个与之前相同的 `POST`
    请求体。
- en: 8-6 *Message board*. Right now our web server is a simple guest book. Extend
    it into a simple message board by adding support for topics. Each topic should
    have its own URL and its own list of messages. So, for example, `/cooking` should
    be a page of posts (about cooking) and comments submitted through the form on
    that page should only show up when you go to `/cooking`, not when you go to `/cars`.
    Make the home page, at `/`, list the available topics with a link to each topic’s
    page. Make it possible for users to add new topics.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 8-6 **留言板**。目前我们的网络服务器是一个简单的留言簿。通过添加对主题的支持，将其扩展为一个简单的留言板。每个主题都应该有自己的URL和自己的消息列表。例如，`/cooking`
    应该是一个关于烹饪的帖子页面，并且通过该页面上表单提交的评论只有在访问 `/cooking` 时才会显示，而不是访问 `/cars` 时显示。使主页在 `/`
    上列出可用的主题，并为每个主题页面提供链接。使用户能够添加新的主题。
- en: 8-7 *Persistence*. Back the server’s list of guest book entries with a file,
    so that when the server is restarted it doesn’t lose data.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 8-7 **持久性**。使用文件备份服务器的留言簿条目列表，这样当服务器重启时不会丢失数据。
- en: 8-8 *Rich buttons*. Make it possible for a button to contain arbitrary elements
    as children, and render them correctly. The children should be contained inside
    the button instead of spilling out—this can make a button really tall. Think about
    edge cases, like a button that contains another button, an input area, or a link,
    and test real browsers to see what they do.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 8-8 *丰富按钮*。使按钮能够包含任意元素作为子元素，并正确渲染它们。子元素应包含在按钮内部而不是溢出——这可以使按钮变得非常高。考虑边缘情况，例如包含另一个按钮、输入区域或链接的按钮，并测试真实浏览器以查看它们的行为。
- en: 8-9 *HTML chrome*. Browser chrome is quite complicated in real browsers, with
    tricky details such as font sizes, padding, outlines, shadows, icons and so on.
    This makes it tempting to try to reuse our layout engine for it. Implement this,
    using `<button>` elements for the new tab and back buttons, an `<input>` element
    for the address bar, and `<a>` elements for the tab names. It won’t look exactly
    the same as the current chrome—outline will have to wait for [Chapter 14](accessibility.html),
    for example—but if you adjust the default CSS you should be able to make it look
    passable.Real browsers have in fact gone down this implementation path multiple
    times, building layout engines for the browser chrome that are heavily inspired
    by or reuse pieces of the main web layout engine. [Firefox had one](https://en.wikipedia.org/wiki/XUL),
    and [Chrome has one](https://www.chromium.org/developers/webui/). However, because
    it’s so important for the browser chrome to be very fast and responsive to draw,
    such approaches have had mixed success.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 8-9 *HTML 外壳*。在真实浏览器中，浏览器外壳相当复杂，具有字体大小、填充、轮廓、阴影、图标等棘手细节。这使得我们尝试重用布局引擎来处理它变得很有吸引力。使用
    `<button>` 元素实现新标签页和后退按钮，使用 `<input>` 元素实现地址栏，使用 `<a>` 元素实现标签名称。它可能不会与当前的壳体完全相同——例如，轮廓将不得不等待[第
    14 章](accessibility.html)，但如果调整默认 CSS，你应该能够使其看起来可以接受。实际上，真实浏览器已经多次走过了这条实现路径，为浏览器外壳构建了受主要网页布局引擎强烈启发或重用其部分的布局引擎。[Firefox
    有一个](https://en.wikipedia.org/wiki/XUL)，[Chrome 也有一个](https://www.chromium.org/developers/webui/)。然而，由于浏览器外壳需要非常快且响应性强的绘制，这种方法已经取得了不同的成功。
- en: Running Interactive Scripts
  id: totrans-1532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行交互式脚本
- en: Chapter 9 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: '[Web 浏览器工程学](./index.html "目录")的第 9 章。'
- en: '[Installing DukPy](#installing-dukpy)'
  id: totrans-1534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[安装 DukPy](#installing-dukpy)'
- en: '[Running JavaScript Code](#running-javascript-code)'
  id: totrans-1535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[运行 JavaScript 代码](#running-javascript-code)'
- en: '[Exporting Functions](#exporting-functions)'
  id: totrans-1536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[导出函数](#exporting-functions)'
- en: '[Handling Crashes](#handling-crashes)'
  id: totrans-1537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[处理崩溃](#handling-crashes)'
- en: '[Returning Handles](#returning-handles)'
  id: totrans-1538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[返回句柄](#returning-handles)'
- en: '[Wrapping Handles](#wrapping-handles)'
  id: totrans-1539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[包装句柄](#wrapping-handles)'
- en: '[Event Handling](#event-handling)'
  id: totrans-1540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[事件处理](#event-handling)'
- en: '[Modifying the DOM](#modifying-the-dom)'
  id: totrans-1541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[修改 DOM](#modifying-the-dom)'
- en: '[Event Defaults](#event-defaults)'
  id: totrans-1542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[事件默认值](#event-defaults)'
- en: '[Summary](#summary)'
  id: totrans-1543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summary)'
- en: '[Outline](#outline)'
  id: totrans-1544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大纲](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-1545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: The first web applications were like [the previous chapter’s guest book](forms.html),
    with the server generating new web pages for every user action. But in the early
    2000s, JavaScript-enhanced web applications, which can update pages dynamically
    and respond immediately to user actions, took their place. Let’s add support for
    this key web technology to our browser.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的 Web 应用程序就像[上一章的留言簿](forms.html)，服务器为每个用户操作生成新的 Web 页面。但在 2000 年代初，JavaScript
    增强的 Web 应用程序，可以动态更新页面并立即响应用户操作，取代了它们。让我们为我们的浏览器添加对这种关键 Web 技术的支持。
- en: Installing DukPy
  id: totrans-1547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 DukPy
- en: Actually writing a JavaScript interpreter is beyond the scope of this book,But
    check out a book on programming language implementation if it sounds interesting!
    so this chapter uses the `dukpy` library for executing JavaScript.
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 实际编写 JavaScript 解释器超出了本书的范围，但如果听起来很有趣，可以查看关于编程语言实现的书籍！因此，本章使用 `dukpy` 库来执行 JavaScript。
- en: '[DukPy](https://github.com/amol-/dukpy) wraps a JavaScript interpreter called
    [Duktape](https://duktape.org). The most famous JavaScript interpreters are those
    used in browsers: TraceMonkey (Firefox), JavaScriptCore (Safari), and V8 (Chrome).
    Unlike those implementations, which are extremely fast but also extremely complex,
    Duktape aims to be simple and extensible, and is usually embedded inside a larger
    C or C++ project.For example, in a video game the high-speed graphics code is
    usually written in C or C++ , but the actual plot of the game is usually written
    in a higher-level language like JavaScript.'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: '[DukPy](https://github.com/amol-/dukpy) 包裹了一个名为 [Duktape](https://duktape.org)
    的 JavaScript 解释器。最著名的 JavaScript 解释器是那些用于浏览器的：TraceMonkey（Firefox）、JavaScriptCore（Safari）和
    V8（Chrome）。与这些实现不同，它们非常快但也很复杂，Duktape 旨在简单且可扩展，通常嵌入到更大的 C 或 C++ 项目中。例如，在视频游戏中，高速图形代码通常用
    C 或 C++ 编写，但游戏的实际情节通常用更高级的语言如 JavaScript 编写。'
- en: Like other JavaScript engines, DukPy not only executes JavaScript code, but
    also allows it to call *exported* Python functions. We’ll be using this feature
    to allow JavaScript code to modify the web page it’s running on.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他 JavaScript 引擎一样，DukPy 不仅执行 JavaScript 代码，还允许它调用 *导出* 的 Python 函数。我们将使用这个特性来允许
    JavaScript 代码修改其运行的网页。
- en: 'The first step to using DukPy is installing it. On most machines, including
    on Windows, macOS, and Linux systems, you should be able to do this with:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DukPy 的第一步是安装它。在大多数机器上，包括 Windows、macOS 和 Linux 系统，你应该能够使用以下命令完成：
- en: '[PRE339]'
  id: totrans-1552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: If you have a really old version of Python, you might need to install the `pip`
    package first, possibly using a command line `easy_install`. If you do your Python
    programming through an integrated development environment (IDE), you may need
    to use your IDE’s package installer. If nothing else works, you can build [from
    source](https://github.com/amol-/dukpy).
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个非常旧的 Python 版本，你可能需要首先安装 `pip` 软件包，可能需要使用命令行 `easy_install`。如果你通过集成开发环境（IDE）进行
    Python 编程，你可能需要使用你的 IDE 的软件包安装器。如果其他方法都不奏效，你可以从源代码构建 [DukPy](https://github.com/amol-/dukpy)。
- en: If you’re following along in something other than Python, you might need to
    skip this chapter, though you could try binding directly to the `duktape` library
    that `dukpy` uses.
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是在 Python 中跟进，你可能需要跳过这一章，尽管你可以尝试直接绑定到 `dukpy` 所使用的 `duktape` 库。
- en: 'To test whether you installed DukPy correctly, execute this:'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你是否正确安装了 DukPy，请执行以下操作：
- en: '[PRE340]'
  id: totrans-1556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: If you get an error on the first line, you probably failed to install DukPy.Or,
    on my Linux machine, I sometimes get errors due to file ownership. You may have
    to do some sleuthing. If you get an error, or a segfault, on the second line,
    there’s a chance that Duktape failed to compile, or maybe doesn’t support your
    system, and you might need to debug further.
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在第一行遇到错误，你可能没有成功安装 DukPy。或者，在我的 Linux 机器上，我有时会因为文件所有权问题而遇到错误。你可能需要进行一些调查。如果你在第二行遇到错误或段错误，那么可能是
    Duktape 编译失败，或者可能不支持你的系统，你可能需要进一步调试。
- en: 'Note to JavaScript experts: DukPy does not implement newer syntax like `let`
    and `const` or arrow functions. In keeping with this book’s aesthetics, you’ll
    need to use old-school JavaScript from the turn of the century.'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于 JavaScript 专家，DukPy 不实现像 `let` 和 `const` 或箭头函数这样的新语法。为了保持本书的美学风格，你需要使用世纪之交的旧式
    JavaScript。
- en: Running JavaScript Code
  id: totrans-1559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 JavaScript 代码
- en: 'The test above shows how you run JavaScript code in DukPy: you just call `evaljs`!
    Let’s put this newfound knowledge to work in our browser.'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 上述测试展示了如何在 DukPy 中运行 JavaScript 代码：你只需调用 `evaljs`！让我们将这新获得的知识应用到我们的浏览器中。
- en: On the web, JavaScript is found in `<script>` tags. Normally, a `<script>` tag
    has a `src` attribute with a relative URL that points to a JavaScript file, much
    like with CSS files. A `<script>` tag could also contain JavaScript source code
    between the start and end tag, but we won’t implement that.It’s a challenge for
    parsing, since it’s hard to avoid less-than and greater-than signs in JavaScript
    code. See [Exercise 4-3](html.html#exercises).
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上，JavaScript 存在于 `<script>` 标签中。通常，一个 `<script>` 标签有一个 `src` 属性，包含一个相对 URL，指向
    JavaScript 文件，就像 CSS 文件一样。一个 `<script>` 标签也可以在开始和结束标签之间包含 JavaScript 源代码，但我们不会实现这一点。由于在
    JavaScript 代码中很难避免小于和大于符号，这会是一个解析的挑战。参见 [练习 4-3](html.html#exercises)。
- en: 'Finding and downloading those scripts is similar to what we did for CSS. First,
    we need to find all of the scripts:'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找和下载这些脚本与我们在 CSS 中所做的工作类似。首先，我们需要找到所有的脚本：
- en: '[PRE341]'
  id: totrans-1563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: 'Next, we run all of the scripts:'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们运行所有的脚本：
- en: '[PRE342]'
  id: totrans-1565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: 'This should run before styling and layout. To try it out, create a simple web
    page with a `script` tag:'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在样式和布局之前运行。为了尝试它，创建一个简单的网页，包含一个`script`标签：
- en: '[PRE343]'
  id: totrans-1567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: 'Then write a super simple script to `test.js`, maybe this:'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编写一个超级简单的脚本到`test.js`，可能如下所示：
- en: '[PRE344]'
  id: totrans-1569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: 'Point your browser at that page, and you should see:'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的浏览器指向这个页面，你应该会看到：
- en: '[PRE345]'
  id: totrans-1571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: That’s your browser running its first bit of JavaScript!
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是你的浏览器正在运行它的第一段JavaScript代码！
- en: Actually, real browsers run JavaScript code as soon as the browser *parses*
    the `<script>` tag, not after the whole page is parsed. Or, at least, that is
    the default; there are [many options](https://html.spec.whatwg.org/multipage/scripting.html#the-script-element).
    What our browser does is what a real browser does when the [`defer`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-defer)
    attribute is set. The default behavior is [much trickier](https://developer.mozilla.org/en-US/docs/Glossary/speculative_parsing)
    to implement efficiently.
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，真实浏览器会在解析完整个页面后立即运行JavaScript代码，而不是在解析完`<script>`标签后。或者至少，这是默认行为；有许多[选项](https://html.spec.whatwg.org/multipage/scripting.html#the-script-element)。我们的浏览器所做的是当设置了`defer`（[defer
    属性](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-defer)）属性时，真实浏览器所做的那样。默认行为[更难以高效实现](https://developer.mozilla.org/en-US/docs/Glossary/speculative_parsing)。
- en: Exporting Functions
  id: totrans-1574
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出函数
- en: 'Right now, our browser just prints the last expression in a script; but in
    a real browser scripts must call the `console.log` function to print. To support
    that, we will need to *export a function* from Python into JavaScript. We’ll be
    exporting a lot of functions, so to avoid polluting the `Tab` object with many
    new methods, let’s put this code in a new `JSContext` class:'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的浏览器只是打印脚本中的最后一个表达式；但在真实浏览器中，脚本必须调用`console.log`函数来打印。为了支持这一点，我们需要从Python中导出一个函数到JavaScript中。由于我们将导出很多函数，为了避免将许多新方法污染`Tab`对象，让我们将这段代码放在一个新的`JSContext`类中：
- en: '[PRE346]'
  id: totrans-1576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: DukPy’s `JSInterpreter` object stores the values of all the JavaScript variables,
    and lets us run multiple JavaScript snippets and share variable values and other
    state between them.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: DukPy的`JSInterpreter`对象存储了所有JavaScript变量的值，并允许我们运行多个JavaScript片段，并在它们之间共享变量值和其他状态。
- en: 'We create this new `JSContext` object while loading the page:'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载页面时，我们创建这个新的`JSContext`对象：
- en: '[PRE347]'
  id: totrans-1579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: 'As a side benefit of using one `JSContext` for all scripts, it is now possible
    to run two scripts and have one of them define a variable that the other uses,
    say on a page like this:'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个`JSContext`对所有脚本进行操作的一个副作用是，现在可以运行两个脚本，其中一个脚本定义一个变量，另一个脚本使用它，比如在一个像这样的页面上：
- en: '[PRE348]'
  id: totrans-1581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: Suppose `a.js` is “`var x = 2;`” and `b.js` is “`console.log(x + x)`”; the variable
    `x` is set in `a.js` but used in `b.js`. In real web browsers, that’s common,
    since one script might define library functions that another script wants to call.
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`a.js`是“`var x = 2;`”而`b.js`是“`console.log(x + x)`”；变量`x`在`a.js`中设置，但在`b.js`中使用。在真实的网页浏览器中，这种情况很常见，因为一个脚本可能定义了另一个脚本想要调用的库函数。
- en: 'Now, to allow JavaScript to interact with the outside world, DukPy allows us
    to “export” functions to it. For example, we can export Python’s `print` function
    like so:'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了允许JavaScript与外部世界交互，DukPy允许我们“导出”函数到它。例如，我们可以像这样导出Python的`print`函数：
- en: '[PRE349]'
  id: totrans-1584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: 'We can call an exported function from JavaScript using DukPy’s `call_python`
    function. For example:'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用DukPy的`call_python`函数从JavaScript调用导出的函数。例如：
- en: '[PRE350]'
  id: totrans-1586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: When this JavaScript code runs, DukPy converts the JavaScript string `"Hi from
    JS"` into a Python string,This conversion works for numbers, strings, and booleans,
    plus arrays and dictionaries thereof, but not with fancy objects. and then passes
    that Python string to the `print` function we exported. Then `print` prints that
    string.
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段JavaScript代码运行时，DukPy将JavaScript字符串`"Hi from JS"`转换为Python字符串，这种转换适用于数字、字符串、布尔值，以及相应的数组和字典，但不适用于复杂对象。然后，它将这个Python字符串传递给导出的`print`函数。然后`print`打印这个字符串。
- en: 'Since we ultimately want a [`console.log`](https://developer.mozilla.org/en-US/docs/Web/API/console/log)
    function, not a `call_python` function, we need to define a `console` object and
    then give it a `log` property. We can do that *in JavaScript*:'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们最终想要一个`console.log`（[console.log 函数](https://developer.mozilla.org/en-US/docs/Web/API/console/log)）函数，而不是一个`call_python`函数，我们需要定义一个`console`对象，然后给它一个`log`属性。我们可以在JavaScript中这样做：
- en: '[PRE351]'
  id: totrans-1589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: In case you’re not too familiar with JavaScript,Now’s a good time to [brush
    up](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/A_first_splash)!
    this defines a variable called `console`, whose value is an object literal with
    the property `log`, whose value is a function that calls `call_python`. The interaction
    between the browser and JavaScript is shown in Figure 1.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 JavaScript，现在是一个很好的时间来 [复习](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/A_first_splash)！这定义了一个名为
    `console` 的变量，其值是一个具有 `log` 属性的对象字面量，其值是一个调用 `call_python` 的函数。浏览器与 JavaScript
    之间的交互如图 1 所示。
- en: '![Figure 1: The browser can evaluate JavaScript and JavaScript code can call
    back into the browser.](img/8630f91e848984a6fae785fc585c9958.png)'
  id: totrans-1591
  prefs: []
  type: TYPE_IMG
  zh: '![图 1：浏览器可以评估 JavaScript，并且 JavaScript 代码可以回调到浏览器。](img/8630f91e848984a6fae785fc585c9958.png)'
- en: 'Figure 1: The browser can evaluate JavaScript and JavaScript code can call
    back into the browser.'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1：浏览器可以评估 JavaScript，并且 JavaScript 代码可以回调到浏览器。
- en: 'We can call that JavaScript code our “JavaScript runtime”; we run it before
    we run any user code, so let’s stick it in a `runtime.js` file and execute it
    when the `JSContext` is created, before we run any user code:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将那个 JavaScript 代码称为我们的“JavaScript 运行时”；我们在运行任何用户代码之前运行它，所以让我们将其放入一个 `runtime.js`
    文件中，并在创建 `JSContext` 之前执行它，在我们运行任何用户代码之前：
- en: '[PRE352]'
  id: totrans-1594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: Now you should be able to put `console.log("Hi from JS!")` into a JavaScript
    file, run it from your browser, and see output in your terminal. You should also
    be able to call `console.log` multiple times.
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够将 `console.log("Hi from JS!")` 放入一个 JavaScript 文件中，从你的浏览器中运行它，并在终端中看到输出。你也应该能够多次调用
    `console.log`。
- en: Taking a step back, when we run JavaScript in our browser, we’re mixing C code,
    which implements the JavaScript interpreter; Python code, which implements certain
    JavaScript functions; a JavaScript runtime, which wraps the Python API to look
    more like the JavaScript one; and of course some user code in JavaScript. There’s
    a lot of complexity here!
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，当我们在我们浏览器中运行 JavaScript 时，我们混合了 C 代码，它实现了 JavaScript 解释器；Python 代码，它实现了某些
    JavaScript 函数；一个 JavaScript 运行时，它将 Python API 包装得更像 JavaScript；当然，还有一些 JavaScript
    用户的代码。这里有很多复杂性！
- en: If a script runs for a long time, or has an infinite loop, our browser locks
    up and becomes completely unresponsive to the user. This is a consequence of JavaScript’s
    single-threaded semantics and its task-based, [run-to-completion scheduling](https://en.wikipedia.org/wiki/Run_to_completion_scheduling).
    Some APIs like [Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)
    allow limited multithreading, but those threads don’t have access to the DOM.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个脚本运行时间过长，或者有无限循环，我们的浏览器就会锁定，对用户完全无响应。这是 JavaScript 的单线程语义及其基于任务的、[运行至完成调度](https://en.wikipedia.org/wiki/Run_to_completion_scheduling)
    的结果。一些 API，如 [Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)，允许有限的并行处理，但这些线程无法访问
    DOM。
- en: Handling Crashes
  id: totrans-1598
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理崩溃
- en: 'Crashes in JavaScript code are frustrating to debug. You can cause a crash
    by writing bad code, or by explicitly raising an exception, like so:'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 代码中的崩溃调试起来很麻烦。你可以通过编写糟糕的代码或显式抛出异常来引发崩溃，如下所示：
- en: '[PRE353]'
  id: totrans-1600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: 'When a web page runs some JavaScript that crashes, the browser should ignore
    the crash. Web pages shouldn’t be able to crash our browser! You can implement
    that like this (plus changing the call site of `run` to pass the script):'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个网页运行一些导致崩溃的 JavaScript 时，浏览器应该忽略这个崩溃。网页不应该能够使我们的浏览器崩溃！你可以这样实现（以及将 `run` 的调用站点更改为传递脚本）：
- en: '[PRE354]'
  id: totrans-1602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: 'But as you go through this chapter, you’ll also run into another type of crash:
    crashes in our own JavaScript runtime. We can’t ignore those, because that’s our
    code. Debugging these crashes is a bear: by default DukPy won’t show a backtrace,
    and if the runtime code calls into an exported function that crashes it gets even
    more confusing.'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: 但随着你进入这一章，你还会遇到另一种类型的崩溃：我们自己的 JavaScript 运行时中的崩溃。我们不能忽略这些，因为那是我们的代码。调试这些崩溃很困难：默认情况下，DukPy
    不会显示回溯，如果运行时代码调用了一个崩溃的导出函数，那么情况会变得更加混乱。
- en: 'Here are a few tips to help with these crashes. First, if you get a crash inside
    some JavaScript function, wrap the body of the function like this:'
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示可以帮助处理这些崩溃。首先，如果你在某个 JavaScript 函数内部遇到崩溃，可以将函数体包装如下：
- en: '[PRE355]'
  id: totrans-1605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: 'This code catches all exceptions and prints a stack trace before re-raising
    them. If you instead are getting crashes inside an exported function you will
    need to wrap that function, on the Python side:'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码捕获所有异常，在重新抛出之前打印堆栈跟踪。如果你在导出的函数内部遇到崩溃，你将需要在 Python 端包装该函数：
- en: '[PRE356]'
  id: totrans-1607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: Debugging these issues is not easy, because all these calls between Python and
    JavaScript get pretty complicated. *Because* these bugs are hard, it’s worth approaching
    debugging systematically and gathering a lot of information before attempting
    a fix.
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 调试这些问题并不容易，因为Python和JavaScript之间的所有调用都变得相当复杂。*因为这些错误很难解决，所以系统性地处理调试并在尝试修复之前收集大量信息是值得的*。
- en: Returning Handles
  id: totrans-1609
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回句柄
- en: So far, JavaScript evaluation is fun but useless, because JavaScript can’t make
    any kinds of modifications to the page itself. (Why even run JavaScript if it
    can’t do anything besides print? Who looks at a browser’s console output?) We
    need to allow JavaScript to modify the page.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，JavaScript的评估很有趣但毫无用处，因为JavaScript无法对页面本身进行任何修改。（如果JavaScript除了打印之外什么都不能做，为什么还要运行它？谁会去看浏览器的控制台输出？）我们需要允许JavaScript修改页面。
- en: 'JavaScript manipulates a web page by calling any of a large set of methods
    collectively called the DOM API. The DOM API is big, and it keeps getting bigger,
    so we won’t be implementing all, or even most, of it. But a few core functions
    show key elements of the full API:'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript通过调用大量统称为DOM API的方法来操作网页。DOM API很大，而且还在不断变大，所以我们不会实现所有，甚至大部分。但一些核心函数展示了完整API的关键元素：
- en: '`querySelectorAll` returns all the elements matching a selector;'
  id: totrans-1612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`querySelectorAll` 返回所有匹配选择器的元素；'
- en: '`getAttribute` returns an element’s value for some attribute; and'
  id: totrans-1613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAttribute` 返回某个属性的元素值；并且'
- en: '`innerHTML` replaces the content of an element with new HTML.'
  id: totrans-1614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innerHTML` 用新的HTML替换元素的内容。'
- en: We’ll implement simplified versions of these APIs.The simplifications will be
    minor. `querySelectorAll` will return an array, not this thing called a `NodeList`;
    `innerHTML` will only write the HTML contents of an element, and won’t allow reading
    those contents. This suffices to demonstrate JavaScript–browser interaction.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现这些API的简化版本。这些简化将是微小的。`querySelectorAll` 将返回一个数组，而不是称为`NodeList`的东西；`innerHTML`
    只会写入元素的HTML内容，不允许读取这些内容。这足以演示JavaScript与浏览器的交互。
- en: 'Let’s start with `querySelectorAll`. First, export a function:'
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`querySelectorAll`开始。首先，导出一个函数：
- en: '[PRE357]'
  id: totrans-1617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: 'In JavaScript, `querySelectorAll` is a method on the `document` object, which
    we need to define in the JavaScript runtime:'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`querySelectorAll`是`document`对象上的一个方法，我们需要在JavaScript运行时中定义它：
- en: '[PRE358]'
  id: totrans-1619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: On the Python side, `querySelectorAll` first has to parse the selector and then
    find and return the matching elements. To parse the selector, I’ll call into the
    `CSSParser`’s `selector` method:If you pass `querySelectorAll` an invalid selector,
    the `selector` call will throw an error, and DukPy will convert that Python-side
    exception into a JavaScript-side exception in the web script we are running, which
    can catch it.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python端，`querySelectorAll`首先需要解析选择器，然后找到并返回匹配的元素。为了解析选择器，我将调用`CSSParser`的`selector`方法：如果你向`querySelectorAll`传递一个无效的选择器，`selector`调用将抛出错误，DukPy将把这个Python端的异常转换成我们在Web脚本中运行的JavaScript端的异常，这可以捕获它。
- en: '[PRE359]'
  id: totrans-1621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'Next we need to find and return all matching elements. To do that, we need
    the `JSContext` to have access to the `Tab`, specifically to its `nodes` field.
    So let’s pass in the `Tab` when creating a `JSContext`:'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要找到并返回所有匹配的元素。为此，我们需要`JSContext`能够访问`Tab`，特别是它的`nodes`字段。所以让我们在创建`JSContext`时传递`Tab`：
- en: '[PRE360]'
  id: totrans-1623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: 'Now `querySelectorAll` will find all nodes matching the selector:'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`querySelectorAll`将找到所有匹配选择器的节点：
- en: '[PRE361]'
  id: totrans-1625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: 'Finally, we need to return those nodes back to JavaScript. You might try something
    like this:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将这些节点返回给JavaScript。你可能尝试这样做：
- en: '[PRE362]'
  id: totrans-1627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: However, this throws an error:Yes, that’s a confusing error message. Is it a
    `JSRuntimeError`, an `EvalError`, or a `TypeError`? The confusion is a consequence
    of the complex interaction of Python, JS, and C code. (JSON, or JavaScript Object
    Notation, is a language-independent data format.)
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会抛出一个错误：是的，这是一个令人困惑的错误消息。它是`JSRuntimeError`、`EvalError`还是`TypeError`？这种混淆是Python、JS和C代码复杂交互的结果。（JSON，或JavaScript对象表示法，是一种语言无关的数据格式。）
- en: '[PRE363]'
  id: totrans-1629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: What DukPy is trying to tell you is that it has no idea what to do with the
    `Element` objects that `querySelectorAll` returns. After all, the `Element` class
    only exists in Python, not JavaScript!
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: DukPy试图告诉你的是，它不知道如何处理`querySelectorAll`返回的`Element`对象。毕竟，`Element`类只存在于Python中，而不在JavaScript中！
- en: Python objects need to stay on the Python side of the browser, so JavaScript
    code will need to refer to them via some kind of indirection. I’ll use a simple
    numeric identifier, which I’ll call a *handle* (see Figure 2).Note the similarity
    to file descriptors, which give user-level applications access to kernel data
    structures.
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: Python对象需要留在浏览器的Python一侧，因此JavaScript代码需要通过某种间接方式来引用它们。我将使用一个简单的数字标识符，我将称之为
    *句柄*（见图2）。注意这与文件描述符的相似性，它为用户级应用程序提供了对内核数据结构的访问。
- en: '![Figure 2: The relationship between Node objects in JavaScript and Element/Text
    objects in the browser is maintained through handles.](img/bdb41fd1b661c3a4733cae644fe9d0d7.png)'
  id: totrans-1632
  prefs: []
  type: TYPE_IMG
  zh: '![图2：JavaScript中的Node对象与浏览器中的Element/Text对象之间的关系是通过句柄来维护的。](img/bdb41fd1b661c3a4733cae644fe9d0d7.png)'
- en: 'Figure 2: The relationship between `Node` objects in JavaScript and `Element`/`Text`
    objects in the browser is maintained through handles.'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：JavaScript中的 `Node` 对象与浏览器中的 `Element`/`Text` 对象之间的关系是通过句柄来维护的。
- en: 'We’ll need to keep track of the handle to node mapping. Let’s create a `node_to_handle`
    data structure to map nodes to handles, and a `handle_to_node` map that goes the
    other way:'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要跟踪句柄到节点的映射。让我们创建一个 `node_to_handle` 数据结构来将节点映射到句柄，以及一个反向映射的 `handle_to_node`
    映射：
- en: '[PRE364]'
  id: totrans-1635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: 'Now the `querySelectorAll` handler can allocate handles for each node and return
    those handles instead:'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的 `querySelectorAll` 处理器可以为每个节点分配句柄，并返回这些句柄：
- en: '[PRE365]'
  id: totrans-1637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'The `get_handle` function should create a new handle if one doesn’t exist yet:'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_handle` 函数应该在句柄不存在时创建一个新的句柄：'
- en: '[PRE366]'
  id: totrans-1639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: 'So now the `querySelectorAll` handler returns something like `[1, 3, 4, 7]`,
    with each number being a handle for an element, which DukPy can easily convert
    into JavaScript objects without issue. Now of course, on the JavaScript side,
    `querySelectorAll` shouldn’t return a bunch of numbers: it should return a list
    of `Node` objects.In a real browser, `querySelectorAll` actually returns a [`NodeList`
    object](https://developer.mozilla.org/en-US/docs/Web/API/NodeList), for kind of
    abstruse reasons that aren’t relevant here. So let’s define a `Node` object in
    our runtime that wraps a handle:If your JavaScript is rusty, you might want to
    read up on the crazy way you define classes in JavaScript. Modern JavaScript also
    provides the `class` syntax, which is more sensible, but it’s not supported in
    DukPy.'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 因此现在 `querySelectorAll` 处理器返回类似 `[1, 3, 4, 7]` 的内容，每个数字都是一个元素的句柄，DukPy可以轻松地将它们转换为JavaScript对象而不会出现问题。当然，在JavaScript一侧，`querySelectorAll`
    不应该返回一串数字：它应该返回一个 `Node` 对象的列表。在一个真实的浏览器中，`querySelectorAll` 实际上返回一个 [NodeList
    对象](https://developer.mozilla.org/en-US/docs/Web/API/NodeList)，出于某种在这里不相关的晦涩原因。所以让我们在我们的运行时中定义一个
    `Node` 对象，它封装了一个句柄：如果你的JavaScript知识有点生疏，你可能需要了解一下你定义JavaScript类时的疯狂方式。现代JavaScript也提供了
    `class` 语法，这更合理，但在DukPy中不受支持。
- en: '[PRE367]'
  id: totrans-1641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: We create these `Node` objects in `querySelectorAll`’s wrapper:This code creates
    new `Node` objects every time you call `querySelectorAll`, even if there’s already
    a `Node` for that handle. That means you can’t use equality to compare `Node`
    objects. I’ll ignore that but a real browser wouldn’t.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `querySelectorAll` 的包装器中创建这些 `Node` 对象：此代码在每次调用 `querySelectorAll` 时都会创建新的
    `Node` 对象，即使已经为该句柄存在一个 `Node`。这意味着你不能使用相等性来比较 `Node` 对象。我会忽略这一点，但一个真实的浏览器不会这么做。
- en: '[PRE368]'
  id: totrans-1643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: Wrapping Handles
  id: totrans-1644
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装句柄
- en: Now that we’ve got some `Node`s, what can we do with them?
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一些 `Node` 对象了，我们可以用它们做什么呢？
- en: 'One simple DOM method is `getAttribute`, a method on `Node` objects that lets
    you get the value of HTML attributes. Implementing `getAttribute` means solving
    the opposite problem to `querySelectorAll`: taking `Node` objects on the JavaScript
    side, and shipping them over to Python.'
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的DOM方法是 `getAttribute`，这是一个在 `Node` 对象上的方法，允许你获取HTML属性值。实现 `getAttribute`
    意味着解决与 `querySelectorAll` 相反的问题：在JavaScript一侧获取 `Node` 对象，并将它们发送到Python。
- en: 'The solution is similar to `querySelectorAll`: instead of shipping the `Node`
    object itself, we send over its handle:'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案类似于 `querySelectorAll`：我们不是直接发送 `Node` 对象本身，而是发送其句柄：
- en: '[PRE369]'
  id: totrans-1648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: 'On the Python side, the `getAttribute` function takes two arguments, a handle
    and an attribute:'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python一侧，`getAttribute` 函数接受两个参数，一个句柄和一个属性：
- en: '[PRE370]'
  id: totrans-1650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: Note that if the attribute is not assigned, the `get` method will return `None`,
    which DukPy will translate to JavaScript’s `null`. Don’t forget to export this
    function as `getAttribute`.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果属性未分配，`get` 方法将返回 `None`，DukPy会将它转换为JavaScript的 `null`。别忘了将这个函数导出为 `getAttribute`。
- en: 'We finally have enough of the DOM API to implement a little character count
    function for text areas:'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有足够的DOM API来实现一个简单的文本区域字符计数函数：
- en: '[PRE371]'
  id: totrans-1653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: Ideally, though we’d update the character count every time the user types into
    an input box. That requires running JavaScript on every key press. Let’s implement
    that next.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望每次用户在输入框中输入时都更新字符计数。这需要在每个按键按下时运行JavaScript。让我们在下一次实现它。
- en: '`Node` objects in the DOM correspond to `Element` nodes in the browser. They
    thus have JavaScript object *properties* as well as HTML *attributes*. They’re
    easy to confuse, and to make matters worse, many DOM object properties [*reflect*](https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#reflecting-content-attributes-in-idl-attributes)
    attribute values automatically. For example, the `id` property on `Node` objects
    gives read-write access to the [`id` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id)
    of the underlying `Element`. This is very convenient, and avoids calling `setAttribute`
    and `getAttribute` all over the place. But this reflection only applies to certain
    fields; setting made-up JavaScript properties won’t create corresponding HTML
    attributes, nor vice versa.'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: DOM中的`Node`对象对应于浏览器中的`Element`节点。因此，它们具有JavaScript对象*属性*以及HTML *属性*。它们很容易混淆，而且更糟糕的是，许多DOM对象属性[*反映*](https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#reflecting-content-attributes-in-idl-attributes)自动属性值。例如，`Node`对象上的`id`属性提供了对底层`Element`的`id`属性的读写访问。这非常方便，避免了到处调用`setAttribute`和`getAttribute`。但这种反映只适用于某些字段；设置虚构的JavaScript属性不会创建相应的HTML属性，反之亦然。
- en: Event Handling
  id: totrans-1656
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理
- en: The browser executes JavaScript code as soon as it loads the web page, but that
    code often wants to change the page *in response* to user actions.
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器在加载网页时立即执行JavaScript代码，但该代码通常希望根据用户操作更改页面*响应*。
- en: 'Here’s how that works. Any time the user interacts with the page, the browser
    generates *events*. Each event has a type, like `change`, `click`, or `submit`,
    and happens at a *target element*. The `addEventListener` method allows JavaScript
    to react to those events: `node.addEventListener(''click'', func)` sets `func`
    to run every time the element corresponding to `node` generates a `click` event.
    It’s basically Tk’s `bind`, but in the browser—see Figure 3\. Let’s implement
    it.'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理。每当用户与页面交互时，浏览器都会生成*事件*。每个事件都有一个类型，例如`change`、`click`或`submit`，并且发生在*目标元素*上。`addEventListener`方法允许JavaScript对这些事件做出反应：`node.addEventListener('click',
    func)`将`func`设置为每当与`node`对应的元素生成`click`事件时运行。这基本上是Tk的`bind`，但在浏览器中——见图3。让我们实现它。
- en: '![Figure 3: The browser calls into JavaScript when events happen.](img/490463402d7ed1cbead4e064fd3109a4.png)'
  id: totrans-1659
  prefs: []
  type: TYPE_IMG
  zh: '![图3：当事件发生时，浏览器调用JavaScript。](img/490463402d7ed1cbead4e064fd3109a4.png)'
- en: 'Figure 3: The browser calls into JavaScript when events happen.'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：当事件发生时，浏览器调用JavaScript。
- en: 'Let’s start with generating events. I’ll create a `dispatch_event` method and
    call it whenever an event is generated. That includes, first of all, any time
    we click in the page:'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从生成事件开始。我将创建一个`dispatch_event`方法，并在生成事件时调用它。首先，包括我们点击页面的任何时间：
- en: '[PRE372]'
  id: totrans-1662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: 'Second, before updating input area values:'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在更新输入区域值之前：
- en: '[PRE373]'
  id: totrans-1664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: 'And finally, when submitting forms but before actually sending the request
    to the server:'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在提交表单但在实际向服务器发送请求之前：
- en: '[PRE374]'
  id: totrans-1666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: 'So far so good—but what should the `dispatch_event` method do? Well, it needs
    to run listeners passed to `addEventListener`, so those need to be stored somewhere.
    Since those listeners are JavaScript functions, we need to keep that data on the
    JavaScript side, in a variable in the runtime. I’ll call that variable `LISTENERS`;
    we’ll use it to look up handles and event types, so let’s make it map handles
    to a dictionary that maps event types to a list of listeners:'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利——但是`dispatch_event`方法应该做什么呢？嗯，它需要运行传递给`addEventListener`的监听器，因此这些监听器需要存储在某个地方。由于这些监听器是JavaScript函数，我们需要在JavaScript端保持这些数据，在运行时变量中。我将称这个变量为`LISTENERS`；我们将使用它来查找句柄和事件类型，所以让我们让它映射句柄到一个将事件类型映射到监听器列表的字典：
- en: '[PRE375]'
  id: totrans-1668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: 'To dispatch an event, we need to look up the type and handle in the `LISTENERS`
    array, like this:'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 要分发一个事件，我们需要在`LISTENERS`数组中查找类型和句柄，如下所示：
- en: '[PRE376]'
  id: totrans-1670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: Note that `dispatchEvent` uses the `call` method on functions, which sets the
    value of `this` inside that function. As is standard in JavaScript, I’m setting
    it to the node that the event was generated on.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`dispatchEvent`在函数上使用`call`方法，这设置了该函数内部`this`的值。按照JavaScript的标准，我将它设置为事件发生所在的节点。
- en: 'When an event occurs, the browser calls `dispatchEvent` from Python:'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件发生时，浏览器从Python调用`dispatchEvent`：
- en: '[PRE377]'
  id: totrans-1673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: 'Here, the `EVENT_DISPATCH_JS` constant is a string of JavaScript code that
    dispatches a new event:'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`EVENT_DISPATCH_JS` 常量是一个字符串，用于触发一个新的事件：
- en: '[PRE378]'
  id: totrans-1675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: So when `dispatch_event` is called on the Python side, that runs `dispatchEvent`
    on the JavaScript side, and that in turn runs all of the event listeners. The
    `dukpy` JavaScript object in this code snippet stores the named `type` and `handle`
    arguments to `evaljs`.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当在 Python 端调用 `dispatch_event` 时，它会在 JavaScript 端运行 `dispatchEvent`，然后它又运行了所有的事件监听器。这个代码片段中的
    `dukpy` JavaScript 对象存储了 `evaljs` 的命名 `type` 和 `handle` 参数。
- en: 'With all this event-handling machinery in place, we can update the character
    count every time an input area changes:'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些事件处理机制到位后，我们可以在输入区域每次更改时更新字符计数：
- en: '[PRE379]'
  id: totrans-1678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-1679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: Note that `lengthCheck` uses `this` to reference the input element that actually
    changed, as set up by `dispatchEvent`.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`lengthCheck` 使用 `this` 来引用实际改变输入元素，这是通过 `dispatchEvent` 设置的。
- en: So far so good—but ideally the length check wouldn’t print to the console; it
    would add a warning to the web page itself. To do that, we’ll need to not only
    read from the page but also modify it.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利——但理想情况下长度检查不应该打印到控制台；它应该在网页本身添加一个警告。为此，我们不仅需要从页面中读取，还需要修改它。
- en: JavaScript [first appeared in 1995](https://auth0.com/blog/a-brief-history-of-javascript/),
    as part of Netscape Navigator. Its name was chosen to indicate a similarity to
    the [Java](https://en.wikipedia.org/wiki/Java_(programming_language)) language,
    and the syntax is Java-esque for that reason. However, under the surface JavaScript
    is a much more dynamic language than Java, as is appropriate given its role as
    a progressive enhancement mechanism for the web. For example, any method or property
    on any object (including built-in ones like `Element`) can be dynamically overridden
    at any time. This makes it possible to [polyfill](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill)
    differences between browsers, adding features that look built-in to other JavaScript
    code.
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript [首次出现在 1995 年](https://auth0.com/blog/a-brief-history-of-javascript/)，作为
    Netscape Navigator 的一部分。它的名字被选择来表明与 [Java](https://en.wikipedia.org/wiki/Java_(programming_language))
    语言的相似性，并且由于这个原因，其语法类似于 Java。然而，在表面之下，JavaScript 是一个比 Java 更动态的语言，这是它作为网页渐进增强机制的角色的合适之处。例如，任何对象（包括内置的，如
    `Element`）上的任何方法或属性都可以在任何时候动态覆盖。这使得可以在浏览器之间 [polyfill](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill)
    差异，向其他 JavaScript 代码添加看起来像是内置的功能。
- en: Modifying the DOM
  id: totrans-1683
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改 DOM
- en: 'So far we’ve implemented read-only DOM methods; now we need methods that change
    the page. The full DOM API provides a lot of such methods, but for simplicity
    I’m going to implement only `innerHTML`, which is used like this:'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了只读的 DOM 方法；现在我们需要改变页面的方法。完整的 DOM API 提供了很多这样的方法，但为了简单起见，我将只实现 `innerHTML`，它的用法如下：
- en: '[PRE381]'
  id: totrans-1685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: In other words, `innerHTML` is a *property* of node objects, with a *setter*
    that is run when the field is modified. That setter takes the new value, which
    must be a string, parses it as HTML, and makes the new, parsed HTML nodes children
    of the original node.
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`innerHTML` 是节点对象的一个 *属性*，当字段被修改时，会运行一个 *setter*。这个 setter 会取新的值，这个值必须是一个字符串，将其解析为
    HTML，并将新的、解析后的 HTML 节点作为原始节点的子节点。
- en: 'Let’s implement this, starting on the JavaScript side. JavaScript has the obscure
    `Object.defineProperty` function to define setters, which DukPy supports:'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这个功能，从 JavaScript 端开始。JavaScript 有一个神秘的 `Object.defineProperty` 函数来定义 setter，DukPy
    支持：
- en: '[PRE382]'
  id: totrans-1688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'In `innerHTML_set`, we’ll need to parse the HTML string. That turns out to
    be trickier than you’d think, because our browser’s HTML parser is intended to
    parse whole HTML documents, not these document fragments. As an expedient, close-enough
    hack,Real browsers follow the [standardized parsing algorithm](https://html.spec.whatwg.org/#parsing-html-fragments)
    for HTML fragments. I’ll just wrap the HTML in an `html` and `body` element:'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `innerHTML_set` 中，我们需要解析 HTML 字符串。这比你想象的要复杂，因为我们的浏览器 HTML 解析器旨在解析整个 HTML 文档，而不是这些文档片段。作为一个权宜之计，足够好的黑客攻击，真实浏览器遵循
    [标准化的解析算法](https://html.spec.whatwg.org/#parsing-html-fragments) 来解析 HTML 片段。我只需将
    HTML 包装在 `html` 和 `body` 元素中：
- en: '[PRE383]'
  id: totrans-1690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: 'Don’t forget to export the `innerHTML_set` function. Note that we extract all
    children of the `body` element, because an `innerHTML_set` call can create multiple
    nodes at a time. These new nodes must now be made children of the element `innerHTML_set`
    was called on:'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记导出 `innerHTML_set` 函数。注意，我们提取了 `body` 元素的所有子元素，因为 `innerHTML_set` 调用一次可以创建多个节点。这些新节点现在必须成为
    `innerHTML_set` 调用所在元素的子节点：
- en: '[PRE384]'
  id: totrans-1692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: We update the parent pointers of those parsed child nodes because otherwise
    they would point to the dummy `body` element that we added to aid parsing.
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新了那些解析后的子节点的父指针，因为否则它们将指向我们添加以帮助解析的虚拟`body`元素。
- en: It might look like we’re done—but try this out and you’ll realize that nothing
    happens when a script calls `innerHTML_set`. That’s because, while we have changed
    the HTML tree, we haven’t regenerated the layout tree or the display list, so
    the browser is still showing the old page.
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来我们已经完成了，但尝试一下你会发现，当脚本调用`innerHTML_set`时，没有任何事情发生。那是因为，虽然我们已经改变了HTML树，但我们没有重新生成布局树或显示列表，所以浏览器仍然显示旧页面。
- en: Whenever the page changes, we need to update its rendering by calling `render`:Redoing
    layout for the whole page is often wasteful; [Chapter 16](invalidation.html) explores
    a more complicated algorithm that speeds this up.
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 每当页面发生变化时，我们需要通过调用`render`来更新其渲染：对整个页面重新布局通常是浪费的；[第16章](invalidation.html)探讨了更复杂的算法，可以加快这个过程。
- en: '[PRE385]'
  id: totrans-1696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: JavaScript can now modify the web page!Note that while rendering will update
    to account for the new HTML, any added scripts or style sheets will not properly
    load, and removed style sheets will (incorrectly) still apply. I’ve left fixing
    that as Exercise 9-7.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 现在JavaScript可以修改网页了！注意，虽然渲染将更新以适应新的HTML，但任何添加的脚本或样式表都不会正确加载，而移除的样式表（错误地）仍然会应用。我将修复这个问题留作练习9-7。
- en: Let’s try this out in our guest book. Say we want a 100-character limit on guest
    book entries to prevent long, incoherent rants from making it in.
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在留言簿中尝试这个。比如说，我们想要对留言簿条目设置一个100个字符的限制，以防止长而混乱的评论进入。
- en: First, switch to the server codebase and add a `<strong>` after the guest book
    form. Initially this element will be empty, but we’ll write an error message into
    it if the paragraph gets too long.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，切换到服务器端代码库，并在留言表单后添加一个 `<strong>` 标签。最初这个元素将是空的，但如果段落太长，我们会将其写入错误信息。
- en: '[PRE386]'
  id: totrans-1700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: Also add a script to the page.
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要在页面上添加一个脚本。
- en: '[PRE387]'
  id: totrans-1702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: 'Now the browser will request `comment.js`, so our server needs to *serve* that
    JavaScript file:'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 现在浏览器将请求`comment.js`，所以我们的服务器需要*提供*那个JavaScript文件：
- en: '[PRE388]'
  id: totrans-1704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: 'We can then put our little input length checker into `comment.js`, with the
    `lengthCheck` function modified to use `innerHTML`:'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将我们的小输入长度检查器放入`comment.js`中，将`lengthCheck`函数修改为使用`innerHTML`：
- en: '[PRE389]'
  id: totrans-1706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: 'Try it out: write a long comment and you should see the page warning you when
    it grows too long. By the way, we might want to make it stand out more, so let’s
    go ahead and add another URL to our web server, `/comment.css`, with the contents:'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下：写一个长的评论，你应该会看到当页面变长时，页面会警告你。顺便说一句，我们可能想让它更加突出，所以让我们继续在我们的Web服务器上添加另一个URL，`/comment.css`，内容如下：
- en: '[PRE390]'
  id: totrans-1708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: Add a `link` to the guest book page so that this style sheet is loaded.
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 在留言簿页面上添加一个`link`，以便加载这个样式表。
- en: But even though we tell the user that their comment is too long the user can
    submit the guest book entry anyway. Oops! Let’s fix that.
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们告诉用户他们的评论太长，但用户仍然可以提交留言簿条目。哎呀！让我们来修复这个问题。
- en: 'This code has a subtle memory leak: if you access an HTML element from JavaScript
    (thereby creating a handle for it) and then remove the element from the page (using
    `innerHTML`), Python won’t be able to garbage-collect the `Element` object because
    it is still stored in the `node_to_handle` map. And that’s good, if JavaScript
    can still access that `Element` via its handle, but bad otherwise. Solving this
    is quite tricky, because it requires the Python and JavaScript garbage collectors
    to [cooperate](https://research.google/pubs/pub47359/).'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有一个微妙的内存泄漏：如果你从JavaScript中访问一个HTML元素（从而为其创建一个句柄）然后从页面上移除该元素（使用 `innerHTML`），Python将无法垃圾回收`Element`对象，因为它仍然存储在`node_to_handle`映射中。如果是这样的话，如果JavaScript可以通过其句柄访问那个`Element`，那还好；但如果不是这样，那就不好了。解决这个问题相当棘手，因为它需要Python和JavaScript垃圾回收器[合作](https://research.google/pubs/pub47359/)。
- en: Event Defaults
  id: totrans-1712
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件默认操作
- en: So far, when an event is generated, the browser will run the listeners, and
    then *also* do whatever it normally does for that event—the *default action*.
    I’d now like JavaScript code to be able to *cancel* that default action.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当生成一个事件时，浏览器将运行监听器，然后*还会*执行该事件通常的操作——*默认操作*。我现在希望JavaScript代码能够*取消*这个默认操作。
- en: There are a few steps involved. First of all, event listeners should receive
    an *event object* as an argument. That object should have a `preventDefault` method.
    When that method is called, the default action shouldn’t occur.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及到几个步骤。首先，事件监听器应该接收一个*事件对象*作为参数。该对象应该有一个`preventDefault`方法。当调用该方法时，默认操作不应发生。
- en: 'First of all, we’ll need event objects. Back to our JavaScript runtime:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要事件对象。回到我们的 JavaScript 运行时：
- en: '[PRE391]'
  id: totrans-1716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: 'Note the `do_default` field, to record whether `preventDefault` has been called.
    We’ll now be passing an `Event` object to `dispatchEvent`, instead of just the
    event type:'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `do_default` 字段，用于记录是否调用了 `preventDefault`。现在我们将传递一个 `Event` 对象给 `dispatchEvent`，而不是仅仅传递事件类型：
- en: '[PRE392]'
  id: totrans-1718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: 'In Python, we now need to create an `Event` to pass to `dispatchEvent`:'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们现在需要创建一个 `Event` 对象传递给 `dispatchEvent`：
- en: '[PRE393]'
  id: totrans-1720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: 'Also note that `dispatchEvent` returns `evt.do_default`, which is not only
    standard in JavaScript but also helpful when dispatching events from Python, because
    Python’s `dispatch_event` can return that boolean to its handler:'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`dispatchEvent` 返回 `evt.do_default`，这不仅符合 JavaScript 的标准，而且在从 Python 分发事件时也很有用，因为
    Python 的 `dispatch_event` 可以将那个布尔值返回给其处理程序：
- en: '[PRE394]'
  id: totrans-1722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: 'This way, every time an event happens, the browser can check the return value
    of `dispatch_event` and stop if it is `True`. We have three such places in the
    `click` method:'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每次发生事件时，浏览器都可以检查 `dispatch_event` 的返回值，并在它是 `True` 时停止。我们在 `click` 方法中有三个这样的地方：
- en: '[PRE395]'
  id: totrans-1724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: 'And one in `submit_form`:'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `submit_form` 中有一个：
- en: '[PRE396]'
  id: totrans-1726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: 'And one in `keypress`:'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `keypress` 中有一个：
- en: '[PRE397]'
  id: totrans-1728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: 'Now our character count code can prevent the user from submitting a form: it
    can use a global variable to track whether or not submission is allowed, and then
    when submission is attempted it can check that variable and cancel that submission
    if necessary:'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用字符计数代码来阻止用户提交表单：它可以使用一个全局变量来跟踪是否允许提交，然后在尝试提交时检查该变量，并在必要时取消该提交：
- en: '[PRE398]'
  id: totrans-1730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: This way it’s impossible to submit the form when the comment is too long!
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当评论过长时，就 impossible 提交表单了！
- en: 'Well … impossible in this browser. But since there are browsers that don’t
    run JavaScript (like ours, one chapter back), we should check the length on the
    server side too:'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯……在这个浏览器中是不可能的。但是，由于有一些浏览器不运行 JavaScript（就像我们之前的一章中提到的），我们也应该在服务器端检查长度：
- en: '[PRE399]'
  id: totrans-1733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: Note that we shouldn’t—can’t—rely on JavaScript being executed by the browser,
    because the browser is the user’s agent, not ours. Ideally, web pages should be
    written so that they work correctly without JavaScript, but work better with it.
    This is called [progressive enhancement](https://en.wikipedia.org/wiki/Progressive_enhancement),
    and it means we’re not replicating in JavaScript what the browser can already
    do.
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不应该——也不能——依赖于浏览器执行 JavaScript，因为浏览器是用户的代理，而不是我们的。理想情况下，网页应该编写得在没有 JavaScript
    的情况下也能正确工作，但在有 JavaScript 的情况下工作得更好。这被称为 [渐进增强](https://en.wikipedia.org/wiki/Progressive_enhancement)，这意味着我们不会在
    JavaScript 中复制浏览器已经可以做到的事情。
- en: 'A closing thought: while our guest book now has a little bit of JavaScript
    code, it’s still mostly HTML, CSS, form elements, other standard web features.
    In this way JavaScript extends the web instead of replacing it. This is in contrast
    to the recently departed [Adobe Flash](https://www.adobe.com/products/flashplayer/end-of-life.html),
    and before that [Java Applets](https://en.wikipedia.org/wiki/Java_applet), which
    were self-contained plug-ins that handled input and rendering on their own.'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 一个思考：虽然我们的留言簿现在有一点点 JavaScript 代码，但它仍然主要是 HTML、CSS、表单元素和其他标准网络功能。这样，JavaScript
    扩展了网络而不是取代它。这与最近已经退出舞台的 [Adobe Flash](https://www.adobe.com/products/flashplayer/end-of-life.html)
    和之前的 [Java Applets](https://en.wikipedia.org/wiki/Java_applet) 形成对比，后者是自包含的插件，可以独立处理输入和渲染。
- en: Search engines are constantly [crawling](https://en.wikipedia.org/wiki/Web_crawler)
    the web and [indexing](https://en.wikipedia.org/wiki/Search_engine_indexing) all
    of the web pages they can find. In the early days, indexing was just a matter
    of loading the HTML, parsing it and extracting the information. But these days,
    a lot of [single-page app](https://en.wikipedia.org/wiki/Single-page_application)
    sites use JavaScript to [“hydrate”](https://en.wikipedia.org/wiki/Hydration_(web_development))This
    process is called “hydration” by analogy with how water is added to dehydrated
    food to make it edible again. their site into its full contents. On such sites,
    before hydration happens, the information in the site is hidden inside of JavaScript
    data structures. For this reason, search engines need to not just parse HTML,
    but also run JavaScript (and load style sheets) during indexing. In other words,
    the indexing systems use browsers (such as, for example, [headless Chrome](https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md))—one
    more place browsers appear in the web ecosystem.
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索引擎不断[抓取](https://en.wikipedia.org/wiki/Web_crawler)网络并[索引](https://en.wikipedia.org/wiki/Search_engine_indexing)它们能找到的所有网页。在早期，索引仅仅是加载HTML，解析它并提取信息的事情。但如今，许多[单页应用](https://en.wikipedia.org/wiki/Single-page_application)网站使用JavaScript来[“激活”](https://en.wikipedia.org/wiki/Hydration_(web_development))它们的网站，使其内容完整。在这些网站上，在激活之前，网站中的信息隐藏在JavaScript数据结构中。因此，搜索引擎不仅需要解析HTML，还需要在索引过程中运行JavaScript（以及加载样式表）。换句话说，索引系统使用浏览器（例如，例如[无头Chrome](https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md)）——浏览器在Web生态系统中的又一出现。
- en: Summary
  id: totrans-1737
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Our browser now runs JavaScript applications on behalf of websites. Granted,
    it supports just four methods from the vast DOM API, but even those demonstrate:'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器现在代表网站运行JavaScript应用程序。诚然，它只支持DOM API中的四种方法，但即使是这些也证明了：
- en: generating handles to allow scripts to refer to page elements;
  id: totrans-1739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成句柄以允许脚本引用页面元素；
- en: reading attribute values from page elements;
  id: totrans-1740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从页面元素中读取属性值；
- en: writing and modifying page elements;
  id: totrans-1741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和修改页面元素；
- en: attaching event listeners so that scripts can respond to page events.
  id: totrans-1742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加事件监听器，以便脚本可以响应用户界面事件。
- en: A web page can now add functionality via a clever script, instead of waiting
    for a browser developer to add it into the browser itself. And as a side benefit,
    a web page can now earn the lofty title of “web application”.
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 现在网页可以通过一个巧妙的脚本添加功能，而不是等待浏览器开发者将其添加到浏览器本身中。作为一个额外的好处，网页现在可以赢得“网络应用”这一崇高的称号。
- en: Starting with this chapter, I won’t be able to inline the chapter’s browser
    into an iframe, due to security restrictions related to the way I’m communicating
    with scripts within the web page. But you can still load it in a new browser tab
    by clicking [here](widgets/lab9-browser.html).
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，由于与网页内脚本通信方式相关的安全限制，我无法将本章的浏览器内嵌到iframe中。但您可以通过点击[这里](widgets/lab9-browser.html)在新浏览器标签页中加载它。
- en: Outline
  id: totrans-1745
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should now
    look something like this:'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整函数、类和方法集现在看起来可能像这样：
- en: '`` class URL: `def __init__(url)` `def request(payload)` `def resolve(url)`
    `def __str__()` `` `` class Text: `def __init__(text, parent)` `def __repr__()`
    `` `` class Element: `def __init__(tag, attributes, parent)` `def __repr__()`
    `` `def print_tree(node, indent)` `def tree_to_list(tree, list)` `` class HTMLParser:
    `SELF_CLOSING_TAGS` `HEAD_TAGS` `def __init__(body)` `def parse()` `def get_attributes(text)`
    `def add_text(text)` `def add_tag(tag)` `def implicit_tags(tag)` `def finish()`
    `` `` class CSSParser: `def __init__(s)` `def whitespace()` `def literal(literal)`
    `def word()` `def ignore_until(chars)` `def pair()` `def selector()` `def body()`
    `def parse()` `` `` class TagSelector: `def __init__(tag)` `def matches(node)`
    `` `` class DescendantSelector: `def __init__(ancestor, descendant)` `def matches(node)`
    `` `FONTS` `def get_font(size, weight, style)` `DEFAULT_STYLE_SHEET` `INHERITED_PROPERTIES`
    `def style(node, rules)` `def cascade_priority(rule)` `WIDTH, HEIGHT` `HSTEP,
    VSTEP` `` class Rect: `def __init__(left, top, right, bottom)` `def contains_point(x,
    y)` `` `INPUT_WIDTH_PX` `BLOCK_ELEMENTS` `` class DocumentLayout: `def __init__(node)`
    `def layout()` `def should_paint()` `def paint()` `` `` class BlockLayout: `def
    __init__(node, parent, previous)` `def layout_mode()` `def layout()` `def recurse(node)`
    `def new_line()` `def word(node, word)` `def input(node)` `def self_rect()` `def
    should_paint()` `def paint()` `` `` class LineLayout: `def __init__(node, parent,
    previous)` `def layout()` `def should_paint()` `def paint()` `` `` class TextLayout:
    `def __init__(node, word, parent, previous)` `def layout()` `def should_paint()`
    `def paint()` `` `` class InputLayout: `def __init__(node, parent, previous)`
    `def layout()` `def should_paint()` `def paint()` `def self_rect()` `` `` class
    DrawText: `def __init__(x1, y1, text, font, color)` `def execute(scroll, canvas)`
    `` `` class DrawRect: `def __init__(rect, color)` `def execute(scroll, canvas)`
    `` `` class DrawLine: `def __init__(x1, y1, x2, y2, color, thickness)` `def execute(scroll,
    canvas)` `` `` class DrawOutline: `def __init__(rect, color, thickness)` `def
    execute(scroll, canvas)` `` `def paint_tree(layout_object, display_list)` `EVENT_DISPATCH_JS`
    `RUNTIME_JS` `` class JSContext: `def __init__(tab)` `def run(script, code)` `def
    dispatch_event(type, elt)` `def get_handle(elt)` `def querySelectorAll(selector_text)`
    `def getAttribute(handle, attr)` `def innerHTML_set(handle, s)` `` `SCROLL_STEP`
    `` class Tab: `def __init__(tab_height)` `def load(url, payload)` `def render()`
    `def draw(canvas, offset)` `def scrolldown()` `def click(x, y)` `def go_back()`
    `def submit_form(elt)` `def keypress(char)` `` `` class Chrome: `def __init__(browser)`
    `def tab_rect(i)` `def paint()` `def click(x, y)` `def keypress(char)` `def enter()`
    `def blur()` `` `` class Browser: `def __init__()` `def draw()` `def new_tab(url)`
    `def handle_down(e)` `def handle_click(e)` `def handle_key(e)` `def handle_enter(e)`
    ``'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-1748
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 9-1 *`Node.children`*. Add support for the [`children`](https://developer.mozilla.org/en-US/docs/Web/API/Element/children)
    property on JavaScript `Node`s. `Node.children` returns the immediate `Element`
    children of a node, as an array. `Text` children are not included.The DOM method
    `childNodes` gives access to both elements and text nodes.
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 9-1 *`Node.children`*. 在JavaScript `Node` 上添加对 `children` [属性](https://developer.mozilla.org/en-US/docs/Web/API/Element/children)
    的支持。`Node.children` 返回一个数组，包含节点的直接 `Element` 子元素。`Text` 子元素不包括在内。DOM方法 `childNodes`
    提供了对元素和文本节点的访问。
- en: 9-2 *`createElement`*. The [`document.createElement`](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement)
    method creates a new element, which can be *attached* to the document with the
    [`appendChild`](https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild)
    and [`insertBefore`](https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore)
    methods on `Node`s; unlike `innerHTML`, there’s no parsing involved. Implement
    all three methods.
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 9-2 *`createElement`*. `document.createElement` [方法](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement)
    创建一个新元素，该元素可以通过 `Node` 上的 `appendChild` 和 `insertBefore` [方法](https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild)
    和 [方法](https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore)附加到文档中；与
    `innerHTML` 不同，没有涉及解析。实现所有三个方法。
- en: 9-3 *`removeChild`*. The [`removeChild`](https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild)
    method on `Node`s detaches the provided child and returns it, bringing that child—and
    its subtree—back into a *detached* state. (It can then be *re-attached* elsewhere,
    with `appendChild` and `insertBefore`, or deleted.) Implement this method. It’s
    more challenging to implement this one, because you’ll need to also remove the
    subtree from the Python side.
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: 9-3 *`removeChild`*. `Node` 上的 `removeChild` [方法](https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild)
    从提供的子元素中分离该子元素并返回它，将那个子元素及其子树带回 *分离* 状态。（然后它可以被 *重新附加* 到其他地方，使用 `appendChild`
    和 `insertBefore`，或者被删除。）实现此方法。实现这个方法更具挑战性，因为您还需要从Python端删除子树。
- en: 9-4 *IDs*. When an HTML element has an `id` attribute, a JavaScript variable
    pointing to that element is predefined. So, if a page has a `<div id="foo"></div>`,
    then there’s a variable `foo` referring to that node.This is [standard](http://www.whatwg.org/specs/web-apps/current-work/#named-access-on-the-window-object)
    behavior. Implement this in your browser. Make sure to handle the case of nodes
    being added and removed (such as with `innerHTML`).
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: 9-4 *ID*. 当一个HTML元素有 `id` 属性时，一个指向该元素的JavaScript变量是预定义的。因此，如果页面有一个 `<div id="foo"></div>`，那么就有一个变量
    `foo` 指向该节点。这是 [标准](http://www.whatwg.org/specs/web-apps/current-work/#named-access-on-the-window-object)
    行为。在您的浏览器中实现这一点。确保处理节点被添加和删除的情况（例如使用 `innerHTML`）。
- en: '9-5 *Event bubbling*. Right now, you can attach a `click` handler to `a` (anchor)
    elements, but not to anything else. Fix this. One challenge you’ll face is that
    when you click on an element, you also click on all its ancestors. On the web,
    this sort of quirk is handled by [*event bubbling*](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling):
    when an event is generated on an element, listeners are run not just on that element
    but also on its ancestors. Implement event bubbling, and make sure listeners can
    call `stopPropagation` on the event object to stop bubbling the event up the tree.
    Double-check that clicking on links still works, and make sure `preventDefault`
    still successfully prevents clicks on a link from actually following the link.'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 9-5 *事件冒泡*. 目前，您可以将 `click` 处理程序附加到 `a`（锚点）元素上，但不能附加到其他任何元素上。修复这个问题。您将面临的一个挑战是，当您点击一个元素时，您也会点击其所有祖先元素。在网络上，这种怪癖是通过
    [*事件冒泡*](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling)
    处理的：当在元素上生成事件时，监听器不仅在该元素上运行，还在其祖先元素上运行。实现事件冒泡，并确保监听器可以在事件对象上调用 `stopPropagation`
    以停止事件向上冒泡。请再次确认点击链接仍然有效，并确保 `preventDefault` 仍然成功阻止点击链接以实际跟随链接。
- en: '9-6 *Serializing HTML*. Reading from [`innerHTML`](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)
    should return a string containing HTML source code. That source code should reflect
    the *current* attributes of the element; for example:'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 9-6 *序列化HTML*. 从 `innerHTML` [读取](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)
    应该返回一个包含HTML源代码的字符串。该源代码应反映元素的 *当前* 属性；例如：
- en: '[PRE400]'
  id: totrans-1755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: Implement this behavior for `innerHTML` as a getter. Also implement `outerHTML`,
    which differs from `innerHTML` in that it contains the element itself, not just
    its children.
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: 将此行为作为 `innerHTML` 的 getter 实现。同时实现 `outerHTML`，它与 `innerHTML` 的区别在于它包含元素本身，而不仅仅是其子元素。
- en: 9-7 *Script-added scripts and style sheets*. The `innerHTML` API could cause
    `<script>` or `<link>` elements to be added to the document, but currently our
    browser does not load them when this happens. Fix this. Likewise, when a `<link>`
    element is removed from the document, its style sheet should be removed from the
    global list; implement that as well.Note that, unlike a style sheet, a removed
    `<script>`’s evaluated code still exists for the lifetime of the web page. Can
    you see why it has to be that way?
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 9-7 *脚本添加的脚本和样式表*。`innerHTML`API可能会导致`<script>`或`<link>`元素被添加到文档中，但当前我们的浏览器在发生这种情况时不会加载它们。修复这个问题。同样，当`<link>`元素从文档中移除时，其样式表也应该从全局列表中移除；也要实现这一点。请注意，与样式表不同，移除的`<script>`的评估代码仍然存在于网页的生命周期中。你能看出为什么必须这样吗？
- en: Keeping Data Private
  id: totrans-1758
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护数据隐私
- en: Chapter 10 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: '[Web浏览器工程](./index.html "目录")的第10章。'
- en: '[Cookies](#cookies)'
  id: totrans-1760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Cookies](#cookies)'
- en: '[A Login System](#a-login-system)'
  id: totrans-1761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[登录系统](#a-login-system)'
- en: '[Implementing Cookies](#implementing-cookies)'
  id: totrans-1762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实现Cookies](#implementing-cookies)'
- en: '[Cross-site Requests](#cross-site-requests)'
  id: totrans-1763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[跨站请求](#cross-site-requests)'
- en: '[Same-origin Policy](#same-origin-policy)'
  id: totrans-1764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[同源策略](#same-origin-policy)'
- en: '[Cross-site Request Forgery](#cross-site-request-forgery)'
  id: totrans-1765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[跨站请求伪造](#cross-site-request-forgery)'
- en: '[SameSite Cookies](#samesite-cookies)'
  id: totrans-1766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SameSite Cookies](#samesite-cookies)'
- en: '[Cross-site Scripting](#cross-site-scripting)'
  id: totrans-1767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[跨站脚本](#cross-site-scripting)'
- en: '[Content Security Policy](#content-security-policy)'
  id: totrans-1768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内容安全策略](#content-security-policy)'
- en: '[Summary](#summary)'
  id: totrans-1769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summary)'
- en: '[Outline](#outline)'
  id: totrans-1770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大纲](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-1771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: 'Our browser has grown up and now runs (small) web applications. With one final
    step—user identity via cookies—it will be able to run all sorts of personalized
    online services. But capability demands responsibility: our browser must now secure
    cookies against adversaries interested in stealing them. Luckily, browsers have
    sophisticated systems for controlling access to cookies and preventing their misuse.'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器已经成长起来，现在可以运行（小型）Web应用程序。通过最后一步——通过cookie实现用户身份——它将能够运行各种个性化的在线服务。但是能力需要责任：我们的浏览器现在必须保护cookie免受那些想要窃取它们的对手的侵害。幸运的是，浏览器有复杂的系统来控制对cookie的访问并防止其滥用。
- en: 'Web security is a vast topic, covering browser, network, and application security.
    It also involves educating the user, so that attackers can’t mislead them into
    revealing their own secure data. This chapter can’t cover all of that: if you’re
    writing web applications or other security-sensitive code, this book is not enough.'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全是一个广泛的话题，涵盖了浏览器、网络和应用安全。它还涉及到对用户的培训，以便攻击者不能误导他们泄露自己的安全数据。本章无法涵盖所有内容：如果你正在编写Web应用程序或其他安全敏感的代码，这本书是不够的。
- en: Cookies
  id: totrans-1774
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cookies
- en: With what we’ve implemented so far, there’s no way for a web server to tell
    whether two HTTP requests come from the same user or from two different ones;
    our browser is effectively anonymous.I don’t mean anonymous against malicious
    attackers, who might use *browser fingerprinting* or similar techniques to tell
    users apart. I mean anonymous in the good-faith sense. That means it can’t “log
    in” anywhere, since a logged-in user’s requests would be indistinguishable from
    those of not-logged-in users.
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实现的方法无法让Web服务器判断两个HTTP请求是否来自同一个用户或两个不同的用户；我们的浏览器实际上是匿名的。我并不是指对抗恶意攻击者，他们可能会使用*浏览器指纹识别*或类似技术来区分用户。我指的是在善意意义上的匿名。这意味着它不能“登录”任何地方，因为登录用户请求与未登录用户请求是无法区分的。
- en: The web fixes this problem with cookies. A cookie—the name is meaningless, ignore
    it—is a little bit of information stored by your browser on behalf of a web server.
    The cookie distinguishes your browser from any other, and is sent with each web
    request so the server can distinguish which requests come from whom. In effect,
    a cookie is a decentralized, server-granted identity for your browser.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 网络通过cookie解决这个问题。cookie——这个名字没有意义，忽略它——是浏览器代表Web服务器存储的一小部分信息。cookie区分了你的浏览器与其他任何浏览器，并且与每个Web请求一起发送，以便服务器可以区分哪些请求来自谁。实际上，cookie是浏览器的一个去中心化、由服务器授予的身份。
- en: 'Here are the technical details. An HTTP response can contain a `Set-Cookie`
    header. This header contains a key–value pair; for example, the following header
    sets the value of the `foo` cookie to `bar`:'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是技术细节。HTTP响应可以包含一个`Set-Cookie`头。这个头包含一个键值对；例如，以下头将`foo`cookie的值设置为`bar`：
- en: '[PRE401]'
  id: totrans-1778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: 'The browser remembers this key–value pair, and the next time it makes a request
    to the same server (cookies are site-specific), the browser echoes it back in
    the `Cookie` header:'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器会记住这个键值对，下次它向同一服务器（cookies是针对特定站点的）发送请求时（cookies是站点特定的），浏览器会在`Cookie`头部中回显它：
- en: '[PRE402]'
  id: totrans-1780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: Servers can set multiple cookies, and also set parameters like expiration dates,
    but this `Set-Cookie` / `Cookie` transaction as shown in Figure 1 is the core
    principle.
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以设置多个cookies，也可以设置参数，如过期日期，但如图1所示的`Set-Cookie` / `Cookie`事务是核心原则。
- en: '![Figure 1: The server assigns cookies to the browser with the Set-Cookie header,
    and the browser thereafter identifies itself with the Cookie header.](img/9d49b9523c994d40e6dd850e149ef248.png)'
  id: totrans-1782
  prefs: []
  type: TYPE_IMG
  zh: '![图1：服务器通过Set-Cookie头部将cookies分配给浏览器，浏览器随后使用Cookie头部来标识自己。](img/9d49b9523c994d40e6dd850e149ef248.png)'
- en: 'Figure 1: The server assigns cookies to the browser with the `Set-Cookie` header,
    and the browser thereafter identifies itself with the `Cookie` header.'
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：服务器通过`Set-Cookie`头部将cookies分配给浏览器，浏览器随后使用`Cookie`头部来标识自己。
- en: 'Let’s use cookies to write a login system for our guest book. Each user will
    be identified by a long random number stored in the `token` cookie.This `random.random`
    call returns a decimal number with 53 bits of randomness. That’s not great; 256
    bits is typically the goal. And `random.random` is not a secure random number
    generator: by observing enough tokens you can predict future values and use those
    to hijack accounts. A real web application must use a cryptographically secure
    random number generator for tokens. The server will either extract a token from
    the `Cookie` header, or generate a new one for new visitors:'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用cookies为我们的留言板编写一个登录系统。每个用户将通过存储在`token`cookie中的长随机数来识别。这个`random.random`调用返回一个具有53位随机性的十进制数。这并不理想；通常目标是256位。而且`random.random`不是一个安全的随机数生成器：通过观察足够的tokens，你可以预测未来的值并使用这些值来劫持账户。真正的Web应用程序必须使用密码学安全的随机数生成器来生成tokens。服务器将要么从`Cookie`头部提取一个token，要么为新访客生成一个新的token：
- en: '[PRE403]'
  id: totrans-1785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: 'Of course, new visitors need to be told to remember their newly generated token:'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，新访客需要被告知记住他们新生成的token：
- en: '[PRE404]'
  id: totrans-1787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: The first code block runs after all the request headers are parsed, before handling
    the request in `do_request`, while the second code block runs after `do_request`
    returns, when the server is assembling the HTTP response.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个代码块在解析完所有请求头部后运行，在处理`do_request`请求之前，而第二个代码块在`do_request`返回后运行，当服务器正在组装HTTP响应时。
- en: With these two code changes, each visitor to the guest book now has a unique
    identity. We can now use that identity to store information about each user. Let’s
    do that in a server side `SESSIONS` variable:Browsers and servers both limit header
    lengths, so it’s best to store minimal data in cookies. Plus, cookies are sent
    back and forth on every request, so long cookies mean a lot of useless traffic.
    It’s therefore wise to store user data on the server, and only store a pointer
    to that data in the cookie. And, since cookies are stored by the browser, they
    can be changed arbitrarily by the user, so it would be insecure to trust the cookie
    data.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个代码更改，现在每个访问留言板的访客都有一个唯一的身份。我们现在可以使用这个身份来存储有关每个用户的信息。让我们在服务器端的`SESSIONS`变量中这样做：浏览器和服务器都对头部长度有限制，因此最好在cookies中存储最少的数据。此外，cookies在每次请求中都会来回发送，所以长的cookies意味着大量的无用流量。因此，将用户数据存储在服务器上，只在cookies中存储该数据的指针是明智的。而且，由于cookies由浏览器存储，用户可以随意更改它们，因此信任cookie数据是不安全的。
- en: '[PRE405]'
  id: totrans-1790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '`SESSIONS` maps tokens to session data dictionaries. The `setdefault` method
    both gets a key from a dictionary and also sets a default value if the key isn’t
    present. I’m passing that session data via `do_request` to individual pages like
    `show_comments` and `add_entry`:'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: '`SESSIONS`将tokens映射到会话数据字典。`setdefault`方法既从字典中获取一个键，如果键不存在，也会设置一个默认值。我通过`do_request`将这个会话数据传递给单个页面，如`show_comments`和`add_entry`：'
- en: '[PRE406]'
  id: totrans-1792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: You’ll need to modify the argument lists for `add_entry` and `show_comments`
    to accept this new argument. We now have the foundation upon which to build a
    login system.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要修改`add_entry`和`show_comments`的参数列表，以接受这个新参数。我们现在有了构建登录系统的基础。
- en: The [original specification](https://curl.se/rfc/cookie_spec.html) for cookies
    says there is “no compelling reason” for calling them “cookies”, but in fact using
    this term for opaque identifiers exchanged between programs seems to date way
    back; [Wikipedia](https://en.wikipedia.org/wiki/Magic_cookie) traces it back to
    at least 1979, and cookies were used in [X11](https://en.wikipedia.org/wiki/X_Window_authorization#Cookie-based_access)
    for authentication before they were used on the web.
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: 关于cookie的[原始规范](https://curl.se/rfc/cookie_spec.html)表示“没有充分的理由”将它们称为“cookie”，但实际上，在程序之间交换的不透明标识符中使用这个术语似乎可以追溯到很久以前；[维基百科](https://en.wikipedia.org/wiki/Magic_cookie)将其追溯到至少1979年，在它们在Web上使用之前，cookie被用于[X11](https://en.wikipedia.org/wiki/X_Window_authorization#Cookie-based_access)进行身份验证。
- en: A Login System
  id: totrans-1795
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录系统
- en: 'I want users to log in before posting to the guest book. Minimally, that means:'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 我想用户在留言簿中发布之前必须登录。至少这意味着：
- en: Users will log in with a username and password.
  id: totrans-1797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将使用用户名和密码登录。
- en: The server will check if the login is valid.
  id: totrans-1798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器将检查登录是否有效。
- en: Users have to be logged in to add guest book entries.
  id: totrans-1799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须登录才能添加留言簿条目。
- en: The server will display who added which guest book entry.
  id: totrans-1800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器将显示谁添加了哪个留言簿条目。
- en: 'Let’s start coding. We’ll hard-code two user/password pairs:'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编码。我们将硬编码两个用户/密码对：
- en: '[PRE407]'
  id: totrans-1802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: 'Users will log in by going to `/login`:'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过访问`/login`来登录：
- en: '[PRE408]'
  id: totrans-1804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: This page shows a form with a username and a password field:I’ve given the `password`
    input area the type `password`, which in a real browser will draw stars or dots
    instead of showing what you’ve entered, though our browser doesn’t do that; see
    [Exercise 10-1](#exercises). Also, do note that this is not particularly accessible
    HTML, lacking for example `<label>` elements around the form labels. Not that
    our browser supports that!
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面显示了一个包含用户名和密码字段的表单：我已经给`password`输入区域设置了类型`password`，在真正的浏览器中，它将绘制星号或点而不是显示你输入的内容，尽管我们的浏览器不这样做；参见[练习10-1](#exercises)。此外，请注意，这不是特别易于访问的HTML，例如，表单标签周围缺少`<label>`元素。我们的浏览器不支持这些！
- en: '[PRE409]'
  id: totrans-1806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: 'Note that the form `POST`s its data to the `/` URL. We’ll want to handle these
    `POST` requests in a new function that checks passwords and does logins:'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，表单通过`POST`方法将数据发送到`/` URL。我们希望在一个新函数中处理这些`POST`请求，该函数检查密码并执行登录操作：
- en: '[PRE410]'
  id: totrans-1808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: 'This `do_login` function checks passwords and logs people in by storing their
    user name in the session data:Actually, using `==` to compare passwords like this
    is a bad idea: Python’s equality function for strings scans the string from left
    to right, and exits as soon as it finds a difference. Therefore, you get a clue
    about the password from *how long* it takes to check a password guess; this is
    called a [timing side channel](https://en.wikipedia.org/wiki/Timing_attack). This
    book is about the browser, not the server, but a real web application has to do
    a [constant-time string comparison](https://www.chosenplaintext.ca/articles/beginners-guide-constant-time-cryptography.html)!'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`do_login`函数检查密码并通过在会话数据中存储用户名来登录用户：实际上，使用`==`来比较密码这种做法是不好的：Python的字符串相等函数从左到右扫描字符串，并在找到差异时立即退出。因此，你可以从检查密码猜测所需的时间长度中获取关于密码的线索；这被称为[时间侧信道](https://en.wikipedia.org/wiki/Timing_attack)。这本书是关于浏览器的，而不是服务器，但一个真正的Web应用必须进行[恒时字符串比较](https://www.chosenplaintext.ca/articles/beginners-guide-constant-time-cryptography.html)！
- en: '[PRE411]'
  id: totrans-1810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: Note that the session data (including the `user` key) is stored on the server,
    so users can’t modify it directly. That’s good, because we only want to set the
    `user` key in the session data if users supply the right password in the login
    form.
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，会话数据（包括`user`键）存储在服务器上，因此用户不能直接修改它。这是好事，因为我们只想在登录表单中提供正确密码的用户时在会话数据中设置`user`键。
- en: 'So now we can check if a user is logged in by checking the `session` data.
    Let’s only show the comment form to logged in users:'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过检查`session`数据来确认用户是否已登录。让我们只向已登录用户显示评论表单：
- en: '[PRE412]'
  id: totrans-1813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: 'Likewise, `add_entry` must check that the user is logged in before posting
    comments:'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`add_entry`必须在发布评论之前检查用户是否已登录：
- en: '[PRE413]'
  id: totrans-1815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: Note that the username from the session is stored into `ENTRIES`:The pre-loaded
    comments reference 1995’s *Hackers*. [Hack the Planet!](https://xkcd.com/1337)
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，会话中的用户名被存储到`ENTRIES`中：预加载的评论引用了1995年的*黑客*。[征服地球！](https://xkcd.com/1337)
- en: '[PRE414]'
  id: totrans-1817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: 'When we print the guest book entries, we’ll show who authored them:'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印留言簿条目时，我们会显示它们的作者：
- en: '[PRE415]'
  id: totrans-1819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: Try it out in a normal web browser. You should be able to go to the main guest
    book page, click the link to log in, log in with one of the username/password
    pairs above, and then be able to post entries.The login flow slows down debugging.
    You might want to add the empty string as a username/password pair. Of course,
    this login system has a whole slew of insecurities.The insecurities include not
    hashing passwords, not using [`bcrypt`](https://auth0.com/blog/hashing-in-action-understanding-bcrypt/),
    not allowing password changes, not having a “forget your password” flow, not forcing
    TLS, not sandboxing the server, and many many others. But the focus of this book
    is the browser, not the server, so once you’re sure it’s all working, let’s switch
    back to our web browser and implement cookies.
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通网络浏览器中尝试一下。你应该能够进入主留言簿页面，点击登录链接，使用上面列出的用户名/密码之一登录，然后能够发布条目。登录流程会减慢调试速度。你可能想添加一个空字符串作为用户名/密码对。当然，这个登录系统有一系列不安全性。这些不安全性包括不散列密码，不使用[`bcrypt`](https://auth0.com/blog/hashing-in-action-understanding-bcrypt/)，不允许更改密码，没有“忘记密码”流程，不强制使用TLS，不对服务器进行沙箱隔离，以及许多其他问题。但本书的重点是浏览器，而不是服务器，所以一旦你确定一切正常，让我们回到我们的网络浏览器并实现cookie。
- en: A more obscure browser authentication system is [TLS client certificates](https://aboutssl.org/ssl-tls-client-authentication-how-does-it-works/).
    The user downloads a public/private key pair from the server, and the browser
    then uses them to prove who it is upon later requests to that server. Also, if
    you’ve ever seen a URL with `username:password@` before the hostname, that’s [HTTP
    authentication](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication).
    Please don’t use either method in new websites (without a good reason).
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更神秘的浏览器身份验证系统是[TLS客户端证书](https://aboutssl.org/ssl-tls-client-authentication-how-does-it-works/)。用户从服务器下载一个公钥/私钥对，然后浏览器在后续对该服务器的请求中用它们来证明自己的身份。此外，如果你以前见过在主机名之前有`username:password@`的URL，那么那是[HTTP身份验证](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication)。请勿在新网站（除非有充分的理由）中使用这两种方法。
- en: Implementing Cookies
  id: totrans-1822
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Cookies
- en: To start, we need a place in the browser that stores cookies; that data structure
    is traditionally called a *cookie jar*:Because once you have one silly name it’s
    important to stay on-brand.
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在浏览器中找到一个存储cookie的地方；这个数据结构传统上被称为*cookie jar*：因为一旦你有一个愚蠢的名字，保持品牌一致性就很重要。
- en: '[PRE416]'
  id: totrans-1824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: Since cookies are site-specific, our cookie jar will map sites to cookies. Note
    that the cookie jar is global, not limited to a particular tab. That means that
    if you’re logged in to a website and you open a second tab, you’re logged in on
    that tab as well.Moreover, since `request` can be called multiple times on one
    page—to load CSS and JavaScript—later requests transmit cookies set by previous
    responses. For example our guest book sets a cookie when the browser first requests
    the page and then receives that cookie when our browser later requests the page’s
    CSS file.
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: 由于cookie是针对特定站点的，我们的cookie存储将站点映射到cookie。请注意，cookie存储是全局的，不仅限于特定标签页。这意味着如果你在一个网站上登录并打开第二个标签页，你也会在那个标签页上登录。此外，由于`request`可以在一个页面上多次调用——用于加载CSS和JavaScript——后续请求会传输之前响应设置的cookie。例如，我们的留言簿在浏览器首次请求页面时设置cookie，然后在浏览器稍后请求页面CSS文件时接收该cookie。
- en: 'When the browser visits a page, it needs to send the cookie for that site:'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器访问一个页面时，它需要为该站点发送cookie：
- en: '[PRE417]'
  id: totrans-1827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: Symmetrically, the browser has to update the cookie jar when it sees a `Set-Cookie`
    header:A server can actually send multiple `Set-Cookie` headers to set multiple
    cookies in one request, though our browser won’t handle that correctly.
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 相似地，当浏览器看到`Set-Cookie`头时，它必须更新cookie存储：服务器实际上可以在一个请求中发送多个`Set-Cookie`头以设置多个cookie，尽管我们的浏览器不会正确处理这种情况。
- en: '[PRE418]'
  id: totrans-1829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: You should now be able to use your browser to log in to the guest book and post
    to it. Moreover, you should be able to open the guest book in two browsers simultaneously—maybe
    your browser and a real browser as well—and log in and post as two different users.
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够使用你的浏览器登录留言簿并发布到它。此外，你应该能够同时打开两个浏览器中的留言簿——可能是你的浏览器和一个真正的浏览器——并以两个不同的用户登录和发布。
- en: Now that our browser supports cookies and uses them for logins, we need to make
    sure cookie data is safe from malicious actors. After all, the cookie is the browser’s
    identity, so if someone stole it, the server would think they are you. We need
    to prevent that.
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们浏览器支持cookie并使用它们进行登录，我们需要确保cookie数据免受恶意行为者的侵害。毕竟，cookie是浏览器的身份，如果有人偷走了它，服务器会认为他们是您。我们需要防止这种情况发生。
- en: At one point, an attempt was made to “clean up” the cookie specification in
    [RFC 2965](https://datatracker.ietf.org/doc/html/rfc2965), including human-readable
    cookie descriptions and cookies restricted to certain ports. This required introducing
    the `Cookie2` and `Set-Cookie2` headers; the new headers were not popular. They
    are now [obsolete](https://datatracker.ietf.org/doc/html/rfc6265).
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，有人试图在 [RFC 2965](https://datatracker.ietf.org/doc/html/rfc2965) 中“清理”cookie
    规范，包括人类可读的 cookie 描述和限制在特定端口上的 cookie。这需要引入 `Cookie2` 和 `Set-Cookie2` 头部；新的头部并不受欢迎。现在它们已经[过时](https://datatracker.ietf.org/doc/html/rfc6265)。
- en: Cross-site Requests
  id: totrans-1833
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站请求
- en: 'Cookies are site-specific, so one server shouldn’t be sent another server’s
    cookies.Well… Our connection isn’t encrypted, so an attacker could read it from
    an open Wi-Fi connection. But another *server* couldn’t. Or how about this attack:
    another server could hijack our DNS and redirect our hostname to a different IP
    address, and then steal our cookies. Some internet service providers support DNSSEC,
    which prevents this, but not all. Or consider this attack: a state-level attacker
    could announce fradulent BGP (Border Gateway Protocol) routes, which would send
    even a correctly retrieved IP address to the wrong physical computer. (Security
    is very hard.) But if an attacker is clever, they might be able to get *the server*
    or *the browser* to help them steal cookie values.'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies 是特定于站点的，因此一个服务器不应该发送另一个服务器的 cookie。嗯……我们的连接没有加密，所以攻击者可以从开放的 Wi-Fi 连接中读取它。但另一个*服务器*不能。或者考虑这种攻击：另一个服务器可以劫持我们的
    DNS，并将我们的主机名重定向到不同的 IP 地址，然后窃取我们的 cookie。一些互联网服务提供商支持 DNSSEC，这可以防止这种情况，但并非所有都支持。或者考虑这种攻击：一个国家级别的攻击者可以宣布欺诈性的
    BGP（边界网关协议）路由，这将导致即使正确检索到的 IP 地址也会发送到错误的物理计算机。（安全性非常困难。）但如果攻击者足够聪明，他们可能能够让*服务器*或*浏览器*帮助他们窃取
    cookie 值。
- en: The easiest way for an attacker to steal your private data is to ask for it.
    Of course, there’s no API in the browser for a website to ask for another website’s
    cookies. But there *is* an API to make requests to another website. It’s called
    `XMLHttpRequest`.It’s a weird name! Why is `XML` capitalized but not `Http`? And
    it’s not restricted to XML! Ultimately, the naming is [historical](https://en.wikipedia.org/wiki/XMLHttpRequest#History),
    dating back to Microsoft’s “Outlook Web Access” feature for Exchange Server 2000.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者窃取您私人数据的最简单方法就是索要它。当然，浏览器中没有 API 允许一个网站请求另一个网站的 cookie。但确实有一个 API 可以向另一个网站发起请求。它被称为
    `XMLHttpRequest`。这个名字很奇怪！为什么 `XML` 大写而 `Http` 不大写？而且它不仅限于 XML！最终，命名是[历史性的](https://en.wikipedia.org/wiki/XMLHttpRequest#History)，可以追溯到微软为
    Exchange Server 2000 服务的“Outlook Web Access”功能。
- en: '`XMLHttpRequest` sends asynchronous HTTP requests from JavaScript. Since I’m
    using `XMLHttpRequest` just to illustrate security issues, I’ll implement a minimal
    version here. Specifically, I’ll support only *synchronous* requests.Synchronous
    `XMLHttpRequest`s are slowly moving through [deprecation and obsolescence](https://xhr.spec.whatwg.org/#the-open()-method),
    but I’m using them here because they are easier to implement. We’ll implement
    the asynchronous variant in Chapter 12. Using this minimal `XMLHttpRequest` looks
    like this:'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` 从 JavaScript 发送异步 HTTP 请求。由于我使用 `XMLHttpRequest` 只是为了说明安全问题，所以我将在这里实现一个最小版本。具体来说，我将只支持*同步*请求。同步
    `XMLHttpRequest` 正在逐渐走向[弃用和过时](https://xhr.spec.whatwg.org/#the-open()-method)，但我在这里使用它们，因为它们更容易实现。我们将在第
    12 章实现异步版本。使用这个最小版本的 `XMLHttpRequest` 看起来是这样的：'
- en: '[PRE419]'
  id: totrans-1837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: We’ll define the `XMLHttpRequest` objects and methods in JavaScript. The `open`
    method will just save the method and URL:`XMLHttpRequest` has more options not
    implemented here, like support for usernames and passwords. This code is also
    missing some error checking, like making sure the method is a valid HTTP method
    supported by our browser.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 JavaScript 中定义 `XMLHttpRequest` 对象和方法。`open` 方法只是保存方法和 URL：`XMLHttpRequest`
    在这里没有实现更多选项，例如支持用户名和密码。此代码还缺少一些错误检查，例如确保方法是我们浏览器支持的有效的 HTTP 方法。
- en: '[PRE420]'
  id: totrans-1839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: The `send` method calls an exported function:As above, this implementation skips
    important `XMLHttpRequest` features, like setting request headers (and reading
    response headers), changing the response type, or triggering various events and
    callbacks during the request.
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: '`send` 方法调用一个导出的函数：如上所述，此实现跳过了重要的 `XMLHttpRequest` 功能，例如设置请求头（和读取响应头）、更改响应类型，或在请求过程中触发各种事件和回调。'
- en: '[PRE421]'
  id: totrans-1841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: The `XMLHttpRequest_send` function just calls `request`:Note that the `method`
    argument is ignored, because our `request` function chooses the method on its
    own based on whether a payload is passed. This doesn’t match the standard (which
    allows `POST` requests with no payload), and I’m only doing it here for convenience.
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest_send` 函数只是调用 `request`：请注意，`method` 参数被忽略，因为我们的 `request` 函数会根据是否传递有效负载自行选择方法。这不符合标准（标准允许没有有效负载的
    `POST` 请求），我只是在方便起见这样做。'
- en: '[PRE422]'
  id: totrans-1843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: With `XMLHttpRequest`, a web page can make HTTP requests in response to user
    actions, making websites more interactive (see Figure 2). This API, and newer
    analogs like [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch),
    are how websites allow you to like a post, see hover previews, or submit a form
    without reloading.
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `XMLHttpRequest`，网页可以在用户操作后发出 HTTP 请求，使网站更加互动（见图 2）。这个 API 以及像 `fetch`（[https://developer.mozilla.org/en-US/docs/Web/API/fetch](https://developer.mozilla.org/en-US/docs/Web/API/fetch)）这样的新类似物，是网站允许你点赞帖子、查看悬停预览或提交表单而不重新加载的方式。
- en: '![Figure 2: The architecture of a single-page application leveraging XMLHttpRequest.](img/d5a6ccdafaf2ab349f93595b84fef11b.png)'
  id: totrans-1845
  prefs: []
  type: TYPE_IMG
  zh: '![图 2：利用 XMLHttpRequest 的单页应用程序架构](img/d5a6ccdafaf2ab349f93595b84fef11b.png)'
- en: 'Figure 2: The architecture of a single-page application leveraging `XMLHttpRequest`.'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：利用 `XMLHttpRequest` 的单页应用程序架构。
- en: '`XMLHttpRequest` objects have [`setRequestHeader`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader)
    and [`getResponseHeader`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getResponseHeader)
    methods to control HTTP headers. However, this could allow a script to interfere
    with the cookie mechanism or with other security measures, so some [request](https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name)
    and [response](https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_response_header_name)
    headers are not accessible from JavaScript.'
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` 对象有 `setRequestHeader`（[https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader)）和
    `getResponseHeader`（[https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getResponseHeader](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getResponseHeader)）方法来控制
    HTTP 头部。然而，这可能会允许脚本干扰 cookie 机制或其他安全措施，因此一些 [请求](https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name)
    和 [响应](https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_response_header_name)
    头部在 JavaScript 中不可访问。'
- en: Same-origin Policy
  id: totrans-1848
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同源策略
- en: 'However, new capabilities lead to new responsibilities. HTTP requests sent
    with `XMLHttpRequest` include cookies. This is by design: when you “like” something,
    the server needs to associate the “like” to your account. But it also means that
    `XMLHttpRequest` can access private data, and thus there is a need to protect
    it.'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，新的功能带来了新的责任。使用 `XMLHttpRequest` 发送的 HTTP 请求包括 cookie。这是设计上的考虑：当你“喜欢”某物时，服务器需要将“喜欢”与你的账户关联起来。但这同时也意味着
    `XMLHttpRequest` 可以访问私人数据，因此需要保护它。
- en: Let’s imagine an attacker wants to know your username on our guest book server.
    When you’re logged in, the guest book includes your username on the page (where
    it says “Hello, so and so”), so reading the guest book with your cookies is enough
    to determine your username.
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设攻击者想了解你在我们的留言簿服务器上的用户名。当你登录时，留言簿会在页面上显示你的用户名（比如“你好，某某”），所以通过你的 cookie 读取留言簿就足以确定你的用户名。
- en: 'With `XMLHttpRequest`, an attacker’s websiteWhy is the user on the attacker’s
    site? Perhaps it has funny memes, or it’s been hacked and is being used for the
    attack against its will, or perhaps the evildoer paid for ads on sketchy websites
    where users have low standards for security anyway. could request the guest book
    page:'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `XMLHttpRequest`，攻击者的网站可以请求留言簿页面：用户为什么会在攻击者的网站上？可能是因为那里有有趣的表情包，或者网站被黑客攻击并被用于攻击，或者可能是坏人付费在安全标准较低的网站上投放广告。这些网站的用户对安全的要求本身就低。
- en: '[PRE423]'
  id: totrans-1852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: The issue here is that one server’s web page content is being sent to a script
    running on a website delivered by another server. Since the content is derived
    from cookies, this leaks private data.
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，一个服务器的网页内容被发送到另一个服务器提供的网站上运行的脚本。由于内容来自 cookie，这会导致私人数据泄露。
- en: 'To prevent issues like this, browsers have a [*same-origin policy*](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy),
    which says that requests like `XMLHttpRequest`Some kinds of request are not subject
    to the same-origin policy (most prominently CSS and JavaScript files linked from
    a web page); conversely, the same-origin policy also governs JavaScript interactions
    with `iframe`s, images, `localStorage` and many other browser features. can only
    go to web pages on the same “origin”—scheme, hostname, and port.You may have noticed
    that this is not the same definition of “website” as cookies use: cookies don’t
    care about scheme or port! This seems to be an oversight or incongruity left over
    from the messy early web. This way, a website’s private data has to stay on that
    website, and cannot be leaked to an attacker on another server.'
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这类问题，浏览器有一个[*同源策略*](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)，它规定像
    `XMLHttpRequest` 这样的请求只能发送到同一“源”的网页上——方案、主机名和端口。你可能已经注意到，这与 cookies 使用的“网站”定义不同：cookies
    不关心方案或端口！这似乎是早期混乱的网页留下的一个疏忽或不一致。这样，网站的私有数据必须保持在那个网站上，不能泄露到另一个服务器上的攻击者。
- en: 'Let’s implement the same-origin policy for our browser. We’ll need to compare
    the URL of the request to the URL of the page we are on:'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的浏览器实现同源策略。我们需要比较请求的 URL 和我们所在的页面的 URL：
- en: '[PRE424]'
  id: totrans-1856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: 'The `origin` function can just strip off the path from a URL:'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: '`origin` 函数可以仅从 URL 中剥离路径：'
- en: '[PRE425]'
  id: totrans-1858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: Now an attacker can’t read the guest book web page. But can they write to it?
    Actually…
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: 现在攻击者不能读取留言簿网页。但他们能写入吗？实际上…
- en: One interesting form of the same-origin policy involves images and the HTML
    `<canvas>` element. The [`drawImage` method](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage)
    allows drawing an image to a canvas, even if that image was loaded from another
    origin. But to prevent that image from being read back with [`getImageData`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getImageData)
    or related methods, writing cross-origin data to a canvas [taints](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image)
    it, blocking read methods.
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: 同源策略的一个有趣形式涉及图像和 HTML `<canvas>` 元素。`drawImage` 方法（[drawImage 方法](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage)）允许将图像绘制到画布上，即使该图像是从另一个源加载的。但为了防止使用
    `getImageData` 或相关方法读取该图像，将跨源数据写入画布会[污染](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image)它，从而阻止读取方法。
- en: Cross-site Request Forgery
  id: totrans-1861
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站请求伪造（Cross-site Request Forgery）
- en: The same-origin policy prevents cross-origin `XMLHttpRequest` calls. But the
    same-origin policy doesn’t apply to normal browser actions like clicking a link
    or filling out a form. This enables an exploit called *cross-site request forgery*,
    often shortened to CSRF.
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 同源策略阻止跨源 `XMLHttpRequest` 调用。但同源策略不适用于正常的浏览器操作，如点击链接或填写表单。这使一种称为 *跨站请求伪造* 的利用成为可能，通常简称为
    CSRF。
- en: 'In cross-site request forgery, instead of using `XMLHttpRequest`, the attacker
    uses a form that submits to the guest book:'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨站请求伪造中，攻击者使用一个提交到留言簿的表单，而不是使用 `XMLHttpRequest`：
- en: '[PRE426]'
  id: totrans-1864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: Even though this form is on the evildoer’s website, when you submit the form,
    the browser will make an HTTP request to the *guest book*. And that means it will
    send its guest book cookies, so it will be logged in, so the guest book code will
    allow a post. But the user has no way of knowing which server a form submits to—the
    attacker’s web page could have misrepresented that—so they may have posted something
    they didn’t mean to.Even worse, the form submission could be triggered by JavaScript,
    with the user not involved at all. And this kind of attack can be further disguised
    by hiding the entry widget, pre-filling the post, and styling the button to look
    like a normal link.
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个表单在邪恶者的网站上，当你提交表单时，浏览器会向 *留言簿* 发出 HTTP 请求。这意味着它会发送其留言簿 cookie，因此它会登录，留言簿代码将允许发表帖子。但用户无法知道表单提交到哪个服务器——攻击者的网页可能已经误导了这一点——因此他们可能发布了他们无意中发布的帖子。更糟糕的是，表单提交可能由
    JavaScript 触发，用户根本不参与。而且这种攻击可以通过隐藏输入小部件、预先填充帖子以及将按钮样式设置为正常链接来进一步伪装。
- en: Of course, the attacker can’t read the response, so this doesn’t leak private
    data to the attacker. But it can allow the attacker to *act* as the user! Posting
    a comment this way is not too scary (though shady advertisers will pay for it!)
    but posting a bank transaction is. And if the website has a change-of-password
    form, there could even be a way to take control of the account.
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，攻击者无法读取响应，所以这不会将私有数据泄露给攻击者。但它可以让攻击者 *充当* 用户！以这种方式发表评论并不太可怕（尽管可疑的广告商会为此付费！）但发表银行交易就不同了。如果网站有更改密码的表单，甚至可能有一种方法来控制账户。
- en: Unfortunately, we can’t just apply the same-origin policy to form submissions.For
    example, many search forms on websites submit to Google, because those websites
    don’t have their own search engines. So how do we defend against this attack?
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们不能仅仅将同源策略应用于表单提交。例如，许多网站上的搜索表单提交给 Google，因为这些网站没有自己的搜索引擎。那么我们如何防御这种攻击呢？
- en: To start with, there are things the server can do. The usual advice is to give
    a unique identity to every form the server serves, and make sure that every POST
    request comes from one of them. The way to do that is to embed a secret value,
    called a *nonce*, into the form, and to reject form submissions that don’t come
    with the right secret value.Note the similarity to cookies, except that instead
    of granting identity to browsers, we grant one to forms. Like a cookie, a nonce
    can be stolen with cross-site scripting. You can only get a nonce from the server,
    and the nonce is tied to the user session,It’s important that nonces are associated
    with the particular user. Otherwise, the attacker can generate a nonce for *themselves*
    and insert it into a form meant for the *user*. so the attacker could not embed
    it in their form.
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，服务器可以做一些事情。通常的建议是为服务器提供的每个表单赋予一个唯一的身份，并确保每个 POST 请求都来自它们之一。实现这一点的办法是将一个称为
    *nonce* 的秘密值嵌入到表单中，并拒绝没有正确秘密值的表单提交。注意这与 cookies 的相似之处，除了我们不是授予浏览器身份，而是授予表单。像 cookie
    一样，nonce 可以通过跨站脚本攻击被窃取。您只能从服务器获取 nonce，并且 nonce 与用户会话相关联。确保 nonce 与特定用户相关联非常重要。否则，攻击者可以为
    *自己* 生成一个 nonce 并将其插入到为 *用户* 准备的表单中，因此攻击者无法将其嵌入到自己的表单中。
- en: To implement this fix, generate a nonce and save it in the user session when
    a form is requested:Usually `<input type=hidden>` is invisible, though our browser
    doesn’t support this.
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个修复，当请求表单时生成一个随机数并将其保存在用户会话中：通常 `<input type=hidden>` 是不可见的，尽管我们的浏览器不支持这一点。
- en: '[PRE427]'
  id: totrans-1870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: When a form is submitted, the server checks that the right nonce is submitted
    with it:In real websites it’s usually best to allow one user to have multiple
    active nonces, so that a user can open two forms in two tabs without that overwriting
    the valid nonce. To prevent the nonce set from growing over time, you’d have nonces
    expire after a while. I’m skipping this here, because it’s not the focus of this
    chapter.
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单提交时，服务器检查是否提交了正确的 nonce：在真实网站上，通常最好允许一个用户拥有多个活动 nonce，这样用户就可以在两个标签页中打开两个表单，而不会覆盖有效的
    nonce。为了防止 nonce 集合随时间增长，您会设置 nonce 在一段时间后过期。我在这里跳过了这一点，因为它不是本章的重点。
- en: '[PRE428]'
  id: totrans-1872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: Now this form can’t be submitted except from our website. Repeat this nonce
    fix for each form in the application, and it’ll be secure from CSRF attacks. But
    server-side solutions are fragile (what if you forget a form?) and relying on
    every website out there to do it right is a pipe dream. It’d be better for the
    browser to provide a fail-safe backup.
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个表单只能从我们的网站提交。为应用程序中的每个表单重复此 nonce 修复，它将免受 CSRF 攻击。但服务器端解决方案是脆弱的（如果你忘记了一个表单怎么办？）并且依赖每个网站都正确执行这只是一个幻想。浏览器提供一种安全备份会更好。
- en: One unusual attack, similar in spirit to cross-site request forgery, is [click-jacking](https://owasp.org/www-community/attacks/Clickjacking).
    In this attack, an external site in a transparent `iframe` is positioned over
    the attacker’s site. The user thinks they are clicking around one site, but they
    actually take actions on a different one. Nowadays, sites can prevent this with
    the [`frame-ancestors` directive](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors)
    to `Content-Security-Policy` or the older [`X-Frame-Options` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options).
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: 一种不同寻常的攻击，与跨站请求伪造类似，是 [click-jacking](https://owasp.org/www-community/attacks/Clickjacking)。在这种攻击中，一个外部站点在透明的
    `iframe` 中定位在攻击者的网站上。用户认为他们在点击一个站点，但实际上他们在另一个站点上执行操作。如今，网站可以通过将 `frame-ancestors`
    指令添加到 `Content-Security-Policy` 或较旧的 `X-Frame-Options` 标头来防止这种情况。[frame-ancestors
    指令](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors)。
- en: SameSite Cookies
  id: totrans-1875
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SameSite Cookies
- en: For form submissions, that fail-safe solution is `SameSite` cookies. The idea
    is that if a server marks its cookies `SameSite`, the browser will not send them
    in cross-site form submissions.At the time of writing the `SameSite` cookie standard
    is still in a draft stage, and not all browsers implement that draft fully. So
    it’s possible that this section may become out of date, though some kind of `SameSite`
    cookies will probably be ratified. The [MDN page](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)
    is helpful for checking the current status of `SameSite` cookies.
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表单提交，这个安全解决方案是 `SameSite` cookie。其想法是，如果服务器标记其 cookie 为 `SameSite`，则浏览器不会在跨站表单提交中发送它们。在撰写本文时，`SameSite`
    cookie 标准仍处于草案阶段，并且并非所有浏览器都完全实现了该草案。因此，本节可能变得过时，尽管可能会批准某种 `SameSite` cookie。[MDN
    页面](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)对于检查
    `SameSite` cookie 的当前状态很有帮助。
- en: 'A cookie is marked `SameSite` in the `Set-Cookie` header like this:'
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: cookie 在 `Set-Cookie` 标头中标记为 `SameSite`，如下所示：
- en: '[PRE429]'
  id: totrans-1878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: The `SameSite` attribute can take the value `Lax`, `Strict`, or `None`, and
    as I write, browsers have and plan different defaults. Our browser will implement
    only `Lax` and `None`, and default to `None`. When `SameSite` is set to `Lax`,
    the cookie is not sent on cross-site `POST` requests, but is sent on same-site
    `POST` or cross-site `GET` requests.Cross-site `GET` requests are also known as
    “clicking a link”, which is why those are allowed in `Lax` mode. The `Strict`
    version of `SameSite` blocks these too, but you need to design your web application
    carefully for this to work.
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: '`SameSite` 属性可以取 `Lax`、`Strict` 或 `None` 的值，并且在我撰写本文时，浏览器有不同的默认值。我们的浏览器将仅实现
    `Lax` 和 `None`，并默认为 `None`。当 `SameSite` 设置为 `Lax` 时，cookie 不会在跨站 `POST` 请求中发送，但在同一站点的
    `POST` 或跨站 `GET` 请求中发送。跨站 `GET` 请求也称为“点击链接”，这就是为什么在 `Lax` 模式下允许这些操作。`Strict` 版本的
    `SameSite` 也阻止这些操作，但您需要仔细设计您的 Web 应用程序才能使其工作。'
- en: 'First, let’s modify `COOKIE_JAR` to store cookie/parameter pairs, and then
    parse those parameters out of `Set-Cookie` headers:'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修改 `COOKIE_JAR` 以存储 cookie/参数对，然后从 `Set-Cookie` 标头中解析这些参数：
- en: '[PRE430]'
  id: totrans-1881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: 'When sending a cookie in an HTTP request, the browser only sends the cookie
    value, not the parameters:'
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 请求中发送 cookie 时，浏览器只发送 cookie 值，而不是参数：
- en: '[PRE431]'
  id: totrans-1883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: This stores the `SameSite` parameter of a cookie. But to actually use it, we
    need to know which site an HTTP request is being made from. Let’s add a new `referrer`
    parameter to `request` to track that:The “referrer” is the web page that “referred”
    our browser to make the current request. `SameSite` cookies are actually supposed
    to [use the “top-level site”](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-same-site-00#section-2.1),
    not the referrer, to determine if the cookies should be sent, but the differences
    are subtle and I’m skipping them for simplicity.
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: 这存储了 cookie 的 `SameSite` 参数。但为了实际使用它，我们需要知道 HTTP 请求是从哪个网站发出的。让我们向 `request`
    添加一个新的 `referrer` 参数来跟踪它：“referrer”是“推荐”我们的浏览器发出当前请求的网页。`SameSite` cookie 实际上应该[使用“顶级站点”](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-same-site-00#section-2.1)，而不是
    referrer，来决定是否发送 cookie，但这些差异很微妙，为了简单起见，我跳过了它们。
- en: '[PRE432]'
  id: totrans-1885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: 'Our browser calls `request` in three places, and we need to send the top-level
    URL in each case. At the top of `load`, it makes the initial request to a page.
    Modify it like so:'
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器在三个地方调用 `request`，我们需要在每种情况下发送顶级 URL。在 `load` 的顶部，它向页面发出初始请求。修改如下：
- en: '[PRE433]'
  id: totrans-1887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: Here, `url` is the new URL to visit, but `self.url` is the URL of the page the
    request comes from. Make sure this line comes at the top of `load`, before `self.url`
    is changed!
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`url` 是要访问的新URL，但 `self.url` 是请求来源的页面URL。确保这一行在 `load` 顶部，在 `self.url` 被更改之前！
- en: 'Later, the browser loads styles and scripts with more `request` calls:'
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，浏览器通过更多的 `request` 调用来加载样式和脚本：
- en: '[PRE434]'
  id: totrans-1890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: For these requests the top-level URL is the new URL being loaded. That’s because
    it is the new page that made us request these particular styles and scripts, so
    it defines which of those resources are on the same site.
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些请求，顶级URL是正在加载的新URL。这是因为是新的页面让我们请求了这些特定的样式和脚本，因此它定义了哪些资源位于同一站点。
- en: 'Similarly, `XMLHttpRequest`-triggered requests use the tab URL as their top-level
    URL:'
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，由 `XMLHttpRequest` 触发的请求使用标签页URL作为它们的顶级URL：
- en: '[PRE435]'
  id: totrans-1893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: The `request` function can now check the `referrer` argument before sending
    `SameSite` cookies. Remember that `SameSite` cookies are only sent for `GET` requests
    or if the new URL and the top-level URL have the same host name:As I write this,
    some browsers also check that the new URL and the top-level URL have the same
    scheme and some browsers ignore subdomains, so that `www.foo.com` and `login.foo.com`
    are considered the “same site”. If cookies were invented today, they’d probably
    be specific to URL origins (in fact, there is [an effort to do just that](https://github.com/sbingler/Origin-Bound-Cookies)),
    much like content security policies, but alas historical contingencies and backward
    compatibility force rules that are more complex but easier to deploy.
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` 函数现在可以在发送 `SameSite` cookies之前检查 `referrer` 参数。记住，`SameSite` cookies只会在
    `GET` 请求中发送，或者如果新URL和顶级URL有相同的域名：当我写这篇文章时，一些浏览器还会检查新URL和顶级URL是否有相同的方案，而一些浏览器会忽略子域名，所以
    `www.foo.com` 和 `login.foo.com` 被认为是“同一站点”。如果今天发明cookies，它们可能只会针对URL起源（实际上，有[一个努力做到这一点](https://github.com/sbingler/Origin-Bound-Cookies)），就像内容安全策略一样，但遗憾的是，历史偶然性和向后兼容性迫使规则更加复杂但更容易部署。'
- en: '[PRE436]'
  id: totrans-1895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: Note that we check whether the `referrer` is set—it won’t be when we’re loading
    the first web page in a new tab.
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们检查 `referrer` 是否已设置——当我们在一个新标签页中加载第一个网页时，它不会设置。
- en: 'Our guest book can now mark its cookies `SameSite`:'
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以标记我们的留言簿的cookies为 `SameSite`：
- en: '[PRE437]'
  id: totrans-1898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '`SameSite` provides a kind of “defense in depth”, a fail-safe that makes sure
    that even if we forgot a nonce somewhere, we’re still secure against CSRF attacks.
    But don’t remove the nonces we added earlier! They’re important for older browsers
    and are more flexible in cases like multiple domains.'
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
  zh: '`SameSite` 提供了一种“多层次防御”，一个安全措施，确保即使我们忘记了某个nonce，我们仍然对CSRF攻击保持安全。但不要移除我们之前添加的nonces！它们对旧浏览器很重要，并且在多域名等情况下更加灵活。'
- en: The web was not initially designed around security, which has led to some [awkward
    patches](https://jakearchibald.com/2021/cors/) after the fact. These patches may
    be ugly, but a dedication to backward compatibility is a strength of the web,
    and at least newer APIs can be designed around more consistent policies.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网最初并没有围绕安全性设计，这导致后来出现了一些[尴尬的补丁](https://jakearchibald.com/2021/cors/)。这些补丁可能很丑陋，但致力于向后兼容性是互联网的一个优势，并且至少新的API可以围绕更一致的政策进行设计。
- en: To this end, while there is a full specification for `SameSite`, it is still
    the case that real browsers support different subsets of the feature or different
    defaults. For example, Chrome defaults to `Lax`, but Firefox and Safari do not.
    Likewise, Chrome uses the scheme (`https` or `http`) as part of the definition
    of a “site”,This is called “schemeful same-site”. but other browsers may not.
    The main reason for this situation is the need to maintain backward compatibility
    with existing websites.
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，尽管有 `SameSite` 的完整规范，但现实中的浏览器仍然支持该功能的不同子集或不同的默认值。例如，Chrome默认为 `Lax`，但Firefox和Safari不是。同样，Chrome使用方案（`https`
    或 `http`）作为“站点”定义的一部分，这被称为“schemeful same-site”。但其他浏览器可能不会。这种情况的主要原因是需要与现有网站保持向后兼容性。
- en: Cross-site Scripting
  id: totrans-1902
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站脚本
- en: Now other websites can’t misuse our browser’s cookies to read or write private
    data. This seems secure! But what about *our own* website? With cookies accessible
    from JavaScript, any scripts run on our browser could, in principle, read the
    cookie value. This might seem benign—doesn’t our browser only run `comment.js`?
    But in fact…
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: 现在其他网站无法滥用我们的浏览器cookies来读取或写入私有数据。这似乎很安全！但我们的网站呢？由于JavaScript可以访问cookies，任何在我们浏览器上运行的脚本原则上都可以读取cookie值。这看起来可能无害——我们的浏览器不是只运行
    `comment.js` 吗？但实际上……
- en: 'A web service needs to defend itself from being *misused*. Consider the code
    in our guest book that outputs guest book entries:'
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Web服务需要防御其被*滥用*。考虑我们留言簿中的代码，该代码输出留言簿条目：
- en: '[PRE438]'
  id: totrans-1905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: 'Note that `entry` can be anything, including anything the user might stick
    into our comment form. That includes HTML tags, like a custom `<script>` tag!
    So, a malicious user could post this comment:'
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`entry`可以是任何东西，包括用户可能放入我们评论表单中的任何东西。这包括HTML标签，如自定义`<script>`标签！因此，恶意用户可以发布以下评论：
- en: '[PRE439]'
  id: totrans-1907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: 'The server would then output this HTML:'
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器随后会输出以下HTML：
- en: '[PRE440]'
  id: totrans-1909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: Every user’s browser would then download and run the `evil.js` script, which
    can sendA site’s cookies and cookie parameters are available to scripts running
    on that site through the [`document.cookie`](https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie)
    API. See Exercise 10-5 for more details on how web servers can *opt in* to allowing
    cross-origin requests. To steal cookies, it’s the attacker’s server that would
    to opt in to receiving stolen cookies. Or, in a real browser, `evil.js` could
    add images or scripts to the page to trigger additional requests. In our limited
    browser the attack has to be a little clunkier, but the evil script can still,
    for example, replace the whole page with a link that goes to their site and includes
    the token value in the URL. You’ve seen “please click to continue” screens and
    have clicked through unthinkingly; your users will too. the cookies to the attacker.
    The attacker could then impersonate other users, posting as them or misusing any
    other capabilities those users had.
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户的浏览器随后会下载并运行`evil.js`脚本，该脚本可以向攻击者发送网站的cookies和cookie参数。通过该网站的脚本可以通过`document.cookie`
    API访问这些cookies。有关网络服务器如何允许跨源请求的更多详细信息，请参阅练习10-5。为了窃取cookies，攻击者的服务器需要同意接收被盗的cookies。或者，在真实浏览器中，`evil.js`可以向页面添加图片或脚本以触发额外的请求。在我们的有限浏览器中，攻击可能需要更复杂一些，但邪恶的脚本仍然可以，例如，用指向他们网站并包含令牌值的URL的链接替换整个页面。你已经见过“请点击继续”的屏幕，并且不加思考地点击了；你的用户也会这样做。将cookies发送给攻击者。攻击者随后可以冒充其他用户，以他们的名义发帖或滥用他们拥有的任何其他功能。
- en: The core problem here is that user comments are supposed to be data, but the
    browser is interpreting them as code. In web applications, this kind of exploit
    is usually called *cross-site scripting* (often written “XSS”), though misinterpreting
    data as code is a common security issue in all kinds of programs.
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: 这里核心问题是用户评论应该是数据，但浏览器将它们解释为代码。在Web应用程序中，这类漏洞通常被称为*跨站脚本攻击*（通常写作“XSS”），尽管将数据误解释为代码是所有程序中常见的安全问题。
- en: 'The standard fix is to encode the data so that it can’t be interpreted as code.
    For example, in HTML, you can write `&lt;` to display a less-than sign.You may
    have implemented this in Exercise 1-4. Python has an `html` module for this kind
    of encoding:'
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的修复方法是编码数据，使其不能被解释为代码。例如，在HTML中，你可以写`&lt;`来显示小于号。你可能已经在练习1-4中实现了这一点。Python有一个`html`模块用于此类编码：
- en: '[PRE441]'
  id: totrans-1913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: This is a good fix, and every application should be careful to do this escaping.
    But if you forget to encode any text anywhere—that’s a security bug. So browsers
    provide additional layers of defense.
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的修复，每个应用程序都应该小心地这样做。但如果你在任何地方忘记对文本进行编码——这是一个安全漏洞。因此，浏览器提供了额外的防御层。
- en: 'Since the CSS parser we implemented in Chapter 6 is very permissive, some HTML
    pages also parse as valid CSS. This leads to an attack: include an external HTML
    page as a style sheet and observe the styling it applies. A [similar attack](https://owasp.org/www-pdf-archive/OWASPLondon20161124_JSON_Hijacking_Gareth_Heyes.pdf)
    involves including external JSON files as scripts. Setting a `Content-Type` header
    can prevent this sort of attack thanks to browsers’ [Cross-Origin Read Blocking](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/services/network/cross_origin_read_blocking_explainer.md)
    policy.'
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在第6章中实现的自定义CSS解析器非常宽容，一些HTML页面也被解析为有效的CSS。这导致了一种攻击：将外部HTML页面作为样式表包含，并观察它应用的样式。一种[类似的攻击](https://owasp.org/www-pdf-archive/OWASPLondon20161124_JSON_Hijacking_Gareth_Heyes.pdf)涉及将外部JSON文件作为脚本包含。设置`Content-Type`头可以通过浏览器的[跨源读取阻止](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/services/network/cross_origin_read_blocking_explainer.md)策略来防止此类攻击。
- en: Content Security Policy
  id: totrans-1916
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容安全策略
- en: 'One such layer is the `Content-Security-Policy` header. The full specification
    for this header is quite complex, but in the simplest case, the header is set
    to the keyword `default-src` followed by a space-separated list of servers:'
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个层次是`Content-Security-Policy`头部。这个头部信息的完整规范相当复杂，但在最简单的情况下，头部被设置为关键字`default-src`，后面跟着一个由空格分隔的服务器列表：
- en: '[PRE442]'
  id: totrans-1918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: This header asks the browser not to load any resources (including CSS, JavaScript,
    images, and so on) except from the listed origins. If our guest book used `Content-Security-Policy`,
    even if an attacker managed to get a `<script>` added to the page, the browser
    would refuse to load and run that script.
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头部信息要求浏览器不要加载任何资源（包括CSS、JavaScript、图片等），除非是从列出的源中。如果我们的留言簿使用了`Content-Security-Policy`，即使攻击者设法在页面上添加了`<script>`，浏览器也会拒绝加载和运行该脚本。
- en: 'Let’s implement support for this header. First, we’ll need `request` to return
    the response headers:'
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现对这个头部信息的支持。首先，我们需要`request`返回响应头部：
- en: '[PRE443]'
  id: totrans-1921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: Make sure to update all existing uses of `request` to ignore the headers.
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将所有现有的`request`使用更新为忽略头部信息。
- en: Next, we’ll need to extract and parse the `Content-Security-Policy` header when
    loading a page:In real browsers `Content-Security-Policy` can also list scheme-generic
    URLs and other sources like `self`. And there are keywords other than `default-src`,
    to restrict styles, scripts, and `XMLHttpRequest`s each to their own set of URLs.
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在加载页面时提取和解析`Content-Security-Policy`头部：在实际浏览器中，`Content-Security-Policy`也可以列出通配符URL和其他源，如`self`。此外，除了`default-src`之外，还有其他关键字，用于限制样式、脚本和`XMLHttpRequest`各自对应的URL集合。
- en: '[PRE444]'
  id: totrans-1924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: 'This parsing needs to happen *before* we request any JavaScript or CSS, because
    we now need to check whether those requests are allowed:'
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解析需要在请求任何JavaScript或CSS之前发生，因为我们现在需要检查这些请求是否被允许：
- en: '[PRE445]'
  id: totrans-1926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: Note that we need to first resolve relative URLs to know if they’re allowed.
    Add a similar test to the CSS-loading code.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要首先解析相对URL，以确定它们是否被允许。将类似的测试添加到CSS加载代码中。
- en: '`XMLHttpRequest` URLs also need to be checked:Note that when loading styles
    and scripts, our browser merely ignores blocked resources, while for blocked `XMLHttpRequest`s
    it throws an exception. That’s because exceptions in `XMLHttpRequest` calls can
    be caught and handled in JavaScript.'
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` URL也需要进行检查：请注意，当加载样式和脚本时，我们的浏览器只是忽略被阻止的资源，而对于被阻止的`XMLHttpRequest`，它会抛出一个异常。这是因为`XMLHttpRequest`调用中的异常可以在JavaScript中被捕获和处理。'
- en: '[PRE446]'
  id: totrans-1929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: 'The `allowed_request` check needs to handle both the case where there is no
    `Content-Security-Policy` and the case where there is one:'
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: '`allowed_request`检查需要处理没有`Content-Security-Policy`和有`Content-Security-Policy`两种情况：'
- en: '[PRE447]'
  id: totrans-1931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: 'The guest book can now send a `Content-Security-Policy` header:'
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: 留言簿现在可以发送一个`Content-Security-Policy`头部：
- en: '[PRE448]'
  id: totrans-1933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: 'To check that our implementation works, let’s have the guest book request a
    script from outside the list of allowed servers:'
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查我们的实现是否有效，让我们让留言簿从一个不允许的服务器列表中请求一个脚本：
- en: '[PRE449]'
  id: totrans-1935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: If you’ve got everything implemented correctly, the browser should block the
    evil scriptNeedless to say, `example.com` does not actually host an `evil.js`
    file, and any request to it returns “404 Not Found”. and report so in the console.
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经正确实现了所有功能，浏览器应该会阻止恶意脚本。不言而喻，`example.com`实际上并没有托管`evil.js`文件，任何对其的请求都会返回“404
    Not Found”。并在控制台报告这一点。
- en: 'So are we done? Is the guest book totally secure? Uh … no. There’s more—much,
    *much* more—to web application security than what’s in this book. And just like
    the rest of this book, there are many other browser mechanisms that touch on security
    and privacy. Let’s settle for this fact: the guest book is more secure than before.'
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就完成了？留言簿完全安全了吗？嗯……不。关于网络应用安全，除了这本书中提到的内容，还有许多，*许多*更多。就像这本书的其他部分一样，还有许多其他浏览器机制涉及到安全和隐私。让我们接受这个事实：留言簿比以前更安全了。
- en: On a complicated site, deploying `Content-Security-Policy` can accidentally
    break something. For this reason, browsers can automatically report `Content-Security-Policy`
    violations to the server, using the [`report-to` directive](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-to).
    The [`Content-Security-Policy-Report-Only`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only)
    header asks the browser to report violations of the content security policy *without*
    actually blocking the requests.
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个复杂的网站上，部署`Content-Security-Policy`可能会意外地破坏某些东西。出于这个原因，浏览器可以自动向服务器报告`Content-Security-Policy`违规，使用`report-to`指令（[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-to](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-to)）。`Content-Security-Policy-Report-Only`头请求浏览器报告内容安全策略违规，而不实际阻止请求。
- en: Summary
  id: totrans-1939
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We’ve added user data, in the form of cookies, to our browser, and immediately
    had to bear the heavy burden of securing that data and ensuring it was not misused.
    That involved:'
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将用户数据，以cookie的形式添加到我们的浏览器中，并立即不得不承担保护这些数据并确保其不被滥用的重任。这包括：
- en: mitigating cross-site `XMLHttpRequest`s with the same-origin policy;
  id: totrans-1941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用同源策略缓解跨站`XMLHttpRequest`；
- en: mitigating cross-site request forgery with nonces and with `SameSite` cookies;
  id: totrans-1942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非ces和`SameSite` cookies缓解跨站请求伪造；
- en: mitigating cross-site scripting with escaping and with `Content-Security-Policy`.
  id: totrans-1943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用转义和`Content-Security-Policy`缓解跨站脚本；
- en: We’ve also seen the more general lesson that every increase in the capabilities
    of a web browser also leads to an increase in its responsibility to safeguard
    user data. Security is an ever-present consideration throughout the design of
    a web browser.
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了一个更普遍的教训，即网络浏览器能力的每一次提升也导致其保护用户数据责任的增加。在整个网络浏览器设计过程中，安全性是一个始终存在的考虑因素。
- en: The purpose of this book is to teach the *internals of web browsers*, not to
    teach web application security. There’s much more you’d want to do to make this
    guest book truly secure, let alone what we’d need to do to avoid denial of service
    attacks or to handle spam and malicious use. Please consult other sources before
    working on security-critical code.
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的是教授网络浏览器的*内部机制*，而不是教授网络应用安全。为了使这本留言簿真正安全，你需要做更多的事情，更不用说我们需要做些什么来避免拒绝服务攻击或处理垃圾邮件和恶意使用。请在处理安全关键代码之前咨询其他来源。
- en: Click [here](widgets/lab10-browser.html) to try this chapter’s browser.
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[这里](widgets/lab10-browser.html)尝试本章的浏览器。
- en: Outline
  id: totrans-1947
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should now
    look something like this:'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整功能、类和方法现在看起来可能像这样：
- en: '`COOKIE_JAR` `` class URL: `def __init__(url)` `def request(referrer, payload)`
    `def resolve(url)` `def origin()` `def __str__()` `` `` class Text: `def __init__(text,
    parent)` `def __repr__()` `` `` class Element: `def __init__(tag, attributes,
    parent)` `def __repr__()` `` `def print_tree(node, indent)` `def tree_to_list(tree,
    list)` `` class HTMLParser: `SELF_CLOSING_TAGS` `HEAD_TAGS` `def __init__(body)`
    `def parse()` `def get_attributes(text)` `def add_text(text)` `def add_tag(tag)`
    `def implicit_tags(tag)` `def finish()` `` `` class CSSParser: `def __init__(s)`
    `def whitespace()` `def literal(literal)` `def word()` `def ignore_until(chars)`
    `def pair()` `def selector()` `def body()` `def parse()` `` `` class TagSelector:
    `def __init__(tag)` `def matches(node)` `` `` class DescendantSelector: `def __init__(ancestor,
    descendant)` `def matches(node)` `` `FONTS` `def get_font(size, weight, style)`
    `DEFAULT_STYLE_SHEET` `INHERITED_PROPERTIES` `def style(node, rules)` `def cascade_priority(rule)`
    `WIDTH, HEIGHT` `HSTEP, VSTEP` `` class Rect: `def __init__(left, top, right,
    bottom)` `def contains_point(x, y)` `` `INPUT_WIDTH_PX` `BLOCK_ELEMENTS` `` class
    DocumentLayout: `def __init__(node)` `def layout()` `def should_paint()` `def
    paint()` `` `` class BlockLayout: `def __init__(node, parent, previous)` `def
    layout_mode()` `def layout()` `def recurse(node)` `def new_line()` `def word(node,
    word)` `def input(node)` `def self_rect()` `def should_paint()` `def paint()`
    `` `` class LineLayout: `def __init__(node, parent, previous)` `def layout()`
    `def should_paint()` `def paint()` `` `` class TextLayout: `def __init__(node,
    word, parent, previous)` `def layout()` `def should_paint()` `def paint()` ``
    `` class InputLayout: `def __init__(node, parent, previous)` `def layout()` `def
    should_paint()` `def paint()` `def self_rect()` `` `` class DrawText: `def __init__(x1,
    y1, text, font, color)` `def execute(scroll, canvas)` `` `` class DrawRect: `def
    __init__(rect, color)` `def execute(scroll, canvas)` `` `` class DrawLine: `def
    __init__(x1, y1, x2, y2, color, thickness)` `def execute(scroll, canvas)` `` ``
    class DrawOutline: `def __init__(rect, color, thickness)` `def execute(scroll,
    canvas)` `` `def paint_tree(layout_object, display_list)` `EVENT_DISPATCH_JS`
    `RUNTIME_JS` `` class JSContext: `def __init__(tab)` `def run(script, code)` `def
    dispatch_event(type, elt)` `def get_handle(elt)` `def querySelectorAll(selector_text)`
    `def getAttribute(handle, attr)` `def innerHTML_set(handle, s)` `def XMLHttpRequest_send(...)`
    `` `SCROLL_STEP` `` class Tab: `def __init__(tab_height)` `def load(url, payload)`
    `def render()` `def draw(canvas, offset)` `def allowed_request(url)` `def scrolldown()`
    `def click(x, y)` `def go_back()` `def submit_form(elt)` `def keypress(char)`
    `` `` class Chrome: `def __init__(browser)` `def tab_rect(i)` `def paint()` `def
    click(x, y)` `def keypress(char)` `def enter()` `def blur()` `` `` class Browser:
    `def __init__()` `def draw()` `def new_tab(url)` `def handle_down(e)` `def handle_click(e)`
    `def handle_key(e)` `def handle_enter(e)` ``'
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
- en: 'The server has also grown since the previous chapter:'
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器自上一章以来也有所增长：
- en: '`SESSIONS` `def handle_connection(conx)` `ENTRIES` `LOGINS` `def do_request(session,
    method, url, headers, body)` `def form_decode(body)` `def show_comments(session)`
    `def login_form(session)` `def do_login(session, params)` `def not_found(url,
    method)` `def add_entry(session, params)`'
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: '`SESSIONS` `def handle_connection(conx)` `ENTRIES` `LOGINS` `def do_request(session,
    method, url, headers, body)` `def form_decode(body)` `def show_comments(session)`
    `def login_form(session)` `def do_login(session, params)` `def not_found(url,
    method)` `def add_entry(session, params)`'
- en: Exercises
  id: totrans-1952
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 10-1 *New inputs*. Add support for hidden and password input elements. Hidden
    inputs shouldn’t show up or take up space, while password input elements should
    show their contents as stars instead of characters.
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: 10-1 *新输入*。添加对隐藏和密码输入元素的支持。隐藏输入不应显示或占用空间，而密码输入元素应将内容显示为星号而不是字符。
- en: 10-2 *Certificate errors*. When accessing an HTTPS page, the web server can
    send an invalid certificate ([`badssl.com`](https://badssl.com) hosts various
    invalid certificates you can use for testing). In this case, the `wrap_socket`
    function will raise a certificate error; catch these errors and show a warning
    message to the user. For all *other* HTTPS pages draw a padlock (spelled `\N{lock}`)
    in the address bar.
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: 10-2 *证书错误*。在访问HTTPS页面时，网络服务器可以发送一个无效的证书（[`badssl.com`](https://badssl.com)提供了各种无效证书，您可以用它们进行测试）。在这种情况下，`wrap_socket`函数将引发证书错误；捕获这些错误并向用户显示警告信息。对于所有*其他*
    HTTPS页面，在地址栏中绘制一个锁形图标（表示为`\N{lock}`）。
- en: 10-3 *Script access*. Implement the [`document.cookie` JavaScript API](https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie).
    Reading this field should return a string containing the cookie value and parameters,
    formatted similarly to the `Cookie` header. Writing to this field updates the
    cookie value and parameters, just like receiving a `Set-Cookie` header does. Also
    implement the `HttpOnly` cookie parameter; cookies with this parameter [cannot
    be read or written](https://datatracker.ietf.org/doc/html/rfc6265#section-5.3)
    from JavaScript.
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: 10-3 *脚本访问*。实现`document.cookie` JavaScript API（[https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie](https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie)）。读取此字段应返回一个包含cookie值和参数的字符串，格式类似于`Cookie`头。向此字段写入更新cookie值和参数，就像接收`Set-Cookie`头一样。还要实现`HttpOnly`
    cookie参数；带有此参数的cookie[不能从JavaScript中读取或写入](https://datatracker.ietf.org/doc/html/rfc6265#section-5.3)。
- en: 10-4 *Cookie expiration*. Add support for cookie expiration. Cookie expiration
    dates are set in the `Set-Cookie` header, and can be overwritten if the same cookie
    is set again with a later date. On the server side, save the expiration date in
    the `SESSIONS` variable and use it to delete old sessions to save memory.
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: 10-4 *Cookie过期*。添加对cookie过期的支持。Cookie过期日期在`Set-Cookie`头中设置，如果再次使用较晚的日期设置相同的cookie，则可以覆盖。在服务器端，将过期日期保存在`SESSIONS`变量中，并使用它来删除旧会话以节省内存。
- en: 10-5 *Cross-origin resource sharing (CORS)*. Web servers can [*opt in*](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
    to allowing cross-origin `XMLHttpRequest`s. The way it works is that on cross-origin
    HTTP requests, the browser makes the request and includes an `Origin` header with
    the origin of the requesting site; this request includes cookies for the target
    origin. To satisfy the same-origin policy, the browser then throws away the response.
    But the server can send the `Access-Control-Allow-Origin` header, and if its value
    is either the requesting origin or the special `*` value, the browser returns
    the response to the script instead. All requests made by your browser will be
    what the CORS standard calls “simple requests”.
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: 10-5 *跨源资源共享（CORS）*。Web服务器可以[*选择加入*](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)以允许跨源的`XMLHttpRequest`。其工作方式是，在跨源HTTP请求中，浏览器发出请求并包含一个带有请求站点源的`Origin`头；此请求包含目标源cookie。为了满足同源策略，浏览器随后会丢弃响应。但是，服务器可以发送`Access-Control-Allow-Origin`头，如果其值是请求源或特殊的`*`值，则浏览器将响应返回给脚本。您浏览器发出的所有请求都将被CORS标准称为“简单请求”。
- en: 10-6 *`Referer`*. When your browser visits a web page, or when it loads a CSS
    or JavaScript file, it sends a `Referer` headerYep, [spelled that way](https://en.wikipedia.org/wiki/HTTP_referer#Etymology).
    containing the URL it is coming from. Sites often use this for analytics. Implement
    this in your browser. However, some URLs contain personal data that they don’t
    want revealed to other websites, so browsers support a `Referrer-Policy` header,Yep,
    [spelled that way](https://en.wikipedia.org/wiki/HTTP_referer#Etymology). which
    can contain values like `no-referrer`Yep, [spelled that way](https://en.wikipedia.org/wiki/HTTP_referer#Etymology).
    (never send the `Referer` header when leaving this page) or `same-origin` (only
    do so if navigating to another page on the same origin). Implement those two values
    for `Referrer-Policy`.
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: 10-6 *`Referer`*。当你的浏览器访问一个网页，或者当它加载 CSS 或 JavaScript 文件时，它会发送一个 `Referer` 标头，包含它来自的
    URL。网站经常使用这个来进行分析。在你的浏览器中实现这个功能。然而，一些 URL 包含他们不想泄露给其他网站的个人信息，因此浏览器支持一个 `Referrer-Policy`
    标头，其中可以包含像 `no-referrer`（在离开此页面时永不发送 `Referer` 标头）或 `same-origin`（只有在导航到同一源上的另一个页面时才这样做）这样的值。为
    `Referrer-Policy` 实现这两个值。
- en: Adding Visual Effects
  id: totrans-1959
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加视觉效果
- en: Chapter 11 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: '[网络浏览器工程](./index.html "目录")的第 11 章。'
- en: '[Installing Skia and SDL](#installing-skia-and-sdl)'
  id: totrans-1961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[安装 Skia 和 SDL](#installing-skia-and-sdl)'
- en: '[SDL Creates the Window](#sdl-creates-the-window)'
  id: totrans-1962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SDL 创建窗口](#sdl-creates-the-window)'
- en: '[Surfaces and Pixels](#surfaces-and-pixels)'
  id: totrans-1963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表面和像素](#surfaces-and-pixels)'
- en: '[Rasterizing with Skia](#rasterizing-with-skia)'
  id: totrans-1964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 Skia 渲染](#rasterizing-with-skia)'
- en: '[Browser Compositing](#browser-compositing)'
  id: totrans-1965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[浏览器合成](#browser-compositing)'
- en: '[Transparency](#transparency)'
  id: totrans-1966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[透明度](#transparency)'
- en: '[Blending and Stacking](#blending-and-stacking)'
  id: totrans-1967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[混合和堆叠](#blending-and-stacking)'
- en: '[Compositing Pixels](#compositing-pixels)'
  id: totrans-1968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[合成像素](#compositing-pixels)'
- en: '[Clipping and Masking](#clipping-and-masking)'
  id: totrans-1969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[裁剪和遮罩](#clipping-and-masking)'
- en: '[Optimizing Surface Use](#optimizing-surface-use)'
  id: totrans-1970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[优化表面使用](#optimizing-surface-use)'
- en: '[Summary](#summary)'
  id: totrans-1971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summary)'
- en: '[Outline](#outline)'
  id: totrans-1972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[轮廓](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-1973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: Right now our browser can only draw colored rectangles and text—pretty boring!
    Real browsers support all kinds of *visual effects* that change how pixels and
    colors blend together. To implement those effects, and also make our browser faster,
    we’ll need control over *surfaces*, the key low-level feature behind fast scrolling,
    visual effects, animations, and many other browser capabilities. To get that control,
    we’ll also switch to using the Skia graphics library and even take a peek under
    its hood.
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们的浏览器只能绘制彩色矩形和文本——相当无聊！真正的浏览器支持各种 *视觉效果*，这些效果可以改变像素和颜色的混合方式。为了实现这些效果，并使我们的浏览器运行更快，我们需要对
    *表面* 有控制权，这是快速滚动、视觉效果、动画以及许多其他浏览器功能背后的关键低级特性。为了获得这种控制权，我们还将切换到使用 Skia 图形库，甚至可以一窥其内部。
- en: Installing Skia and SDL
  id: totrans-1975
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Skia 和 SDL
- en: While Tkinter is great for basic shapes and input handling, it doesn’t give
    us control over surfacesThat’s because Tk, the graphics library that Tkinter uses,
    dates from the early 1990s, before high-performance graphics cards and GPUs became
    widespread. and lacks implementations of most visual effects. Implementing them
    ourselves would be fun, but it’s outside the scope of this book, so we need a
    new graphics library. Let’s use [Skia](https://skia.org), the library that Chromium
    uses. Unlike Tkinter, Skia doesn’t handle inputs or create graphical windows,
    so we’ll pair it with the [SDL](https://www.libsdl.org/) GUI library. Beyond new
    capabilities, switching to Skia will allow us to control graphics and rasterization
    at a lower level.
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Tkinter 在基本形状和输入处理方面很棒，但它并不提供对表面的控制。这是因为 Tkinter 使用的图形库 Tk 诞生于 20 世纪 90 年代初期，那时高性能显卡和
    GPU 还没有普及，并且缺乏大多数视觉效果的实现。我们自己实现它们会很有趣，但这超出了本书的范围，因此我们需要一个新的图形库。让我们使用 [Skia](https://skia.org)，这是
    Chromium 使用的库。与 Tkinter 不同，Skia 不处理输入或创建图形窗口，因此我们将它与 [SDL](https://www.libsdl.org/)
    图形用户界面库配对。除了新的功能外，切换到 Skia 还将允许我们在更低的级别控制图形和光栅化。
- en: 'Start by installing [Skia](https://kyamagu.github.io/skia-python/) and [SDL](https://pypi.org/project/PySDL2/):'
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装 [Skia](https://kyamagu.github.io/skia-python/) 和 [SDL](https://pypi.org/project/PySDL2/)：
- en: '[PRE450]'
  id: totrans-1978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: As elsewhere in this book, you may need to install the `pip` package first,
    or use your IDE’s package installer. If you’re on Linux, you’ll need to install
    additional dependencies, like OpenGL and fontconfig. Also, you may not be able
    to install `pysdl2-dll`; if so, you’ll need to find SDL in your system package
    manager instead. Consult the [`skia-python`](https://kyamagu.github.io/skia-python/)
    and [`pysdl2`](https://pypi.org/project/PySDL2/) web pages for more details.
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书其他地方所提到的，您可能需要首先安装 `pip` 软件包，或者使用您 IDE 的软件包安装器。如果您使用的是 Linux，您还需要安装额外的依赖项，如
    OpenGL 和 fontconfig。此外，您可能无法安装 `pysdl2-dll`；如果是这样，您需要通过系统软件包管理器找到 SDL。有关更多详细信息，请参阅
    [skia-python](https://kyamagu.github.io/skia-python/) 和 [pysdl2](https://pypi.org/project/PySDL2/)
    的网页。
- en: Note that I’m explicitly installing Skia version 87\. Skia makes regular releases
    that change APIs or break compatibility; version 87 is fairly old and should work
    reliably on most systems. In your own projects, or before filing bug reports in
    Skia, please do use more recent Skia releases. It’s also possible that future
    Python version no longer support Skia 87; our [porting notes](https://browser.engineering/porting.html)
    explain how to use recent Skia releases for the code in this book.
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我明确安装了 Skia 版本 87。Skia 定期发布，可能会更改 API 或破坏兼容性；版本 87 相对较旧，应该能在大多数系统上可靠地工作。在您自己的项目中，或者在进行
    Skia 的错误报告之前，请使用更新的 Skia 版本。也有可能未来的 Python 版本不再支持 Skia 87；我们的 [移植说明](https://browser.engineering/porting.html)
    解释了如何使用本书中的代码使用最新的 Skia 版本。
- en: 'Once installed, remove the `tkinter` imports from browser and replace them
    with these:'
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，从浏览器中删除 `tkinter` 导入，并用这些替换：
- en: '[PRE451]'
  id: totrans-1982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: The `ctypes` module is a standard part of Python; we’ll use it to convert between
    Python and C types. If any of these imports fail, check that Skia and SDL were
    installed correctly.
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctypes` 模块是 Python 的标准部分；我们将使用它来在 Python 和 C 类型之间进行转换。如果这些导入失败，请检查 Skia 和
    SDL 是否正确安装。'
- en: The [`<canvas>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas)
    HTML element provides a JavaScript API that is similar to Skia and Tkinter. Combined
    with [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API), it’s
    possible to implement basically all of SDL and Skia in JavaScript. Alternatively,
    one can [compile Skia](https://skia.org/docs/user/modules/canvaskit/) to [WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly)
    to do the same.
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: '`[<canvas>](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas)`
    HTML 元素提供了一个类似于 Skia 和 Tkinter 的 JavaScript API。结合 [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API)，可以使用
    JavaScript 实现基本上所有的 SDL 和 Skia 功能。或者，可以将 Skia [编译](https://skia.org/docs/user/modules/canvaskit/)
    为 [WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly) 来完成相同的工作。'
- en: SDL Creates the Window
  id: totrans-1985
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SDL 创建窗口
- en: 'The first big task is to switch to using SDL to create the window and handle
    events. The main loop of the browser first needs some boilerplate to get SDL started:'
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重要任务是切换到使用 SDL 创建窗口和处理事件。浏览器的主循环首先需要一些样板代码来启动 SDL：
- en: '[PRE452]'
  id: totrans-1987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: 'Next, we need to create an SDL window, instead of a Tkinter window, inside
    the `Browser`. Here’s the SDL incantation:'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `Browser` 中创建一个 SDL 窗口，而不是 Tkinter 窗口，这里是 SDL 的咒语：
- en: '[PRE453]'
  id: totrans-1989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: 'Now that we’ve created a window, we need to handle events sent to it. SDL doesn’t
    have a `mainloop` or `bind` method; we have to implement it ourselves:'
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个窗口，我们需要处理发送到该窗口的事件。SDL 没有主循环或 `bind` 方法；我们必须自己实现它：
- en: '[PRE454]'
  id: totrans-1991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: 'The details of `ctypes` and `PollEvent` aren’t too important here, but note
    that `SDL_QUIT` is an event, sent when the user closes the last open window. The
    `handle_quit` method it calls just cleans up the window object:'
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctypes` 和 `PollEvent` 的细节在这里不是很重要，但请注意，`SDL_QUIT` 是一个事件，当用户关闭最后一个打开的窗口时发送。它调用的
    `handle_quit` 方法只是清理窗口对象：'
- en: '[PRE455]'
  id: totrans-1993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: 'Call `mainloop` in place of `tkinter.mainloop`:'
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: 用 `mainloop` 替换 `tkinter.mainloop`：
- en: '[PRE456]'
  id: totrans-1995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: 'In place of all the `bind` calls in the `Browser` constructor, we can just
    directly call methods for various types of events, like clicks, typing, and so
    on. The SDL syntax looks like this:'
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Browser` 构造函数中的所有 `bind` 调用中，我们可以直接调用各种类型的事件的方法，如点击、输入等。SDL 语法看起来像这样：
- en: '[PRE457]'
  id: totrans-1997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: I’ve changed the signatures of the various event handler methods. For example,
    the `handle_click` method is now passed a `MouseButtonEvent` object, which thankfully
    contains `x` and `y` coordinates, while the `handle_enter` and `handle_down` methods
    aren’t passed any argument at all, because we don’t use that argument anyway.
    You’ll need to change the `Browser` methods’ signatures to match.
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经更改了各种事件处理方法的签名。例如，`handle_click` 方法现在传递一个 `MouseButtonEvent` 对象，幸运的是，它包含了
    `x` 和 `y` 坐标，而 `handle_enter` 和 `handle_down` 方法根本不传递任何参数，因为我们根本不使用那个参数。你需要更改
    `Browser` 方法的签名以匹配。
- en: SDL is most popular for making games. Their site lists [a selection of books](https://wiki.libsdl.org/Books)
    about game programming in SDL.
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
  zh: SDL 最受欢迎的用途是制作游戏。他们的网站列出了关于 SDL 游戏编程的 [一系列书籍](https://wiki.libsdl.org/Books)。
- en: Surfaces and Pixels
  id: totrans-2000
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Surface 和 Pixel
- en: Let’s peek under the hood of these SDL calls. When we create an SDL window,
    we’re asking SDL to allocate a *surface*, a chunk of memory representing the pixels
    on the screen.A surface may or may not be bound to the physical pixels on the
    screen via a window, and there can be many surfaces. A *canvas* is an API interface
    that allows you to draw into a surface with higher-level commands such as for
    rectangles or text. Our browser uses separate Skia and SDL surfaces for simplicity,
    but in a highly optimized browser, minimizing the number of surfaces is important
    for good performance. Creating and managing surfaces is going to be the big focus
    of this chapter. On today’s large screens, surfaces take up a lot of memory, so
    handling surfaces well is essential to good browser performance.
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些 SDL 调用的内部结构。当我们创建一个 SDL 窗口时，我们是在请求 SDL 分配一个 *surface*，即代表屏幕上像素的一块内存。一个
    *surface* 可能或可能不会通过一个窗口绑定到屏幕上的物理像素，并且可以有多个 surface。一个 *canvas* 是一个 API 接口，它允许你使用更高层次的命令（如矩形或文本）在
    surface 上绘制。为了简单起见，我们的浏览器使用独立的 Skia 和 SDL surface，但在高度优化的浏览器中，最小化 surface 的数量对于良好的性能至关重要。创建和管理
    surface 将是本章的重点。在今天的宽屏上，surface 占用大量内存，因此妥善处理 surface 对于良好的浏览器性能至关重要。
- en: 'A *surface* is a representation of a graphics buffer into which you can draw
    *pixels* (bits representing colors). We implicitly created an SDL surface when
    we created an SDL window; let’s also create a surface for Skia to draw to:'
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *surface* 是一个图形缓冲区的表示，你可以将其绘制为 *pixels*（代表颜色的位）。当我们创建一个 SDL 窗口时，我们隐式地创建了一个
    SDL surface；让我们也创建一个 surface 供 Skia 绘制：
- en: '[PRE458]'
  id: totrans-2003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: 'Each pixel has a color. Note the `ct` argument, meaning “color type”, which
    indicates that each pixel of this surface should be represented as *r*ed, *g*reen,
    *b*lue, and *a*lpha values, each of which should take up eight bits. In other
    words, pixels are basically defined like so:'
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
  zh: 每个像素都有一个颜色。注意 `ct` 参数，意味着“颜色类型”，它表示这个 surface 的每个像素都应该用 *r*ed（红色）、*g*reen（绿色）、*b*lue（蓝色）和
    *a*lpha（alpha）值来表示，每个值应该占用八位。换句话说，像素基本上是这样定义的：
- en: '[PRE459]'
  id: totrans-2005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: This `Pixel` definition is an illustrative example, not actual code in our browser.
    It’s standing in for somewhat more complex code within SDL and Skia themselves.Skia
    actually represents colors as 32-bit integers, with the most significant byte
    representing the alpha value (255 meaning opaque and 0 meaning transparent) and
    the next three bytes representing the red, green, and blue color channels.
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Pixel` 定义是一个说明性的例子，而不是我们浏览器中的实际代码。它代表 SDL 和 Skia 本身中更复杂的代码。Skia 实际上使用 32
    位整数来表示颜色，最高有效字节表示 alpha 值（255 表示不透明，0 表示透明），接下来的三个字节表示红色、绿色和蓝色颜色通道。
- en: Defining colors via red, green, and blue components is fairly standardIt’s formally
    known as the [sRGB color space](https://en.wikipedia.org/wiki/SRGB), and it dates
    back to [CRT (cathode-ray tube) displays](https://en.wikipedia.org/wiki/Cathode-ray_tube),
    which had a pretty limited *gamut* of expressible colors. New technologies like
    LCD, LED, and OLED can display more colors, so CSS now includes [syntax](https://drafts.csswg.org/css-color-4/)
    for expressing these new colors. Still, all color spaces have a limited gamut
    of expressible colors. and corresponds to how computer screens work.Actually,
    some screens contain [lights besides red, green, and blue](https://geometrian.com/programming/reference/subpixelzoo/index.php),
    including white, cyan, or yellow. Moreover, different screens can use slightly
    different reds, greens, or blues; professional color designers typically have
    to [calibrate their screen](https://en.wikipedia.org/wiki/Color_calibration) to
    display colors accurately. For the rest of us, the software still communicates
    with the display in terms of standard red, green, and blue colors, and the display
    hardware converts them to whatever pixels it uses. For example, in CSS, we refer
    to arbitrary colors with a hash character and six hex digits, like `#ffd700`,
    with two digits each for red, green, and blue:Alpha is implicitly 255, meaning
    opaque, in this case.
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
  zh: 通过红色、绿色和蓝色组件定义颜色是相当标准的。它正式上被称为[sRGB颜色空间](https://en.wikipedia.org/wiki/SRGB)，它起源于[CRT（阴极射线管）显示器](https://en.wikipedia.org/wiki/Cathode-ray_tube)，这些显示器能够表达的颜色范围相当有限。新的技术如LCD、LED和OLED可以显示更多的颜色，因此CSS现在包括了[语法](https://drafts.csswg.org/css-color-4/)来表示这些新颜色。尽管如此，所有颜色空间都有有限的颜色范围。这对应于计算机屏幕的工作方式。实际上，一些屏幕除了红色、绿色和蓝色之外还包含[其他光源](https://geometrian.com/programming/reference/subpixelzoo/index.php)，包括白色、青色或黄色。此外，不同的屏幕可能使用略有不同的红色、绿色或蓝色；专业色彩设计师通常需要[校准他们的屏幕](https://en.wikipedia.org/wiki/Color_calibration)以准确显示颜色。对于我们其他人来说，软件仍然以标准红色、绿色和蓝色的术语与显示硬件通信，而显示硬件将它们转换为它使用的像素。例如，在CSS中，我们使用一个井号字符和六个十六进制数字来引用任意颜色，如`#ffd700`，红色、绿色和蓝色各用两个数字表示：Alpha值隐式为255，意味着不透明，在这种情况下。
- en: '[PRE460]'
  id: totrans-2008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: 'The colors we’ve seen so far can just be specified in terms of this syntax:'
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的颜色可以用这种语法来指定：
- en: '[PRE461]'
  id: totrans-2010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: You can add more named colors from [the list](https://developer.mozilla.org/en-US/docs/Web/CSS/named-color)
    as you come across them; the demos in this book use `blue`, `green`, `lightblue`,
    `lightgreen`, `orange`, `orangered`, and `gray`. Note that unsupported colors
    are interpreted as black, so that at least something is drawn to the screen.This
    is not the standards-required behavior—the invalid value should just not participate
    in styling, so an element styled with an unknown color might inherit a color other
    than black—but I’m doing it as a convenience.
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随着遇到它们而添加更多命名的颜色，[颜色列表](https://developer.mozilla.org/en-US/docs/Web/CSS/named-color)中包含了这些颜色；本书中的示例使用了`blue`、`green`、`lightblue`、`lightgreen`、`orange`、`orangered`和`gray`。请注意，不支持的颜色将被解释为黑色，这样至少可以在屏幕上绘制出一些内容。这不是标准要求的行为——无效的值应该根本不参与样式，因此使用未知颜色的元素可能会继承除黑色以外的颜色——但我这样做是为了方便。
- en: 'Let’s now use our understanding of surfaces and colors to copy from the Skia
    surface, where we will draw the chrome and page content, to the SDL surface, which
    actually appears on the screen. This is a little hairy, because we are moving
    data between two low-level libraries, but really we’re just copying pixels from
    one place to another. First, get the sequence of bytes representing the Skia surface:'
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将利用我们对表面和颜色的理解，从Skia表面（我们将在这里绘制铬和页面内容）复制到SDL表面，SDL表面实际上显示在屏幕上。这有点棘手，因为我们正在在两个底层库之间移动数据，但实际上我们只是在从一个地方复制像素到另一个地方。首先，获取表示Skia表面的字节数据序列：
- en: '[PRE462]'
  id: totrans-2013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: 'Next, we need to copy the data to an SDL surface. This requires telling SDL
    what order the pixels are stored in and your computer’s [endianness](https://en.wikipedia.org/wiki/Endianness):'
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将数据复制到SDL表面。这需要告诉SDL像素存储的顺序以及你电脑的[字节序](https://en.wikipedia.org/wiki/Endianness)：
- en: '[PRE463]'
  id: totrans-2015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: 'The `CreateRGBSurfaceFrom` method then wraps the data in an SDL surface (without
    copying the bytes):'
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateRGBSurfaceFrom`方法随后将数据包装在一个SDL表面中（不复制字节）：'
- en: '[PRE464]'
  id: totrans-2017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: Finally, we draw all this pixel data on the window itself by blitting (copying)
    it from `sdl_surface` to `sdl_window`’s surface:Note that since Skia and SDL are
    C++ libraries, they are not always consistent with Python’s garbage collection
    system. So the link between the output of `tobytes` and `sdl_window` is not guaranteed
    to be kept consistent when `skia_bytes` is garbage-collected. The SDL surface
    could be left pointing at a bogus piece of memory, leading to memory corruption
    or a crash. The code here is correct because all of these are local variables
    that are garbage-collected together, but if not you need to be careful to keep
    all of them alive at the same time.
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过位块（复制）将所有这些像素数据绘制到窗口本身上，从 `sdl_surface` 复制到 `sdl_window` 的表面：请注意，由于 Skia
    和 SDL 是 C++ 库，它们并不总是与 Python 的垃圾回收系统保持一致。因此，当 `skia_bytes` 被垃圾回收时，`tobytes` 和
    `sdl_window` 之间的链接不保证保持一致。SDL 表面可能会指向一个无效的内存块，导致内存损坏或崩溃。这里的代码是正确的，因为这些都是在垃圾回收时一起回收的局部变量，但如果不这样做，你需要小心地同时保持它们都处于活动状态。
- en: '[PRE465]'
  id: totrans-2019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: 'So now we can copy from the Skia surface to the SDL window. One last step:
    we have to draw the browser to the Skia surface.'
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们可以从 Skia 表面复制到 SDL 窗口。最后一步：我们必须将浏览器绘制到 Skia 表面。
- en: 'We take it for granted, but color standards like [CIELAB](https://en.wikipedia.org/wiki/CIELAB_color_space)
    derive from attempts to [reverse-engineer human vision](https://en.wikipedia.org/wiki/Opponent_process).
    Screens use red, green, and blue color channels to match the three types of [cone
    cells](https://en.wikipedia.org/wiki/Cone_cell) in a human eye. These cone cells
    vary between people: some have [more](https://en.wikipedia.org/wiki/Tetrachromacy#Humans)
    and some [fewer](https://en.wikipedia.org/wiki/Color_blindness) (typically an
    inherited condition carried on the X chromosome). Moreover, different people have
    different ratios of cone types and those cone types use different protein structures
    that vary in the exact frequency of green, red, and blue that they respond to.
    The study of color thus combines software, hardware, chemistry, biology, and psychology.'
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为这是理所当然的，但像 [CIELAB](https://en.wikipedia.org/wiki/CIELAB_color_space) 这样的颜色标准源于尝试
    [逆向工程人类视觉](https://en.wikipedia.org/wiki/Opponent_process)。屏幕使用红色、绿色和蓝色通道来匹配人眼中三种类型的
    [视锥细胞](https://en.wikipedia.org/wiki/Cone_cell)。这些视锥细胞在人们之间有所不同：有些人有 [更多](https://en.wikipedia.org/wiki/Tetrachromacy#Humans)
    和有些人 [更少](https://en.wikipedia.org/wiki/Color_blindness)（通常是一种由 X 染色体携带的遗传条件）。此外，不同的人有不同的锥体类型比例，而这些锥体类型使用不同的蛋白质结构，这些结构对绿色、红色和蓝色的精确频率有不同的反应。因此，色彩研究结合了软件、硬件、化学、生物学和心理学。
- en: Rasterizing with Skia
  id: totrans-2022
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Skia 进行光栅化
- en: 'We want to draw text, rectangles, and so on to the Skia surface. This step—coloring
    in the pixels of a surface to draw shapes on it—is called “rasterization” and
    is one important task of a graphics library. In Skia, rasterization happens via
    a *canvas* API. A canvas is just an object that draws to a particular surface:'
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在 Skia 表面上绘制文本、矩形等。这一步——在表面上着色像素以绘制形状——被称为“光栅化”，是图形库的一个重要任务。在 Skia 中，光栅化是通过一个
    *画布* API 来实现的。画布只是一个绘制到特定表面的对象：
- en: '[PRE466]'
  id: totrans-2024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: Let’s change the various classes to use Skia’s raster APIs.
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将各种类更改为使用 Skia 的光栅 API。
- en: The first thing we need to do is change the `rect` field into a Skia `Rect`
    object. Get rid of the old `Rect` class that was introduced in [Chapter 7](chrome.html)
    in favor of `skia.Rect`. Everywhere that a `Rect` was constructed, instead put
    `skia.Rect.MakeLTRB` (for “make left-top-right-bottom”) or `MakeXYWH` (for “make
    *x*-*y*-width-height”). Everywhere that the sides of the rectangle (e.g., `left`)
    were checked, replace them with the corresponding function on a Skia `Rect` (e.g.,
    `left()`). Also replace calls to `containsPoint` with Skia’s `contains`.
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将 `rect` 字段改为 Skia 的 `Rect` 对象。用 `skia.Rect` 替换在 [第 7 章](chrome.html)
    中引入的旧 `Rect` 类。在所有创建 `Rect` 的地方，改为使用 `skia.Rect.MakeLTRB`（表示“创建左-上-右-下”）或 `MakeXYWH`（表示“创建
    *x*-*y*-宽度-高度”）。在检查矩形边（例如，`left`）的地方，用 Skia `Rect` 的相应函数（例如，`left()`）替换它们。还将 `containsPoint`
    的调用替换为 Skia 的 `contains`。
- en: 'For `DrawText` and `DrawLine` in particular, it’s:'
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `DrawText` 和 `DrawLine` 尤其是如此：
- en: '[PRE467]'
  id: totrans-2028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: Our browser’s drawing commands will need to invoke Skia methods on this canvas.
    To draw a line, you use Skia’s `Path` object:Consult the [Skia](https://skia.org)
    and [skia-python](https://kyamagu.github.io/skia-python/) documentation for more
    on the Skia API.
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器上的绘图命令需要在这个画布上调用 Skia 方法。要画一条线，你使用 Skia 的 `Path` 对象：有关 Skia API 的更多信息，请参阅
    [Skia](https://skia.org) 和 [skia-python](https://kyamagu.github.io/skia-python/)
    文档。
- en: '[PRE468]'
  id: totrans-2030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: Note the steps involved here. We first create a `Path` object, and then call
    `drawPath` to actually draw this path to the canvas. This `drawPath` call takes
    a second argument, `paint`, which defines how to actually perform this drawing.
    We specify the color, but we also need to specify that we want to draw a line
    *along* the path, instead of filling in the interior of the path, which is the
    default. To do that we set the style to “stroke”, a standard term referring to
    drawing along the border of some shape.The opposite is “fill”, meaning filling
    in the interior of the shape.
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里涉及到的步骤。我们首先创建一个 `Path` 对象，然后调用 `drawPath` 实际将此路径绘制到画布上。这个 `drawPath` 调用接受第二个参数
    `paint`，它定义了如何实际执行此绘图。我们指定了颜色，但还需要指定我们想要沿着路径绘制线条，而不是填充路径的内部，这是默认行为。为此，我们将样式设置为“stroke”，这是一个标准术语，指的是沿着某个形状的边缘绘制。相反的是“fill”，意味着填充形状的内部。
- en: 'We do something similar to draw text using `drawString`:'
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类似的方法通过 `drawString` 绘制文本：
- en: '[PRE469]'
  id: totrans-2033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: Note again that we create a `Paint` object identifying the color and asking
    for anti-aliased text.“Anti-alias”ing just means drawing some semi-transparent
    pixels to better approximate the shape of the text. This is important when drawing
    shapes with fine details, like text, but is less important when drawing large
    shapes like rectangles and lines. We don’t specify the “style” because we want
    to fill the interior of the text, the default.
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，我们创建了一个 `Paint` 对象，用于标识颜色并请求抗锯齿文本。“抗锯齿”只是意味着绘制一些半透明的像素来更好地逼近文本的形状。这在绘制具有精细细节的形状，如文本时很重要，但在绘制大形状，如矩形和线条时则不太重要。我们没有指定“样式”，因为我们想填充文本的内部，默认情况下就是这样。
- en: 'Finally, for drawing rectangles you use `drawRect`:'
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于绘制矩形，使用 `drawRect`：
- en: '[PRE470]'
  id: totrans-2036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: 'To create an outline, draw a rectangle but set the `Style` parameter of the
    `Paint` to `Stroke_Style`:'
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建轮廓，绘制一个矩形，但将 `Paint` 的 `Style` 参数设置为 `Stroke_Style`：
- en: '[PRE471]'
  id: totrans-2038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: 'Since we’re replacing Tkinter with Skia, we are also replacing `tkinter.font`.
    In Skia, a font object has two pieces: a `Typeface`, which is a type family with
    a certain weight, style, and width; and a `Font`, which is a `Typeface` at a particular
    size. It’s the `Typeface` that contains data and caches, so that’s what we need
    to cache:'
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在用 Skia 替换 Tkinter，因此我们也在替换 `tkinter.font`。在 Skia 中，字体对象有两个部分：一个 `Typeface`，它是一个具有特定重量、样式和宽度的字体族；以及一个
    `Font`，它是在特定大小下的 `Typeface`。`Typeface` 包含数据和缓存，因此这是我们需要缓存的部分：
- en: '[PRE472]'
  id: totrans-2040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: 'Our browser also needs font metrics and measurements. In Skia, these are provided
    by the `measureText` and `getMetrics` methods. Let’s start with `measureText`
    replacing all calls to `measure`. For example, in the `paint` method in `InputLayout`,
    we must do:'
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器还需要字体度量值和测量。在 Skia 中，这些由 `measureText` 和 `getMetrics` 方法提供。让我们从用 `measureText`
    替换所有对 `measure` 的调用开始。例如，在 `InputLayout` 的 `paint` 方法中，我们必须这样做：
- en: '[PRE473]'
  id: totrans-2042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: There are `measure` calls in several other layout objects (both in `paint` and
    `layout`), in `DrawText`, in the `draw` method on `Chrome`, in the `text` method
    in `BlockLayout`, and in the `layout` method in `TextLayout`. Update all of them
    to use `measureText`.
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个其他布局对象中（在 `paint` 和 `layout` 中）有 `measure` 调用（在 `DrawText` 中），在 `Chrome`
    的 `draw` 方法中，在 `BlockLayout` 的 `text` 方法中，以及在 `TextLayout` 的 `layout` 方法中。将它们全部更新为使用
    `measureText`。
- en: Also, in the `layout` method of `LineLayout` and in `DrawText` we make calls
    to the `metrics` method on fonts. In Skia, this method is called `getMetrics`,
    and to get the ascent and descent we need the `fAscent` and `fDescent` fields
    on its result.
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `LineLayout` 的 `layout` 方法以及 `DrawText` 中，我们对字体调用了 `metrics` 方法。在 Skia
    中，这个方法称为 `getMetrics`，要获取上升和下降，我们需要其结果上的 `fAscent` 和 `fDescent` 字段。
- en: 'Importantly, in Skia the ascent needs to be negated. In Skia, ascent and descent
    are positive if they go downward and negative if they go upward, so ascents will
    normally be negative, the opposite of Tkinter. There’s no analog for the `linespace`
    field that Tkinter provides, but you can use descent minus ascent instead:'
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，在 Skia 中，上升方向需要取反。在 Skia 中，如果上升或下降方向向下，则上升和下降都是正的；如果向上，则上升和下降都是负的，因此上升通常为负，与
    Tkinter 相反。Tkinter 提供的 `linespace` 字段没有对应项，但你可以使用下降减去上升来代替：
- en: '[PRE474]'
  id: totrans-2046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: You should now be able to run the browser again. It should look and behave just
    as it did in previous chapters, and it might feel faster on complex pages, because
    Skia and SDL are in general faster than Tkinter. If the transition felt easy—well,
    that’s one of the benefits to abstracting over the drawing backend using a display
    list!
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够再次运行浏览器。它应该看起来和表现就像之前章节中一样，并且可能在复杂页面上感觉更快，因为 Skia 和 SDL 通常比 Tkinter
    快。如果过渡感觉很容易——嗯，这就是使用显示列表抽象绘图后端的一个好处！
- en: 'Finally, Skia also provides some new features. For example, Skia has native
    support for rounded rectangles via `RRect` objects. We can implement that by converting
    `DrawRect` to `DrawRRect`:'
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Skia还提供了一些新功能。例如，Skia通过`RRect`对象原生支持圆角矩形。我们可以通过将`DrawRect`转换为`DrawRRect`来实现这一点：
- en: '[PRE475]'
  id: totrans-2049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: 'Then we can draw these rounded rectangles for backgrounds:'
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以绘制这些圆角矩形作为背景：
- en: '[PRE476]'
  id: totrans-2051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: With that, [this example](https://browser.engineering/examples/example11-rounded-background.html):Note
    that the example listed here, in common with other examples present in the book,
    accesses a local resource (a CSS file in this case) that is also present on [browser.engineering](https://browser.engineering/).
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，[这个示例](https://browser.engineering/examples/example11-rounded-background.html)：请注意，这里列出的示例，与其他书中提供的示例一样，访问了一个本地资源（在这个例子中是一个CSS文件），该资源也存在于[browser.engineering](https://browser.engineering/)上。
- en: '[PRE477]'
  id: totrans-2053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: will round the corners of its background (see Figure 1).
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
  zh: 将其背景的角落圆滑（见图1）。
- en: '![Figure 1: Example of a rounded background.](img/86440f1fd28a60a39d31c72fa630576f.png)'
  id: totrans-2055
  prefs: []
  type: TYPE_IMG
  zh: '![图1：圆角背景示例。](img/86440f1fd28a60a39d31c72fa630576f.png)'
- en: 'Figure 1: Example of a rounded background.'
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：圆角背景示例。
- en: Similar changes should be made to `InputLayout`. New shapes, like rounded rectangles,
    is one way that Skia is a more advanced rasterization library than Tk. More broadly,
    since Skia is also used by Chromium, we know it has fast, built-in support for
    all of the shapes we might need in a browser.
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
  zh: 应该对`InputLayout`进行类似的更改。新的形状，如圆角矩形，是Skia比Tk更先进的光栅化库的方式之一。更广泛地说，由于Skia也被Chromium使用，我们知道它为浏览器中可能需要的所有形状提供了快速内置的支持。
- en: '[Font rasterization](https://en.wikipedia.org/wiki/Font_rasterization) is surprisingly
    deep, with techniques such as [subpixel rendering](https://en.wikipedia.org/wiki/Subpixel_rendering)
    and [hinting](https://en.wikipedia.org/wiki/Font_hinting) used to make fonts look
    better on lower-resolution screens. These techniques are much less necessary on
    [high-pixel-density](https://en.wikipedia.org/wiki/Pixel_density) screens, though.
    It’s likely that all screens will eventually be high-density enough to retire
    these techniques.'
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
  zh: '[字体光栅化](https://en.wikipedia.org/wiki/Font_rasterization)非常复杂，使用了诸如[亚像素渲染](https://en.wikipedia.org/wiki/Subpixel_rendering)和[提示](https://en.wikipedia.org/wiki/Font_hinting)等技术来使字体在低分辨率屏幕上看起来更好。然而，在[高像素密度](https://en.wikipedia.org/wiki/Pixel_density)屏幕上，这些技术就不再那么必要了。很可能所有屏幕最终都会足够高密度，以至于可以淘汰这些技术。'
- en: Browser Compositing
  id: totrans-2059
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器合成
- en: Skia and SDL have just made our browser more complex, but the low-level control
    offered by these libraries is important because it allows us to optimize common
    interactions like scrolling.
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
  zh: Skia和SDL刚刚使我们的浏览器变得更加复杂，但这些库提供的低级控制非常重要，因为它允许我们优化如滚动等常见交互。
- en: 'So far, any time the user scrolled a web page, we had to clear the canvas and
    re-raster everything on it from scratch. This is inefficient—we’re drawing the
    same pixels, just in a different place. When the context is complex or the screen
    is large, rastering too often produces a visible slowdown and drains laptop and
    mobile batteries. Real browsers optimize scrolling using a technique I’ll call
    *browser compositing*: drawing the whole web page to a hidden surface, and only
    copying the relevant pixels to the window itself.'
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，每次用户滚动网页时，我们都必须清除画布并从头开始重新光栅化上面的所有内容。这是低效的——我们在不同的地方绘制相同的像素。当上下文复杂或屏幕较大时，过于频繁的光栅化会产生明显的减速并耗尽笔记本电脑和移动电池的电量。真实浏览器通过一种我称之为*浏览器合成*的技术来优化滚动：将整个网页绘制到一个隐藏的表面，并且只复制相关的像素到窗口本身。
- en: 'To implement this, we’ll need two new Skia surfaces: a surface for browser
    chrome and a surface for the current `Tab`’s contents. We’ll only need to re-raster
    the `Tab` surface if page contents change, but not when (say) the user types into
    the address bar. And we can scroll the `Tab` without any raster at all—we just
    copy a different part of the current `Tab` surface to the screen. Let’s call those
    surfaces `chrome_surface` and `tab_surface`:We could even use a different surface
    for each `Tab`, but real browsers don’t do this, since each surface uses up a
    lot of memory, and typically users don’t notice the small raster delay when switching
    tabs.'
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要两个新的Skia表面：一个用于浏览器chrome的表面和一个用于当前`Tab`内容的表面。只有在页面内容发生变化时，我们才需要重新光栅化`Tab`表面，而在用户在地址栏中输入时则不需要。我们可以完全不进行光栅化地滚动`Tab`——我们只需将当前`Tab`表面的不同部分复制到屏幕上。让我们将这些表面称为`chrome_surface`和`tab_surface`：我们甚至可以为每个`Tab`使用不同的表面，但真实浏览器并不这样做，因为每个表面都会消耗大量内存，而且通常用户在切换标签时不会注意到微小的光栅化延迟。
- en: '[PRE478]'
  id: totrans-2063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: I’m not explicitly creating `tab_surface` right away, because we need to lay
    out the page contents to know how tall the surface needs to be.
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有立即创建`tab_surface`，因为我们需要布局页面内容以知道表面需要多高。
- en: 'We’ll also need to split the browser’s `draw` method into three parts:'
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将浏览器的`draw`方法分成三个部分：
- en: '`raster_tab` will raster the page to the `tab_surface`;'
  id: totrans-2066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raster_tab`会将页面渲染到`tab_surface`；'
- en: '`raster_chrome` will raster the browser chrome to the `chrome_surface`;'
  id: totrans-2067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raster_chrome`会将浏览器chrome渲染到`chrome_surface`；'
- en: '`draw` will composite the chrome and tab surfaces and copy the result from
    Skia to SDL.It might seem wasteful to copy from the chrome and tab surfaces to
    an intermediate Skia surface, instead of directly to the SDL surface. It is, but
    skipping that copy requires a lot of tricky low-level code. In [Chapter 13](animations.html)
    we’ll avoid this copy in a different, better way.'
  id: totrans-2068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw`会将chrome和tab表面复合，并将结果从Skia复制到SDL。从chrome和tab表面直接复制到SDL表面可能看起来有些浪费，但跳过这个复制需要大量的底层代码。在[第13章](animations.html)中，我们将以不同的、更好的方式避免这个复制。'
- en: 'Let’s start by doing the split:'
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先进行拆分：
- en: '[PRE479]'
  id: totrans-2070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: Since we didn’t create the `tab_surface` on startup, we need to create it at
    the top of `raster_tab`:For a very big web page, `tab_surface` can be much larger
    than the size of the SDL window, and therefore take up a very large amount of
    memory. We’ll ignore that, but a real browser would only paint and raster surface
    content up to a certain distance from the visible region, and re-paint/raster
    as the user scrolls.
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有在启动时创建`tab_surface`，我们需要在`raster_tab`的顶部创建它：对于一个非常大的网页，`tab_surface`可能比SDL窗口的大小大得多，因此会占用大量的内存。我们将忽略这一点，但一个真正的浏览器只会绘制和渲染可见区域内的内容，并在用户滚动时重新绘制/渲染。
- en: '[PRE480]'
  id: totrans-2072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: Note that we need to recreate the tab surface if the page’s height changes.
    The way we compute the page bounds here, based on the layout tree’s height, would
    be incorrect if page elements could stick out below (or to the right) of their
    parents—but our browser doesn’t support any features like that.
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果页面高度改变，我们需要重新创建标签表面。我们在这里根据布局树的长度计算页面边界的方式，如果页面元素可以超出其父元素（或右侧），将是错误的——但我们的浏览器不支持任何这样的功能。
- en: 'Next, `draw` should copy from the chrome and tab surfaces to the root surface.
    Moreover, we need to translate the `tab_surface` down by `chrome_bottom` and up
    by `scroll`, and clip it to just the area of the window that doesn’t overlap the
    browser chrome:'
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`draw`应该从chrome和tab表面复制到根表面。此外，我们需要将`tab_surface`向下平移`chrome_bottom`，向上平移`scroll`，并将其裁剪到不与浏览器chrome重叠的窗口区域：
- en: '[PRE481]'
  id: totrans-2075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: 'Note the `draw` calls: these copy the `tab_surface` and `chrome_surface` to
    the `canvas`, which is bound to `root_surface`. The `clipRect` and `translate`
    calls make sure we copy the right parts.'
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`draw`调用：这些将`tab_surface`和`chrome_surface`复制到`canvas`，它绑定到`root_surface`。`clipRect`和`translate`调用确保我们复制了正确的部分。
- en: 'Finally, everywhere in `Browser` that we call `draw`, we now need to call either
    `raster_tab` or `raster_chrome` first. For example, in `handle_click`, we do this:'
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Browser`中我们每次调用`draw`的地方，现在都需要先调用`raster_tab`或`raster_chrome`。例如，在`handle_click`中，我们这样做：
- en: '[PRE482]'
  id: totrans-2078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: Notice how we don’t redraw the chrome when only the tab changes, and vice versa.
    Likewise, in `handle_down`, we don’t need to call `raster_tab` at all, since scrolling
    doesn’t change the page.
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当只有标签改变时，我们不会重新绘制chrome，反之亦然。同样，在`handle_down`中，我们根本不需要调用`raster_tab`，因为滚动不会改变页面。
- en: 'However, clicking on a web page can cause it to navigate to a new one, so we
    do need to detect that and raster the browser chrome if the URL changed:'
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，点击网页可能会使其导航到新的网页，因此我们需要检测URL是否改变，并在URL改变时渲染浏览器chrome：
- en: '[PRE483]'
  id: totrans-2081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: 'We also have some related changes in `Tab`. Let’s rename `Tab`’s `draw` method
    to `raster`. In it, we no longer need to pass around the scroll offset to the
    `execute` methods, or account for `chrome_bottom`, because we always draw the
    whole tab to the tab surface:'
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`Tab`中做了一些相关的更改。让我们将`Tab`的`draw`方法重命名为`raster`。在其中，我们不再需要将滚动偏移传递给`execute`方法，或考虑`chrome_bottom`，因为我们总是将整个标签绘制到标签表面：
- en: '[PRE484]'
  id: totrans-2083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: 'Likewise, we can remove the `scroll` parameter from each drawing command’s
    `execute` method:'
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以从每个绘图命令的`execute`方法中移除`scroll`参数：
- en: '[PRE485]'
  id: totrans-2085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: Our browser now uses composited scrolling, making scrolling faster and smoother,
    all because we are now using a mix of intermediate surfaces to store already-rastered
    content and avoid re-rastering unless the content has actually changed.
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器现在使用合成滚动，这使得滚动更快更平滑，所有这一切都因为我们现在使用中间表面混合来存储已栅格化的内容，并且只有在内容实际改变时才避免重新栅格化。
- en: 'Real browsers allocate new surfaces for various different situations, such
    as implementing accelerated overflow scrolling and animations of certain CSS properties
    such as [transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform)
    and opacity that can be done without raster. They also allow scrolling arbitrary
    HTML elements via [`overflow: scroll`](https://developer.mozilla.org/en-US/docs/Web/CSS/overflow)
    in CSS. Basic scrolling for DOM elements is very similar to what we’ve just implemented.
    But implementing it in its full generality, and with excellent performance, is
    *extremely* challenging. Scrolling may well be the single most complicated feature
    in a browser rendering engine. The corner cases and subtleties involved are almost
    endless.'
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
  zh: '实际浏览器为各种不同的情况分配新的表面，例如实现加速的溢出滚动和某些CSS属性（如[transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform)和透明度）的动画，这些动画可以在不栅格化的情况下完成。它们还允许通过CSS中的`overflow:
    scroll`（[overflow](https://developer.mozilla.org/en-US/docs/Web/CSS/overflow)）属性滚动任意HTML元素。DOM元素的基本滚动与我们刚刚实现的方式非常相似。但是，以完全通用的方式实现它，并且具有出色的性能，是**极其**具有挑战性的。滚动可能是浏览器渲染引擎中最为复杂的单个功能。涉及的边缘情况和细微差别几乎是无穷无尽的。'
- en: Transparency
  id: totrans-2088
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 透明度
- en: 'Drawing shapes quickly is already a challenge, but with multiple shapes there’s
    an additional question: what color should the pixel be when two shapes overlap?
    So far, our browser has only handled opaque shapes,It also hasn’t considered subpixel
    geometry or anti-aliasing, which also rely on color mixing. and the answer has
    been simple: take the color of the top shape. But now we need more nuance.'
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: 快速绘制形状已经是一个挑战，但如果有多个形状，还有一个额外的问题：当两个形状重叠时，像素应该是什么颜色？到目前为止，我们的浏览器只处理不透明形状，它也没有考虑亚像素几何或抗锯齿，这些都依赖于颜色混合。答案一直是简单的：取顶部形状的颜色。但现在我们需要更多的细微差别。
- en: Consider partially transparent colors in CSS. These use a hex color with eight
    hex digits, with the last two indicating the level of transparency. For example,
    the color `#00000080` is 50% transparent black. Over a white background, that
    looks gray, but over an orange background it looks like Figure 2.
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑CSS中的部分透明颜色。这些使用八位十六进制颜色，最后两位表示透明度级别。例如，颜色`#00000080`是50%透明的黑色。在白色背景上，它看起来是灰色，但在橙色背景上它看起来像图2。
- en: Test
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
  zh: 测试
- en: 'Figure 2: Example of black semi-transparent text blending into an orange background.'
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：黑色半透明文本与橙色背景融合的示例。
- en: 'Note that the text is a kind of dark orange, because its color is a mix of
    50% black and 50% orange. Many objects in the real world are partially transparent:
    frosted glass, clouds, or colored paper, for example. Looking through one, you
    see multiple colors *blended* together. That’s also why computer screens work:
    the red, green, and blue lights [blend together](https://en.wikipedia.org/wiki/Color_mixing)
    and appear to our eyes as another color. Designers use this effectMostly. Some
    more advanced blending modes on the web are difficult, or perhaps impossible,
    in real-world physics. in overlays, shadows, and tooltips, so our browser needs
    to support color mixing.'
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，文本是一种深橙色，因为它的颜色是50%黑色和50%橙色的混合。现实世界中的许多物体都是部分透明的：例如磨砂玻璃、云彩或彩色纸张。透过它们可以看到多种颜色*混合*在一起。这也是为什么计算机屏幕可以工作：红色、绿色和蓝色的光线[混合](https://en.wikipedia.org/wiki/Color_mixing)并出现在我们的眼睛中作为另一种颜色。设计师使用这种效果Mostly。一些更高级的混合模式在网络上可能很难，或者可能在现实世界的物理中不可能。在叠加、阴影和工具提示中，因此我们的浏览器需要支持颜色混合。
- en: 'Skia supports this kind of transparency by setting the “alpha” field on the
    parsed color:'
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: Skia通过在解析颜色时设置“alpha”字段来支持这种透明度：
- en: '[PRE486]'
  id: totrans-2095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: Check that your browser renders dark-orange text for the example above. That
    shows that it’s actually mixing the black color with the existing orange color
    from the background.
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: 请检查您的浏览器是否渲染了上面示例中的深橙色文本。这表明它实际上是将黑色与背景中现有的橙色混合在一起。
- en: However, there’s another, subtly different way to create transparency with CSS.
    Here, 50% transparency is applied to the whole element using the `opacity` property,
    as in Figure 3.
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有另一种微妙不同的方法使用CSS创建透明度。在这里，50%的透明度通过`opacity`属性应用于整个元素，如图3所示。
- en: Test
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: 测试
- en: 'Figure 3: Example of black text on an orange background, then blended semi-transparently
    into its ancestor.'
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：黑色文本在橙色背景上的示例，然后半透明地混合到其祖先元素中。
- en: Now the opacity applies to both the background and the text, so the background
    is now a little lighter. But note that the text is now gray, not dark orange.
    The black and orange pixels are no longer blended together!
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在透明度应用于背景和文本，因此背景现在稍微亮一些。但请注意，文本现在是灰色，而不是深橙色。黑色和橙色像素不再混合在一起！
- en: That’s because opacity introduces what CSS calls a [stacking context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context).
    Most of the details aren’t important right now, but the order of operations is.
    In the first example, the black pixels were first made transparent, then blended
    with the background. Thus, 50% transparent black pixels were blending with orange
    pixels, resulting in a dark-orange color. In the second example, the black pixels
    were first blended with the background, then the result was made transparent.
    Thus, fully black pixels replaced fully orange ones, resulting in just black pixels,
    which were later made 50% transparent.
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为透明度引入了CSS所说的[堆叠上下文](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)。大多数细节现在并不重要，但操作顺序很重要。在第一个例子中，黑色像素首先被设置为透明，然后与背景混合。因此，50%透明的黑色像素与橙色像素混合，结果产生深橙色。在第二个例子中，黑色像素首先与背景混合，然后结果被设置为透明。因此，完全黑色的像素替换了完全橙色的像素，结果只留下黑色像素，这些像素后来被设置为50%透明。
- en: Applying blending in the proper order, as is necessary to implement effects
    like `opacity`, requires more careful handling of surfaces.
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: 正确地按顺序应用混合，这是实现如`透明度`等效果所必需的，需要更仔细地处理表面。
- en: Mostly, elements [form a stacking context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)
    because of CSS properties that have something to do with layering (like `z-index`)
    or visual effects (like `mix-blend-mode`). On the other hand, the `overflow` property,
    which can make an element scrollable, does not induce a stacking context, which
    I think was a mistake.While we’re at it, perhaps scrollable elements should also
    be a [containing block](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block)
    for descendants. Otherwise, a scrollable element can have non-scrolling children
    via properties like `position`. This situation is very complicated to handle in
    real browsers. The reason is that inside a modern browser, scrolling is done on
    the GPU by offsetting two surfaces. Without a stacking context the browser might
    (depending on the web page structure) have to move around multiple independent
    surfaces with complex paint orders, in lockstep, to achieve scrolling. Fixed-
    and sticky-positioned elements also form stacking contexts because of their interaction
    with scrolling.
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: 主要是因为CSS属性与分层有关（如`z-index`）或视觉效果（如`mix-blend-mode`），元素[形成堆叠上下文](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)。另一方面，`overflow`属性可以使元素可滚动，但它不会引起堆叠上下文，我认为这是一个错误。在此过程中，也许可滚动的元素也应该成为后代的[包含块](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block)。否则，一个可滚动的元素可以通过`position`等属性拥有不可滚动的子元素。这种情况在实际浏览器中处理起来非常复杂。原因是，在现代浏览器中，滚动是通过在GPU上偏移两个表面来完成的。如果没有堆叠上下文，浏览器可能（取决于网页结构）必须同步移动多个独立的表面，并具有复杂的绘制顺序，以实现滚动。固定和粘性定位的元素也形成堆叠上下文，因为它们与滚动的交互。
- en: Blending and Stacking
  id: totrans-2104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合与堆叠
- en: 'To handle the order of operations properly, browsers apply blending not to
    individual shapes but to a tree of surfaces (see Figure 4). Conceptually, each
    shape is drawn to its own surface, and then blended into its parent surface. Different
    structures of intermediate surfaces create different visual effects.You can see
    a more detailed discussion of how the tree structure affects the final image,
    and how that impacted the CSS specifications, on [David Baron’s blog](https://dbaron.org/log/20130306-compositing-blending).
    Rastering a web page requires a bottom-up traversal of this conceptual tree: to
    raster a surface you first need to raster its contents, including its child surfaces,
    and then the contents need to be blended together into the parent.This tree of
    surfaces is an implementation strategy and not something required by any specific
    web API. However, the concept of a [*stacking context*](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)
    is related. A stacking context is technically a mechanism to define groups and
    ordering during paint, and stacking contexts need not correspond to a surface
    (e.g. ones created via [`z-index`](https://developer.mozilla.org/en-US/docs/Web/CSS/z-index)
    do not). However, for ease of implementation, all visual effects in CSS that generally
    require surfaces to implement are specified to go hand-in-hand with a stacking
    context, so the tree of stacking contexts is very related to the tree of surfaces.'
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确处理操作顺序，浏览器将混合应用于表面树而不是单个形状（见图4）。从概念上讲，每个形状都绘制到自己的表面，然后与父表面混合。不同的中间表面结构会产生不同的视觉效果。你可以看到关于树结构如何影响最终图像以及它如何影响CSS规范的更详细讨论，以及这对[David
    Baron的博客](https://dbaron.org/log/20130306-compositing-blending)的影响。渲染网页需要从下到上遍历这个概念树：要栅格化一个表面，首先需要栅格化其内容，包括其子表面，然后将内容混合到父表面中。这个表面树是一个实现策略，而不是任何特定Web
    API的要求。然而，[*堆叠上下文*](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)的概念与之相关。堆叠上下文在技术上是一种在绘制时定义组和排序的机制，堆叠上下文不必对应于表面（例如，通过`z-index`创建的堆叠上下文不对应）。然而，为了便于实现，CSS中所有通常需要表面来实现的视觉效果都被指定为与堆叠上下文一起使用，因此堆叠上下文树与表面树非常相关。
- en: '![Figure 4: A rendered web page is actually the result of stacking and blending
    a series of different surfaces.](img/f8fd7fbc45be2aabfee76d2cd60511df.png)'
  id: totrans-2106
  prefs: []
  type: TYPE_IMG
  zh: '![图4：一个渲染的网页实际上是堆叠和混合一系列不同表面得到的结果。](img/f8fd7fbc45be2aabfee76d2cd60511df.png)'
- en: 'Figure 4: A rendered web page is actually the result of stacking and blending
    a series of different surfaces.'
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：一个渲染的网页实际上是堆叠和混合一系列不同表面得到的结果。
- en: 'To match this use pattern, in Skia, surfaces form a stack. You can push a new
    surface on the stack, raster things to it, and then pop it off, which blends it
    with the surface below. When rastering, you push a new surface onto the stack
    every time you need to apply some visual effect, and pop-and-blend once you’re
    done rastering all the elements that that effect will be applied to, like this:'
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配这种使用模式，在Skia中，表面形成了一个堆栈。你可以在堆栈上推入一个新的表面，将图像栅格化到它上面，然后弹出，使其与下面的表面混合。在栅格化过程中，每次需要应用某种视觉效果时，你都会在堆栈上推入一个新的表面，完成所有要应用该效果的元素栅格化后，进行弹出和混合，如下所示：
- en: '[PRE487]'
  id: totrans-2109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: Here, the `saveLayer` call asks SkiaIt’s called `saveLayer` instead of `createSurface`
    because Skia doesn’t actually promise to create a new surface, if it can optimize
    that away. So what you’re really doing with `saveLayer` is telling Skia that there
    is a new conceptual layer (“piece of paper”) on the stack. Skia’s terminology
    distinguishes between a layer and a surface for this reason as well, but for our
    purposes it makes sense to assume that each new layer comes with a surface. to
    draw all the children to a separate surface before blending them into the parent
    once `restore` is called. The second parameter to `saveLayer` specifies the specific
    type of blending, here with the `Alphaf` parameter requesting 50% opacity.
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`saveLayer`调用请求Skia绘制所有子元素到一个单独的表面，然后再将它们混合到父表面中。一旦调用`restore`，`saveLayer`的第二个参数指定了具体的混合类型，这里使用`Alpha`参数请求50%的不透明度。
- en: '`saveLayer` and `restore` are like a pair of parentheses enclosing child drawing
    operations. This means our display list is no longer just a linear sequence of
    drawing operations, but a tree. So in our display list, let’s handle `opacity`
    with an `Opacity` command that takes a sequence of other drawing commands as an
    argument:'
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveLayer`和`restore`就像一对括号，包围着子绘图操作。这意味着我们的显示列表不再只是绘图操作的线性序列，而是一棵树。因此，在我们的显示列表中，让我们使用一个接受其他绘图命令序列作为参数的`Opacity`命令来处理`opacity`：'
- en: '[PRE488]'
  id: totrans-2112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: 'We can now wrap the drawing commands painted by an element with `Opacity` to
    add transparency to the whole element. I’m going to do this by adding a new `paint_effects`
    method to layout objects, which should be passed a list of drawing commands to
    wrap:'
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用`Opacity`包装一个元素绘制的绘图命令，为整个元素添加透明度。我将通过向布局对象添加一个新的`paint_effects`方法来实现这一点，该方法应该传递一个要包装的绘图命令列表：
- en: '[PRE489]'
  id: totrans-2114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: 'I put the actual construction of the `Opacity` command in a new global `paint_visual_effects`
    method (because other object types will also need it):'
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`Opacity`命令的实际构建放在一个新的全局`paint_visual_effects`方法中（因为其他对象类型也将需要它）：
- en: '[PRE490]'
  id: totrans-2116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: A change is now needed in `paint_tree` to call `paint_effects`, but only *after*
    recursing into children, and only if `should_paint` is true. That’s because these
    visual effects apply to the entire subtree’s display list, not just the current
    object, and don’t apply to “anonymous” objects (see Chapter 8).
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要在`paint_tree`中进行更改，以调用`paint_effects`，但只有在递归到子节点之后，并且只有当`should_paint`为真时。这是因为这些视觉效果应用于整个子树的显示列表，而不仅仅是当前对象，并且不应用于“匿名”对象（见第8章）。
- en: '[PRE491]'
  id: totrans-2118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: Note that `paint_visual_effects` receives a list of commands and returns another
    list of commands. It’s just that the output list is always a single `Opacity`
    command that wraps the original content—which makes sense, because first we need
    to draw the commands to a surface, and *then* apply transparency to it when blending
    into the parent.
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`paint_visual_effects`接收一个命令列表并返回另一个命令列表。只是输出列表始终是一个包含原始内容的单个`Opacity`命令——这是有意义的，因为首先我们需要将命令绘制到表面，然后当与父元素混合时再应用透明度。
- en: I highly recommend a [blog post by Bartosz Ciechanowski](https://ciechanow.ski/alpha-compositing/),
    that gives a really nice visual overview of many of the concepts explored in this
    chapter, plus way more content about how a library such as Skia might implement
    features like raster sampling of vector graphics for lines and text and interpolation
    of surfaces when their pixel arrays don’t match in resolution or orientation.
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐阅读[Bartosz Ciechanowski的博客文章](https://ciechanow.ski/alpha-compositing/)，这篇文章对本章探讨的许多概念进行了非常棒的视觉概述，并且还提供了关于如何实现像Skia这样的库如何实现矢量图形的栅格采样、线条和文本以及当它们的像素数组在分辨率或方向上不匹配时的表面插值等功能的更多内容。
- en: Compositing Pixels
  id: totrans-2121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 像素合成
- en: Now let’s pause and explore how opacity actually works under the hood. Skia,
    SDL, and many other color libraries account for opacity with a fourth *alpha*
    value for each pixel.The difference between opacity and alpha can be confusing.
    Think of opacity as a visual effect *applied to* content, but alpha as a *part
    of* content. Think of alpha as implementation technique for representing opacity.
    An alpha of 0 means the pixel is fully transparent (meaning, no matter what the
    colors are, you can’t see them anyway), and an alpha of 1 means fully opaque.
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们暂停一下，探索透明度实际上是如何在底层工作的。Skia、SDL以及许多其他颜色库为每个像素提供一个第四个*alpha*值来考虑透明度。透明度和alpha之间的区别可能会让人困惑。将透明度视为应用于内容的视觉效果，而alpha则是内容的一部分。将alpha视为表示透明度的实现技术。alpha值为0表示像素完全透明（这意味着，无论颜色如何，你都无法看到它们），而alpha值为1表示完全不透明。
- en: When a pixel with alpha overlaps another pixel, the final color is a mix of
    their two colors. How exactly the colors are mixed is defined by Skia’s `Paint`
    objects. Of course, Skia is pretty complex, but we can sketch these paint operations
    in Python as methods on the conceptual `Pixel` class I introduced earlier.
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: 当带有alpha值的像素与另一个像素重叠时，最终的颜色是这两种颜色的混合。颜色如何混合是由Skia的`Paint`对象定义的。当然，Skia相当复杂，但我们可以通过在之前引入的概念性`Pixel`类上定义方法来在Python中草拟这些绘图操作。
- en: 'When we apply a `Paint` with an `Alphaf` parameter, the first thing Skia does
    is add the requested opacity to each pixel:'
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用带有`Alphaf`参数的`Paint`时，Skia首先为每个像素添加请求的透明度：
- en: '[PRE492]'
  id: totrans-2125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: I want to emphasize that this code is not a part of our browser—I’m simply using
    Python code to illustrate what Skia is doing internally.
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调，这段代码不是我们浏览器的一部分——我只是在用Python代码来展示Skia内部是如何工作的。
- en: That `Alphaf` parameter applies to pixels in one surface. But with `saveLayer`
    we will end up with two surfaces, with all of their pixels aligned, and therefore
    we will need to combine, or *blend*, corresponding pairs of pixels.
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`Alphaf`参数适用于一个表面的像素。但使用`saveLayer`，我们最终会得到两个表面，它们的像素全部对齐，因此我们需要组合，或*混合*相应的像素对。
- en: 'Here, the terminology can get confusing: we imagine that the pixels “on top”
    are blending into the pixels “below”, so we call the top surface the *source surface*,
    with source pixels, and the bottom surface the *destination surface*, with destination
    pixels. When we combine them, there are lots of ways we could do it, but the default
    on the web is called “simple alpha compositing” or *source-over* compositing.
    In Python, the code to implement it looks like this:The formula for this code
    can be found [here](https://www.w3.org/TR/SVG11/masking.html#SimpleAlphaBlending).
    Note that that page refers to *premultiplied* alpha colors, but Skia’s API generally
    does not use premultiplied representations, and this code doesn’t either. (Skia
    does represent colors internally in a premultiplied form, however.)'
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，术语可能会让人困惑：我们想象“在上面”的像素正在与“下面”的像素混合，所以我们称顶层表面为*源表面*，带有源像素，而底层表面为*目标表面*，带有目标像素。当我们组合它们时，有好多方法可以做到，但在网络上的默认方法是“简单alpha合成”或*源覆盖*合成。在Python中，实现它的代码看起来像这样：这个代码的公式可以在[这里](https://www.w3.org/TR/SVG11/masking.html#SimpleAlphaBlending)找到。注意，那个页面指的是*预乘*alpha颜色，但Skia的API通常不使用预乘表示，这段代码也不使用。（然而，Skia确实在内部以预乘形式表示颜色。）
- en: '[PRE493]'
  id: totrans-2129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: Here, the destination pixel `self` is modified to blend in the source pixel
    `source`. The mathematical expressions for the red, green, and blue color channels
    are identical, and basically average the source and destination colors, weighted
    by alpha.For example, if the alpha of the source pixel is 1, the result is just
    the source pixel color, and if it is 0 the result is the backdrop pixel color.
    You might imagine the overall operation of `saveLayer` with an `Alphaf` parameter
    as something like this:In reality, reading individual pixels into memory to manipulate
    them like this is slow, so libraries such as Skia don’t make it convenient to
    do so. (Skia canvases do have `peekPixels` and `readPixels` methods that are sometimes
    used, but not for this.)
  id: totrans-2130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，目标像素`self`被修改以混合源像素`source`。红色、绿色和蓝色颜色通道的数学表达式是相同的，基本上是源颜色和目标颜色的平均值，按alpha加权。例如，如果源像素的alpha值为1，结果是源像素颜色，如果为0，结果是背景像素颜色。你可能想象`saveLayer`与`Alphaf`参数的整体操作就像这样：实际上，将单个像素读入内存以进行这种操作是慢的，因此像Skia这样的库不会让它变得方便。（Skia画布确实有`peekPixels`和`readPixels`方法，有时会用到，但不是用于这个。）
- en: '[PRE494]'
  id: totrans-2131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: Source-over compositing is one way to combine two pixel values. But it’s not
    the only method—you could write literally any computation that combines two pixel
    values if you wanted. Two computations that produce interesting effects are traditionally
    called “multiply” and “difference” and use simple mathematical operations.
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
  zh: 源覆盖合成是组合两个像素值的一种方法。但不是唯一的方法——如果你愿意，你可以编写任何组合两个像素值的计算。两种产生有趣效果的计算传统上被称为“乘法”和“差异”，并使用简单的数学运算。
- en: '“Multiply” multiplies the color values:'
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: “乘法”会乘以颜色值：
- en: '[PRE495]'
  id: totrans-2134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: 'And “difference” computes their absolute differences:'
  id: totrans-2135
  prefs: []
  type: TYPE_NORMAL
  zh: 而“差异”计算它们的绝对差值：
- en: '[PRE496]'
  id: totrans-2136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: 'CSS supports these and many other blending modesMany of these blending modes
    are [common](https://en.wikipedia.org/wiki/Blend_modes) to other graphics editing
    programs like Photoshop and GIMP. Some, like [“dodge” and “burn”](https://en.wikipedia.org/wiki/Dodging_and_burning),
    go back to analog photography, where photographers would expose some parts of
    the image more than others to manipulate their brightness. via the [`mix-blend-mode`
    property](https://drafts.fxtf.org/compositing-1/#propdef-mix-blend-mode), like
    this:'
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
  zh: CSS支持这些以及其他许多混合模式。许多这些混合模式与其他图形编辑程序（如Photoshop和GIMP）[常见](https://en.wikipedia.org/wiki/Blend_modes)。一些，如[“
    dodge”和“burn”](https://en.wikipedia.org/wiki/Dodging_and_burning)，可以追溯到模拟摄影，摄影师会曝光图像的一些部分多于其他部分以调整亮度。通过`mix-blend-mode`属性，如下所示：
- en: '[PRE497]'
  id: totrans-2138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: This HTML will look like Figure 5.
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
  zh: 这段HTML将看起来像图5。
- en: ParentChild
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
  zh: 父子关系
- en: Parent
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
  zh: 父元素
- en: 'Figure 5: Example of the `difference` value for `mix-blend-mode` with a blue
    child and orange parent, resulting in pink.'
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：`mix-blend-mode`的`difference`值示例，蓝色子元素和橙色父元素混合，结果为粉色。
- en: 'Here, when blue overlaps with orange, we see pink: blue has (red, green, blue)
    color channels of `(0, 0, 1)`, and orange has `(1, 0.65, 0)`, so with “difference”
    blending the resulting pixel will be `(1, 0.65, 1)`, which is pink. On a pixel
    level, what’s happening is something like this:'
  id: totrans-2143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当蓝色与橙色重叠时，我们看到的是粉红色：蓝色有（红，绿，蓝）颜色通道为`(0, 0, 1)`，橙色有`(1, 0.65, 0)`，所以使用“差值”混合后，结果像素将是`(1,
    0.65, 1)`，这是粉红色。在像素级别，发生的事情类似于这样：
- en: '[PRE498]'
  id: totrans-2144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: This looks weird, but conceptually it blends the destination into the source
    (which ignores alpha) and then draws the source over the destination (with alpha
    considered). In some sense, blending thus [happens twice](https://drafts.fxtf.org/compositing-1/#blending).
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很奇怪，但从概念上讲，它是将目标混合到源中（忽略alpha通道）然后绘制源到目标上（考虑alpha通道）。在某种程度上，混合因此[发生两次](https://drafts.fxtf.org/compositing-1/#blending)。
- en: 'Skia supports the [multiply](https://drafts.fxtf.org/compositing-1/#blendingmultiply)
    and [difference](https://drafts.fxtf.org/compositing-1/#blendingdifference) blend
    modes natively:'
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: Skia原生支持[乘法](https://drafts.fxtf.org/compositing-1/#blendingmultiply)和[差值](https://drafts.fxtf.org/compositing-1/#blendingdifference)混合模式：
- en: '[PRE499]'
  id: totrans-2147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: 'We can then support blending in our browser by defining a new `Blend` operation:'
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义一个新的`Blend`操作来支持浏览器中的混合：
- en: '[PRE500]'
  id: totrans-2149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: 'Applying it when `mix-blend-mode` is set just requires a simple change to `paint_visual_effects`:'
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
  zh: 当`mix-blend-mode`设置为混合模式时，只需对`paint_visual_effects`进行简单的更改：
- en: '[PRE501]'
  id: totrans-2151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: 'Note the order of operations here: we *first* apply transparency, and *then*
    blend the result into the rest of the page. If we switched the `Opacity` and `Blend`
    calls there wouldn’t be anything to blend it into!'
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的操作顺序：我们首先应用透明度，然后*再*将结果混合到页面的其余部分。如果我们交换了`Opacity`和`Blend`的调用，就没有东西可以混合了！
- en: 'Alpha might seem intuitive, but it’s less obvious than you think: see, for
    example, this [history of alpha](http://alvyray.com/Memos/CG/Microsoft/7_alpha.pdf)
    written by its co-inventor (and co-founder of Pixar). And there are several different
    implementation options. For example, many graphics libraries, Skia included, multiply
    the color channels by the opacity instead of allocating a whole color channel.
    This [premultiplied](https://limnu.com/premultiplied-alpha-primer-artists/) representation
    is generally more efficient; for example, `source_over` above had to divide by
    `self.a` at the end, because otherwise the result would be premultiplied. Using
    a premultiplied representation throughout would save a division. Nor is it obvious
    how alpha [behaves when resized](https://jcgt.org/published/0004/02/03/paper.pdf).'
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
  zh: Alpha可能看起来直观，但比你想象的要复杂：例如，看看它的共同发明者（皮克斯的共同创始人）写的这个[alpha的历史](http://alvyray.com/Memos/CG/Microsoft/7_alpha.pdf)。并且有几种不同的实现选项。例如，许多图形库，包括Skia，将颜色通道乘以不透明度而不是分配整个颜色通道。这种[预乘](https://limnu.com/premultiplied-alpha-primer-artists/)表示通常更高效；例如，上面的`source_over`在最后必须除以`self.a`，否则结果将是预乘的。在整个过程中使用预乘表示可以节省除法。alpha[在缩放时的行为](https://jcgt.org/published/0004/02/03/paper.pdf)也不明显。
- en: Clipping and Masking
  id: totrans-2154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 裁剪和蒙版
- en: The “multiply” and “difference” blend modes can seem kind of obscure, but blend
    modes are a flexible way to implement per-pixel operations. One common use case
    is clipping—intersecting a surface with a given shape. It’s called clipping because
    it’s like putting a second piece of paper (called a *mask*) over the first one,
    and then using scissors to cut along the mask’s edge.
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
  zh: “乘法”和“差值”混合模式可能看起来有些晦涩，但混合模式是实现像素级操作的灵活方式。一个常见的用例是裁剪——将一个表面与给定的形状相交。这被称为裁剪，因为它就像在第一张纸（称为*蒙版*）上再放一张纸，然后用剪刀沿着蒙版的边缘剪裁。
- en: 'There are all sorts of powerful methodsThe CSS [`clip-path` property](https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path)
    lets you specify a mask shape using a curve, while the [`mask` property](https://developer.mozilla.org/en-US/docs/Web/CSS/mask)
    lets you instead specify a image URL for the mask. for clipping content on the
    web, but the most common form involves the `overflow` property. This property
    has lots of possible values,For example, `overflow: scroll` adds scroll bars and
    makes an element scrollable, while `overflow: hidden` is similar to but subtly
    different from `overflow: clip`. but let’s focus here on `overflow: clip`, which
    cuts off contents of an element that are outside the element’s bounds.'
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: 'CSS中的`clip-path`属性[https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path](https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path)允许您使用曲线指定遮罩形状，而`mask`属性允许您指定遮罩的图像URL。对于在网页上裁剪内容，有各种强大的方法，但最常见的形式涉及`overflow`属性。这个属性有很多可能的值，例如，`overflow:
    scroll`会添加滚动条并使元素可滚动，而`overflow: hidden`与`overflow: clip`类似，但略有不同。但让我们在这里关注`overflow:
    clip`，它会切断超出元素边界的元素内容。'
- en: 'Usually, `overflow: clip` is used with properties like `height` or `rotate`
    which can make an element’s children poke outside their parent. Our browser doesn’t
    support these, but there is one edge case where `overflow: clip` is relevant:
    rounded corners.Technically, clipping is also relevant for our browser with single
    words that are longer than the browser window’s width. [Here](examples/example11-longword.html)
    is an example; visually it looks like Figure 6. Consider this example:'
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
  zh: '通常，`overflow: clip`与`height`或`rotate`等属性一起使用，这些属性可以使元素的子元素伸出其父元素之外。我们的浏览器不支持这些属性，但有一个边缘情况，其中`overflow:
    clip`是相关的：圆角。从技术上讲，裁剪对于我们的浏览器来说也与单词长度超过浏览器窗口宽度的情况相关。[这里](examples/example11-longword.html)是一个示例；从视觉上看，它看起来像图6。考虑这个例子：'
- en: '![Figure 6: An example of overflowing text not being clipped by rounded corners.
    ](img/fe481997225485a5ae83a6a15ff15777.png)'
  id: totrans-2158
  prefs: []
  type: TYPE_IMG
  zh: '![图6：一个示例，展示了文本溢出时未被圆角裁剪的情况](img/fe481997225485a5ae83a6a15ff15777.png)'
- en: 'Figure 6: An example of overflowing text not being clipped by rounded corners.'
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：一个示例，展示了文本溢出时未被圆角裁剪的情况。
- en: '[PRE502]'
  id: totrans-2160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: That HTML looks like Figure 7.
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTML看起来像图7。
- en: This test text exists here to ensure that the “div” element is large enough
    that the border radius is obvious.
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
  zh: 这段测试文本存在于此，以确保“div”元素足够大，以便边框半径明显。
- en: 'Figure 7: An example of overflow from text children of a div with `overflow:clip`
    and `border-radius` being clipped out.'
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：一个示例，展示了具有`overflow:clip`和`border-radius`的div元素的文本子元素溢出时被裁剪掉。
- en: 'Observe that the letters near the corner are cut off to maintain a sharp rounded
    edge. That’s clipping; without the `overflow: clip` property these letters would
    instead be fully drawn.'
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
  zh: '注意到角落附近的字母被裁剪掉，以保持锐利的圆角边缘。这就是裁剪；如果没有`overflow: clip`属性，这些字母将被完全绘制。'
- en: Counterintuitively, we’ll implement clipping using blending modes. We’ll make
    a new surface (the mask), draw a rounded rectangle into it, and then blend it
    with the element contents. But we want to see the element contents, not the mask,
    so when we do this blending we will use *destination-in* compositing.
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: 与直觉相反，我们将使用混合模式来实现裁剪。我们将创建一个新的表面（遮罩），在其中绘制一个圆角矩形，然后将其与元素内容混合。但我们需要看到元素内容，而不是遮罩，因此在进行这种混合时，我们将使用*目标-内*合成。
- en: '[Destination-in compositing](https://drafts.fxtf.org/compositing-1/#porterduffcompositingoperators_dstin)
    basically means keeping the pixels of the destination surface that intersect with
    the source surface. The source surface’s color is not used—just its alpha. In
    our case, the source surface is the rounded rectangle mask and the destination
    surface is the content we want to clip, so destination-in fits perfectly. In code,
    destination-in looks like this:'
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
  zh: '[目标-内合成](https://drafts.fxtf.org/compositing-1/#porterduffcompositingoperators_dstin)基本上意味着保留与源表面相交的目标表面的像素。源表面的颜色不被使用——只使用其alpha值。在我们的例子中，源表面是圆角矩形遮罩，目标表面是我们想要裁剪的内容，因此目标-内非常适合。在代码中，目标-内看起来像这样：'
- en: '[PRE503]'
  id: totrans-2167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: 'Now, in `paint_visual_effects`, we need to create a new layer, draw the mask
    image into it, and then blend it with the element contents with destination-in
    blending:'
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`paint_visual_effects`中，我们需要创建一个新的层，将遮罩图像绘制到其中，然后使用目标-内混合将其与元素内容混合：
- en: '[PRE504]'
  id: totrans-2169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: 'Here I pass `destination-in` as the blend mode, though note that this is a
    bit of a hack and that isn’t actually a valid value of `mix-blend-mode`:'
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里传递`destination-in`作为混合模式，尽管请注意这有点像是一个黑客行为，并且实际上这不是`mix-blend-mode`的有效值：
- en: '[PRE505]'
  id: totrans-2171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: After drawing all of the element contents with `cmds` (and applying opacity),
    this code draws a rounded rectangle on another layer to serve as the mask, and
    uses destination-in blending to clip the element contents. Here I chose to draw
    the rounded rectangle in white, but the color doesn’t matter as long as it’s opaque.
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`cmds`（以及应用不透明度）绘制所有元素内容之后，这段代码在另一层上绘制一个圆形矩形作为遮罩，并使用目的地合成的混合来剪裁元素内容。在这里，我选择用白色绘制圆形矩形，但只要是不透明的，颜色无关紧要。
- en: Notice how similar this masking technique is to the physical analogy with scissors
    described earlier, with the two layers playing the role of two sheets of paper
    and destination-in compositing playing the role of the scissors.If all our browser
    wanted to clip were rounded rectangles, Skia actually provides a specialized `clipRRect`
    operation. It’s more efficient than destination-in blending because it applies
    as other commands are being drawn, and so can skip drawing anything outside the
    clipped region. This requires specialized code in each of Skia’s *shaders*, or
    GPU programs, so can only be done for a couple of common shapes. Destination-in
    blending is more general.
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个遮罩技术与之前描述的剪刀物理类比有多相似，其中两层扮演了两张纸的角色，而目的地合成则扮演了剪刀的角色。如果我们的浏览器只想剪切圆形矩形，Skia实际上提供了一个专门的`clipRRect`操作。这比目的地合成的混合更高效，因为它在绘制其他命令的同时应用，因此可以跳过绘制剪裁区域外的任何内容。这需要在Skia的每个*着色器*或GPU程序中编写专门的代码，因此只能用于几种常见的形状。目的地合成的混合更通用。
- en: Rounded corners have an [interesting history](https://www.folklore.org/StoryView.py?story=Round_Rects_Are_Everywhere.txt)
    in computing. Features that are simple today were [very complex](https://raw.githubusercontent.com/jrk/QuickDraw/master/RRects.a)
    to implement on early personal computers with limited memory and no hardware floating-point
    arithmetic. Even when floating-point hardware and eventually GPUs became standard,
    the `border-radius` CSS property didn’t appear in browsers until around 2010.The
    lack of support didn’t stop web developers from putting rounded corners on their
    sites before `border-radius` was supported. There are a number of clever ways
    to do it; [a video from 2008](https://css-tricks.com/video-screencasts/24-rounded-corners/)
    walks through several. More recently, the introduction of animations, visual effects,
    multi-process compositing, and [hardware overlays](https://en.wikipedia.org/wiki/Hardware_overlay)
    have made rounded corners pretty complex to implement. The `clipRRect` fast path,
    for example, can fail to apply for cases such as hardware video overlays and nested
    rounded corner clips.
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: 圆角在计算机科学中有着[有趣的历史](https://www.folklore.org/StoryView.py?story=Round_Rects_Are_Everywhere.txt)。今天看似简单的功能，在早期内存有限且没有硬件浮点运算的个人计算机上实现时非常复杂。[非常复杂](https://raw.githubusercontent.com/jrk/QuickDraw/master/RRects.a)。即使浮点硬件和最终GPU成为标准，`border-radius`
    CSS属性直到大约2010年才出现在浏览器中。不支持并没有阻止在`border-radius`得到支持之前，网络开发者在自己的网站上添加圆角。有几种巧妙的方法可以实现这一点；[2008年的一段视频](https://css-tricks.com/video-screencasts/24-rounded-corners/)展示了几个方法。最近，动画、视觉效果、多进程合成和[硬件叠加](https://en.wikipedia.org/wiki/Hardware_overlay)的引入使得圆角实现变得相当复杂。例如，`clipRRect`快速路径可能无法应用于硬件视频叠加和嵌套圆角剪裁等案例。
- en: Optimizing Surface Use
  id: totrans-2175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化表面使用
- en: Our browser now works correctly, but uses way too many surfaces. For example,
    for a single, no-effects-needed `div` with some text content, there are currently
    18 surfaces allocated in the display list. If there’s no blending going on, we
    should only need one!
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器现在工作正常，但使用了太多的表面。例如，对于一个不需要效果的单一`div`元素，当前在显示列表中分配了18个表面。如果没有混合操作，我们应该只需要一个！
- en: 'Let’s review all the surfaces that our code can create for an element:'
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们的代码可以为元素创建的所有表面：
- en: The top-level surface is used to apply *blend modes*. Since it’s the top-level
    surface, it also *isolates* the element from other parts of the page, so that
    clipping only applies to that element.
  id: totrans-2178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最高级表面用于应用*混合模式*。由于它是顶级表面，它还*隔离*了元素与其他页面部分，因此剪裁只应用于该元素。
- en: The first nested surface is used for applying *opacity*.
  id: totrans-2179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个嵌套表面用于应用*不透明度*。
- en: The second nested surface is used to implement *clipping*.
  id: totrans-2180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个嵌套表面用于实现*剪裁*。
- en: 'But not every element has opacity, blend modes, or clipping applied, and we
    could skip creating those surfaces most of the time. For example, there’s no reason
    to create a surface in `Opacity` if no opacity is actually applied:'
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非每个元素都有不透明度、混合模式或裁剪应用，我们大多数时候可以跳过创建这些表面。例如，如果没有实际应用不透明度，就没有必要在`Opacity`中创建一个表面：
- en: '[PRE506]'
  id: totrans-2182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: 'Similarly, `Blend` doesn’t necessarily need to create a layer if there’s no
    blending going on. But the logic here is a little trickier: the `Blend` operation
    not only applies blending but also isolates the element contents, which matters
    if they are being clipped by `overflow`. So let’s skip creating a layer in `Blend`
    when there’s no blending mode, but let’s set the blend mode to a special, non-standard
    `source-over` value when we need clipping:'
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果没有混合操作，`Blend`不一定需要创建一个层。但这里的逻辑稍微复杂一些：`Blend`操作不仅应用混合，还隔离了元素内容，这在它们被`overflow`裁剪时很重要。所以，当没有混合模式时，让我们在`Blend`中跳过创建层，但当我们需要裁剪时，让我们将混合模式设置为特殊的不标准`source-over`值：
- en: '[PRE507]'
  id: totrans-2184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: 'We’ll parse that as the default source-over blend mode:'
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其解析为默认的源覆盖混合模式：
- en: '[PRE508]'
  id: totrans-2186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: 'This is actually unnecessary, since `parse_blend_mode` already parses unknown
    strings as source-over blending, but it’s good to be explicit. Anyway, now `Blend`
    can skip `saveLayer` if no blend mode is passed:'
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这并不是必要的，因为`parse_blend_mode`已经将未知字符串解析为源覆盖混合，但明确一点总是好的。无论如何，现在`Blend`可以在没有传递混合模式时跳过`saveLayer`：
- en: '[PRE509]'
  id: totrans-2188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: 'So now we skip creating extra surfaces when `Opacity` and `Blend` aren’t really
    necessary. But there’s still one case where we use too many: both `Opacity` and
    `Blend` can create a surface instead of sharing one. Let’s fix that by just merging
    opacity into `Blend`:This works for opacity, but not for filters that “move pixels”
    such as [blur](https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur()).
    Such a filter needs to be applied before clipping, not when blending into the
    parent surface. Otherwise, the edge of the blur will not be sharp.'
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此现在我们跳过了在`Opacity`和`Blend`不是真正必要的情况下创建额外表面的操作。但仍然有一种情况我们会使用太多：`Opacity`和`Blend`都可以创建一个表面而不是共享一个。让我们通过将不透明度合并到`Blend`中解决这个问题：这对于不透明度是有效的，但对于像[模糊](https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur())这样的“移动像素”的过滤器则不适用。这样的过滤器需要在裁剪之前应用，而不是在混合到父表面时应用。否则，模糊的边缘将不会很锐利。
- en: '[PRE510]'
  id: totrans-2190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: 'Now `paint_visual_effects` looks like this:'
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`paint_visual_effects`看起来是这样的：
- en: '[PRE511]'
  id: totrans-2192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: Note that I’ve specified an opacity of `1.0` for the clip `Blend`.
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经为`clip` `Blend`指定了不透明度为`1.0`。
- en: 'Implementing high-quality raster libraries is very interesting in its own right—check
    out [*Real-Time Rendering*](https://www.realtimerendering.com/) for more.There
    is also [*Computer Graphics: Principles and Practice*](https://en.wikipedia.org/wiki/Computer_Graphics:_Principles_and_Practice),
    which incidentally I remember buying—this is Chris speaking—back in the days of
    my youth (1992 or so). At the time I didn’t get much further than rastering lines
    and polygons (in assembly language!). These days you can do the same and more
    with Skia and a few lines of Python. These days, it’s especially important to
    leverage GPUs when they’re available, and browsers often push the envelope. Browser
    teams typically include or work closely with raster library experts: Skia for
    Chromium and [Core Graphics](https://developer.apple.com/documentation/coregraphics)
    for WebKit, for example. Both of these libraries are used outside of the browser,
    too: Core Graphics in iOS and macOS, and Skia in Android.'
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
  zh: 实现高质量的位图库本身就是很有趣的——查看[*实时渲染*](https://www.realtimerendering.com/)了解更多。还有[*计算机图形学：原理与实践*](https://en.wikipedia.org/wiki/Computer_Graphics:_Principles_and_Practice)，我偶然记得在年轻时（大约1992年左右）买过这本书。当时我并没有在光栅化线条和多边形（汇编语言）上走得更远！这些天，你可以用Skia和几行Python做同样的事情，甚至更多。现在，当可用时，利用GPU特别重要，浏览器经常挑战极限。浏览器团队通常包括或与位图库专家紧密合作：例如，Chromium的Skia和WebKit的[Core
    Graphics](https://developer.apple.com/documentation/coregraphics)。这两个库在浏览器外也得到使用：Core
    Graphics在iOS和macOS中，Skia在Android中。
- en: Summary
  id: totrans-2195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'So there you have it: our browser can draw not only boring text and boxes but
    also:'
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是我们的浏览器不仅能绘制无聊的文本和框，还能做到的事情：
- en: browser compositing with extra surfaces for faster scrolling.
  id: totrans-2197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器使用额外表面进行快速滚动的合成。
- en: partial transparency via an alpha channel;
  id: totrans-2198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过alpha通道实现部分透明度；
- en: user-configurable blending modes via `mix-blend-mode`;
  id: totrans-2199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`mix-blend-mode`实现用户可配置的混合模式；
- en: rounded rectangle clipping via destination-in blending or direct clipping;
  id: totrans-2200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过目标内混合或直接裁剪实现圆角矩形裁剪；
- en: optimizations to avoid surfaces when possible;
  id: totrans-2201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当可能时避免表面的优化；
- en: Besides the new features, we’ve upgraded from Tkinter to SDL and Skia, which
    makes our browser faster and more responsive, and also sets a foundation for more
    work on browser performance to come.
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新特性之外，我们还从Tkinter升级到了SDL和Skia，这使得我们的浏览器运行更快、响应更灵敏，同时也为未来对浏览器性能的更多改进奠定了基础。
- en: Click [here](widgets/lab11-browser.html) to try this chapter’s browser.
  id: totrans-2203
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[这里](widgets/lab11-browser.html)来尝试本章的浏览器。
- en: Outline
  id: totrans-2204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should now
    look something like this:'
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整功能集、类和方法现在应该看起来像这样：
- en: '`COOKIE_JAR` `` class URL: `def __init__(url)` `def request(referrer, payload)`
    `def resolve(url)` `def origin()` `def __str__()` `` `` class Text: `def __init__(text,
    parent)` `def __repr__()` `` `` class Element: `def __init__(tag, attributes,
    parent)` `def __repr__()` `` `def print_tree(node, indent)` `def tree_to_list(tree,
    list)` `` class HTMLParser: `SELF_CLOSING_TAGS` `HEAD_TAGS` `def __init__(body)`
    `def parse()` `def get_attributes(text)` `def add_text(text)` `def add_tag(tag)`
    `def implicit_tags(tag)` `def finish()` `` `` class CSSParser: `def __init__(s)`
    `def whitespace()` `def literal(literal)` `def word()` `def ignore_until(chars)`
    `def pair()` `def selector()` `def body()` `def parse()` `` `` class TagSelector:
    `def __init__(tag)` `def matches(node)` `` `` class DescendantSelector: `def __init__(ancestor,
    descendant)` `def matches(node)` `` `FONTS` `def get_font(size, weight, style)`
    `def linespace(font)` `NAMED_COLORS` `def parse_color(color)` `def parse_blend_mode(blend_mode_str)`
    `DEFAULT_STYLE_SHEET` `INHERITED_PROPERTIES` `def style(node, rules)` `def cascade_priority(rule)`
    `WIDTH, HEIGHT` `HSTEP, VSTEP` `INPUT_WIDTH_PX` `BLOCK_ELEMENTS` `` class DocumentLayout:
    `def __init__(node)` `def layout()` `def should_paint()` `def paint()` `def paint_effects(cmds)`
    `` `` class BlockLayout: `def __init__(node, parent, previous)` `def layout_mode()`
    `def layout()` `def recurse(node)` `def new_line()` `def word(node, word)` `def
    input(node)` `def self_rect()` `def should_paint()` `def paint()` `def paint_effects(cmds)`
    `` `` class LineLayout: `def __init__(node, parent, previous)` `def layout()`
    `def should_paint()` `def paint()` `def paint_effects(cmds)` `` `` class TextLayout:
    `def __init__(node, word, parent, previous)` `def layout()` `def should_paint()`
    `def paint()` `def paint_effects(cmds)` `` `` class InputLayout: `def __init__(node,
    parent, previous)` `def layout()` `def should_paint()` `def paint()` `def paint_effects(cmds)`
    `def self_rect()` `` `` class DrawText: `def __init__(x1, y1, text, font, color)`
    `def execute(canvas)` `` `` class DrawRect: `def __init__(rect, color)` `def execute(canvas)`
    `` `` class DrawRRect: `def __init__(rect, radius, color)` `def execute(canvas)`
    `` `` class DrawLine: `def __init__(x1, y1, x2, y2, color, thickness)` `def execute(canvas)`
    `` `` class DrawOutline: `def __init__(rect, color, thickness)` `def execute(canvas)`
    `` `` class Blend: `def __init__(opacity, blend_mode, children)` `def execute(canvas)`
    `` `def paint_tree(layout_object, display_list)` `def paint_visual_effects(node,
    cmds, rect)` `EVENT_DISPATCH_JS` `RUNTIME_JS` `` class JSContext: `def __init__(tab)`
    `def run(script, code)` `def dispatch_event(type, elt)` `def get_handle(elt)`
    `def querySelectorAll(selector_text)` `def getAttribute(handle, attr)` `def innerHTML_set(handle,
    s)` `def XMLHttpRequest_send(...)` `` `SCROLL_STEP` `` class Tab: `def __init__(tab_height)`
    `def load(url, payload)` `def render()` `def allowed_request(url)` `def raster(canvas)`
    `def scrolldown()` `def click(x, y)` `def go_back()` `def submit_form(elt)` `def
    keypress(char)` `` `` class Chrome: `def __init__(browser)` `def tab_rect(i)`
    `def paint()` `def click(x, y)` `def keypress(char)` `def enter()` `def blur()`
    `` `` class Browser: `def __init__()` `def raster_tab()` `def raster_chrome()`
    `def draw()` `def new_tab(url)` `def handle_down()` `def handle_click(e)` `def
    handle_key(char)` `def handle_enter()` `def handle_quit()` `` `def mainloop(browser)`'
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-2207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 11-1 *Filters*. The `filter` CSS property allows specifying various kinds of
    more [complex effects](https://developer.mozilla.org/en-US/docs/Web/CSS/filter),
    such as grayscale or blur. These are fun to implement, and some, like `blur`,
    have built-in support in Skia. Implement `blur`. Think carefully about when blurring
    occurs, relative to other effects like transparency, clipping, and blending.
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 11-1 *过滤器*。`filter` CSS 属性允许指定各种更复杂的 [效果](https://developer.mozilla.org/en-US/docs/Web/CSS/filter)，例如灰度或模糊。这些效果很有趣，而且一些效果，如
    `blur`，在 Skia 中有内置支持。实现 `blur`。仔细思考模糊相对于其他效果（如透明度、裁剪和混合）何时发生。
- en: 11-2 *Hit testing*. If you have an element with a `border-radius`, it’s possible
    to click outside the element but inside its containing rectangle, by clicking
    in the part of the corner that is “rounded off”. This shouldn’t result in clicking
    on the element, but in our browser it currently does. Modify the `click` method
    to take border radii into account.
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
  zh: 11-2 *点击测试*。如果你有一个带有 `border-radius` 的元素，通过点击角落的“圆角”部分，你可以在元素外部但在其包含矩形内部点击，从而实现点击。这不应该导致点击元素，但在我们的浏览器中目前是这样的。修改
    `click` 方法以考虑边框半径。
- en: 11-3 *Interest region*. Our browser now draws the whole web page to a single
    surface, which means a very long web page (like [this chapter’s](http://browser.engineering/visual-effects.html)!)
    creates a large surface, thereby using a lot of memory. Instead, only draw an
    “interest region” of limited height, say `4 * HEIGHT` pixels. You’ll need to keep
    track of where the interest region is on the page, draw the correct part of it
    to the screen, and re-raster the interest region when the user attempts to scroll
    outside of it. Use Skia’s `clipRect` operation to avoid drawing outside the interest
    region.
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
  zh: 11-3 *兴趣区域*。我们的浏览器现在将整个网页绘制到单个表面上，这意味着非常长的网页（如 [本章的](http://browser.engineering/visual-effects.html)！）创建了一个大的表面，因此使用了大量的内存。相反，只绘制一个有限高度的“兴趣区域”，例如
    `4 * HEIGHT` 像素。你需要跟踪兴趣区域在页面上的位置，将其正确部分绘制到屏幕上，并在用户尝试滚动到其外部时重新光栅化兴趣区域。使用 Skia 的
    `clipRect` 操作来避免在兴趣区域外绘制。
- en: '11-4 *Overflow scrolling*. An element with the `overflow` property set to `scroll`
    and a fixed pixel `height` is scrollable. (You’ll want to implement Exercise 6-2)
    so that `height` is supported.) Implement some version of `overflow: scroll`.
    I recommend the following user interaction: the user clicks within a scrollable
    element to focus it, and then can press the arrow keys to scroll up and down.
    You’ll need to keep track of the [*layout overflow*](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout/Flow_Layout_and_Overflow).
    For an extra challenge, make sure you support scrollable elements nested within
    other scrollable elements.'
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
  zh: '11-4 *溢出滚动*。具有 `overflow` 属性设置为 `scroll` 和固定像素 `height` 的元素是可滚动的。（你将需要实现练习
    6-2，以便 `height` 被支持。）实现 `overflow: scroll` 的某个版本。我建议以下用户交互：用户在可滚动元素内点击以将其聚焦，然后可以按箭头键上下滚动。你需要跟踪
    [*布局溢出*](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flow_Layout/Flow_Layout_and_Overflow)。作为一个额外的挑战，确保你支持嵌套在其他可滚动元素中的可滚动元素。'
- en: 11-5 *Touch input*. Many desktop (and all mobile, of course) screens these days
    support touch and multitouch input. And SDL has [APIs](https://wiki.libsdl.org/SDL2/SDL_MultiGestureEvent)
    to support it. Implement a touch-input variant of `click`.You might want to go
    back and look at the “Go Further” block in [Chapter 7](chrome.html) for some hints
    about good ways to implement touch input.
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
  zh: 11-5 *触摸输入*。如今，许多桌面（当然，所有移动设备）屏幕都支持触摸和多点触摸输入。SDL 提供了 [API](https://wiki.libsdl.org/SDL2/SDL_MultiGestureEvent)
    来支持它。实现 `click` 的触摸输入变体。你可能需要回顾第 7 章中的“更进一步”部分，以获取有关实现触摸输入的一些好方法的提示。
- en: Scheduling Tasks and Threads
  id: totrans-2213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度任务和线程
- en: Chapter 12 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
  zh: '[网络浏览器工程](./index.html "目录")的第 12 章。'
- en: '[Tasks and Task Queues](#tasks-and-task-queues)'
  id: totrans-2215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[任务和任务队列](#tasks-and-task-queues)'
- en: '[Timers and `setTimeout`](#timers-and-settimeout)'
  id: totrans-2216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定时器和 `setTimeout`](#timers-and-settimeout)'
- en: '[Long-lived threads](#long-lived-threads)'
  id: totrans-2217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[长生存线程](#long-lived-threads)'
- en: '[The Cadence of Rendering](#the-cadence-of-rendering)'
  id: totrans-2218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[渲染节奏](#the-cadence-of-rendering)'
- en: '[Optimizing with Dirty Bits](#optimizing-with-dirty-bits)'
  id: totrans-2219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用脏位优化](#optimizing-with-dirty-bits)'
- en: '[Animating Frames](#animating-frames)'
  id: totrans-2220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[帧动画](#animating-frames)'
- en: '[Profiling Rendering](#profiling-rendering)'
  id: totrans-2221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[渲染分析](#profiling-rendering)'
- en: '[Two Threads](#two-threads)'
  id: totrans-2222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[两个线程](#two-threads)'
- en: '[Committing a Display List](#committing-a-display-list)'
  id: totrans-2223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提交显示列表](#committing-a-display-list)'
- en: '[Threaded Profiling](#threaded-profiling)'
  id: totrans-2224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[线程分析](#threaded-profiling)'
- en: '[Threaded Scrolling](#threaded-scrolling)'
  id: totrans-2225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[线程化滚动](#threaded-scrolling)'
- en: '[Threaded Style and Layout](#threaded-style-and-layout)'
  id: totrans-2226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[线程化样式和布局](#threaded-style-and-layout)'
- en: '[Summary](#summary)'
  id: totrans-2227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summary)'
- en: '[Outline](#outline)'
  id: totrans-2228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大纲](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-2229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: Modern browsers must handle user input, request remote files, run various callbacks,
    and ultimately render to the screen, all while staying fast and responsive. That
    requires a unified task abstraction to keep track of the browser’s pending work.
    Moreover, browser work must be split across multiple CPU threads, with different
    threads running tasks in parallel to maximize responsiveness.
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器必须处理用户输入、请求远程文件、运行各种回调，并最终将内容渲染到屏幕上，同时保持快速和响应。这需要一个统一的任务抽象来跟踪浏览器待处理的工作。此外，浏览器的工作必须在多个CPU线程之间分配，不同的线程并行运行任务以最大化响应性。
- en: Tasks and Task Queues
  id: totrans-2231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务和任务队列
- en: 'So far, most of the work our browser’s been doing has come from user actions
    like scrolling, pressing buttons, and clicking on links. But as the web applications
    our browser runs get more and more sophisticated, they begin querying remote servers,
    showing animations, and prefetching information for later. And while users are
    slow and deliberative, leaving long gaps between actions for the browser to catch
    up, applications can be very demanding. This requires a change in perspective:
    the browser now has a never-ending queue of tasks to do.'
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们浏览器所做的大部分工作都来自于用户的操作，如滚动、按按钮和点击链接。但随着我们浏览器运行的Web应用变得越来越复杂，它们开始查询远程服务器、显示动画和预取信息以供后续使用。尽管用户操作缓慢且谨慎，在浏览器赶上之前留下长时间的操作间隔，但应用可能非常苛刻。这需要改变视角：浏览器现在有一个永远做不完的任务队列。
- en: 'Modern browsers adapt to this reality by multitasking, prioritizing, and deduplicating
    work. Every bit of work the browser might do—loading pages, running scripts, and
    responding to user actions—is turned into a *task*, which can be executed later,
    where a task is just a function (plus its arguments) that can be executed:'
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器通过多任务处理、优先级排序和去重工作来适应这一现实。浏览器可能执行的所有工作——加载页面、运行脚本和响应用户操作——都被转换成*任务*，这些任务可以在稍后执行，其中任务只是一个可以执行（及其参数）的函数：
- en: '[PRE512]'
  id: totrans-2234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: Note the special `*args` syntax in the constructor arguments and in the call
    to `task_code`. This syntax indicates that a `Task` can be constructed with any
    number of arguments, which are then available as the list `args`. Then, calling
    a function with `*args` unpacks the list back into multiple arguments.
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意构造函数参数和调用`task_code`时特殊的`*args`语法。这种语法表示`Task`可以用任意数量的参数来构建，这些参数随后作为`args`列表可用。然后，使用`*args`调用函数将列表重新展开成多个参数。
- en: 'The point of a task is that it can be created at one point in time, and then
    run at some later time by a task runner of some kind, according to a scheduling
    algorithm.The event loops we discussed in [Chapter 2](graphics.html#eventloop)
    and [Chapter 11](visual-effects.html#sdl-creates-the-window) are task runners,
    where the tasks to run are provided by the operating system. In our browser, the
    task runner will store tasks in a first-in, first-out queue:'
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的目的在于它可以在某个时间点创建，然后由某种类型的任务运行器在稍后的时间运行，根据调度算法。我们在[第2章](graphics.html#eventloop)和[第11章](visual-effects.html#sdl-creates-the-window)中讨论的事件循环是任务运行器，其中要运行的任务由操作系统提供。在我们的浏览器中，任务运行器将任务存储在一个先进先出队列中：
- en: '[PRE513]'
  id: totrans-2237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: When the time comes to run a task, our task runner can just remove the first
    task from the queue and run it:First-in, first-out is a simplistic way to choose
    which task to run next, and real browsers have sophisticated *schedulers* which
    consider [many different factors](https://blog.chromium.org/2015/04/scheduling-tasks-intelligently-for_30.html).
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行任务的时间到来时，我们的任务运行器只需从队列中移除第一个任务并运行它：先进先出是一种简单的选择下一个要运行的任务的方法，而真正的浏览器拥有复杂的*调度器*，它们会考虑[许多不同的因素](https://blog.chromium.org/2015/04/scheduling-tasks-intelligently-for_30.html)。
- en: '[PRE514]'
  id: totrans-2239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: 'To run those tasks, we need to call the `run` method on our `TaskRunner`, which
    we can do in the main event loop:'
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些任务，我们需要在`TaskRunner`上调用`run`方法，我们可以在主事件循环中这样做：
- en: '[PRE515]'
  id: totrans-2241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-2242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: The `TaskRunner` allows us to choose when exactly different tasks are handled.
    Here, I’ve chosen to check for user events between every `Task` the browser runs,
    which makes our browser more responsive when there are lots of tasks. I’ve also
    chosen to only run tasks on the active tab, which means background tabs can’t
    slow our browser down.
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskRunner` 允许我们选择在何时处理不同的任务。在这里，我选择在浏览器运行每个 `Task` 之间检查用户事件，这使得在有很多任务时，我们的浏览器响应更快。我还选择只在活动标签页上运行任务，这意味着后台标签页不能减慢我们的浏览器速度。'
- en: 'With this simple task runner, we can now queue up tasks and execute them later.
    For example, right now, when loading a web page, our browser will download and
    run all scripts before doing its rendering steps. That makes pages slower to load.
    We can fix this by creating tasks for running scripts:'
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个简单的任务运行器，我们现在可以排队任务并在稍后执行它们。例如，现在，当加载网页时，我们的浏览器会在执行渲染步骤之前下载并运行所有脚本。这使得页面加载变慢。我们可以通过创建运行脚本的任务来解决这个问题：
- en: '[PRE517]'
  id: totrans-2245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: Now our browser will not run scripts until after `load` has completed and the
    event loop comes around again. And if there are lots of scripts to run, we’ll
    also be able to process user events while the page loads.
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的浏览器将在 `load` 完成后以及事件循环再次开始之前运行脚本。如果有大量脚本要运行，我们还可以在页面加载时处理用户事件。
- en: JavaScript uses a task-based [event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)
    even [outside](https://nodejs.dev/learn/the-nodejs-event-loop) of the browser.
    For example, JavaScript uses message passing, handles input and output via [asynchronous](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking)
    APIs, and has run-to-completion semantics. Of course, this programming model grew
    out of early browser implementations, and is now another important reason to architect
    a browser using tasks.
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 即使在浏览器之外也使用基于任务的 [事件循环](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)
    。例如，JavaScript 使用消息传递，通过 [异步](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking)
    API 处理输入和输出，并且具有运行到完成的语义。当然，这种编程模型源于早期的浏览器实现，并且现在也是使用任务来架构浏览器的重要原因。
- en: Timers and `setTimeout`
  id: totrans-2248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器和 `setTimeout`
- en: 'Tasks are *also* a natural way to support several JavaScript APIs that ask
    for a function to be run at some point in the future. For example, [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout)
    lets you run a JavaScript function some number of milliseconds from now. This
    code prints “Callback” to the console one second from now:'
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
  zh: 任务也是一种支持多个 JavaScript API 的自然方式，这些 API 要求在未来的某个时刻运行一个函数。例如，[`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout)
    允许你在现在起一段时间后运行一个 JavaScript 函数。以下代码将在一秒后将“回调”打印到控制台：
- en: '[PRE518]'
  id: totrans-2250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: 'As with `addEventListener` in [Chapter 9](scripts.html#event-handling), we’ll
    implement `setTimeout` by saving the callback in a JavaScript variable and creating
    a handle by which the Python-side code can call it:'
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [第 9 章](scripts.html#event-handling) 中的 `addEventListener` 一样，我们将通过在 JavaScript
    变量中保存回调并创建一个 Python 端代码可以调用的句柄来实现 `setTimeout`：
- en: '[PRE519]'
  id: totrans-2252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: The exported `setTimeout` function will create a timer, wait for the requested
    time period, and then ask the JavaScript runtime to run the callback. That last
    part will happen via `__runSetTimeout`:Note that we never remove `callback` from
    the `SET_TIMEOUT_REQUESTS` dictionary. This could lead to a memory leak, if the
    callback is holding on to the last reference to some large data structure. [Chapter
    9](scripts.html) had a similar issue with handles. Avoiding memory leaks in data
    structures shared between the browser and the browser application takes a lot
    of care and this book doesn’t attempt to do it right.
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的 `setTimeout` 函数将创建一个定时器，等待请求的时间段，然后要求 JavaScript 运行时运行回调。最后一部分将通过 `__runSetTimeout`
    来完成：请注意，我们从未从 `SET_TIMEOUT_REQUESTS` 字典中移除 `callback`。如果回调持有对某些大型数据结构的最后一个引用，这可能导致内存泄漏。[第
    9 章](scripts.html) 中也遇到了类似的问题。避免在浏览器和浏览器应用程序之间共享的数据结构中的内存泄漏需要很多小心，本书并不试图做到这一点。
- en: '[PRE520]'
  id: totrans-2254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: Now let’s implement the Python side of this API. We can use the [`Timer`](https://docs.python.org/3/library/threading.html#timer-objects)
    class in Python’s [`threading`](https://docs.python.org/3/library/threading.html)
    module. You use the class like this:An alternative approach would be to record
    when each `Task` is supposed to occur, and compare against the current time in
    the event loop. This is called *polling*, and is what, for example, the SDL event
    loop does to look for events and tasks. However, that can mean wasting CPU cycles
    in a loop until the task is ready, so I expect the `Timer` to be more efficient.
  id: totrans-2255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来实现这个API的Python部分。我们可以使用Python的`threading`模块中的`Timer`类。你可以这样使用这个类：另一种方法是在事件循环中记录每个`Task`应该发生的时间，并与当前时间进行比较。这被称为*轮询*，例如，SDL事件循环就是这样查找事件和任务的。然而，这可能会导致在循环中浪费CPU周期，直到任务准备就绪，所以我预计`Timer`将更高效。
- en: '[PRE521]'
  id: totrans-2256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: 'This runs `callback` one second from now. Simple! But `threading.Timer` executes
    its callback *on a new Python thread*, and that introduces a lot of challenges.
    The callback can’t just call `evaljs` directly: we’d end up with JavaScript running
    on two Python threads at the same time, which is not good.JavaScript is not a
    multithreaded programming language. It’s possible on the web to create [workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)
    of various kinds, but they all run independently and communicate only via special
    message-passing APIs. So as a workaround, the callback will add a new `Task` to
    the task queue to call `__runSetTimeout`. That has the downside of potentially
    delaying the callback, but it means that JavaScript will only ever execute on
    the main thread.'
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在一秒后运行`callback`。简单！但是`threading.Timer`会在一个新的Python线程上执行其回调，这引入了许多挑战。回调不能直接调用`evaljs`：我们最终会在两个Python线程上同时运行JavaScript，这并不好。JavaScript不是一个多线程的编程语言。在网络上可以创建各种类型的[workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)，但它们都是独立运行的，并且只能通过特殊的消息传递API进行通信。因此，作为权宜之计，回调将向任务队列添加一个新的`Task`来调用`__runSetTimeout`。这的缺点是可能会延迟回调，但这意味着JavaScript将始终在主线程上执行。
- en: 'Let’s implement that:'
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来实现它：
- en: '[PRE522]'
  id: totrans-2259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: 'But this still isn’t quite right. We now have two threads accessing the `task_runner`:
    the primary thread, to run tasks, and the timer thread, to add them. This is a
    [race condition](https://en.wikipedia.org/wiki/Race_condition) that can cause
    all sorts of bad things to happen, so we need to make sure only one thread accesses
    the `task_runner` at a time.'
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: 但这仍然不太对。我们现在有两个线程访问`task_runner`：主线程用于运行任务，定时器线程用于添加它们。这是一个[竞争条件](https://en.wikipedia.org/wiki/Race_condition)，可能会导致各种不良事件发生，因此我们需要确保一次只有一个线程访问`task_runner`。
- en: To do so we use a [`Condition`](https://docs.python.org/3/library/threading.html#threading.Condition)
    object, which can only be held by one thread at a time. Each thread will try to
    acquire `condition` before reading or writing to the `task_runner`, avoiding simultaneous
    access.The `blocking` parameter to `acquire` indicates whether the thread should
    wait for the condition to be available before continuing; in this chapter you’ll
    always set it to `True`. (When the thread is waiting, it’s said to be *blocked*.)
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们使用一个`Condition`对象，它一次只能被一个线程持有。每个线程在读取或写入`task_runner`之前都会尝试获取`condition`，以避免同时访问。`acquire`函数的`blocking`参数指示线程是否应该在继续之前等待条件可用；在本章中，你将始终将其设置为`True`。（当线程等待时，它被称为*阻塞*。）
- en: The `Condition` class is actually a [`Lock`](https://docs.python.org/3/library/threading.html#threading.Lock),
    plus functionality to be able to *wait* until a state condition occurs. If you
    have no more work to do right now, acquire `condition` and then call `wait`. This
    will cause the thread to stop at that line of code. When more work comes in to
    do, such as in `schedule_task`, a call to `notify_all` will wake up the thread
    that called `wait`.
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: '`Condition`类实际上是一个`Lock`，并且增加了能够等待状态条件发生的功能。如果你现在没有更多的工作要做，获取`condition`然后调用`wait`。这将导致线程在该代码行处停止。当有更多工作要做时，例如在`schedule_task`中，对`notify_all`的调用将唤醒调用`wait`的线程。'
- en: '[PRE523]'
  id: totrans-2263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: It’s important to call `wait` at the end of the `run` loop if there is nothing
    left to do. Otherwise that thread will tend to use up a lot of the CPU, plus constantly
    be acquiring and releasing `condition`. This busywork not only slows down the
    computer, but also causes the callbacks from the `Timer` to happen at erratic
    times, because the two threads are competing for the lock.Try removing this code
    and observe. The timers will become quite erratic.
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`run`循环结束时没有其他事情要做，那么调用`wait`非常重要。否则，那个线程可能会消耗大量的CPU资源，并且不断地获取和释放`condition`。这种忙碌的工作不仅会减慢计算机的速度，还会导致`Timer`的回调在不可预测的时间发生，因为两个线程正在竞争锁。尝试移除此代码并观察。计时器将变得非常不可预测。
- en: When using locks, it’s super important to remember to release the lock eventually
    and to hold it for the shortest time possible. The code above, for example, releases
    the lock before running the `task`. That’s because after the task has been removed
    from the queue, it can’t be accessed by another thread, so the lock does not need
    to be held while the task is running.
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用锁时，非常重要的一点是要记住最终释放锁，并且尽可能保持最短的时间。例如，上面的代码在运行`task`之前释放了锁。这是因为任务从队列中移除后，其他线程无法访问它，因此在任务运行时不需要持有锁。
- en: 'The `setTimeout` code is now thread-safe, but still has yet another bug: if
    we navigate from one page to another, `setTimeout` callbacks still pending on
    the previous page might still try to execute. That is easily prevented by adding
    a `discarded` field on `JSContext` and setting it when loading a new page:'
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout`代码现在是线程安全的，但仍然有一个另一个错误：如果我们从一个页面导航到另一个页面，之前页面上挂起的`setTimeout`回调仍然可能尝试执行。通过在`JSContext`上添加一个`discarded`字段并在加载新页面时设置它，可以轻松防止这种情况：'
- en: '[PRE524]'
  id: totrans-2267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-2268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: Unfortunately, Python currently has a [global interpreter lock](https://wiki.python.org/moin/GlobalInterpreterLock)
    (GIL), so Python threads don’t truly run in parallel. This unfortunate limitation
    of Python has some effect on our browser, but not on real browsers, so in this
    chapter I mostly pretend the GIL isn’t there. And perhaps a future version of
    Python will [get rid of it](https://peps.python.org/pep-0703/). We still need
    locks despite the global interpreter lock, because Python threads can yield between
    bytecode operations or during calls into C libraries. That means concurrent accesses
    and race conditions are still possible.In fact, while debugging the code for this
    chapter, I often encountered this kind of race condition when I forgot to add
    a lock. Remove some of the locks from your browser and you can see for yourself!
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Python目前有一个[全局解释器锁](https://wiki.python.org/moin/GlobalInterpreterLock)（GIL），所以Python线程实际上并不真正并行运行。Python的这个不幸限制对我们的浏览器有影响，但对真实浏览器没有影响，所以在这章中我主要假装GIL不存在。也许Python的将来版本会[去除它](https://peps.python.org/pep-0703/)。尽管有全局解释器锁，我们仍然需要锁，因为Python线程可以在字节码操作之间或调用C库期间让出。这意味着并发访问和竞态条件仍然可能。事实上，在调试本章代码时，我经常忘记添加锁而遇到这种竞态条件。从你的浏览器中移除一些锁，你可以亲自看到这一点！
- en: Long-lived threads
  id: totrans-2270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长期运行的线程
- en: 'Threads can also be used to add browser multitasking. For example, in [Chapter
    10](security.html#cross-site-requests) we implemented the `XMLHttpRequest` class,
    which lets scripts make requests to the server. But in our implementation, the
    whole browser would seize up while waiting for the request to finish. That’s obviously
    bad.For this reason, the synchronous version of the API that we implemented in
    Chapter 10 is not very useful and a huge performance footgun. Some browsers are
    now moving to deprecate synchronous `XMLHttpRequest`. Python’s `Thread` class
    lets us do better:'
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
  zh: 线程也可以用来添加浏览器多任务处理。例如，在第10章（security.html#cross-site-requests）中，我们实现了`XMLHttpRequest`类，它允许脚本向服务器发送请求。但在我们的实现中，整个浏览器在等待请求完成时会冻结。这显然很糟糕。因此，第10章中我们实现的API的同步版本并不很有用，而且性能非常差。一些浏览器现在正在转向废弃同步`XMLHttpRequest`。Python的`Thread`类让我们做得更好：
- en: '[PRE526]'
  id: totrans-2272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: This code creates a new thread and then immediately returns. The `callback`
    then runs in parallel, on the new thread, while the initial thread continues to
    execute later code.
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个新线程然后立即返回。然后`callback`在新线程上并行运行，而初始线程继续执行后续代码。
- en: We’ll implement asynchronous `XMLHttpRequest` calls using threads. Specifically,
    we’ll have the browser start a thread, do the request and parse the response on
    that thread, and then schedule a `Task` to send the response back to the script.
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用线程实现异步`XMLHttpRequest`调用。具体来说，我们将让浏览器启动一个线程，在该线程上执行请求并解析响应，然后安排一个`Task`将响应发送回脚本。
- en: 'Like with `setTimeout`, we’ll store the callback on the JavaScript side and
    refer to it with a handle:'
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `setTimeout` 类似，我们将在 JavaScript 端存储回调并使用处理程序引用它：
- en: '[PRE527]'
  id: totrans-2276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: When a script calls the `open` method on an `XMLHttpRequest` object, we’ll now
    allow the `is_async` flag to be true:In browsers, the `is_async` parameter is
    optional and defaults to `true`, but our browser doesn’t implement that.
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本在 `XMLHttpRequest` 对象上调用 `open` 方法时，我们现在将允许 `is_async` 标志为真：在浏览器中，`is_async`
    参数是可选的，默认为 `true`，但我们的浏览器没有实现这一点。
- en: '[PRE528]'
  id: totrans-2278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: 'The `send` method will need to send over the `is_async` flag and the handle:'
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
  zh: '`send` 方法需要发送 `is_async` 标志和处理程序：'
- en: '[PRE529]'
  id: totrans-2280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: 'On the browser side, the `XMLHttpRequest_send` handler will have three parts.
    The first part will resolve the URL and do security checks:'
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器端，`XMLHttpRequest_send` 处理程序将包含三个部分。第一部分将解析 URL 并进行安全检查：
- en: '[PRE530]'
  id: totrans-2282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: 'Then, we’ll define a function that makes the request and enqueues a task for
    running callbacks:'
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义一个函数来发送请求并将任务排队以运行回调：
- en: '[PRE531]'
  id: totrans-2284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: Note that the task runs `dispatch_xhr_onload`, which we’ll define in just a
    moment.
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任务会运行 `dispatch_xhr_onload`，我们将在稍后定义它。
- en: 'Finally, depending on the `is_async` flag the browser will either call this
    function right away, or in a new thread:'
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，根据 `is_async` 标志，浏览器将立即调用此函数，或在新的线程中调用：
- en: '[PRE532]'
  id: totrans-2287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: Note that in the asynchronous case, the `XMLHttpRequest_send` method starts
    a thread and then immediately returns. That thread will run in parallel with the
    browser’s main work until the request is done.In theory two parallel requests
    could race while accessing the cookie jar; I’m not fixing this out of expediency
    but a proper implementation would have locks for the cookie jar.
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在异步情况下，`XMLHttpRequest_send` 方法启动一个线程然后立即返回。该线程将在请求完成之前与浏览器的主要工作并行运行。理论上，两个并行请求可能会在访问
    cookie jar 时发生竞争；我并不是因为方便而不解决这个问题，但一个合适的实现应该为 cookie jar 提供锁。
- en: 'To communicate the result back to JavaScript, we’ll call a `__runXHROnload`
    function from `dispatch_xhr_onload`:'
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将结果传回 JavaScript，我们将从 `dispatch_xhr_onload` 调用 `__runXHROnload` 函数：
- en: '[PRE533]'
  id: totrans-2290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: 'The `__runXHROnload` method just pulls the relevant object from `XHR_REQUESTS`
    and calls its `onload` function, which is the standard callback for asynchronous
    `XMLHttpRequest`s:'
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: '`__runXHROnload` 方法只是从 `XHR_REQUESTS` 中提取相关对象并调用其 `onload` 函数，这是异步 `XMLHttpRequest`
    的标准回调：'
- en: '[PRE534]'
  id: totrans-2292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: As you can see, tasks allow not only the browser but also applications running
    in the browser to delay tasks until later.
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，任务不仅允许浏览器，还允许在浏览器中运行的应用程序延迟任务直到稍后。
- en: '`XMLHttpRequest` played a key role in helping the web evolve. In the 1990s,
    clicking on a link or submitting a form required loading a new pages. With `XMLHttpRequest`
    web pages were able to act a whole lot more like a dynamic application; GMail
    was one famous early example.GMail dates from April 2004, [soon after](https://en.wikipedia.org/wiki/XMLHttpRequest#History)
    enough browsers finished adding support for the API. The first application to
    use `XMLHttpRequest` was [Outlook Web Access](https://en.wikipedia.org/wiki/Outlook_on_the_web),
    in 1999, but it took a while for the API to make it into other browsers. Nowadays,
    a web application that uses DOM mutations instead of page loads to update its
    state is called a [single-page app](https://en.wikipedia.org/wiki/Single-page_application).
    Single-page apps enabled more interactive and complex web apps, which in turn
    made browser speed and responsiveness more important.'
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest` 在帮助网络进化中发挥了关键作用。在 1990 年代，点击链接或提交表单需要加载新页面。有了 `XMLHttpRequest`，网页能够更像动态应用程序；GMail
    是一个著名的早期例子。GMail 日期为 2004 年 4 月，[不久之后](https://en.wikipedia.org/wiki/XMLHttpRequest#History)足够多的浏览器完成了对该
    API 的支持。第一个使用 `XMLHttpRequest` 的应用程序是 [Outlook Web Access](https://en.wikipedia.org/wiki/Outlook_on_the_web)，在
    1999 年，但 API 进入其他浏览器花费了一段时间。如今，使用 DOM 变化而不是页面加载来更新其状态的 Web 应用程序被称为 [单页应用](https://en.wikipedia.org/wiki/Single-page_application)。单页应用使得更交互和复杂的
    Web 应用程序成为可能，这反过来又使得浏览器速度和响应性变得更加重要。'
- en: The Cadence of Rendering
  id: totrans-2295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染的节奏
- en: 'There’s more to tasks than just implementing some JavaScript APIs. Once something
    is a `Task`, the task runner controls when it runs: perhaps now, perhaps later,
    or maybe at most once a second, or even at different rates for active and inactive
    pages, or according to its priority. A browser could even have multiple task runners,
    optimized for different use cases.'
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
  zh: 任务不仅仅是实现一些 JavaScript API。一旦某物成为 `Task`，任务运行器将控制其运行时间：可能是现在，可能是稍后，或者最多每秒一次，甚至对于活动和非活动页面有不同的速率，或者根据其优先级。浏览器甚至可以有多个任务运行器，针对不同的用例进行优化。
- en: Now, it might be hard to see how the browser can prioritize which JavaScript
    callback to run, or why it might want to execute JavaScript tasks at a fixed cadence.
    But besides JavaScript the browser also has to render the page, and as you may
    recall from [Chapter 2](graphics.html#framebudget), we’d like the browser to render
    the page exactly as fast as the display hardware can refresh. On most computers,
    this is 60 times per second, or 16 ms per frame. However, even with today’s computers,
    it’s quite difficult to maintain such a high frame rate, and certainly too high
    a bar for our toy browser.
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可能很难看出浏览器如何优先处理要运行的JavaScript回调，或者为什么它可能想要以固定的节奏执行JavaScript任务。但除了JavaScript之外，浏览器还必须渲染页面，并且如您从[第二章](graphics.html#framebudget)中回忆的那样，我们希望浏览器以显示硬件可以刷新的速度渲染页面。在大多数计算机上，这是每秒60次，或每帧16毫秒。然而，即使是在今天的计算机上，保持如此高的帧率也是相当困难的，对于我们的玩具浏览器来说，这无疑是一个过高的标准。
- en: So let’s establish 30 frames per second—33 ms for each frame—as our refresh
    rate target:Of course, 30 times per second is actually 33.33333… ms. But it’s
    a toy browser, and having a more exact value also makes tests easier to write.
  id: totrans-2298
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们设定每秒30帧——每帧33毫秒——作为我们的刷新率目标：当然，每秒30次实际上是33.33333…毫秒。但这是一个玩具浏览器，拥有更精确的值也使得编写测试更容易。
- en: '[PRE535]'
  id: totrans-2299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: 'Now, drawing a frame is split between the `Tab` and `Browser`. The `Tab` needs
    to call `render` to compute a display list. Then the `Browser` needs to raster
    and draw that display list (and also the chrome display list). Let’s put those
    `Browser` tasks in their own method:'
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，绘制框架的工作被分配给了`Tab`和`Browser`。`Tab`需要调用`render`来计算显示列表。然后`Browser`需要光栅化和绘制那个显示列表（以及chrome显示列表）。让我们将这些`Browser`任务放入它们自己的方法中：
- en: '[PRE536]'
  id: totrans-2301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: 'Now, we don’t need *each* tab redrawing itself every frame, because the user
    only sees one tab at a time. We just need the *active* tab redrawing itself. Therefore,
    it’s the `Browser` that should control when we update the display, not individual
    `Tab`s. So let’s write a `schedule_animation_frame` methodIt’s called an “animation
    frame” because sequential rendering of different pixels is an animation, and each
    time you render it’s one “frame”—like a drawing in a picture frame. that schedules
    a task to `render` the active tab:'
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不需要每个标签每帧都重绘自己，因为用户一次只能看到一个标签。我们只需要活动标签自己重绘。因此，控制我们何时更新显示的是`Browser`，而不是单个`Tab`。所以让我们编写一个`schedule_animation_frame`方法。它被称为“动画帧”，因为不同像素的顺序渲染是一个动画，每次渲染都是一帧——就像画框中的一幅画。这个方法安排一个任务来`render`活动标签：
- en: '[PRE537]'
  id: totrans-2303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: 'We can kick off the process when we start the browser. In the top-level loop,
    after running a task on the active tab the browser will need to raster and draw,
    in case that task was a rendering task:'
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在启动浏览器时启动这个过程。在顶层循环中，在运行活动标签的任务之后，浏览器将需要光栅化和绘制，以防该任务是渲染任务：
- en: '[PRE538]'
  id: totrans-2305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: The additional call to `schedule_animation_frame` will happen every time through
    the loop. However, because of the check for `self.animation_timer` being `None`,
    it will only have an effect once `callback` was called, which only happens after
    33 ms. Thus we’re scheduling a new rendering task every 33 ms, just as we wanted
    to.
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环中都会发生对`schedule_animation_frame`的额外调用。然而，由于检查`self.animation_timer`是否为`None`，它只有在`callback`被调用后才会产生效果，这通常发生在33毫秒之后。因此，我们每33毫秒就安排一个新的渲染任务，正如我们想要的那样。
- en: 'There’s nothing special about any particular refresh rate. Some displays refresh
    72 times per second, and displays that [refresh even more often](https://www.intel.com/content/www/us/en/gaming/resources/highest-refresh-rate-gaming.html)
    are becoming more common. Movies are often shot at 24 frames per second (though
    [some directors advocate 48](https://www.extremetech.com/extreme/128113-why-movies-are-moving-from-24-to-48-fps))
    while television shows traditionally use 30 frames per second. Consistency is
    often more important than the actual frame rate: a consistant 24 frames per second
    can look a lot smoother than a varying rate between 60 and 24.'
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何特定的刷新率是特别的。一些显示器每秒刷新72次，而刷新率更高的显示器[越来越常见](https://www.intel.com/content/www/us/en/gaming/resources/highest-refresh-rate-gaming.html)。电影通常以每秒24帧的速度拍摄（尽管[一些导演提倡48帧](https://www.extremetech.com/extreme/128113-why-movies-are-moving-from-24-to-48-fps)），而电视节目传统上使用每秒30帧。一致性通常比实际帧率更重要：一致的24帧每秒看起来比在60和24之间的变化率要平滑得多。
- en: Optimizing with Dirty Bits
  id: totrans-2308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脏位优化
- en: If you run this on your computer, there’s a good chance your CPU usage will
    spike and your batteries will start draining. That’s because we’re calling `render`
    every frame, which means our browser is now constantly styling elements, building
    layout trees, and painting display lists. Most of that work is wasted, because
    on most frames, the web page will not have changed at all, so the old styles,
    layout trees, and display lists would have worked just as well as the new ones.
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在自己的电脑上运行这个程序，你的CPU使用率可能会急剧上升，电池开始耗尽。这是因为我们在每一帧都调用`render`，这意味着我们的浏览器现在不断地对元素进行样式化、构建布局树和绘制显示列表。其中大部分工作都是浪费的，因为在大多数帧上，网页根本没有任何变化，所以旧的样式、布局树和显示列表会和新的一样有效。
- en: 'Let’s fix this using a *dirty bit*, a piece of state that tells us if some
    complex data structure is up to date. Since we want to know if we need to run
    `render`, let’s call our dirty bit `needs_render`:'
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个*脏位*来解决这个问题，这是一个告诉我们某些复杂数据结构是否最新的状态。由于我们想知道是否需要运行`render`，让我们将我们的脏位命名为`needs_render`：
- en: '[PRE539]'
  id: totrans-2311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: 'One advantage of this flag is that we can now set `needs_render` when the HTML
    has changed instead of calling `render` directly. The `render` will still happen,
    but later. This makes scripts faster, especially if they modify the page multiple
    times. Make this change in `innerHTML_set`, `load`, `click`, and `keypress` when
    changing the DOM. For example, in `load`, do this:'
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标志的一个优点是，现在我们可以在HTML发生变化时设置`needs_render`，而不是直接调用`render`。`render`仍然会发生，但会晚一些。这使得脚本运行更快，尤其是在它们多次修改页面时。在更改DOM时，在`innerHTML_set`、`load`、`click`和`keypress`中做出这个更改。例如，在`load`中，这样做：
- en: '[PRE540]'
  id: totrans-2313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: 'And in `innerHTML_set`, do this:'
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: 在`innerHTML_set`中，这样做：
- en: '[PRE541]'
  id: totrans-2315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: There are more calls to `render`; you should find and fix all of them … except,
    let’s take a closer look at `click`.
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多的`render`调用；你应该找到并修复所有这些调用……除了，让我们更仔细地看看`click`。
- en: 'We now don’t immediately render when something changes. That means that the
    layout tree (and style) could be out of date when a method is called. Normally,
    this isn’t a problem, but in one important case it is: click handling. That’s
    because we need to read the layout tree to figure out what object was clicked
    on, which means the layout tree needs to be up to date. To fix this, add a call
    to `render` at the top of `click`:'
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不会在发生变化时立即渲染。这意味着当调用方法时，布局树（和样式）可能已经过时。通常情况下，这不是问题，但在一个重要的情况下它是：点击处理。这是因为我们需要读取布局树来确定被点击的对象是什么，这意味着布局树需要是最新的。为了解决这个问题，在`click`的顶部添加对`render`的调用：
- en: '[PRE542]'
  id: totrans-2318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: Another problem with our implementation is that the browser is now doing `raster_and_draw`
    every time the active tab runs a task. But sometimes that task is just running
    JavaScript that doesn’t touch the web page, and the `raster_and_draw` call is
    a waste.
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现中的另一个问题是，浏览器现在在活动标签运行任务时每次都会执行`raster_and_draw`。但有时这个任务只是运行不接触网页的JavaScript，而`raster_and_draw`调用是浪费的。
- en: We can avoid this using another dirty bit, which I’ll call `needs_raster_and_draw`:The
    `needs_raster_and_draw` dirty bit doesn’t just make the browser a bit more efficient.
    Later in this chapter, we’ll add multiple browser threads, and at that point this
    dirty bit is necessary to avoid erratic behavior when animating. Try removing
    it later and see for yourself!
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一个脏位来避免这个问题，我将称之为`needs_raster_and_draw`：`needs_raster_and_draw`脏位不仅使浏览器更有效率。在本章的后面，我们将添加多个浏览器线程，到那时这个脏位是必要的，以避免在动画时出现不稳定的行为。尝试稍后移除它，看看效果如何！
- en: '[PRE543]'
  id: totrans-2321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: 'We will need to call `set_needs_raster_and_draw` every time either the `Browser`
    changes something about the browser chrome, or any time the `Tab` changes its
    rendering. The browser chrome is changed by event handlers:'
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`Browser`更改浏览器外观或`Tab`更改其渲染时调用`set_needs_raster_and_draw`。浏览器外观是通过事件处理器更改的：
- en: '[PRE544]'
  id: totrans-2323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: 'Here I need a small change to make `enter` return whether something was done:'
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我需要一个小改动，使`enter`返回是否执行了某些操作：
- en: '[PRE545]'
  id: totrans-2325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: 'And the `Tab` should also set this bit after running `render`:'
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: 并且`Tab`在运行`render`后也应该设置这个位：
- en: '[PRE546]'
  id: totrans-2327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: 'You’ll need to pass in the `browser` parameter when a `Tab` is constructed:'
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
  zh: 当构造`Tab`时，你需要传递`browser`参数：
- en: '[PRE547]'
  id: totrans-2329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: Now the rendering pipeline is only run if necessary, and the browser should
    have acceptable performance again.
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在渲染管线只有在必要时才会运行，浏览器应该再次具有可接受的性能。
- en: This scheduled, task-based approach to rendering is necessary for running complex
    interactive applications, but it still took until the 2010s for all modern browsers
    to adopt it, well after such web applications became widespread. That’s because
    it typically required extensive refactors of vast browser codebases. Chromium,
    for example, [only recently](https://developer.chrome.com/docs/chromium/renderingng)
    finished 100% of the work to leverage this model, though of course work (always)
    remains to be done.
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于任务的渲染方法对于运行复杂的交互式应用是必要的，但直到2010年代，所有现代浏览器才采纳它，这比此类网络应用普及得要晚得多。这是因为通常需要对庞大的浏览器代码库进行大量的重构。例如，Chromium最近才完成了利用此模型100%的工作，尽管当然还有工作要做（总是）。
- en: Animating Frames
  id: totrans-2332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画帧
- en: 'One big reason for a steady rendering cadence is so that animations run smoothly.
    Web pages can set up such animations using the [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)
    API. This API allows scripts to run code right before the browser runs its rendering
    pipeline, making the animation maximally smooth. It works like this:'
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定的渲染节奏的一个重要原因是使动画运行平滑。网页可以使用 `requestAnimationFrame` API（[requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)）来设置此类动画。此API允许脚本在浏览器运行其渲染管道之前运行代码，使动画尽可能平滑。它的工作方式如下：
- en: '[PRE548]'
  id: totrans-2334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: 'By calling `requestAnimationFrame`, this code is doing two things: scheduling
    a rendering task, and asking that the browser call `callback` *at the beginning*
    of that rendering task, before any browser rendering code. This lets web page
    authors change the page and be confident that it will be rendered right away.'
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `requestAnimationFrame`，这段代码正在做两件事：安排一个渲染任务，并要求浏览器在渲染任务的**开始**时调用 `callback`，在所有浏览器渲染代码之前。这允许网页作者更改页面并确信它将立即被渲染。
- en: 'The implementation of this JavaScript API is straightforward. Like before,
    we store the callbacks on the JavaScript side:'
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
  zh: 此JavaScript API的实现很简单。和之前一样，我们在JavaScript端存储回调函数：
- en: '[PRE549]'
  id: totrans-2337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: 'In `JSContext`, when that method is called, we need to schedule a new rendering
    task:'
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `JSContext` 中，当调用该方法时，我们需要安排一个新的渲染任务：
- en: '[PRE550]'
  id: totrans-2339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-2340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: 'Then, when `render` is actually called, we need to call back into JavaScript,
    like this:'
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当 `render` 实际被调用时，我们需要像这样回调到JavaScript：
- en: '[PRE552]'
  id: totrans-2342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: 'This `__runRAFHandlers` function is a little tricky:'
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `__runRAFHandlers` 函数有点棘手：
- en: '[PRE553]'
  id: totrans-2344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: Note that `__runRAFHandlers` needs to reset `RAF_LISTENERS` to the empty array
    before it runs any of the callbacks. That’s because one of the callbacks could
    itself call `requestAnimationFrame`. If this happens during such a callback, the
    specification says that a *second* animation frame should be scheduled. That means
    we need to make sure to store the callbacks for the *current* frame separately
    from the callbacks for the *next* frame.
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`__runRAFHandlers` 在运行任何回调之前需要将 `RAF_LISTENERS` 重置为空数组。这是因为其中一个回调本身可能会调用
    `requestAnimationFrame`。如果这种情况发生在这样的回调中，规范说明应该安排一个**第二个**动画帧。这意味着我们需要确保将当前帧的回调与下一帧的回调分开存储。
- en: 'This situation may seem like a corner case, but it’s actually very important,
    as this is how pages can run an *animation*: by iteratively scheduling one frame
    after another. For example, here’s a simple counter “animation”:'
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可能看起来像是一个边缘情况，但实际上非常重要，因为页面可以通过这种方式运行**动画**：通过迭代地安排一个帧接一个帧。例如，这里有一个简单的计数“动画”：
- en: '[PRE554]'
  id: totrans-2347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: 'This script will cause 100 animation frame tasks to run on the rendering event
    loop. During that time, our browser will display an animated count from 0 to 99\.
    Serve this example web page from our HTTP server:'
  id: totrans-2348
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将在渲染事件循环上运行100个动画帧任务。在这段时间内，我们的浏览器将显示从0到99的动画计数。请从我们的HTTP服务器提供此示例网页：
- en: '[PRE555]'
  id: totrans-2349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: Load this up and observe an animation from 0 to 99.
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
  zh: 打开它并观察从0到99的动画。
- en: One flaw with our implementation so far is that an inattentive coder might call
    `requestAnimationFrame` multiple times and thereby schedule more animation frames
    than expected. If other JavaScript tasks appear later, they might end up delayed
    by many, many frames.
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前实现的一个缺陷是，一个粗心的程序员可能会多次调用 `requestAnimationFrame`，从而安排比预期更多的动画帧。如果之后出现其他JavaScript任务，它们可能会被延迟很多帧。
- en: 'Luckily, rendering is special in that it never makes sense to have two rendering
    tasks in a row, since the page wouldn’t have changed in between. To avoid having
    two rendering tasks we’ll add a dirty bit called `needs_animation_frame` to the
    `Browser` that indicates whether a rendering task actually needs to be scheduled:'
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，渲染是特殊的，因为连续进行两次渲染任务是没有意义的，因为页面在这之间没有发生变化。为了避免有两个渲染任务，我们将在`Browser`中添加一个名为`needs_animation_frame`的脏位，以指示是否需要调度渲染任务：
- en: '[PRE556]'
  id: totrans-2353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: '[PRE557]'
  id: totrans-2354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: 'A tab will set the `needs_animation_frame` flag when an animation frame is
    requested:'
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求动画帧时，标签页会设置`needs_animation_frame`标志：
- en: '[PRE558]'
  id: totrans-2356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: Note that `set_needs_animation_frame` will only actually set the dirty bit if
    called from the active tab. This guarantees that inactive tabs can’t interfere
    with active tabs. Besides preventing scripts from scheduling too many animation
    frames, this system also makes sure that if our browser consistently runs slower
    than 30 frames per second, we won’t end up with an ever-growing queue of rendering
    tasks.
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`set_needs_animation_frame`只有在从活动标签页调用时才会实际设置脏位。这保证了非活动标签页不会干扰活动标签页。除了防止脚本调度过多的动画帧外，这个系统还确保如果我们的浏览器持续运行速度低于每秒30帧，我们不会最终得到一个不断增长的渲染任务队列。
- en: Before the `requestAnimationFrame` API, developers approximated it with `setTimeout`.
    This did run animations at a (roughly) fixed cadence, but because it didn’t line
    up with the browser’s rendering loop, events would sometimes be handled between
    the callback and rendering, which might force an extra, unnecessary rendering
    step. Not only does `requestAnimationFrame` avoid this, but it also lets the browser
    turn off rendering work when a web page tab or window is backgrounded, minimized
    or otherwise throttled, while still allowing other background tasks like saving
    your work to the cloud.
  id: totrans-2358
  prefs: []
  type: TYPE_NORMAL
  zh: 在`requestAnimationFrame` API出现之前，开发者使用`setTimeout`来近似实现。这确实可以在（大致上）固定的节奏下运行动画，但由于它没有与浏览器的渲染循环对齐，事件有时会在回调和渲染之间被处理，这可能会强制进行额外的、不必要的渲染步骤。`requestAnimationFrame`不仅避免了这一点，而且还能让浏览器在网页标签页或窗口处于后台、最小化或以其他方式节流时关闭渲染工作，同时仍然允许其他后台任务，如将您的作品保存到云端。
- en: Profiling Rendering
  id: totrans-2359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染分析
- en: We now have a system for scheduling a rendering task every 33 ms. But what if
    rendering takes longer than 33 ms to finish? Before we answer this question, let’s
    instrument the browser and measure how much time is really being spent rendering.
    It’s important to always measure before optimizing, because the result is often
    surprising.
  id: totrans-2360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个每33毫秒调度一个渲染任务的系统。但如果渲染需要超过33毫秒才能完成怎么办？在我们回答这个问题之前，让我们对浏览器进行测量，看看实际花费在渲染上的时间有多少。在优化之前始终进行测量很重要，因为结果往往令人惊讶。
- en: To instrument our browser, let’s have it output the [JSON](https://www.json.org/)
    tracing format used by [`chrome://tracing` in Chrome](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool/),
    [Firefox Profiler](https://profiler.firefox.com/) or [Perfetto UI](https://ui.perfetto.dev/).Though
    note that these three tools seem to have somewhat different interpretations of
    the JSON format and display the same trace in slightly different ways.
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
  zh: 要对浏览器进行测量，让我们让它输出[JSON](https://www.json.org/)跟踪格式，这是Chrome中的`chrome://tracing`、[Firefox
    Profiler](https://profiler.firefox.com/)或[Perfetto UI](https://ui.perfetto.dev/)使用的。但请注意，这三个工具似乎对JSON格式的解释有所不同，并以略微不同的方式显示相同的跟踪信息。
- en: 'To start, let’s wrap the actual file and format in a class:'
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将实际的文件和格式封装在一个类中：
- en: '[PRE559]'
  id: totrans-2363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: 'A trace file is just a JSON object with a `traceEvents` fieldThere are other
    optional fields too, which provide various kinds of metadata. We won’t need them
    here. which contains a list of trace events:'
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪文件只是一个带有`traceEvents`字段的JSON对象，其中包含一系列跟踪事件：
- en: '[PRE560]'
  id: totrans-2365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: 'Each trace event has a number of fields. The `ph` and `name` fields define
    the event type. For example, setting `ph` to `M` and `name` to `process_name`
    allows us to change the displayed process name:'
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
  zh: 每个跟踪事件都有多个字段。`ph`和`name`字段定义了事件类型。例如，将`ph`设置为`M`并将`name`设置为`process_name`允许我们更改显示的进程名称：
- en: '[PRE561]'
  id: totrans-2367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: The new name (“Browser”) is passed in `args`, and the other fields are required.
    Since our browser only has one process, I just pass `1` for the process ID, and
    the `cat`egory has to be `__metadata` for metadata trace events. The `ts` field
    stores a timestamp; since this is the first event, it’ll set the start time for
    the whole trace, so it’s important to put in the actual current time.
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
  zh: 新的名称（“Browser”）通过`args`传入，其他字段是必需的。由于我们的浏览器只有一个进程，我只为进程 ID 传递`1`，并且`cat`egory字段必须为`__metadata`以存储元数据追踪事件。`ts`字段存储时间戳；由于这是第一个事件，它将为整个追踪设置开始时间，因此输入实际当前时间非常重要。
- en: 'We’ll create this `MeasureTime` object when we start the browser, so we can
    use it to measure how long various browser components take:'
  id: totrans-2369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在启动浏览器时创建这个`MeasureTime`对象，这样我们就可以用它来测量各种浏览器组件的耗时：
- en: '[PRE562]'
  id: totrans-2370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: 'Now let’s add trace events when our browser does something interesting. We
    specifically want `B` and `E` events, which mark the beginning and end of some
    interesting computation. Because we have that initial trace event, every later
    trace event needs to be preceded by a comma:'
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在浏览器执行有趣操作时添加追踪事件。我们特别想要`B`和`E`事件，这些事件标记了一些有趣计算的开始和结束。因为我们有那个初始追踪事件，所以每个后续的追踪事件都需要以逗号开头：
- en: '[PRE563]'
  id: totrans-2372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: 'Here, the `name` argument to `time` should describe what kind of computation
    is starting, and it needs to match the name passed to the corresponding `stop`
    event:'
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`time`函数的`name`参数应该描述开始进行的计算类型，并且它需要与传递给相应`stop`事件的名称匹配：
- en: '[PRE564]'
  id: totrans-2374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: 'We can measure tab rendering by just calling `time` and `stop`:'
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需调用`time`和`stop`就可以测量标签渲染：
- en: '[PRE565]'
  id: totrans-2376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: Do the same for `raster_and_draw`, and for all of the code that calls `evaljs`
    to run JavaScript.
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`raster_and_draw`以及所有调用`evaljs`来运行 JavaScript 的代码，也要做同样的操作。
- en: 'Finally, when we finish tracing (that is, when we close the browser window),
    we want to leave the file a valid JSON file:'
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们完成追踪（即关闭浏览器窗口）时，我们希望留下一个有效的 JSON 文件：
- en: '[PRE566]'
  id: totrans-2379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: By the way, note that I’m careful to `flush` after every write. This makes sure
    that if the browser crashes, all of the log events—which might help me debug—are
    already safely on disk.Some of the tracing tools listed above actually accept
    invalid JSON files, in case the trace comes from a browser crash.
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，我在每次写入后都会小心地执行`flush`操作。这确保了如果浏览器崩溃，所有可能帮助我调试的日志事件都已经安全地存储在磁盘上。上面列出的某些追踪工具实际上可以接受无效的
    JSON 文件，以防追踪来自浏览器崩溃。
- en: Fire up the server, open our timer script, wait for it to finish counting, and
    then exit the browser. Then open up Chrome tracing or one of the other tracing
    tools named above and load the trace. If you don’t want to do it yourself, [here](examples/example12-count-single-threaded.trace)
    is a sample trace file from my computer. You should see something like Figure
    1.
  id: totrans-2381
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器，打开我们的计时脚本，等待它完成计数，然后退出浏览器。然后打开 Chrome 追踪或其他上述追踪工具并加载追踪文件。如果你不想自己操作，[这里](examples/example12-count-single-threaded.trace)是我的电脑上的一个示例追踪文件。你应该会看到类似于图
    1 的内容。
- en: '![Figure 1: Tracing for the timer script in single-threaded mode.](img/6554eb10e87d8eb52c0616cb354973d6.png)'
  id: totrans-2382
  prefs: []
  type: TYPE_IMG
  zh: '![图 1：计时脚本在单线程模式下的追踪](img/6554eb10e87d8eb52c0616cb354973d6.png)'
- en: 'Figure 1: Tracing for the timer script in single-threaded mode.'
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1：计时脚本在单线程模式下的追踪。
- en: In Chrome tracing, you can choose the cursor icon from the toolbar and drag
    a selection around a set of trace events. That will show counts and average times
    for those events in the details window at the bottom of the screen. On my computer,
    my browser spent about 23 ms in `render` and about 62 ms in `raster_and_draw`
    on average, as you can see in the zoomed-in view in Figure 2\. That clearly blows
    through our 33 ms budget. So, what can we do?
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chrome 追踪中，你可以从工具栏中选择光标图标，并将它拖动到一组追踪事件周围。这将在屏幕底部的详细信息窗口中显示这些事件的计数和平均时间。在我的电脑上，我的浏览器在`render`上平均花费了大约
    23 毫秒，在`raster_and_draw`上平均花费了大约 62 毫秒，如图 2 中的放大视图所示。这显然超出了我们的 33 毫秒预算。那么，我们能做什么呢？
- en: '![Figure 2: Tracing for render and raster of one frame of the timer script.](img/8ddd9b48eb52e1d47a85eb3cf9c2fa75.png)'
  id: totrans-2385
  prefs: []
  type: TYPE_IMG
  zh: '![图 2：计时脚本一帧的渲染和光栅化追踪](img/8ddd9b48eb52e1d47a85eb3cf9c2fa75.png)'
- en: 'Figure 2: Tracing for render and raster of one frame of the timer script.'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：计时脚本一帧的渲染和光栅化追踪。
- en: Our browser spends a lot of time copying pixels. That’s why [optimizing surfaces](visual-effects.html#optimizing-surface-use)
    is important! It’ll be faster if you’ve completed Exercise 11-3, because making
    `tab_surface` smaller also helps a lot. Modern browsers go a step further and
    perform raster-and-draw [on the GPU](https://skia.org/docs/user/api/skcanvas_creation/#gpu),
    where a lot more parallelism is available. Even so, on complex pages raster and
    draw really do sometimes take a lot of time. I’ll dig into this more in Chapter
    13.
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器花费大量时间复制像素。这就是为什么[优化表面](visual-effects.html#optimizing-surface-use)很重要的原因！如果你完成了练习11-3，这将更快，因为使`tab_surface`更小也有很大帮助。现代浏览器更进一步，在GPU上执行光栅化和绘制[操作](https://skia.org/docs/user/api/skcanvas_creation/#gpu)，那里有更多的并行性。即便如此，在复杂页面上，光栅化和绘制确实有时会花费很多时间。我将在第13章中更深入地探讨这个问题。
- en: Two Threads
  id: totrans-2388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两个线程
- en: Well, one option, of course, is optimizing raster-and-draw, or even render,
    and we’ll do that in [Chapter 13](animations.html) But another option—complex,
    but worthwhile and done by every major browser—is to do the render step in parallel
    with the raster-and-draw step by adopting a multithreaded architecture. Not only
    would this speed up the rendering pipeline (dropping from 85 ms to 62 ms) but
    we could also execute JavaScript on one thread while the expensive `raster_and_draw`
    task runs on the other.
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，当然一个选择是优化光栅化和绘制，甚至渲染，我们将在[第13章](animations.html)中这样做。但另一个选择——复杂但值得且每个主要浏览器都在做的是——通过采用多线程架构，将渲染步骤与光栅化和绘制步骤并行执行。这不仅会加快渲染管道（从85毫秒降低到62毫秒），我们还可以在一个线程上执行JavaScript，同时在另一个线程上运行昂贵的`raster_and_draw`任务。
- en: Let’s call our two threads the *browser thread*In modern browsers the analogous
    thread is often called the [*compositor thread*](https://chromium.googlesource.com/chromium/src.git/+/refs/heads/main/docs/how_cc_works.md),
    though modern browsers have lots of threads and the correspondence isn’t exact.
    and the *main thread*.Here I’m going with the name real browsers often use. A
    better name might be the “DOM” thread (since JavaScript can sometimes run on [other
    threads](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)). The
    browser thread corresponds to the `Browser` class and will handle raster-and-draw.
    It’ll also handle interactions with the browser chrome. The main thread, on the
    other hand, corresponds to a `Tab` and will handle running scripts, loading resources,
    and rendering, along with associated tasks like running event handlers and callbacks.
    If you’ve got more than one tab open, you’ll have multiple main threads (one per
    tab) but only one browser thread.
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这两个线程称为*浏览器线程*。在现代浏览器中，类似的线程通常被称为[*合成线程*](https://chromium.googlesource.com/chromium/src.git/+/refs/heads/main/docs/how_cc_works.md)，尽管现代浏览器有很多线程，而且这种对应关系并不完全准确。这里我采用真实浏览器常用的名称。更好的名称可能是“DOM”线程（因为JavaScript有时可以在[其他线程](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)上运行）。浏览器线程对应于`Browser`类，将处理光栅化和绘制。它还将处理与浏览器界面的交互。另一方面，主线程对应于一个`Tab`，将处理脚本的执行、资源的加载和渲染，以及相关任务，如运行事件处理程序和回调函数。如果你打开了多个标签页，你将拥有多个主线程（每个标签页一个），但只有一个浏览器线程。
- en: Now, multithreaded architectures are tricky, so let’s do a little planning.
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，多线程架构有些复杂，所以我们来做一点规划。
- en: To start, the one thread that exists already—the one that runs when you start
    the browser—will be the browser thread. We’ll make a main thread every time we
    create a tab. These two threads will need to communicate to handle events and
    draw to the screen.
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，已经存在的一个线程——当你启动浏览器时运行的线程——将是浏览器线程。每次我们创建一个标签页时，我们都会创建一个主线程。这两个线程需要通信来处理事件并在屏幕上绘制。
- en: 'When the browser thread needs to communicate with the main thread, to inform
    it of events, it’ll place tasks on the main thread’s `TaskRunner`.You might be
    wondering why the main thread doesn’t also communicate back to the browser thread
    with a `TaskRunner`. That could certainly be done. Here I chose to only do it
    in one direction, because the main thread is generally the “slowest” thread in
    browsers, due to the unpredictable nature of JavaScript and the unknown size of
    the DOM. The main thread will need to communicate with the browser thread to request
    animation frames and to send it a display list to raster-and-draw, and the main
    thread will do that via two methods on `browser`: `set_needs_animation_frame`
    to request an animation frame and `commit` to send it a display list.'
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器线程需要与主线程通信，以通知它事件时，它会在主线程的 `TaskRunner` 上放置任务。你可能想知道为什么主线程不也使用 `TaskRunner`
    来与浏览器线程通信。这当然是可以做到的。在这里，我选择只在一个方向上这样做，因为主线程通常是浏览器中“最慢”的线程，这是由于JavaScript的不可预测性和DOM未知大小的原因。主线程需要与浏览器线程通信，以请求动画帧并发送显示列表进行光栅化和绘制，主线程将通过
    `browser` 上的两种方法来实现：`set_needs_animation_frame` 用于请求动画帧，`commit` 用于发送显示列表。
- en: 'The overall control flow for rendering a frame will therefore be:'
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，渲染帧的整体控制流程将是：
- en: The code running in the main thread requests an animation frame with `set_needs_animation_frame`,
    perhaps in response to an event handler or due to `requestAnimationFrame`.
  id: totrans-2395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主线程中运行的代码使用 `set_needs_animation_frame` 请求动画帧，可能是响应事件处理程序或由于 `requestAnimationFrame`。
- en: The browser thread event loop schedules an animation frame on the main thread
    `TaskRunner`.
  id: totrans-2396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器线程的事件循环在主线程的 `TaskRunner` 上安排一个动画帧。
- en: The main thread executes its part of rendering, then calls `browser.commit`.
  id: totrans-2397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主线程执行其渲染部分，然后调用 `browser.commit`。
- en: The browser thread rasters the display list and draws to the screen.
  id: totrans-2398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器线程将显示列表光栅化并在屏幕上绘制。
- en: Let’s implement this design. To start, we’ll add a `Thread` to each `TaskRunner`,
    which will be the tab’s main thread. This thread will need to run in a loop, pulling
    tasks from the task queue and running them. We’ll put that loop inside the `TaskRunner`’s
    `run` method.
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这个设计。首先，我们将在每个 `TaskRunner` 中添加一个 `Thread`，这将作为标签页的主线程。这个线程需要在一个循环中运行，从任务队列中拉取任务并执行它们。我们将这个循环放在
    `TaskRunner` 的 `run` 方法中。
- en: '[PRE567]'
  id: totrans-2400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: 'Note that I name the thread; this is a good habit that helps with debugging.
    Let’s also name the browser thread:'
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我命名了这个线程；这是一个良好的习惯，有助于调试。让我们也给浏览器线程命名：
- en: '[PRE568]'
  id: totrans-2402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: 'Remove the call to `run` from the top-level `while True` loop, since that loop
    is now going to be running in the browser thread. And `run` will have its own
    loop:'
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶层 `while True` 循环中移除对 `run` 的调用，因为这个循环现在将在浏览器线程中运行。并且 `run` 将有自己的循环：
- en: '[PRE569]'
  id: totrans-2404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: 'Because this loop runs forever, the main thread will live on indefinitely.
    So if the browser quits, we’ll want it to ask the main thread to quit as well:'
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个循环会永远运行，所以主线程将无限期地存在。所以如果浏览器退出，我们希望它也要求主线程退出：
- en: '[PRE570]'
  id: totrans-2406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: 'The `set_needs_quit` method sets a flag on `TaskRunner` that’s checked every
    time it loops:'
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_needs_quit` 方法在 `TaskRunner` 上设置一个标志，每次循环时都会检查：'
- en: '[PRE571]'
  id: totrans-2408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: 'The `Browser` should no longer call any methods on the `Tab`. Instead, to handle
    events, it should schedule tasks on the main thread. For example, here is loading:'
  id: totrans-2409
  prefs: []
  type: TYPE_NORMAL
  zh: '`Browser` 应该不再调用 `Tab` 上的任何方法。相反，为了处理事件，它应该在主线程上安排任务。例如，这里是加载：'
- en: '[PRE572]'
  id: totrans-2410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: 'We need to clear any pending tasks before loading a new page, because those
    previous tasks are now invalid:'
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载新页面之前，我们需要清除任何挂起的任务，因为那些之前的任务现在已无效：
- en: '[PRE573]'
  id: totrans-2412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: 'We also need to split `new_tab` into a version that acquires a lock and one
    that doesn’t (`new_tab_internal`):'
  id: totrans-2413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将 `new_tab` 分割成获取锁和不获取锁的版本（`new_tab_internal`）：
- en: '[PRE574]'
  id: totrans-2414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: This way `new_tab_internal` can be called directly by methods, like `Chrome`’s
    `click` method, that already hold the lock.Using locks while avoiding race conditions
    and deadlocks can be quite difficult!
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`new_tab_internal` 可以直接由像 `Chrome` 的 `click` 方法这样的方法调用，这些方法已经持有锁。在使用锁的同时避免竞争条件和死锁可能相当困难！
- en: '[PRE575]'
  id: totrans-2416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: 'Event handlers are mostly similar, except that we need to be careful to distinguish
    events that affect the browser chrome from those that affect the tab. For example,
    consider `handle_click`. If the user clicked on the browser chrome, we can handle
    it right there in the browser thread. But if the user clicked on the web page,
    we must schedule a task on the main thread:'
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序大多相似，但我们需要小心地区分影响浏览器外观的事件和影响标签页的事件。例如，考虑`handle_click`。如果用户点击了浏览器外观，我们可以在浏览器线程中直接处理它。但如果用户点击了网页，我们必须在主线程上安排一个任务：
- en: '[PRE576]'
  id: totrans-2418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: 'The same logic holds for `keypress`:'
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`keypress`同样适用：
- en: '[PRE577]'
  id: totrans-2420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: Do the same with any other calls from the `Browser` to the `Tab`.
  id: totrans-2421
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Browser`对`Tab`的任何其他调用都做同样处理。
- en: So now we have the browser thread telling the main thread what to do. Communication
    in the other direction is a little subtler.
  id: totrans-2422
  prefs: []
  type: TYPE_NORMAL
  zh: 因此现在浏览器线程告诉主线程要做什么。其他方向的通信稍微复杂一些。
- en: Originally, threads were a mechanism for improving *responsiveness* via pre-emptive
    multitasking, but these days they also allow browsers to increase *throughput*
    because even phones have several cores. But different CPU architectures differ,
    and browser engineers (like you!) have to use more or less hardware parallelism
    as appropriate to the situation. For example, some devices have more [CPU cores](https://en.wikipedia.org/wiki/Multi-core_processor)
    than others, or are more sensitive to battery power usage, or their system processes
    such as listening to the wireless radio may limit the actual parallelism available
    to the browser.
  id: totrans-2423
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，线程是通过抢占式多任务来提高响应性的机制，但如今它们也允许浏览器增加吞吐量，因为即使是手机也有多个核心。但是不同的CPU架构不同，浏览器工程师（就像你一样！）必须根据情况适当使用更多或更少的硬件并行性。例如，一些设备比其他设备拥有更多的[CPU核心](https://en.wikipedia.org/wiki/Multi-core_processor)，或者对电池电力使用更敏感，或者它们的系统进程，如监听无线无线电，可能会限制浏览器实际可用的并行性。
- en: Committing a Display List
  id: totrans-2424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交显示列表
- en: We already have a `set_needs_animation_frame` method, but we also need a `commit`
    method that a `Tab` can call when it’s finished creating a display list. And if
    you look carefully at our raster-and-draw code, you’ll see that to draw a display
    list we also need to know the URL (to update the browser chrome), the document
    height (to allocate a surface of the right size), and the scroll position (to
    draw the right part of the surface).
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了`set_needs_animation_frame`方法，但我们还需要一个`commit`方法，当`Tab`完成创建显示列表后可以调用它。如果你仔细查看我们的光栅化和绘制代码，你会看到为了绘制显示列表，我们还需要知道URL（以更新浏览器外观）、文档高度（以分配正确大小的表面）和滚动位置（以绘制表面的正确部分）。
- en: 'Let’s make a simple class for storing this data:'
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的类来存储这些数据：
- en: '[PRE578]'
  id: totrans-2427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: When running an animation frame, the `Tab` should construct one of these objects
    and pass it to `commit`. To keep `render` from getting too confusing, let’s put
    this in a new `run_animation_frame` method, and move `__runRAFHandlers` there
    too.Why not reuse `render` instead of a new method? Because the `render` method
    is just about updating style, layout and paint when needed; it’s called for every
    frame, but it’s also called from `click`, and in real browsers from many other
    places too. Meanwhile, `run_animation_frame` is only called for frames, and therefore
    it, not `render`, runs RAF handlers and calls `commit`.
  id: totrans-2428
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行动画帧时，`Tab`应该构建这些对象之一并将其传递给`commit`。为了防止`render`变得过于复杂，让我们将其放入一个新的`run_animation_frame`方法中，并将`__runRAFHandlers`也移到那里。为什么不重用`render`而使用新方法呢？因为`render`方法只是在需要时更新样式、布局和绘制；它对每一帧都会被调用，但它也来自`click`，在真实浏览器中来自许多其他地方。同时，`run_animation_frame`只对帧进行调用，因此它，而不是`render`，运行RAF处理程序并调用`commit`。
- en: '[PRE579]'
  id: totrans-2429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: 'Think of the `CommitData` object as being sent from the main thread to the
    browser thread. That means the main thread shouldn’t access it any more, and for
    this reason I’m resetting the `display_list` field. The `Browser` should now schedule
    `run_animation_frame`:'
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
  zh: 将`CommitData`对象视为从主线程发送到浏览器线程。这意味着主线程不再访问它，因此我重置了`display_list`字段。现在`Browser`应该安排`run_animation_frame`：
- en: '[PRE580]'
  id: totrans-2431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: 'On the `Browser` side, the new `commit` method needs to read out all of the
    data it was sent and call `set_needs_raster_and_draw` as needed. Because this
    call will come from another thread, we’ll need to acquire a lock. Another important
    step is to not clear the `animation_timer` object until *after* the next commit
    occurs. Otherwise multiple rendering tasks could be queued at the same time. Finally,
    store all the `CommitData`: save the `scroll` in `active_tab_scroll`, the `url`
    in `active_tab_url`, and additionally store the `height` and, if available, the
    `display_list`:'
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Browser` 端，新的 `commit` 方法需要读取发送的所有数据，并根据需要调用 `set_needs_raster_and_draw`。由于这个调用将来自另一个线程，我们需要获取一个锁。另一个重要的步骤是在下一个提交发生之后才清除
    `animation_timer` 对象。否则，可能会同时排队多个渲染任务。最后，存储所有的 `CommitData`：将 `scroll` 存储在 `active_tab_scroll`
    中，将 `url` 存储在 `active_tab_url` 中，并且另外存储 `height` 和（如果可用）`display_list`：
- en: '[PRE581]'
  id: totrans-2433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: Make sure to update the `Chrome` class to use this new `url` field, since we
    don’t want the chrome, running on the browser thread, to read from the tab, running
    on the main thread.
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
  zh: 确保更新 `Chrome` 类以使用这个新的 `url` 字段，因为我们不希望运行在浏览器线程上的 chrome 从运行在主线程上的标签页中读取。
- en: Note that `commit` is called on the main thread, but acquires the browser thread
    lock. As a result, `commit` is a critical time when both threads are “stopped”
    simultaneously.For this reason commit needs to be as fast as possible, to maximize
    parallelism and responsiveness. In modern browsers, optimizing commit is quite
    challenging, because their method of caching and sending data between threads
    is much more sophisticated. Also note that it’s possible for the browser thread
    to get a `commit` from an inactive tab,That’s because even inactive tabs might
    be processing one last animation frame. so the `tab` parameter is compared with
    the active tab before copying over any committed data.
  id: totrans-2435
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`commit` 是在主线程上调用的，但会获取浏览器线程锁。因此，`commit` 是一个两个线程同时“停止”的关键时刻。因此，`commit`
    需要尽可能快，以最大化并行性和响应性。在现代浏览器中，优化 `commit` 是一项相当具有挑战性的任务，因为它们在线程之间缓存和发送数据的方法要复杂得多。此外，浏览器线程也可能从非活动标签页接收到
    `commit`，这是因为即使非活动标签页也可能正在处理最后一个动画帧。因此，在复制任何提交的数据之前，需要将 `tab` 参数与活动标签页进行比较。
- en: 'Now that we have a browser lock, we also need to acquire the lock any time
    the browser thread accesses any of its variables. For example, in `set_needs_animation_frame`,
    do this:'
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了浏览器锁，每次浏览器线程访问其任何变量时，我们都需要获取该锁。例如，在 `set_needs_animation_frame` 中，执行以下操作：
- en: '[PRE582]'
  id: totrans-2437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: 'In `schedule_animation_frame` you’ll need to do it both inside and outside
    the callback:'
  id: totrans-2438
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `schedule_animation_frame` 中，你需要在回调内部和外部都执行此操作：
- en: '[PRE583]'
  id: totrans-2439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: Add locks to `raster_and_draw`, `handle_down`, `handle_click`, `handle_key`,
    and `handle_enter` as well.
  id: totrans-2440
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `raster_and_draw`、`handle_down`、`handle_click`、`handle_key` 和 `handle_enter`
    添加锁。
- en: 'We also don’t want the main thread doing rendering faster than the browser
    thread can raster and draw. So we should only schedule animation frames once raster
    and draw are done.The technique of controlling the speed of the front of a pipeline
    by means of the speed of its end is called *back pressure*. Luckily, that’s exactly
    what we’re doing:'
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不希望主线程的渲染速度超过浏览器线程的栅格化和绘制速度。因此，我们只能在栅格化和绘制完成后安排动画帧。通过控制管道末端的速率来控制管道前端速率的技术称为
    *背压*。幸运的是，这正是我们正在做的事情：
- en: '[PRE584]'
  id: totrans-2442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: 'And that’s it: we should now be doing render on one thread and raster and draw
    on another!'
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：我们现在应该在一条线程上执行渲染，在另一条线程上执行栅格化和绘制！
- en: Due to the Python GIL, threading in Python doesn’t increase *throughput*, but
    it can increase *responsiveness* by, say, running JavaScript tasks on the main
    thread while the browser does raster and draw. It’s also possible to turn off
    the global interpreter lock while running foreign C/C++ code linked into a Python
    library; Skia is thread-safe, but DukPy and SDL may not be, and don’t seem to
    release the GIL. If they did, then JavaScript or raster-and-draw truly could run
    in parallel with the rest of the browser, and performance would improve as well.
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python GIL 的存在，Python 中的多线程并不会增加 *吞吐量*，但可以通过在浏览器执行栅格化和绘制任务的同时在主线程上运行 JavaScript
    任务等方式，提高 *响应性*。在运行链接到 Python 库的外部 C/C++ 代码时，也可以关闭全局解释器锁；Skia 是线程安全的，但 DukPy 和
    SDL 可能不是，并且似乎没有释放 GIL。如果它们释放了 GIL，那么 JavaScript 或栅格化和绘制任务就可以与浏览器中的其他部分并行运行，性能也会得到提升。
- en: Threaded Profiling
  id: totrans-2445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程化分析
- en: 'Now that we have two threads, we’ll want to be able to visualize this in the
    traces we produce. Luckily, the Chrome tracing format supports that. First of
    all, we’ll want to make the `MeasureTime` methods thread-safe, so they can be
    called from either thread:'
  id: totrans-2446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个线程，我们希望能够在生成的跟踪中可视化这一点。幸运的是，Chrome跟踪格式支持这一点。首先，我们希望使`MeasureTime`方法线程安全，这样它们就可以从任何线程中调用：
- en: '[PRE585]'
  id: totrans-2447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: 'Next, in every trace event, we’ll want to provide a real thread ID in the `tid`
    field, which we can get by calling `get_ident` from the `threading` library:'
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在每一个跟踪事件中，我们希望在`tid`字段中提供一个真实的线程ID，我们可以通过从`threading`库中调用`get_ident`来获取：
- en: '[PRE586]'
  id: totrans-2449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: Do the same thing in `stop`. We can also show human-readable thread names by
    adding metadata events when finishing the trace:Note that our browser doesn’t
    let you close tabs, so any thread stays around until the trace is `finish`ed. If
    closing tabs were possible, we’d need to do thread names somewhat differently.
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
  zh: 在`stop`中也做同样的事情。我们也可以在完成跟踪时添加元数据事件来显示可读的线程名称：请注意，我们的浏览器不允许你关闭标签页，所以任何线程都会在跟踪`finish`后仍然存在。如果可以关闭标签页，我们可能需要对线程名称进行一些不同的处理。
- en: '[PRE587]'
  id: totrans-2451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: 'Now, if you make a new trace from the counting animation and load it into one
    of the tracing tools, you should see something like Figure 3 ( click [here](examples/example12-count-two-threads.trace)
    to download an example trace):'
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你从计数动画中创建一个新的跟踪并将其加载到跟踪工具中，你应该会看到类似于图3的内容（点击[这里](examples/example12-count-two-threads.trace)下载示例跟踪）：
- en: '![Figure 3: Tracing for the timer script in two-threads mode.](img/65099e6e695b1123fba72dd5ebe9daf8.png)'
  id: totrans-2453
  prefs: []
  type: TYPE_IMG
  zh: '![图3：在双线程模式下对计时器脚本的跟踪。](img/65099e6e695b1123fba72dd5ebe9daf8.png)'
- en: 'Figure 3: Tracing for the timer script in two-threads mode.'
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：在双线程模式下对计时器脚本的跟踪。
- en: You can see how the render and raster tasks now happen on different threads,
    and how our multithreaded architecture allows them to happen concurrently.However,
    in this case the two threads are *not* running tasks concurrently. That’s because
    all of the JavaScript tasks are `requestAnimationFrame` callbacks, which are scheduled
    by the browser thread, and those are only kicked off once the browser thread finishes
    its raster and draw work. Execise 12-8 addresses that problem.
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到渲染和光栅化任务现在在不同的线程上发生，以及我们的多线程架构如何允许它们并发执行。然而，在这种情况下，这两个线程并不是并发运行任务的。这是因为所有的JavaScript任务都是`requestAnimationFrame`回调，这些回调由浏览器线程调度，并且只有在浏览器线程完成光栅化和绘制工作后才会启动。练习12-8解决了这个问题。
- en: The tracing system we introduced in this chapter comes directly from real browsers.
    And it’s used every day by browser engineers to understand the performance characteristics
    of the browser in different situations, find bottlenecks, and fix them. Without
    these tools, browsers would not have been able to make many of the performance
    leaps they did in recent years. Good debugging tools are essential to software
    engineering!
  id: totrans-2456
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中引入的跟踪系统直接来自真实浏览器。浏览器工程师每天都会使用它来了解浏览器在不同情况下的性能特征，找到瓶颈并修复它们。没有这些工具，浏览器就不可能实现近年来在性能上的许多飞跃。良好的调试工具对于软件工程至关重要！
- en: Threaded Scrolling
  id: totrans-2457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程化滚动
- en: 'Splitting the main thread from the browser thread means that the main thread
    can run a lot of JavaScript without slowing down the browser much. But it’s still
    possible for really slow JavaScript to slow the browser down. For example, imagine
    our counter adds the following artificial slowdown:'
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
  zh: 将主线程从浏览器线程中分离出来意味着主线程可以运行大量的JavaScript而不会显著减慢浏览器的速度。但是，确实存在一些非常慢的JavaScript可能会减慢浏览器速度的情况。例如，想象我们的计数器添加以下人工的减速：
- en: '[PRE588]'
  id: totrans-2459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: Now, every tick of the counter has an artificial pause during which the main
    thread is stuck running JavaScript. This means it can’t respond to any events;
    for example, if you hold down the down key, the scrolling will be janky and annoying.
    I encourage you to try this and witness how annoying it is, because modern browsers
    usually don’t have this kind of jank.Adjust the loop bound to make it pause for
    about a second or so on your computer.
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，计数器的每个滴答都会有一个人工的暂停，此时主线程会卡在运行JavaScript。这意味着它无法响应用户事件；例如，如果你按住向下键，滚动将会变得不流畅且令人烦恼。我鼓励你尝试一下，看看它是多么令人烦恼，因为现代浏览器通常不会有这种不流畅的情况。调整循环边界，使其在电脑上暂停大约一秒钟左右。
- en: To fix this, we need the browser thread to handle scrolling, not the main thread.
    This is harder than it might seem, because the scroll offset can be affected by
    both the browser (when the user scrolls) and the main thread (when loading a new
    page or changing the height of the document via JavaScript). Now that the browser
    thread and the main thread run in parallel, they can disagree about the scroll
    offset.
  id: totrans-2461
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要浏览器线程来处理滚动，而不是主线程。这比看起来要困难，因为滚动偏移量可能受到浏览器（当用户滚动时）和主线程（当加载新页面或通过JavaScript更改文档高度时）的影响。现在浏览器线程和主线程是并行运行的，它们可能会对滚动偏移量产生不同的看法。
- en: The best we can do is to keep two scroll offsets, one on the browser thread
    and one on the main thread. Importantly, the browser thread’s scroll offset refers
    to the browser’s copy of the display list, while the main thread’s scroll offset
    refers to the main thread’s display list, which can be slightly different. We’ll
    have the browser thread send scroll offsets to the main thread when it renders,
    but then the main thread will have to be able to *override* that scroll offset
    if the new frame requires it.
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做的最好的事情是保留两个滚动偏移量，一个在浏览器线程上，一个在主线程上。重要的是，浏览器线程的滚动偏移量指的是浏览器显示列表的副本，而主线程的滚动偏移量指的是主线程的显示列表，它们可能略有不同。当浏览器线程渲染时，我们将滚动偏移量发送到主线程，但此时主线程必须能够*覆盖*该滚动偏移量，如果新帧需要的话。
- en: 'Let’s implement that. To start, we’ll need to store an `active_tab_scroll`
    variable on the `Browser`, and update it when the user scrolls:'
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来实现它。首先，我们需要在`Browser`上存储一个`active_tab_scroll`变量，并在用户滚动时更新它：
- en: '[PRE589]'
  id: totrans-2464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: This code calls `set_needs_raster_and_draw` to redraw the screen with a new
    scroll offset, and also sets `needs_animation_frame` to cause the main thread
    to receive the scroll offset asynchronously in the future. Even though the browser
    thread has already handled scrolling, it’s still important to synchronize the
    new value back to the main thread soon because APIs like click handling depend
    on it.
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码调用`set_needs_raster_and_draw`来使用新的滚动偏移量重新绘制屏幕，并且还将`needs_animation_frame`设置为使主线程异步接收滚动偏移量。尽管浏览器线程已经处理了滚动，但仍然很重要，需要尽快将新值同步回主线程，因为像点击处理这样的API依赖于它。
- en: The scroll offset also needs to change when the user switches tabs, but in this
    case we don’t know the right scroll offset yet. We need the main thread to run
    in order to commit a new display list for the other tab, and at that point we
    will have a new scroll offset as well. Move tab switching (in `load` and `handle_click`)
    to a new method `set_active_tab` that simply schedules a new animation frame:Note
    that both callers already hold the lock, so this method doesn’t need to acquire
    it.
  id: totrans-2466
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户切换标签时，滚动偏移量也需要改变，但在这个情况下，我们还不知道正确的滚动偏移量。我们需要主线程运行，以便为其他标签提交新的显示列表，那时我们也将有一个新的滚动偏移量。将标签切换（在`load`和`handle_click`中）移动到新的方法`set_active_tab`，该方法仅安排一个新的动画帧：请注意，调用者已经持有锁，因此此方法不需要获取锁。
- en: '[PRE590]'
  id: totrans-2467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: 'So far, this is only updating the scroll offset on the browser thread. But
    the main thread eventually needs to know about the scroll offset, so it can pass
    it back to `commit`. So, when the `Browser` creates a rendering task for `run_animation_frame`,
    it should pass in the scroll offset. The `run_animation_frame` function can then
    store the scroll offset before doing anything else. Add a `scroll` parameter to
    `run_animation_frame`:'
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这只是在浏览器线程上更新滚动偏移量。但最终主线程需要知道滚动偏移量，以便将其传递回`commit`。因此，当`Browser`为`run_animation_frame`创建渲染任务时，它应该传递滚动偏移量。然后`run_animation_frame`函数可以在做其他任何事情之前存储滚动偏移量。向`run_animation_frame`添加一个`scroll`参数：
- en: '[PRE591]'
  id: totrans-2469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: But the main thread also needs to be able to modify the scroll offset. We’ll
    add a `scroll_changed_in_tab` flag that tracks whether it’s done so, and only
    store the browser thread’s scroll offset if `scroll_changed_in_tab` is not already
    true.Two-threaded scroll has a lot of edge cases, including some I didn’t anticipate
    when writing this chapter. For example, it’s pretty clear that a load should force
    scroll to 0 (unless the browser implements [scroll restoration](https://developer.mozilla.org/en-US/docs/Web/API/History/scrollRestoration)
    for back-navigations!), but what about a scroll clamp followed by a browser scroll
    that brings it back to within the clamped region? By splitting the browser into
    two threads, we’ve brought in all of the challenges of concurrency and distributed
    state.
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
  zh: 但主线程也需要能够修改滚动偏移量。我们将添加一个`scroll_changed_in_tab`标志来跟踪它是否已经这样做，并且只有当`scroll_changed_in_tab`不是`true`时才存储浏览器线程的滚动偏移量。双线程滚动有很多边缘情况，包括我在编写本章时没有预料到的一些情况。例如，很明显，加载应该将滚动强制设置为0（除非浏览器实现了[滚动恢复](https://developer.mozilla.org/en-US/docs/Web/API/History/scrollRestoration)以支持回退导航！），但随后浏览器滚动将其带回到夹紧区域内的滚动夹具又该如何处理呢？通过将浏览器分成两个线程，我们引入了并发和分布式状态的所有挑战。
- en: '[PRE592]'
  id: totrans-2471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: 'We’ll set `scroll_changed_in_tab` when loading a new page or when the browser
    thread’s scroll offset is past the bottom of the page:'
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载新页面或浏览器线程的滚动偏移量超过页面底部时，我们将设置`scroll_changed_in_tab`：
- en: '[PRE593]'
  id: totrans-2473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: 'If the main thread *hasn’t* overridden the browser’s scroll offset, we’ll set
    the scroll offset to `None` in the commit data:'
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主线程**没有**覆盖浏览器的滚动偏移量，我们将在提交数据中将滚动偏移量设置为`None`：
- en: '[PRE594]'
  id: totrans-2475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: 'The browser thread can ignore the scroll offset in this case:'
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，浏览器线程可以忽略滚动偏移量：
- en: '[PRE595]'
  id: totrans-2477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: That’s it! If you try the counting demo now, you’ll be able to scroll even during
    the artificial pauses. [Here](examples/example12-count-with-scroll.trace) is a
    trace that shows threaded scrolling at work (notice how raster and draw now sometimes
    happen at the same time as main-thread work), and it’s visualized in Figure 4.
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部了！如果你现在尝试计数演示，你将能够在人工暂停期间滚动。[这里](examples/example12-count-with-scroll.trace)是一个显示线程滚动工作的跟踪记录（注意现在光栅和绘制有时会与主线程工作同时发生），并在图4中进行了可视化。
- en: '![Figure 4: Trace output of threaded scrolling on the counting demo.](img/0c2ec47ae01a3968dfc520a97b17057c.png)'
  id: totrans-2479
  prefs: []
  type: TYPE_IMG
  zh: '![图4：计数演示中线程滚动的跟踪输出。](img/0c2ec47ae01a3968dfc520a97b17057c.png)'
- en: 'Figure 4: Trace output of threaded scrolling on the counting demo.'
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：计数演示中线程滚动的跟踪输出。
- en: As you’ve seen, moving tasks to the browser thread can be challenging, but can
    also lead to a much more responsive browser. These same trade-offs are present
    in real browsers, at a much greater level of complexity.
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，将任务移动到浏览器线程可能会很具挑战性，但也可以使浏览器变得更加响应。这些相同的权衡在真实浏览器中也存在，但复杂程度要高得多。
- en: 'Scrolling in real browsers goes *way* beyond what we’ve implemented here. For
    example, in a real browser JavaScript can listen to a [`scroll`](https://developer.mozilla.org/en-US/docs/Web/API/Document/scroll_event)
    event and call `preventDefault` to cancel scrolling. And some rendering features
    like [`background-attachment: fixed`](https://developer.mozilla.org/en-US/docs/Web/CSS/background-attachment)
    are hard to implement on the browser thread.Our browser doesn’t support any of
    these features, so it doesn’t run into these difficulties. That’s also a strategy.
    For example, until 2020, Chromium-based browsers on Android did not support `background-attachment:
    fixed`. For this reason, most real browsers implement both threaded and non-threaded
    scrolling, and fall back to non-threaded scrolling when these advanced features
    are used.Actually, a real browser only falls back to non-threaded scrolling when
    necessary. For example, it might disable threaded scrolling only if a `scroll`
    event listener calls `preventDefault`. Concerns like this also drive [new JavaScript
    APIs](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#passive).'
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
  zh: '在真实浏览器中的滚动功能远超我们在这里实现的。例如，在真实浏览器中，JavaScript可以监听一个[`scroll`](https://developer.mozilla.org/en-US/docs/Web/API/Document/scroll_event)事件，并调用`preventDefault`来取消滚动。还有一些渲染特性，如[`background-attachment:
    fixed`](https://developer.mozilla.org/en-US/docs/Web/CSS/background-attachment)，在浏览器线程上难以实现。我们的浏览器不支持这些功能，因此不会遇到这些困难。这也是一种策略。例如，直到2020年，基于Chromium的Android浏览器不支持`background-attachment:
    fixed`。因此，大多数真实浏览器都实现了并行和非并行滚动，并在使用这些高级功能时回退到非并行滚动。实际上，真实浏览器只有在必要时才会回退到非并行滚动。例如，它可能会禁用并行滚动，如果`scroll`事件监听器调用了`preventDefault`。这样的担忧也推动了[新的JavaScript
    API](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#passive)的发展。'
- en: Threaded Style and Layout
  id: totrans-2483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行处理样式和布局
- en: Now that we have separate browser and main threads, and now that some operations
    are performed on the browser thread, our browser’s thread architecture has started
    to resemble that of a real browser.Note that many browsers now run some parts
    of the browser thread and main thread in different processes, which has advantages
    for security and error handling. But why not move even more browser components
    into even more threads? Wouldn’t that make the browser even faster?
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了独立的浏览器线程和主线程，并且一些操作是在浏览器线程上执行的，我们的浏览器线程架构已经开始类似于真实浏览器的架构。请注意，许多浏览器现在将浏览器线程和主线程的部分运行在不同的进程中，这对安全和错误处理有优势。但为什么不能将更多的浏览器组件移动到更多的线程中呢？这不会使浏览器运行得更快吗？
- en: In a word, yes. Modern browsers have [dozens of threads](https://developer.chrome.com/blog/renderingng-architecture/#process-and-thread-structure),
    which together serve to make the browser even faster and more responsive. For
    example, raster-and-draw often runs on its own thread so that the browser thread
    can handle events even while a new frame is being prepared. Likewise, modern browsers
    typically have a collection of network or input/output (I/O) threads, which move
    all interaction with the network or the file system off the main thread.
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，是的。现代浏览器拥有[数十个线程](https://developer.chrome.com/blog/renderingng-architecture/#process-and-thread-structure)，这些线程共同作用，使得浏览器运行更快、响应更灵敏。例如，光栅化和绘制通常在自己的线程上运行，这样浏览器线程就可以在准备新帧的同时处理事件。同样，现代浏览器通常有一组网络或输入/输出（I/O）线程，这些线程将所有与网络或文件系统的交互都从主线程上移开。
- en: 'On the other hand, some parts of the browser can’t be easily threaded. For
    example, consider the earlier part of the rendering pipeline: style, layout and
    paint. In our browser, these run on the main thread. But could they move to their
    own thread?'
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，浏览器的一些部分并不能轻易地并行处理。例如，考虑渲染管道的早期部分：样式、布局和绘制。在我们的浏览器中，这些操作都在主线程上运行。但它们能否移动到自己的线程上呢？
- en: In principle, yes. The only thing browsers *have* to do is implement all the
    web API specifications correctly, and draw to the screen after scripts and `requestAnimationFrame`
    callbacks have completed. The specification spells this out in detail in what
    it calls the “[update-the-rendering](https://html.spec.whatwg.org/multipage/webappapis.html#update-the-rendering)”
    steps. These steps don’t mention style or layout at all—because style and layout,
    just like paint and draw, are implementation details of a browser. The specification’s
    update-the-rendering steps are the *JavaScript-observable* things that have to
    happen before drawing to the screen.
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
  zh: 从原则上讲，是的。浏览器*必须*做到的是正确实现所有网络 API 规范，并在脚本和 `requestAnimationFrame` 回调完成后将内容绘制到屏幕上。规范在它所称为的“[更新渲染](https://html.spec.whatwg.org/multipage/webappapis.html#update-the-rendering)”步骤中详细说明了这一点。这些步骤根本不提样式或布局——因为样式和布局，就像绘制一样，是浏览器的实现细节。规范的更新渲染步骤是在绘制到屏幕之前必须发生的*JavaScript
    可观察*的事情。
- en: 'Nevertheless, in practice, no current modern browser runs style or layout on
    any thread but the main one.Some browsers do use multiple threads *within* style
    and layout; the [Servo](https://en.wikipedia.org/wiki/Servo_(software)) research
    browser was the pioneer here, attempting a fully parallel style, layout, and paint
    phase. Some of Servo’s code is now part of Firefox. Still, even if style or another
    phase uses threads internally, those steps still don’t happen concurrently with,
    say, JavaScript execution. The reason is simple: there are many JavaScript APIs
    that can query style or layout state. For example, [`getComputedStyle`](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
    requires first computing style, and [`getBoundingClientRect`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)
    requires first doing layout.There is no JavaScript API that allows reading back
    state from anything later in the rendering pipeline than layout, which is what
    made it possible to move the back half of the pipeline to another thread. If a
    web page calls one of these APIs, and style or layout is not up to date, then
    it has to be computed then and there. These computations are called *forced style*
    or *forced layout*: style or layout are “forced” to happen right away, as opposed
    to possibly 33 ms in the future, if they’re not already computed. Because of these
    forced style and layout situations, browsers have to be able to compute style
    and layout on the main thread.Or the main thread could force the browser thread
    to do that work, but that’s even worse, because forcing work on the compositor
    thread will make scrolling janky unless you do even more work to avoid that somehow.'
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在实际操作中，没有任何现代浏览器在除了主线程之外的任何线程上运行样式或布局。一些浏览器确实在样式和布局内部使用多个线程；[Servo](https://en.wikipedia.org/wiki/Servo_(software))
    研究浏览器在这方面是先驱，试图实现完全并行的样式、布局和绘制阶段。Servo 的一些代码现在已成为 Firefox 的一部分。然而，即使样式或另一个阶段在内部使用线程，这些步骤仍然不会与
    JavaScript 执行等操作并发进行。原因很简单：存在许多可以查询样式或布局状态的 JavaScript API。例如，`getComputedStyle`（[getComputedStyle](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)）需要首先计算样式，而
    `getBoundingClientRect`（[getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)）需要首先进行布局。没有
    JavaScript API 允许从渲染管道中布局之后的任何地方读取状态，这就是为什么可以将管道的后半部分移动到另一个线程的原因。如果一个网页调用这些 API
    之一，并且样式或布局尚未更新，那么就必须立即在那里进行计算。这些计算被称为“强制样式”或“强制布局”：样式或布局“强制”立即发生，而不是在未来可能延迟 33
    毫秒，如果它们尚未计算的话。由于这些强制样式和布局情况，浏览器必须能够在主线程上计算样式和布局。或者，主线程可以强制浏览器线程执行这项工作，但这甚至更糟糕，因为如果强制在合成器线程上工作，除非你做更多工作来避免这种情况，否则滚动将会变得不流畅。
- en: 'One possible way to resolve these tensions is to optimistically move style
    and layout off the main thread, similar to optimistically doing threaded scrolling
    if a web page doesn’t `preventDefault` a scroll. Is that a good idea? Maybe, but
    forced style and layout aren’t just caused by JavaScript execution. One example
    is our implementation of `click`, which causes a forced render before hit testing:'
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些紧张关系的一种可能方法是将样式和布局乐观地移出主线程，类似于在网页没有 `preventDefault` 滚动时乐观地进行线程化滚动。这是一个好主意吗？也许吧，但强制样式和布局不仅仅是由
    JavaScript 执行引起的。一个例子是我们的 `click` 实现，它会在点击测试之前强制渲染：
- en: '[PRE596]'
  id: totrans-2490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: It’s possible (but very hard) to move hit testing off the main thread or to
    do hit testing against an older version of the layout tree, or to come up with
    some other technological fix. Thus it’s not *impossible* to move style and layout
    off the main thread “optimistically”, but it *is* challenging. That said, browser
    developers are always looking for ways to make things faster, and I expect that
    at some point in the future style and layout will be moved to their own thread.
    Maybe you’ll be the one to do it?
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
  zh: 将碰撞测试从主线程移除或对旧版本的布局树进行碰撞测试，或者想出其他技术解决方案是可能的（但非常困难）。因此，虽然“乐观”地认为将样式和布局移出主线程并非不可能，但这确实具有挑战性。话虽如此，浏览器开发者总是在寻找让事情变得更快的方法，我预计在未来的某个时刻，样式和布局将被移至它们自己的线程。也许你将成为那个实现它的人？
- en: Browser rendering pipelines are strongly influenced by graphics and games. Many
    high-performance games are driven by event loops, update a [scene graph](https://en.wikipedia.org/wiki/Scene_graph)
    on each event, convert the scene graph into a display list, and then convert the
    display list into pixels. But in a game, the programmer knows *in advance* what
    scene graphs will be provided, and can tune the graphics pipeline for those graphs.
    Games can upload hyper-optimized code and pre-rendered data to the CPU and GPU
    memory when they start. Browsers, on the other hand, need to handle arbitrary
    web pages, and can’t spend much time optimizing anything. This makes for a very
    different set of trade-offs, and is why browsers often feel less fancy and smooth
    than games.
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器渲染管道受到图形和游戏的影响很大。许多高性能游戏由事件循环驱动，每个事件更新一个[场景图](https://en.wikipedia.org/wiki/Scene_graph)，然后将场景图转换为显示列表，最后将显示列表转换为像素。但在游戏中，程序员可以提前知道将提供哪些场景图，并可以为这些图调整图形管道。游戏可以在开始时将超优化的代码和预渲染的数据上传到CPU和GPU内存中。相比之下，浏览器需要处理任意的网页，并且不能花太多时间优化任何事情。这导致了完全不同的权衡，这也是为什么浏览器通常不如游戏那样花哨和流畅。
- en: Summary
  id: totrans-2493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter demonstrated the two-thread rendering system at the core of modern
    browsers. The main points to remember are:'
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了现代浏览器核心中的双线程渲染系统。需要记住的主要点包括：
- en: The browser organizes work into task queues, with tasks for things like running
    JavaScript, handling user input, and rendering the page.
  id: totrans-2495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器将工作组织成任务队列，包括运行JavaScript、处理用户输入和渲染页面等任务。
- en: The goal is to consistently generate frames to the screen at a 30 Hz cadence,
    which means a 33 ms budget to draw each animation frame.
  id: totrans-2496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标是以30 Hz的节奏持续生成屏幕帧，这意味着每个动画帧有33 ms的绘制预算。
- en: The browser has two key threads involved in rendering.
  id: totrans-2497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器在渲染过程中涉及两个关键线程。
- en: The main thread runs JavaScript and the special rendering task.
  id: totrans-2498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主线程运行JavaScript和特殊的渲染任务。
- en: The browser thread draws the display list to the screen, handles/dispatches
    input events, and performs scrolling.
  id: totrans-2499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器线程将显示列表绘制到屏幕上，处理/调度输入事件，并执行滚动。
- en: The main thread communicates with the browser thread via `commit`, which synchronizes
    the two threads.
  id: totrans-2500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主线程通过`commit`与浏览器线程通信，以同步两个线程。
- en: Additionally, you’ve seen how hard it is to move tasks between the two threads,
    such as the challenges involved in scrolling on the browser thread, or how forced
    style and layout makes it hard to fully isolate the rendering pipeline from JavaScript.
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你也看到了在两个线程之间移动任务是多么困难，比如在浏览器线程上滚动时遇到的挑战，或者强制样式和布局如何使得完全隔离渲染管道与JavaScript变得困难。
- en: Click [here](widgets/lab12-browser.html) to try this chapter’s browser.
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[这里](widgets/lab12-browser.html)尝试本章的浏览器。
- en: Outline
  id: totrans-2503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should now
    look something like this:'
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整函数、类和方法集现在看起来可能像这样：
- en: '`COOKIE_JAR` `` class URL: `def __init__(url)` `def request(referrer, payload)`
    `def resolve(url)` `def origin()` `def __str__()` `` `` class Text: `def __init__(text,
    parent)` `def __repr__()` `` `` class Element: `def __init__(tag, attributes,
    parent)` `def __repr__()` `` `def print_tree(node, indent)` `def tree_to_list(tree,
    list)` `` class HTMLParser: `SELF_CLOSING_TAGS` `HEAD_TAGS` `def __init__(body)`
    `def parse()` `def get_attributes(text)` `def add_text(text)` `def add_tag(tag)`
    `def implicit_tags(tag)` `def finish()` `` `` class CSSParser: `def __init__(s)`
    `def whitespace()` `def literal(literal)` `def word()` `def ignore_until(chars)`
    `def pair()` `def selector()` `def body()` `def parse()` `` `` class TagSelector:
    `def __init__(tag)` `def matches(node)` `` `` class DescendantSelector: `def __init__(ancestor,
    descendant)` `def matches(node)` `` `FONTS` `def get_font(size, weight, style)`
    `def linespace(font)` `NAMED_COLORS` `def parse_color(color)` `def parse_blend_mode(blend_mode_str)`
    `REFRESH_RATE_SEC` `` class MeasureTime: `def __init__()` `def time(name)` `def
    stop(name)` `def finish()` `` `` class Task: `def __init__(task_code)` `def run()`
    `` `` class TaskRunner: `def __init__(tab)` `def schedule_task(task)` `def set_needs_quit()`
    `def clear_pending_tasks()` `def start_thread()` `def run()` `def handle_quit()`
    `` `DEFAULT_STYLE_SHEET` `INHERITED_PROPERTIES` `def style(node, rules)` `def
    cascade_priority(rule)` `WIDTH, HEIGHT` `HSTEP, VSTEP` `INPUT_WIDTH_PX` `BLOCK_ELEMENTS`
    `` class DocumentLayout: `def __init__(node)` `def layout()` `def should_paint()`
    `def paint()` `def paint_effects(cmds)` `` `` class BlockLayout: `def __init__(node,
    parent, previous)` `def layout_mode()` `def layout()` `def recurse(node)` `def
    new_line()` `def word(node, word)` `def input(node)` `def self_rect()` `def should_paint()`
    `def paint()` `def paint_effects(cmds)` `` `` class LineLayout: `def __init__(node,
    parent, previous)` `def layout()` `def should_paint()` `def paint()` `def paint_effects(cmds)`
    `` `` class TextLayout: `def __init__(node, word, parent, previous)` `def layout()`
    `def should_paint()` `def paint()` `def paint_effects(cmds)` `` `` class InputLayout:
    `def __init__(node, parent, previous)` `def layout()` `def should_paint()` `def
    paint()` `def paint_effects(cmds)` `def self_rect()` `` `` class DrawText: `def
    __init__(x1, y1, text, font, color)` `def execute(canvas)` `` `` class DrawRect:
    `def __init__(rect, color)` `def execute(canvas)` `` `` class DrawRRect: `def
    __init__(rect, radius, color)` `def execute(canvas)` `` `` class DrawLine: `def
    __init__(x1, y1, x2, y2, color, thickness)` `def execute(canvas)` `` `` class
    DrawOutline: `def __init__(rect, color, thickness)` `def execute(canvas)` `` ``
    class Blend: `def __init__(opacity, blend_mode, children)` `def execute(canvas)`
    `` `def paint_tree(layout_object, display_list)` `def paint_visual_effects(node,
    cmds, rect)` `EVENT_DISPATCH_JS` `SETTIMEOUT_JS` `XHR_ONLOAD_JS` `RUNTIME_JS`
    `` class JSContext: `def __init__(tab)` `def run(script, code)` `def dispatch_event(type,
    elt)` `def dispatch_settimeout(handle)` `def dispatch_xhr_onload(out, handle)`
    `def get_handle(elt)` `def querySelectorAll(selector_text)` `def getAttribute(handle,
    attr)` `def innerHTML_set(handle, s)` `def XMLHttpRequest_send(...)` `def setTimeout(handle,
    time)` `def requestAnimationFrame()` `` `SCROLL_STEP` `` class Tab: `def __init__(browser,
    tab_height)` `def load(url, payload)` `def run_animation_frame(scroll)` `def render()`
    `def allowed_request(url)` `def raster(canvas)` `def clamp_scroll(scroll)` `def
    set_needs_render()` `def scrolldown()` `def click(x, y)` `def go_back()` `def
    submit_form(elt)` `def keypress(char)` `` `` class Chrome: `def __init__(browser)`
    `def tab_rect(i)` `def paint()` `def click(x, y)` `def keypress(char)` `def enter()`
    `def blur()` `` `` class CommitData: `def __init__(...)` `` `` class Browser:
    `def __init__()` `def schedule_animation_frame()` `def commit(tab, data)` `def
    render()` `def raster_and_draw()` `def raster_tab()` `def raster_chrome()` `def
    draw()` `def set_needs_animation_frame(tab)` `def set_needs_raster_and_draw()`
    `def new_tab(url)` `def new_tab_internal(url)` `def set_active_tab(tab)` `def
    schedule_load(url, body)` `def clamp_scroll(scroll)` `def handle_down()` `def
    handle_click(e)` `def handle_key(char)` `def handle_enter()` `def handle_quit()`
    `` `def mainloop(browser)`'
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
- en: If you run it, it should look something like [this page](widgets/lab12-browser.html);
    due to the browser sandbox, you will need to open that page in a new tab.
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行它，它应该看起来像[这个页面](widgets/lab12-browser.html)；由于浏览器沙盒，你需要在新标签页中打开该页面。
- en: Exercises
  id: totrans-2507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 12-1 *`setInterval`*. [`setInterval`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval)
    is similar to `setTimeout` but runs repeatedly at a given cadence until [`clearInterval`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/clearInterval)
    is called. Implement these APIs. Make sure to test `setInterval` with various
    cadences in a page that also uses `requestAnimationFrame` with some expensive
    rendering pipeline work to do. Record the actual timing of `setInterval` tasks;
    how consistent is the cadence?
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
  zh: 12-1 *`setInterval`*. [`setInterval`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval)
    与 `setTimeout` 类似，但会在给定的节奏下重复运行，直到调用 `clearInterval`。实现这些 API。确保在一个同时使用 `requestAnimationFrame`
    进行一些昂贵渲染管道工作的页面上测试 `setInterval` 的各种节奏。记录 `setInterval` 任务的实际时间；节奏的稳定性如何？
- en: 12-2 *Task timing*. Modify `Task` to add trace events every time a task executes.
    You’ll want to provide a good name for these trace events. One option is to use
    the `__name__` field of `task_code`, which will get the name of the Python function
    run by the task.
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
  zh: 12-2 *任务计时*. 修改 `Task` 以在每次任务执行时添加跟踪事件。你将为这些跟踪事件提供一个好的名称。一个选项是使用 `task_code`
    的 `__name__` 字段，这将获取任务运行的 Python 函数的名称。
- en: 12-3 *Clock-based frame timing*. Right now our browser schedules each animation
    frame exactly 33 ms after the previous one completes. This actually leads to a
    slower animation frame rate cadence than 33 ms. Fix this in our browser by using
    the absolute time to schedule animation frames, instead of a fixed delay between
    frames. Also implement main-thread animation frame scheduling that happens *before*
    raster and draw, not after, allowing both threads to do animation work simultaneously.
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
  zh: 12-3 *基于时钟的帧计时*. 目前我们的浏览器在每个动画帧完成后恰好 33 毫秒后安排每个动画帧。这实际上导致动画帧率节奏比 33 毫秒慢。通过使用绝对时间来安排动画帧，而不是帧之间的固定延迟，在我们的浏览器中修复这个问题。还实现主线程动画帧调度，该调度发生在光栅化和绘制之前，而不是之后，允许两个线程同时进行动画工作。
- en: '12-4 *Scheduling*. As more types of complex tasks end up on the event queue,
    there comes a greater need to carefully schedule them to ensure the rendering
    cadence is as close to 33 ms as possible, and also to avoid task starvation. Implement
    a task scheduler with a priority system that balances these two needs: prioritize
    rendering tasks and input handling, and deprioritize (but don’t completely starve)
    tasks that ultimately come from JavaScript APIs like `setTimeout`. Test it out
    on a web page that taxes the system with a lot of `setTimeout`-based tasks.'
  id: totrans-2511
  prefs: []
  type: TYPE_NORMAL
  zh: 12-4 *调度*. 随着更多类型的复杂任务出现在事件队列中，就有更大的需求来仔细调度它们，以确保渲染节奏尽可能接近 33 毫秒，并且避免任务饥饿。实现一个具有优先级系统的任务调度器，以平衡这两个需求：优先处理渲染任务和输入处理，并降低（但不要完全饥饿）最终来自
    JavaScript API 如 `setTimeout` 的任务。在一个使用大量基于 `setTimeout` 的任务的网页上测试它。
- en: 12-5 *Threaded loading*. When loading a page, our browser currently waits for
    each style sheet or script resource to load in turn. This is unnecessarily slow,
    especially on a bad network. Instead, make your browser send off all the network
    requests in parallel. You must still process resources like styles in source order,
    however. It may be convenient to use the `join` method on a `Thread`, which will
    block the thread calling `join` until the thread being `join`ed completes.
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
  zh: 12-5 *线程加载*. 当加载页面时，我们的浏览器目前会依次等待每个样式表或脚本资源加载。这在网络状况不佳的情况下是不必要的缓慢。相反，让你的浏览器并行发送所有网络请求。然而，你仍然必须按源顺序处理资源，如样式。使用
    `Thread` 上的 `join` 方法可能很方便，这将阻塞调用 `join` 的线程，直到被 `join` 的线程完成。
- en: 12-6 *Networking thread*. Real browsers usually have a separate thread for networking
    (and other I/O). Tasks are added to this thread in a similar fashion to the main
    thread. Implement a third *networking* thread and put all networking tasks on
    it.
  id: totrans-2513
  prefs: []
  type: TYPE_NORMAL
  zh: 12-6 *网络线程*. 真实浏览器通常有一个单独的线程用于网络（和其他 I/O）。任务以类似主线程的方式添加到这个线程。实现第三个 *网络* 线程，并将所有网络任务放在它上面。
- en: 12-7 *Optimized scheduling*. On a complicated web page, the browser may not
    be able to keep up with the desired cadence. Instead of constantly pegging the
    CPU in a futile attempt to keep up, implement a *frame time estimator* that estimates
    the true cadence of the browser based on previous frames, and adjust `schedule_animation_frame`
    to match. This way complicated pages get consistently slower, instead of having
    random slowdowns.
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
  zh: 12-7 *优化调度*. 在一个复杂的网页上，浏览器可能无法跟上所需的节奏。而不是不断将CPU固定在徒劳的尝试中，以跟上节奏，实现一个基于先前帧估计浏览器真实节奏的*帧时间估计器*，并调整`schedule_animation_frame`以匹配。这样复杂的页面会持续变慢，而不是出现随机减速。
- en: '12-8 *Raster-and-draw thread*. Right now, if an input event arrives while the
    browser thread is rastering or drawing, that input event won’t be handled immediately.
    This is especially a problem because [raster and draw are slow](#profiling-rendering).
    Fix this by adding a separate raster-and-draw thread controlled by the browser
    thread. While the raster-and-draw thread is doing its work, the browser thread
    should be available to handle input events. Be careful: SDL is not thread-safe,
    so all of the steps that directly use SDL still need to happen on the browser
    thread.'
  id: totrans-2515
  prefs: []
  type: TYPE_NORMAL
  zh: 12-8 *光栅和绘制线程*. 目前，如果输入事件在浏览器线程进行光栅化或绘制时到达，该输入事件不会立即被处理。这是一个特别的问题，因为[光栅化和绘制很慢](#profiling-rendering)。通过添加一个由浏览器线程控制的单独的光栅和绘制线程来解决这个问题。当光栅和绘制线程正在执行其工作的时候，浏览器线程应该可以处理输入事件。请注意：SDL不是线程安全的，所以所有直接使用SDL的步骤仍然需要在浏览器线程上执行。
- en: Animating and Compositing
  id: totrans-2516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画和合成
- en: Chapter 13 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-2517
  prefs: []
  type: TYPE_NORMAL
  zh: '[Web浏览器工程](./index.html "目录")的第13章。'
- en: '[JavaScript Animations](#javascript-animations)'
  id: totrans-2518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JavaScript动画](#javascript-animations)'
- en: '[GPU Acceleration](#gpu-acceleration)'
  id: totrans-2519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GPU加速](#gpu-acceleration)'
- en: '[Compositing](#compositing)'
  id: totrans-2520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[合成](#compositing)'
- en: '[Compositing Leaves](#compositing-leaves)'
  id: totrans-2521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[合成叶子](#compositing-leaves)'
- en: '[CSS Transitions](#css-transitions)'
  id: totrans-2522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CSS过渡](#css-transitions)'
- en: '[Composited Animations](#composited-animations)'
  id: totrans-2523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[合成动画](#composited-animations)'
- en: '[Optimizing Compositing](#optimizing-compositing)'
  id: totrans-2524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[优化合成](#optimizing-compositing)'
- en: '[Overlap and Transforms](#overlap-and-transforms)'
  id: totrans-2525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[重叠和变换](#overlap-and-transforms)'
- en: '[Summary](#summary)'
  id: totrans-2526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summary)'
- en: '[Outline](#outline)'
  id: totrans-2527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[概要](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-2528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: Complex web applications use *animations* when transitioning between states.
    These animations help users understand the state change and they improve visual
    polish by replacing sudden jumps with gradual changes. But to execute these animations
    smoothly, the browser must minimize time in each animation frame, using GPU acceleration
    to speed up visual effects and compositing to minimize rendering work.
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的Web应用程序在状态之间转换时使用*动画*。这些动画帮助用户理解状态变化，并通过用渐进变化代替突然跳跃来提高视觉的精致度。但是为了平滑地执行这些动画，浏览器必须最小化每个动画帧中的时间，使用GPU加速来加快视觉效果和合成来最小化渲染工作。
- en: JavaScript Animations
  id: totrans-2530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript动画
- en: An [animation](https://en.wikipedia.org/wiki/Animation) is a sequence of still
    pictures shown in quick succession that create an illusion of *movement* to the
    human eye.Here *movement* should be construed broadly to encompass all of the
    kinds of visual changes humans are used to seeing and good at recognizing—not
    just movement from side to side, but growing, shrinking, rotating, fading, blurring,
    and sharpening. The rule is that an animation is not an *arbitrary* sequence of
    pictures; the sequence must feel continuous to a human mind trained by experience
    in the real world. Typical web page animations include changing an element’s color,
    fading it in or out, or resizing it. Browsers also use animations in response
    to user actions like scrolling, resizing, and pinch-zooming. Plus, some types
    of animated media (like videos) can be included in web pages.Video-like animations
    also include animated images and animated canvases. Since our browser doesn’t
    support images yet, this topic is beyond the scope of this chapter; video alone
    has its own [fascinating complexities](https://developer.chrome.com/blog/videong/).
  id: totrans-2531
  prefs: []
  type: TYPE_NORMAL
  zh: '[动画](https://en.wikipedia.org/wiki/Animation) 是一系列以快速连续的方式展示的静态图片，这给人类眼睛造成了一种
    *运动* 的错觉。这里的 *运动* 应该被广泛理解，包括人类习惯看到并擅长识别的所有视觉变化——不仅仅是左右移动，还包括生长、缩小、旋转、淡入淡出、模糊和锐化。规则是，动画不是一系列
    *任意* 的图片；序列必须让在现实世界中通过经验训练的人类大脑感到连续。典型的网页动画包括改变元素的颜色、淡入或淡出，或调整其大小。浏览器还会在用户滚动、调整大小和捏合缩放等操作时使用动画。此外，某些类型的动画媒体（如视频）可以包含在网页中。类似视频的动画也包括动画图像和动画画布。由于我们的浏览器目前还不支持图像，这个主题超出了本章的范围；视频本身有其自己的
    [迷人复杂性](https://developer.chrome.com/blog/videong/)。'
- en: 'In this chapter we’ll focus on animations of web page elements. Let’s start
    by writing a simple animation using the `requestAnimationFrame` API [implemented
    in Chapter 12](scheduling.html#animating-frames). This method requests that some
    JavaScript code run on the next frame; to run repeatedly over many frames, we
    can just have that JavaScript code call `requestAnimationFrame` itself:'
  id: totrans-2532
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于网页元素的动画。让我们从编写一个简单的使用 `requestAnimationFrame` API 的动画开始，该 API 在第
    12 章中实现（scheduling.html#animating-frames）。此方法请求在下一帧上运行一些 JavaScript 代码；为了在多个帧上重复运行，我们只需让那段
    JavaScript 代码调用 `requestAnimationFrame` 本身：
- en: '[PRE597]'
  id: totrans-2533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: The `animate` function then makes some small change to the page to give the
    impression of continuous change.It returns `true` while it’s animating, and then
    stops. By changing what `animate` does we can change what animation occurs.
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`animate` 函数对页面进行一些小的更改，以产生连续变化的印象。它在动画过程中返回 `true`，然后停止。通过更改 `animate` 的行为，我们可以改变发生的动画。
- en: For example, we can fade an element in by smoothly transitioning its `opacity`
    value from 0.1 to 0.999.Real browsers apply certain optimizations when opacity
    is exactly 1, so real-world websites often start and end animations at 0.999 so
    that each frame is drawn the same way and the animation is smooth. It also avoids
    visual popping of the content as it goes in and out of GPU-accelerated mode. I
    chose 0.999 because the visual difference from 1.0 is imperceptible. Doing this
    over 120 frames (about four seconds) means increasing the opacity by about 0.008
    each frame.
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过平滑地将元素的 `opacity` 值从 0.1 过渡到 0.999 来淡入一个元素。真实浏览器在 `opacity` 精确为 1 时应用某些优化，因此现实世界的网站通常在
    0.999 处开始和结束动画，以确保每一帧都以相同的方式绘制，动画流畅。这也避免了内容在进入和退出 GPU 加速模式时的视觉跳动。我选择 0.999 是因为与
    1.0 的视觉差异几乎不可察觉。这样做需要 120 帧（大约四秒）的时间，这意味着每帧增加大约 0.008 的不透明度。
- en: 'So let’s take this `div` containing some text:'
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们来看这个包含一些文本的 `div`：
- en: '[PRE598]'
  id: totrans-2537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: 'and write an `animate` function to incrementally change its `opacity`:'
  id: totrans-2538
  prefs: []
  type: TYPE_NORMAL
  zh: 并编写一个 `animate` 函数来递增地改变其 `opacity`：
- en: '[PRE599]'
  id: totrans-2539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: 'Here’s how it looks; click the buttons to start a fade:'
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它的样子；点击按钮开始淡入：
- en: '[examples/example13-opacity-raf.html](examples/example13-opacity-raf.html)'
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
  zh: '[examples/example13-opacity-raf.html](examples/example13-opacity-raf.html)'
- en: 'This animation *almost* runs in our browser, except that we need to add support
    for changing an element’s `style` attribute from JavaScript. To do that, register
    a setter on the `style` attribute of `Node` in the JavaScript runtime:'
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动画几乎在我们的浏览器中运行，除了我们需要添加支持从 JavaScript 中更改元素 `style` 属性的功能。为此，在 JavaScript
    运行时中注册 `style` 属性的设置器：
- en: '[PRE600]'
  id: totrans-2543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: 'Then, inside the browser, define a handler for `style_set`:'
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在浏览器内部，定义一个 `style_set` 的处理程序：
- en: '[PRE601]'
  id: totrans-2545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: Importantly, the `style_set` function sets the `needs_render` flag to make sure
    that the browser re-renders the web page with the new `style` parameter. With
    these changes, you should now be able to open and run this animation in your browser.
  id: totrans-2546
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，`style_set`函数将`needs_render`标志设置为确保浏览器使用新的`style`参数重新渲染网页。有了这些更改，你现在应该能够在浏览器中打开并运行这个动画。
- en: The animation pattern presented in this section is yet another example of the
    *event loop* first introduced [in Chapter 2](graphics.html#creating-windows) and
    evolved further [in Chapter 12](scheduling.html#animating-frames). What’s new
    in this chapter is that we finally have enough tech built up to actually create
    meaningful, practical animations. And the same happened with the web. A whole
    lot of the APIs for proper animations, from the `requestAnimationFrame` API to
    CSS-native animations, came onto the scene only in the [2010s](https://en.wikipedia.org/wiki/CSS_animations).
  id: totrans-2547
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中展示的动画模式是*事件循环*的另一个例子，它最初在第2章[介绍](graphics.html#creating-windows)并在第12章[进一步发展](scheduling.html#animating-frames)。本章的新颖之处在于，我们终于有了足够的科技来创建有意义的、实用的动画。同样的事情也发生在网页上。许多用于正确动画的API，从`requestAnimationFrame`
    API到CSS原生动画，仅在[2010年代](https://en.wikipedia.org/wiki/CSS_animations)出现。
- en: GPU Acceleration
  id: totrans-2548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPU加速
- en: Try the fade animation in your browser, and you’ll probably notice that it’s
    not particularly smooth. And that shouldn’t be surprising; after all, [Chapter
    12](scheduling.html#profiling-rendering) showed that raster and draw was about
    62ms for simple pages, and render was 23ms.
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中尝试淡入淡出动画，你可能会注意到它并不特别平滑。这并不奇怪；毕竟，[第12章](scheduling.html#profiling-rendering)中显示，对于简单页面，光栅化和绘制大约需要62毫秒，而渲染需要23毫秒。
- en: Even with just 62ms per frame, our browser is barely doing 15 frames per second;
    for smooth animations we want 30! So we need to speed up raster and draw.
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
  zh: 即使每帧只有62毫秒，我们的浏览器也几乎只能达到每秒15帧；对于平滑的动画，我们希望达到30帧！因此，我们需要加快光栅化和绘制的速度。
- en: The best way to do that is to move raster and draw to the [GPU](https://en.wikipedia.org/wiki/Graphics_processing_unit).
    A GPU is essentially a chip in your computer that runs programs much like your
    CPU, but specialized toward running very simple programs with massive parallelism—it
    was developed to apply simple operations, in parallel, for every pixel on the
    screen. This makes GPUs faster for drawing simple shapes and *much* faster for
    applying visual effects.
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，最好的办法是将光栅化和绘制移动到[GPU](https://en.wikipedia.org/wiki/Graphics_processing_unit)。GPU本质上是你电脑中一个运行程序的方式与CPU非常相似，但专门用于运行非常简单的程序，具有巨大的并行性——它是为了对屏幕上的每个像素应用简单的并行操作而开发的。这使得GPU在绘制简单形状时更快，在应用视觉效果时则快得多。
- en: At a high level, to raster and draw on the GPU our browser must:These steps
    vary a bit in their details by GPU architecture.
  id: totrans-2552
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，为了在GPU上进行光栅化和绘制，我们的浏览器必须：这些步骤的细节因GPU架构而异。
- en: '*Upload* the display list to specialized GPU memory.'
  id: totrans-2553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上传*显示列表到专门的GPU内存。'
- en: '*Compile* GPU programs that raster and draw the display list.That’s right,
    GPU programs are dynamically compiled! This allows them to be portable across
    a wide variety of implementations that may have very different instruction sets
    or acceleration tactics. These compiled programs will typically be cached, so
    this step won’t occur on every animation frame.'
  id: totrans-2554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译*用于光栅化和绘制显示列表的GPU程序。没错，GPU程序是动态编译的！这使得它们可以在具有非常不同的指令集或加速策略的广泛实现之间移植。这些编译程序通常会被缓存，因此这一步骤不会在每一帧动画中发生。'
- en: '*Raster* every drawing command into GPU textures.A surface represented on the
    GPU is called a *texture*. There can be more than one texture, and practically
    speaking they often can’t be rastered in parallel with each other.'
  id: totrans-2555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*光栅化*每个绘制命令到GPU纹理中。在GPU上表示的表面称为*纹理*。可以有多于一个的纹理，实际上它们通常不能并行光栅化。'
- en: '*Draw* the textures onto the screen.'
  id: totrans-2556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制*纹理到屏幕上。'
- en: Luckily, SDL and Skia support GPUs and all of these steps; it’s mostly a matter
    of passing them the right parameters to cause them to happen on the GPU. So let’s
    do that. Note that a real browser typically implements both CPU and GPU raster
    and draw, because in some cases CPU raster and draw can be faster than using the
    GPU, or it may be necessary to work around bugs.Any of the four steps can make
    GPU raster and draw slow. Large display lists take a while to upload. Complex
    display list commands take longer to compile. Raster can be slow if there are
    many surfaces, and draw can be slow if surfaces are deeply nested. On a CPU, the
    upload step and compile steps aren’t necessary, and more memory is available for
    raster and draw. Of course, many optimizations are available for both GPUs and
    CPUs, so choosing the best way to raster and draw a given page can be quite complex.
    In our browser, for simplicity, we’ll always use the GPU.
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，SDL 和 Skia 支持 GPU，并且所有这些步骤；这主要是一个传递正确的参数给它们，让它们在 GPU 上执行的问题。所以让我们这么做。请注意，实际的浏览器通常实现
    CPU 和 GPU 的栅格化和绘制，因为在某些情况下，CPU 的栅格化和绘制可能比使用 GPU 更快，或者可能需要绕过错误。任何四个步骤都可能使 GPU 的栅格化和绘制变慢。大的显示列表需要一段时间才能上传。复杂的显示列表命令需要更长的时间来编译。如果有很多表面，栅格化可能会很慢，如果表面深度嵌套，绘制可能会很慢。在
    CPU 上，上传步骤和编译步骤是不必要的，并且有更多的内存可用于栅格化和绘制。当然，GPU 和 CPU 都有许多优化可用，因此选择绘制给定页面的最佳方式可能相当复杂。在我们的浏览器中，为了简单起见，我们将始终使用
    GPU。
- en: 'First, we’ll need to install the OpenGL library:'
  id: totrans-2558
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装 OpenGL 库：
- en: '[PRE602]'
  id: totrans-2559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: 'and import it:'
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入它：
- en: '[PRE603]'
  id: totrans-2561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: Now we’ll need to configure SDL to use OpenGL and start/stop a [GL context](https://www.khronos.org/opengl/wiki/OpenGL_Context)
    at the beginning/end of the program. For our purposes, just consider this API
    boilerplate:Starting a GL context is just OpenGL’s way of saying “set up the surface
    into which subsequent OpenGL commands will draw”. After creating one you can even
    execute OpenGL commands manually, [without using Skia at all](http://pyopengl.sourceforge.net/),
    to draw polygons or other objects on the screen.
  id: totrans-2562
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要配置 SDL 以使用 OpenGL，并在程序的开始/结束时启动/停止 [GL 上下文](https://www.khronos.org/opengl/wiki/OpenGL_Context)。就我们的目的而言，只需考虑这个
    API 模板：启动 GL 上下文只是 OpenGL 表示“设置后续 OpenGL 命令将绘制到的表面”。创建一个后，你甚至可以手动执行 OpenGL 命令，[完全不使用
    Skia](http://pyopengl.sourceforge.net/)，在屏幕上绘制多边形或其他对象。
- en: '[PRE604]'
  id: totrans-2563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: That `print` statement shows the GPU vendor and renderer that the browser is
    using; this will help you verify that it’s actually using your GPU. I’m using
    a Chromebook to write this chapter, so for me it says:The `virgl` renderer stands
    for “virtual GL”, a way of hardware-accelerating the Linux subsystem of ChromeOS
    that works with the ChromeOS Linux sandbox. This is a bit slower than using the
    GPU directly, so you’ll probably see even faster raster and draw than I do.
  id: totrans-2564
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 `print` 语句显示了浏览器正在使用的 GPU 供应商和渲染器；这将帮助你验证它实际上正在使用你的 GPU。我正在使用 Chromebook
    编写这一章节，所以对我来说它显示的是：`virgl` 渲染器代表“虚拟 GL”，这是一种为 ChromeOS 的 Linux 子系统提供硬件加速的方式，它与
    ChromeOS Linux 沙盒一起工作。这比直接使用 GPU 慢一些，所以你可能看到的栅格化和绘制速度甚至比我还要快。
- en: '[PRE605]'
  id: totrans-2565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: Now we can configure Skia to draw directly to the screen. The incantation is:Weirdly,
    this code draws to the window without referencing `gl_context` or `sdl_window`
    directly. That’s because OpenGL is a strange API with a lot of hidden global state;
    the `MakeGL` Skia method implicitly binds to the existing GL context.
  id: totrans-2566
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以配置 Skia 以直接绘制到屏幕上。咒语是：奇怪的是，这段代码绘制到窗口中，没有直接引用 `gl_context` 或 `sdl_window`。这是因为
    OpenGL 是一个奇怪的 API，有很多隐藏的全局状态；`MakeGL` Skia 方法隐式绑定到现有的 GL 上下文。
- en: '[PRE606]'
  id: totrans-2567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: 'An extra advantage of using OpenGL is that we won’t need to copy data between
    Skia and SDL anymore. Instead we just *flush* the Skia surface (Skia surfaces
    draw lazily) and call `SDL_GL_SwapWindow` to activate the new framebuffer (because
    of OpenGL [double-buffering](https://wiki.libsdl.org/SDL_GL_SwapWindow)):'
  id: totrans-2568
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenGL 的额外优点是，我们不再需要在 Skia 和 SDL 之间复制数据了。相反，我们只需 *刷新* Skia 表面（Skia 表面是懒惰绘制的）并调用
    `SDL_GL_SwapWindow` 来激活新的帧缓冲区（因为 OpenGL [双缓冲](https://wiki.libsdl.org/SDL_GL_SwapWindow)）：
- en: '[PRE607]'
  id: totrans-2569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: 'Finally, our browser also creates Skia surfaces for the `chrome_surface` and
    `tab_surface`. We don’t want to draw these straight to the screen, so the incantation
    is a bit different:'
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的浏览器也会为 `chrome_surface` 和 `tab_surface` 创建 Skia 表面。我们不想直接将这些内容绘制到屏幕上，所以咒语略有不同：
- en: '[PRE608]'
  id: totrans-2571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: 'Again, you should think of these changes mostly as boilerplate, since the details
    of GPU operation aren’t our focus here.Example detail: a different color space
    is required for GPU mode. Make sure to apply the same treatment to `tab_surface`
    (with different width and height arguments).'
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你应该主要将这些变化视为模板代码，因为 GPU 操作的细节不是我们关注的重点。示例细节：GPU 模式需要不同的颜色空间。确保对 `tab_surface`（具有不同的宽度和高度参数）应用相同的处理。
- en: Thanks to the thorough support for GPU rendering in SDL and Skia, that should
    be all that’s necessary for our browser to raster and draw on the GPU. And as
    expected, speed is much improved. I found that raster and draw improved to 7 ms
    on average (see Figure 1).
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SDL 和 Skia 对 GPU 渲染的全面支持，这应该就足够我们的浏览器在 GPU 上进行光栅化和绘制了。正如预期的那样，速度有了显著提升。我发现光栅化和绘制平均提高了到
    7 毫秒（见图 1）。
- en: '![Figure 1: Raster and draw times from a trace using GPU raster.](img/a9b2edc5d7e739a3bc469f654b5af36e.png)'
  id: totrans-2574
  prefs: []
  type: TYPE_IMG
  zh: '![图 1：使用 GPU 光栅化进行跟踪的光栅化和绘制时间。](img/a9b2edc5d7e739a3bc469f654b5af36e.png)'
- en: 'Figure 1: Raster and draw times from a trace using GPU raster.'
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1：使用 GPU 光栅化进行跟踪的光栅化和绘制时间。
- en: That’s about 10 times faster, and enough to hit 30 frames per second. (And on
    your computer, you’ll likely see even more speedup than I did, so for you it might
    already be fast enough in this example.) But if we want to go faster yet, we’ll
    need to find ways to reduce the total amount of work in rendering, raster and
    draw.
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
  zh: 这大约是 10 倍的提速，足以达到每秒 30 帧的速度。（而且在你电脑上，你可能会看到比我更高的速度提升，所以对于你来说，在这个例子中可能已经足够快了。）但如果我们还想更快，我们就需要找到减少渲染、光栅化和绘制总工作量方法。
- en: A high-speed, reliable and cross-platform GPU raster path in Skia has only existed
    for a few years.You can see a timeline [on the Chrome developer blog](https://developer.chrome.com/blog/renderingng/#gpu-acceleration-everywhere).
    In the very early days of Chromium, there was only CPU raster. Scrolling was implemented
    much like in the early chapters of this book, by re-rastering content. This was
    deemed acceptable at the time because computers were much slower than today in
    general, GPUs much less reliable, animations less frequent, and mobile platforms
    such as Android and iOS still emerging. (In fact, the first versions of Android
    also didn’t have GPU acceleration.) The same is generally true of Firefox and
    Safari, though Safari was able to accelerate content more easily because it only
    targeted the limited number of GPUs supported by macOS and iOS.
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Skia 中，一个高速、可靠且跨平台的 GPU 光栅化路径只存在了几年。你可以在 Chrome 开发者博客上看到一个时间线[链接](https://developer.chrome.com/blog/renderingng/#gpu-acceleration-everywhere)。在
    Chromium 的早期阶段，只有 CPU 光栅化。滚动就像在这本书的早期章节中实现的那样，通过重新光栅化内容来实现。在当时，这被认为是可接受的，因为计算机总体上比现在慢得多，GPU
    的可靠性也较低，动画较少，移动平台如 Android 和 iOS 正在兴起。（事实上，Android 的早期版本也没有 GPU 加速。）Firefox 和
    Safari 也是如此，尽管 Safari 能够更容易地加速内容，因为它只针对 macOS 和 iOS 支持的有限数量的 GPU。
- en: There are *many* challenges to implementing GPU-accelerated raster, among them
    working correctly across many GPU architectures, gracefully falling back to CPU
    raster in complex or error scenarios, and finding ways to efficiently GPU-raster
    content in difficult situations like anti-aliased and complex shapes. So while
    you might think it’s odd to wait until now to turn on GPU acceleration in our
    browser, this also mirrors the evolution timeline of browsers.
  id: totrans-2578
  prefs: []
  type: TYPE_NORMAL
  zh: 实现GPU加速光栅化有许多挑战，其中包括在许多 GPU 架构上正确工作，在复杂或错误场景中优雅地回退到 CPU 光栅化，以及在抗锯齿和复杂形状等困难情况下找到高效
    GPU 光栅化内容的方法。所以虽然你可能觉得现在才在我们的浏览器中开启 GPU 加速看起来有些奇怪，但这也反映了浏览器的发展历程。
- en: Compositing
  id: totrans-2579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合成
- en: So, how do we do less work in the raster-and-draw phase? The answer is a technique
    called *compositing*, which just means caching some rastered images on the GPU
    and reusing them during later frames.The term [*compositing*](https://en.wikipedia.org/wiki/Compositing)
    means combining multiple images together into a final output. In the context of
    browsers, it typically means combining rastered images into the final on-screen
    image, but a similar technique is used in many operating systems to combine the
    contents of multiple windows. “Compositing” can also refer to multithreaded rendering.
    I first discussed compositing in [Chapter 11](visual-effects.html#browser-compositing);
    the algorithms described here generalize that beyond scrolling.
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在光栅化和绘制阶段做更少的工作呢？答案是称为*合成*的技术，这仅仅意味着在GPU上缓存一些光栅化图像，并在后续帧中重用它们。术语[*合成*](https://en.wikipedia.org/wiki/Compositing)意味着将多个图像组合成最终输出。在浏览器的上下文中，这通常意味着将光栅化图像组合成最终的屏幕图像，但在许多操作系统中也使用类似的技巧来组合多个窗口的内容。“合成”也可以指多线程渲染。我首次在[第11章](visual-effects.html#browser-compositing)中讨论了合成；这里描述的算法将这一点推广到了滚动之外。
- en: 'To explain compositing, we’ll need to think about our browser’s display list,
    and to do that it’s useful to print it out. For example, for `DrawRect` you might
    print:'
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
  zh: 要解释合成，我们需要考虑浏览器的显示列表，并且为了做到这一点，打印出来是很有用的。例如，对于`DrawRect`，你可能打印如下：
- en: '[PRE609]'
  id: totrans-2582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: 'The `Blend` command sometimes does nothing if no opacity or blend mode is passed;
    it’s helpful to indicate that when printing:'
  id: totrans-2583
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有传递不透明度或混合模式，`Blend`命令有时什么都不做；在打印时指出这一点是有帮助的：
- en: '[PRE610]'
  id: totrans-2584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: 'You’ll also need to add `children` fields to all of the paint commands, since
    `print_tree` relies on those. Now we can print out our browser’s display list:'
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要为所有的绘制命令添加`children`字段，因为`print_tree`依赖于这些。现在我们可以打印出浏览器的显示列表：
- en: '[PRE611]'
  id: totrans-2586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: 'For our opacity example, the (key part of) the display list for one frame might
    look like this:'
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的不透明度示例，一帧的显示列表（关键部分）可能看起来像这样：
- en: '[PRE612]'
  id: totrans-2588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: 'On the next frame, it instead might like this:'
  id: totrans-2589
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一帧，它可能看起来是这样的：
- en: '[PRE613]'
  id: totrans-2590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: In each case, rastering this display list means first rastering the three words
    to a Skia surface created by `Blend`, and then copying that to the root surface
    while applying transparency. Crucially, the raster is identical in both frames;
    only the copy differs. This means we can speed it up with caching.
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，光栅化这个显示列表意味着首先将这三个字光栅化到由`Blend`创建的Skia表面，然后将其复制到根表面并应用透明度。关键的是，光栅化在这两帧中是相同的；只有复制不同。这意味着我们可以通过缓存来加速它。
- en: 'The idea is to first raster the three words to a separate surface (but this
    time owned by us, not Skia), which we’ll call a *composited layer*, that is saved
    for future use:'
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是首先将这三个字光栅化到一个单独的表面（但这次是我们拥有的，而不是Skia），我们将它称为*合成层*，以备将来使用：
- en: '[PRE614]'
  id: totrans-2593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: 'Now instead of rastering those three words, we can just copy over the composited
    layer with a `DrawCompositedLayer` command:'
  id: totrans-2594
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用`DrawCompositedLayer`命令直接复制这些三个字，而不是对它们进行光栅化：
- en: '[PRE615]'
  id: totrans-2595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: 'Importantly, on the next frame, the `Blend` changes but the `DrawText`s don’t,
    so on that frame all we need to do is re-run the `Blend`:'
  id: totrans-2596
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，在下一帧中，`Blend`发生了变化，但`DrawText`没有变化，所以在那一帧我们只需要重新运行`Blend`：
- en: '[PRE616]'
  id: totrans-2597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: 'In other words, the idea behind compositing is to split the display list into
    two pieces: a set of composited layers, which are rastered during the browser’s
    raster phase and then cached, and a *draw display list*, which is drawn during
    the browser’s draw phase and which uses the composited layers.'
  id: totrans-2598
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，合成的理念是将显示列表分成两部分：一组合成层，在浏览器的光栅化阶段进行光栅化并缓存，以及一个*绘制显示列表*，在浏览器的绘制阶段绘制，并使用合成层。
- en: Compositing improves performance when subsequent frames of an animation reuse
    composited layers. That’s the case here, because the only difference between frames
    is the `Blend`, which is in the draw display list.
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画的后续帧重用合成层时，合成可以提高性能。这里就是这样，因为帧之间的唯一区别是`Blend`，它位于绘制显示列表中。
- en: How exactly to split up the display list is up to the browser. Typically, visual
    effects like opacity are very fast to execute on a GPU, but *paint commands* that
    draw shapes—in our browser, `DrawText`, `DrawRect`, `DrawRRect`, and `DrawLine`—can
    be slower.And there are usually a lot more of them to execute. Since it’s the
    visual effects that are typically animated, this means browsers usually leave
    animated visual effects in the draw display list and move everything else into
    composited layers. Of course, in a real browser, hardware capabilities, GPU memory,
    and application data all play into these decisions, but the basic idea of compositing
    is the same no matter what goes where.
  id: totrans-2600
  prefs: []
  type: TYPE_NORMAL
  zh: 如何具体分割显示列表由浏览器决定。通常，在GPU上执行如不透明度这样的视觉效果非常快，但绘制形状的绘图命令——在我们的浏览器中是`DrawText`、`DrawRect`、`DrawRRect`和`DrawLine`——可能会慢一些。而且通常有更多这样的命令需要执行。由于视觉效果通常是动画化的，这意味着浏览器通常将动画视觉效果留在绘图显示列表中，并将其他所有内容移动到合成层中。当然，在真实浏览器中，硬件能力、GPU内存和应用数据都会影响这些决策，但合成的基本思想是不变的。
- en: If you look closely at the opacity example in this section, you’ll see that
    the `DrawText` command’s `rect` is only as wide as the text. On the other hand,
    the `Blend` `rect` is almost as wide as the viewport. The reason they differ is
    that the text is only about as wide as it needs to be, but the block element that
    contains it is as wide as the available width.
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察本节中的不透明度示例，你会看到`DrawText`命令的`rect`宽度仅与文本宽度相当。另一方面，`Blend`的`rect`宽度几乎与视口宽度相当。它们之所以不同，是因为文本的宽度仅是其所需宽度，但包含文本的块元素宽度与可用宽度相当。
- en: So if we put it in a composited layer, does it need to be as wide as the text
    or the whole viewport? In practice you could implement either. The algorithm presented
    in this chapter ends up with the smaller one but real browsers sometimes choose
    the larger, depending on their algorithm. Also note that if there was any kind
    of paint command associated with the block element containing the text, such as
    a background color, then the surface would definitely have to be as wide as the
    viewport. Likewise, if there were multiple inline children, the union of their
    bounds would contribute to the surface size.
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们将其放入合成层中，它需要与文本宽度或整个视口宽度相同吗？在实践中，你可以实现任一方式。本章中提出的算法最终得到的是较小的那个，但真实浏览器有时会选择较大的，这取决于它们的算法。此外，请注意，如果与包含文本的块元素相关的任何绘图命令（如背景颜色）存在，则表面宽度肯定需要与视口宽度相同。同样，如果有多个内联子元素，它们的边界并集将影响表面大小。
- en: Compositing Leaves
  id: totrans-2603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合叶片
- en: Let’s implementing compositing. We’ll need to identify paint commands and move
    them to composited layers. Then we’ll need to create the draw display list that
    combines these composited layers with visual effects. To keep things simple, we’ll
    start by creating a composited layer for every paint command.
  id: totrans-2604
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现合成。我们需要识别绘图命令并将它们移动到合成层中。然后我们需要创建一个绘图显示列表，将合成层与视觉效果结合起来。为了简化问题，我们将从为每个绘图命令创建一个合成层开始。
- en: 'To identify paint commands, it’ll be helpful to give them all a `PaintCommand`
    superclass:'
  id: totrans-2605
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别绘图命令，给它们都指定一个`PaintCommand`超类将很有帮助：
- en: '[PRE617]'
  id: totrans-2606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: 'Now each paint command needs to be a subclass of `PaintCommand`; to do that,
    you need to name the superclass when the class is declared and also use some special
    syntax in the constructor:'
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每一个绘图命令都需要是`PaintCommand`的一个子类；为了做到这一点，你需要在声明类的时候指定超类，并在构造函数中使用一些特殊的语法：
- en: '[PRE618]'
  id: totrans-2608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '`MakeLTRB` creates the `rect` for the `PaintCommand` constructor. We can also
    give a superclass to visual effects:'
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeLTRB`为`PaintCommand`构造函数创建`rect`。我们也可以为视觉效果指定一个超类：'
- en: '[PRE619]'
  id: totrans-2610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: Note that since visual effects have children, we need to not only pass those
    to the constructor, but also add their `rect` fields to our own. I use the `makeOffset`
    function to make a copy of the original `rect`, which is then grown by later `join`
    methods to include all of the children as well.
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于视觉效果有子元素，我们不仅需要将它们传递给构造函数，还需要将它们的`rect`字段添加到我们自己的中。我使用`makeOffset`函数来复制原始的`rect`，然后通过后续的`join`方法将其扩展以包括所有子元素。
- en: Go ahead and modify each paint command and visual effect class to be a subclass
    of one of these two new classes. Make sure you declare the superclass on the `class`
    line and also call the superclass constructor in the `__init__` method using the
    `super()` syntax.
  id: totrans-2612
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，修改每个绘图命令和视觉效果类，使它们成为这两个新类之一的一个子类。确保你在`class`行上声明超类，并在`__init__`方法中使用`super()`语法调用超类构造函数。
- en: 'We can now list all of the paint commands using `tree_to_list`:'
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `tree_to_list` 列出所有的绘图命令：
- en: '[PRE620]'
  id: totrans-2614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: 'Next we need to group paint commands into layers. For now, let’s do the simplest
    possible thing and put each paint command into its own `CompositedLayer`:'
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们需要将绘图命令分组到层中。目前，让我们做最简单的事情，将每个绘图命令放入它自己的 `CompositedLayer`:'
- en: '[PRE621]'
  id: totrans-2616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: Here, a `CompositedLayer` just stores a list of *display items* (and a surface
    that they’ll be drawn to).For now, it’s just one display item, but that will change
    pretty soon.
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个 `CompositedLayer` 只存储一个 *显示项* 的列表（以及它们将被绘制到的表面）。目前，它只有一个显示项，但很快就会改变。
- en: '[PRE622]'
  id: totrans-2618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: Now we need a draw display list that combines the composited layers. To build
    this we’ll walk up from each composited layer and build a chain of all of the
    visual effects applied to it, with a `DrawCompositedLayer` at the bottom of the
    chain.
  id: totrans-2619
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个组合层来组合绘图显示列表。为此，我们将从每个合成层向上遍历，构建应用到它的所有视觉效果链，链的底部是 `DrawCompositedLayer`。
- en: 'First, to make it easy to access those ancestor visual effects and compare
    them, let’s add parent pointers to our display list tree:'
  id: totrans-2620
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了方便访问那些祖先视觉效果并比较它们，让我们在我们的显示列表树中添加父指针：
- en: '[PRE623]'
  id: totrans-2621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: 'Next, we’ll need to *clone* each of the ancestors of the layer’s paint commands
    and inject new children, so let’s add a new `clone` method to the visual effects
    classes. For `Blend`, it’ll create a new `Blend` with the same parameters but
    new children:'
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要克隆层绘图命令的每个祖先并注入新的子命令，因此让我们为视觉效果类添加一个新的 `clone` 方法。对于 `Blend`，它将创建一个新的
    `Blend`，具有相同的参数但新的子命令：
- en: '[PRE624]'
  id: totrans-2623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: Our browser won’t be cloning paint commands, since they’re all going to be inside
    a composited layer, so we don’t need to implement `clone` for them.
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器不会克隆绘图命令，因为它们都将位于组合层内部，所以我们不需要为它们实现 `clone`。
- en: 'We can now build the draw display list. For each composited layer, create a
    `DrawCompositedLayer` command (which we’ll define in just a moment). Then, walk
    up the display list, wrapping that `DrawCompositedLayer` in each visual effect
    that applies to that composited layer:'
  id: totrans-2625
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以构建绘图显示列表。对于每个合成层，创建一个 `DrawCompositedLayer` 命令（我们将在稍后定义它）。然后，遍历显示列表，将
    `DrawCompositedLayer` 包裹在应用到该合成层的每个视觉效果中：
- en: '[PRE625]'
  id: totrans-2626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: The code in `paint_draw_list` just walks up from each composited layer, recreating
    all of the effects applied to it. This will work—mostly—but if one effect applies
    to more than one composited layer, it’ll turn into multiple identical effects,
    applied separately to each composited layer. That’s not right, because as we discussed
    in [Chapter 11](visual-effects.html), the order of operations matters.
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
  zh: '`paint_draw_list` 中的代码只是从每个合成层向上遍历，重新创建应用到的所有效果。这基本上是可行的，但如果一个效果应用到多个合成层，它将变成多个相同的效果，分别应用到每个合成层。这是不正确的，因为我们已经在
    [第11章](visual-effects.html) 中讨论过，操作顺序很重要。'
- en: 'Let’s fix that by reusing cloned effects:'
  id: totrans-2628
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过重用克隆的效果来修复这个问题：
- en: '[PRE626]'
  id: totrans-2629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: That’s it! Now that we’ve split the display list into composited layers and
    a draw display list, we need to update the rest of the browser to use them for
    raster and draw.
  id: totrans-2630
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在我们已经将显示列表分割成组合层和绘图显示列表，我们需要更新浏览器以使用它们进行光栅化和绘图。
- en: 'Let’s start with raster. In the raster step, the browser needs to walk the
    list of composited layers and raster each:'
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从光栅化开始。在光栅化步骤中，浏览器需要遍历组合层的列表并对每个进行光栅化：
- en: '[PRE627]'
  id: totrans-2632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: 'Inside `raster`, the composited layer needs to allocate a surface to raster
    itself into; this requires knowing how big it is. That’s just the union of the
    bounding boxes of all of its paint commands—the `rect` field:'
  id: totrans-2633
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `raster` 内部，合成层需要分配一个表面来将其光栅化到；这需要知道它的大小。这仅仅是所有绘图命令的边界框的并集——`rect` 字段：
- en: '[PRE628]'
  id: totrans-2634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: 'We’ll create a surface just big enough to store the items in this composited
    layer; this reduces how much GPU memory we need. That being said, there are some
    tricky corner cases to consider, such as how Skia rasters lines or anti-aliased
    text across multiple pixels in order to look nice or align with the pixel grid.One
    pixel of “slop” around the edges is not good enough for a real browser, which
    has to deal with lots of really subtle issues like nicely blending pixels between
    adjacent composited layers, subpixel positioning, and effects like blur filters
    with infinite theoretical extent. So let’s add in one extra pixel on each side
    to account for that:'
  id: totrans-2635
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个刚好足够存储这个合成层中项目的表面；这减少了我们需要多少GPU内存。但话虽如此，还有一些棘手的边缘情况需要考虑，例如Skia如何光栅化线条或抗锯齿文本以使其看起来不错或与像素网格对齐。边缘周围的“误差”像素对于一个真正的浏览器来说是不够的，它必须处理许多非常微妙的问题，比如在相邻合成层之间很好地混合像素、亚像素定位以及具有无限理论范围的模糊滤镜等效果。所以让我们在每边额外添加一个像素来解决这个问题：
- en: '[PRE629]'
  id: totrans-2636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: 'And now we can make the surface with those bounds:'
  id: totrans-2637
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用这些边界来创建表面：
- en: '[PRE630]'
  id: totrans-2638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: 'To raster the composited layer, draw all of its display items to this surface.
    The only tricky part is the need to offset by the `top` and `left` of the composited
    bounds, since the surface bounds don’t include that offset:'
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
  zh: 要光栅化合成层，将所有显示项目绘制到这个表面上。唯一棘手的部分是需要偏移`top`和`left`，因为表面边界不包括这个偏移：
- en: '[PRE631]'
  id: totrans-2640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: 'That’s all for the raster phase. For the draw phase, we’ll first need to implement
    the `DrawCompositedLayer` command. It takes a composited layer to draw:'
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
  zh: 光栅化阶段就到这里。对于绘制阶段，我们首先需要实现`DrawCompositedLayer`命令。它接受一个要绘制的合成层：
- en: '[PRE632]'
  id: totrans-2642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: 'Executing a `DrawCompositedLayer` is straightforward—just draw its surface
    into the parent surface, adjusting for the correct offset:'
  id: totrans-2643
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`DrawCompositedLayer`很简单——只需将其表面绘制到父表面上，调整正确的偏移：
- en: '[PRE633]'
  id: totrans-2644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: 'Compared with raster, the browser’s `draw` phase is satisfyingly simple: simply
    execute the draw display list.'
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
  zh: 与光栅化相比，浏览器的`draw`阶段相当简单：只需执行绘制显示列表。
- en: '[PRE634]'
  id: totrans-2646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: All that’s left is wiring these methods up; let’s rename `raster_and_draw` to
    `composite_raster_and_draw` (to remind us that there’s now an additional composite
    step) and add our two new methods. (And don’t forget to rename the corresponding
    dirty bit and call sites.)
  id: totrans-2647
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是将这些方法连接起来；让我们将`raster_and_draw`重命名为`composite_raster_and_draw`（以提醒我们现在有一个额外的合成步骤）并添加我们的两个新方法。（别忘了重命名相应的脏位和调用点。）
- en: '[PRE635]'
  id: totrans-2648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: So simple and elegant! Now, on every frame, we are simply splitting the display
    list into composited layers and the draw display list, and then running each of
    those in their own phase. We’re now half way toward getting super-smooth animations.
    What remains is skipping the layout and raster steps if the display list didn’t
    change much between frames.
  id: totrans-2649
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单而优雅！现在，在每一帧中，我们只是将显示列表分成合成层和绘制显示列表，然后分别在这些阶段运行它们。我们现在已经完成了一半，以获得超级平滑的动画。剩下的是，如果显示列表在帧之间变化不大，则跳过布局和光栅化步骤。
- en: The algorithm presented here is a simplified version of what Chromium actually
    implements. For more details and information on how Chromium implements these
    concepts see [blog](https://developer.chrome.com/blog/renderingng-data-structures/#display-lists-and-paint-chunks)
    [posts](https://developer.chrome.com/blog/renderingng-data-structures/#compositor-frames-surfaces-render-surfaces-and-gpu-texture-tiles)
    on the Chrome developer blog; other browsers do something broadly similar. Chromium’s
    implementation of the “visual effect nesting” data structure is called [property
    trees](https://developer.chrome.com/blog/renderingng-data-structures/#property-trees).
    The name is plural because there is more than one tree, due to the complex [containing
    block](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block) structure
    of scrolling and clipping.
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提出的算法是Chromium实际实现的一个简化版本。有关更多详细信息以及Chromium如何实现这些概念的信息，请参阅Chrome开发者博客上的[博客](https://developer.chrome.com/blog/renderingng-data-structures/#display-lists-and-paint-chunks)
    [文章](https://developer.chrome.com/blog/renderingng-data-structures/#compositor-frames-surfaces-render-surfaces-and-gpu-texture-tiles)；其他浏览器做的是类似的事情。Chromium对“视觉效果嵌套”数据结构的实现称为[属性树](https://developer.chrome.com/blog/renderingng-data-structures/#property-trees)。这个名字是复数形式，因为有多棵树，这是由于滚动和裁剪的复杂[包含块](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block)结构造成的。
- en: CSS Transitions
  id: totrans-2651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS过渡
- en: 'The key to not re-rastering layers is to know which layers have changed, and
    which haven’t. Right now, we’re basically always assuming all layers have changed,
    but ideally we’d know exactly what’s changed between frames. Browsers have all
    sorts of complex methods to achieve this,Chromium, for example, tries to [diff](https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/style/style_difference.h)
    the old and new styles any time a style changes on the page. But this is tricky,
    because a change in style on one element could be inherited by a different element,
    so diffing will always be somewhat brittle and incomplete. but to keep things
    simple, let’s implement a CSS feature that’s perfect for compositing: [CSS transitions](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions).'
  id: totrans-2652
  prefs: []
  type: TYPE_NORMAL
  zh: 不重新光栅化层的关键是知道哪些层已经改变，哪些没有改变。目前，我们基本上总是假设所有层都发生了变化，但理想情况下，我们想知道帧之间确切发生了什么变化。浏览器有各种复杂的方法来实现这一点，例如，Chromium会尝试在页面上的样式发生变化时[比较](https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/style/style_difference.h)新旧样式。但这很棘手，因为一个元素的样式变化可能会被另一个元素继承，所以比较总是有些脆弱和不完整。但为了简单起见，让我们实现一个适合合成使用的CSS功能：[CSS过渡](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions)。
- en: 'CSS transitions take the `requestAnimationFrame` loop we used to implement
    animations and move it “into the browser”. The web page just needs to add a CSS
    [`transition`](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions)
    property, which defines properties to animate and how long to animate them for.
    Here’s how to say opacity changes to a `div` should animate for two seconds:'
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
  zh: CSS过渡将我们用来实现动画的`requestAnimationFrame`循环“移动到浏览器中”。网页只需要添加一个CSS `transition`属性，该属性定义了要动画化的属性以及动画持续的时间。以下是如何表示将`div`的透明度变化动画设置为两秒的示例：
- en: '[PRE636]'
  id: totrans-2654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: Now, whenever the `opacity` property of a `div` changes for any reason—like
    from changing its style attribute—the browser smoothly interpolates between the
    old and new values for two seconds. Here is [an example](https://browser.engineering/examples/example13-opacity-transition.html).
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论出于何种原因（例如，改变其样式属性）更改`div`的`opacity`属性，浏览器都会在两秒钟内平滑地插值旧值和新值。这里有一个[示例](https://browser.engineering/examples/example13-opacity-transition.html)。
- en: '[examples/example13-opacity-transition.html](examples/example13-opacity-transition.html)'
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
  zh: '[examples/example13-opacity-transition.html](examples/example13-opacity-transition.html)'
- en: (click [here](examples/example13-opacity-transition.html) to load the example
    in your browser)
  id: totrans-2657
  prefs: []
  type: TYPE_NORMAL
  zh: (点击[这里](examples/example13-opacity-transition.html)在您的浏览器中加载示例)
- en: Visually, it looks more or less identicalIt’s not exactly the same, because
    our JavaScript code uses a linear interpolation (or *easing function*) between
    the old and new values. Real browsers use a non-linear default easing function
    for CSS transitions because it looks better. We’ll implement a linear easing function
    for our browser, so it will look identical to the JavaScript and subtly different
    from real browsers, but you can try adding it via Exercise 13-2. to the JavaScript
    animation. But since the browser *understands* the animation, it can optimize
    how the animation is run. For example, since `opacity` only affects `Blend` commands
    that end up in the draw display list, the browser knows that this animation does
    not require layout or raster, just paint and draw.
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，它看起来或多或少是相同的。但这并不完全一样，因为我们的JavaScript代码在旧值和新值之间使用线性插值（或*缓动函数*）。真实浏览器使用非线性的默认缓动函数进行CSS过渡，因为这样看起来更好。我们将为我们的浏览器实现一个线性缓动函数，所以它将看起来与JavaScript动画相同，但与真实浏览器略有不同，但你可以通过练习13-2尝试添加它到JavaScript动画中。但是，由于浏览器*理解*动画，它可以优化动画的运行方式。例如，由于`opacity`只影响最终进入绘制显示列表的`Blend`命令，浏览器知道这个动画不需要布局或光栅化，只需要绘制和绘制。
- en: To implement CSS transitions, we’ll need to represent animation state—like the
    JavaScript variables `current_frame` and `change_per_frame` from the earlier example—in
    the browser. Since multiple elements can animate at a time, let’s store an `animations`
    dictionary on each node, keyed by the property being animated:For simplicity,
    this code leaves animations in the `animations` dictionary even when they’re done
    animating. Removing them would be necessary, however, for really long-running
    tabs where just looping over all the already-completed animations can take a while.
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 CSS 过渡，我们需要在浏览器中表示动画状态——就像之前示例中的 JavaScript 变量 `current_frame` 和 `change_per_frame`——让我们在每个节点上存储一个
    `animations` 字典，以动画的属性为键：为了简单起见，此代码在动画完成后仍然将动画保留在 `animations` 字典中。然而，对于运行时间非常长的标签页，删除它们是必要的，因为仅仅遍历所有已完成的动画可能需要一段时间。
- en: '[PRE637]'
  id: totrans-2660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: 'The simplest type of thing to animate is numeric properties like `opacity`:'
  id: totrans-2661
  prefs: []
  type: TYPE_NORMAL
  zh: 要动画化的最简单类型是数值属性，如 `opacity`：
- en: '[PRE638]'
  id: totrans-2662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: 'Much like in JavaScript, we’ll need an `animate` method that increments the
    frame count, computes the new value and returns it:'
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JavaScript 类似，我们需要一个 `animate` 方法，该方法增加帧计数，计算新值并返回它：
- en: '[PRE639]'
  id: totrans-2664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: 'We’ll create these animation objects every time a style value changes, which
    we can detect in `style` by diffing the old and new styles of each node:'
  id: totrans-2665
  prefs: []
  type: TYPE_NORMAL
  zh: 每当样式值发生变化时，我们将创建这些动画对象，我们可以在 `style` 中通过比较每个节点的旧样式和新样式来检测这种变化：
- en: '[PRE640]'
  id: totrans-2666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: This `diff_styles` function is going to look for all properties that are mentioned
    in the `transition` property and are different between the old and the new style.
    So first, we’re going to have to parse the `transition` value.
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `diff_styles` 函数将查找在 `transition` 属性中提到且在旧样式和新样式之间不同的所有属性。因此，首先，我们必须解析 `transition`
    值。
- en: 'The first challenge is, annoyingly, that at the moment our CSS parser doesn’t
    recognize `opacity 2s` as a valid CSS value, since it parses values as a single
    word. Let’s upgrade the parser to recognize any string of characters except one
    of a specified set of `chars`:'
  id: totrans-2668
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个挑战是，令人烦恼的是，目前我们的 CSS 解析器不识别 `opacity 2s` 作为有效的 CSS 值，因为它将值解析为单个单词。让我们升级解析器以识别除指定集合中的
    `chars` 之外的所有字符字符串：
- en: '[PRE641]'
  id: totrans-2669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: 'Inside a CSS rule body, a property value continues until a semicolon or a close
    curly brace:'
  id: totrans-2670
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CSS 规则体内部，属性值会持续到分号或闭合的大括号：
- en: '[PRE642]'
  id: totrans-2671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: Now that we parse the CSS property, we can parse out the properties with transitions:Note
    that this returns a dictionary mapping property names to transition durations,
    measured in frames.
  id: totrans-2672
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们解析了 CSS 属性，我们可以解析出具有过渡效果的属性：请注意，这返回一个字典，将属性名称映射到过渡持续时间，以帧为单位。
- en: '[PRE643]'
  id: totrans-2673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: Now `diff_style` can loop through all of the properties mentioned in `transition`
    and see which ones changed. It returns a dictionary containing only the transitioning
    properties, and mapping each such property to its old value, new value, and duration
    (again in frames).Note also that this code has to deal with subtleties like the
    `transition` property being added or removed, or properties being removed instead
    of changing values.
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `diff_style` 可以遍历 `transition` 中提到的所有属性，并查看哪些属性已更改。它返回一个只包含过渡属性的字典，并将每个这样的属性映射到其旧值、新值和持续时间（再次以帧为单位）。请注意，此代码还必须处理诸如
    `transition` 属性被添加或删除，或属性被删除而不是更改值等细微差别。
- en: '[PRE644]'
  id: totrans-2675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: Back inside `style`, we’re going to want to create a new animation object for
    each transitioning property—we’ll support only `opacity`.
  id: totrans-2676
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `style` 内部，我们想要为每个正在过渡的属性创建一个新的动画对象——我们将仅支持 `opacity`。
- en: '[PRE645]'
  id: totrans-2677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: Any time a property listed in a `transition` changes its value, we create an
    animation and get ready to run it.Note that we need to call `set_needs_render`
    here to make sure that the animation will run on the next frame.
  id: totrans-2678
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在 `transition` 中列出的属性值发生变化时，我们都会创建一个动画并准备运行它。请注意，我们需要在这里调用 `set_needs_render`，以确保动画将在下一帧运行。
- en: 'Running the animation entails iterating through all the active animations on
    the page and calling `animate` on them. Since CSS transitions are similar to `requestAnimationFrame`
    animations, let’s run animations right after handling `requestAnimationFrame`
    callbacks:'
  id: totrans-2679
  prefs: []
  type: TYPE_NORMAL
  zh: 运行动画意味着遍历页面上的所有活动动画，并对它们调用 `animate` 方法。由于 CSS 过渡与 `requestAnimationFrame` 动画类似，让我们在处理完
    `requestAnimationFrame` 回调后立即运行动画：
- en: '[PRE646]'
  id: totrans-2680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: Inside this loop we need to do two things. First, call the animation’s `animate`
    method and save the new value to the node’s `style`. Second, since that changes
    rendering inputs, set a dirty bit requiring rendering later.We also need to schedule
    an animation frame for the next frame of the animation, but `set_needs_render`
    already does that for us. The whole rendering cycle between the browser and main
    threads is summarized in Figure 2.
  id: totrans-2681
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环中，我们需要做两件事。首先，调用动画的 `animate` 方法并将新值保存到节点的 `style` 中。其次，由于这改变了渲染输入，设置一个脏位要求稍后进行渲染。我们还需要为动画的下一次帧调度一个动画帧，但
    `set_needs_render` 已经为我们做了这件事。浏览器和主线程之间的整个渲染周期总结在图 2 中。
- en: '![Figure 2: The rendering cycle between the browser and main threads.](img/7a9bd1ef8fd7d17d0f7014a62263b95f.png)'
  id: totrans-2682
  prefs: []
  type: TYPE_IMG
  zh: '![图 2：浏览器和主线程之间的渲染周期](img/7a9bd1ef8fd7d17d0f7014a62263b95f.png)'
- en: 'Figure 2: The rendering cycle between the browser and main threads.'
  id: totrans-2683
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：浏览器和主线程之间的渲染周期。
- en: However, it’s not as simple as just setting `needs_render` any time an animation
    is active. Setting `needs_render` means re-running `style`, which would notice
    that the animation changed a property value and start a *new* animation! During
    an animation, we want to run `layout` and `paint`, but we *don’t* want to run
    `style`:While a real browser definitely has an analog of the `needs_layout` and
    `needs_paint` flags, our fix for restarting animations doesn’t handle a bunch
    of edge cases. For example, if a different style property than the one being animated
    changes, the browser shouldn’t restart the animation. Real browsers do things
    like storing multiple copies of the style—the computed style and the animated
    style—to solve issues like this.
  id: totrans-2684
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不像动画激活时设置 `needs_render` 那么简单。设置 `needs_render` 意味着重新运行 `style`，这会注意到动画改变了属性值并启动一个新的动画！在动画期间，我们想要运行
    `layout` 和 `paint`，但我们不想要运行 `style`：虽然真实浏览器确实有 `needs_layout` 和 `needs_paint`
    标志的类似物，但我们修复重启动画的方法没有处理许多边缘情况。例如，如果被动画化的样式属性之外的样式属性发生了变化，浏览器不应该重启动画。真实浏览器会像存储多个样式副本（计算样式和动画样式）这样的方式来解决这类问题。
- en: '[PRE647]'
  id: totrans-2685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: 'To implement `set_needs_layout`, we’ve got to replace the single `needs_render`
    flag with three flags: `needs_style`, `needs_layout`, and `needs_paint`. In our
    implementation, setting a dirty bit earlier in the pipeline will end up causing
    everything after it to also run,This is yet another difference from real browsers,
    which optimize some cases that just require style and paint, or other combinations.
    so `set_needs_render` still just sets the `needs_style` flag:'
  id: totrans-2686
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `set_needs_layout`，我们需要将单个 `needs_render` 标志替换为三个标志：`needs_style`、`needs_layout`
    和 `needs_paint`。在我们的实现中，在管道中较早设置一个脏位会导致其后的所有内容也运行，这与真实浏览器不同，真实浏览器会优化只需要样式和绘制或其它组合的情况。因此，`set_needs_render`
    仍然只设置 `needs_style` 标志：
- en: '[PRE648]'
  id: totrans-2687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: 'Now we can write a `set_needs_layout` method that sets flags for the `layout`
    and `paint` phases, but not the `style` phase:'
  id: totrans-2688
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个 `set_needs_layout` 方法，为 `layout` 和 `paint` 阶段设置标志，但不为 `style` 阶段设置：
- en: '[PRE649]'
  id: totrans-2689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: To support these new dirty bits, `render` must check each phase’s bit instead
    of checking `needs_render` at the start:By the way, this *does* obsolete our tracing
    code for how long rendering takes. Rendering now does different work on different
    frames, so measuring rendering overall doesn’t really make sense! I’m going to
    leave this be and just not look at the rendering measures anymore, but the best
    fix would be to have three trace events for the three phases of `render`.
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这些新的脏位，`render` 必须检查每个阶段的位，而不是在开始时检查 `needs_render`：顺便说一句，这确实使我们的跟踪代码对于渲染所需时间变得过时。现在渲染在不同的帧上做不同的工作，所以测量整体渲染实际上没有意义！我打算让它保持原样，不再查看渲染度量，但最好的修复方法是对于
    `render` 的三个阶段有三个跟踪事件。
- en: '[PRE650]'
  id: totrans-2691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: Well—with all that done, our browser now supports animations with just CSS.
    And importantly, we can have the browser optimize opacity animations to avoid
    layout.
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
  zh: 好了——完成所有这些后，我们的浏览器现在支持仅使用 CSS 的动画。更重要的是，我们可以让浏览器优化不透明度动画以避免布局。
- en: CSS transitions are great for adding animations triggered by DOM updates from
    JavaScript. But what about animations that are just part of a page’s UI, and not
    connected to a visual transition? (For example, a pulse opacity animation on a
    button or cursor.) This can be expressed directly in CSS without any JavaScript
    with a [CSS animation](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations).
  id: totrans-2693
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 过渡非常适合添加由 JavaScript 触发的 DOM 更新触发的动画。但对于只是页面 UI 的一部分，而不是与视觉过渡相关的动画怎么办？（例如，按钮或光标的脉冲不透明度动画。）这可以直接在
    CSS 中表达，而不需要任何 JavaScript，使用 [CSS 动画](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations)。
- en: You can see the CSS animation variant of the opacity demo [here](examples/example13-opacity-animation.html).
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[这里](examples/example13-opacity-animation.html)查看 CSS 动画变体的不透明度演示。
- en: Implementing this feature requires parsing a new `@keyframes` syntax and the
    `animation` CSS property. Notice how `@keyframes` defines the start and end point
    declaratively, which allows us to make the animation alternate infinitely because
    a reverse is just going backward among the keyframes. There is also the [Web Animations
    API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API), which
    allows creation and management of animations via JavaScript.
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此功能需要解析新的 `@keyframes` 语法和 `animation` CSS 属性。注意 `@keyframes` 如何声明性地定义起点和终点，这使得我们可以使动画无限交替，因为反向只是关键帧中的向后移动。还有
    [Web 动画 API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API)，它允许通过
    JavaScript 创建和管理动画。
- en: Composited Animations
  id: totrans-2696
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合动画
- en: 'We’re finally ready to teach the browser how to avoid raster (and layout) when
    running certain animations. These are called *composited animations*, since they
    are compatible with the compositing optimization to avoid raster on every frame.
    Avoiding `raster` and `composite` for opacity animations is simple in concept:
    keep track of what is animating, and re-run only `paint`, `paint_draw_list` and
    `draw` on each frame.'
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好教浏览器如何在运行某些动画时避免光栅化（和布局）。这些被称为 *复合动画*，因为它们与合成优化兼容，可以避免每帧的光栅化。避免不透明度动画的光栅化和合成在概念上很简单：跟踪正在动画化的内容，并在每一帧上仅重新运行
    `paint`、`paint_draw_list` 和 `draw`。
- en: Implementing this is harder than it sounds. We’ll need to split the *new* display
    list into the *old* composited layers and a *new* draw display list. To do this
    we’ll need to know how the new and old display lists are related, and what parts
    of the display list changed. For this purpose we’ll add a `node` field to each
    display item, storing the node that painted it, as a sort of identifier:Note that
    the browser thread can never *access* that node, since it is owned by another
    thread. But it can use the node as an identifier.
  id: totrans-2698
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点比听起来更难。我们需要将新的显示列表拆分为旧的合成层和新的绘制显示列表。为此，我们需要知道新的和旧的显示列表是如何相关的，以及显示列表的哪些部分发生了变化。为此，我们将为每个显示项添加一个
    `node` 字段，存储绘制它的节点，作为某种标识符：请注意，浏览器线程永远不能 *访问* 该节点，因为它属于另一个线程。但它可以使用节点作为标识符。
- en: '[PRE651]'
  id: totrans-2699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: Now, when an animation runs—but nothing else changes—we’ll use these nodes to
    determine which display items in the draw display list we need to update.
  id: totrans-2700
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当一个动画运行但其他内容没有变化时，我们将使用这些节点来确定需要更新的绘制显示列表中的哪些显示项。
- en: 'First, when a composited animation runs, save the `Element` whose style was
    changed in a new array called `composited_updates`. We’ll also only set the `needs_paint`
    flag, not `needs_layout`, in this case:'
  id: totrans-2701
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当一个复合动画运行时，将样式发生变化的 `Element` 保存到一个名为 `composited_updates` 的新数组中。在这种情况下，我们也将只设置
    `needs_paint` 标志，而不是 `needs_layout`：
- en: '[PRE652]'
  id: totrans-2702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: Now, when we `commit` a frame which only needs the paint phase, send the `composited_updates`
    over to the browser, which will use that to skip composite and raster. The data
    to be sent across for each animation update will be an `Element` and a `Blend`.
  id: totrans-2703
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们提交一个只需要绘制阶段的帧时，将 `composited_updates` 发送到浏览器，浏览器将使用这些信息跳过合成和光栅化。每个动画更新要发送的数据将是一个
    `Element` 和一个 `Blend`。
- en: 'To accomplish this we’ll need several steps. First, when painting a `Blend`,
    record it on the `Element`:'
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此操作，我们需要几个步骤。首先，在绘制 `Blend` 时，将其记录在 `Element` 上：
- en: '[PRE653]'
  id: totrans-2705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: Next, add a list of composited updates to `CommitData` (each of which will contain
    the `Element` and `Blend` pointers).
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将一个包含复合更新的列表添加到 `CommitData` 中（每个都将包含 `Element` 和 `Blend` 指针）。
- en: '[PRE654]'
  id: totrans-2707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: And finally, commit the new information.Note the distinction between `None`
    and `{}` for `composited_updates`. `None` means that the compositing step is needed,
    whereas `{}` means that it is not—the dictionary just happens to be empty, because
    there aren’t any composited animations running. A good example of the latter is
    changes to scroll, which don’t affect compositing, yet are not animated.
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，提交新的信息。注意 `composited_updates` 中 `None` 和 `{}` 的区别。`None` 表示需要合成步骤，而 `{}`
    表示不需要——字典恰好是空的，因为没有正在运行的合成动画。后者的一个好例子是滚动更改，它不会影响合成，但也不是动画。
- en: '[PRE655]'
  id: totrans-2709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: 'Now for the browser thread. First, add `needs_composite`, `needs_raster` and
    `needs_draw` dirty bits and corresponding `set_needs_composite`, `set_needs_raster`,
    and `set_needs_draw` methods (and remove the old dirty bit):'
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑浏览器线程。首先，添加 `needs_composite`、`needs_raster` 和 `needs_draw` 脏位以及相应的 `set_needs_composite`、`set_needs_raster`
    和 `set_needs_draw` 方法（并移除旧的脏位）：
- en: '[PRE656]'
  id: totrans-2711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: 'Then, where we currently call `set_needs_raster_and_draw`, such as `handle_down`,
    we need to call `set_needs_raster`:'
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们目前称为 `set_needs_raster_and_draw` 的地方，例如 `handle_down`，我们需要调用 `set_needs_raster`：
- en: '[PRE657]'
  id: totrans-2713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: 'Use the data passed in `commit` to decide whether to call `set_needs_composite`
    or `set_needs_draw`, and store off the updates in `composited_updates`:'
  id: totrans-2714
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `commit` 中传入的数据来决定是否调用 `set_needs_composite` 或 `set_needs_draw`，并将更新存储在 `composited_updates`
    中：
- en: '[PRE658]'
  id: totrans-2715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: Now let’s think about the draw step. Normally, we create the draw display list
    from the composited layers. But that won’t quite work now, because the composited
    layers come from the *old* display list. If we just try re-running `paint_draw_list`,
    we’ll get the old draw display list! We need to update `draw_list` to take into
    account the new display list based on the `composited_updates`.
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑绘制步骤。通常，我们根据合成层创建绘制显示列表。但现在这不会完全起作用，因为合成层来自 *旧* 的显示列表。如果我们只是尝试重新运行 `paint_draw_list`，我们将得到旧的绘制显示列表！我们需要更新
    `draw_list` 以考虑基于 `composited_updates` 的新显示列表。
- en: 'To do so, define a method `get_latest` that gets an updated visual effect from
    `composited_updates` if there is one:'
  id: totrans-2717
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，定义一个 `get_latest` 方法，如果存在，则从 `composited_updates` 获取更新的视觉效果：
- en: '[PRE659]'
  id: totrans-2718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: 'Using `get_latest` in `paint_draw_list` is a one-liner:'
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `paint_draw_list` 中使用 `get_latest` 是一行代码：
- en: '[PRE660]'
  id: totrans-2720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: Update the rest of the `while` loop in `paint_draw_list` to refer to `new_parent`
    instead of `parent` when creating new effects (but not when walking up from the
    composited layer).
  id: totrans-2721
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `paint_draw_list` 中的 `while` 循环的其余部分更新为在创建新效果时引用 `new_parent` 而不是 `parent`（但在从合成层向上遍历时除外）。
- en: Now the draw display list will be based on the new display list, and animations
    that only require the draw step, like our example opacity animation, will now
    run super smoothly.
  id: totrans-2722
  prefs: []
  type: TYPE_NORMAL
  zh: 现在绘制显示列表将基于新的显示列表，并且只需要绘制步骤的动画，如我们的示例不透明度动画，现在将运行得非常顺畅。
- en: 'One final note: the compositing data structures need to be cleared when changing
    tabs. Let’s do that by factoring out a `clear_data` method that clears everything
    in one go.'
  id: totrans-2723
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：在更改标签时需要清除合成数据结构。让我们通过提取一个 `clear_data` 方法来一次性清除所有内容来完成这项工作。
- en: '[PRE661]'
  id: totrans-2724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: 'Figure 3 shows a screenshot of a rendered frame of an opacity transition that
    only spends a bit more than a millisecond in each `composite_raster_and_draw`
    call (source trace [here](examples/example13-opacity-transition.trace)):'
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
  zh: 图3显示了仅在每个 `composite_raster_and_draw` 调用中花费略多于毫秒的不透明度转换渲染帧的截图（源跟踪[这里](examples/example13-opacity-transition.trace)）：
- en: '![Figure 3: Example trace of an opacity transition optimized by compositing.](img/b92c986b39b08a3f9adb3ede90e48901.png)'
  id: totrans-2726
  prefs: []
  type: TYPE_IMG
  zh: '![图3：通过合成优化的不透明度转换示例跟踪。](img/b92c986b39b08a3f9adb3ede90e48901.png)'
- en: 'Figure 3: Example trace of an opacity transition optimized by compositing.'
  id: totrans-2727
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：通过合成优化的不透明度转换示例跟踪。
- en: This can be compared to the same with compositing disabled, shown in Figure
    4, which spends about double that time (source [here](examples/example13-opacity-transition-no-compositing.trace)):And
    it would be much slower for a more complex example.
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以与禁用合成的相同情况相比较，如图4所示，它花费的时间大约是前者的一倍（源[这里](examples/example13-opacity-transition-no-compositing.trace)）：对于更复杂的示例，这会慢得多。
- en: '![Figure 4: Example trace of an opacity transition with compositing disabled.](img/d5480b40e6c0ac8b3e0de4b260318b88.png)'
  id: totrans-2729
  prefs: []
  type: TYPE_IMG
  zh: '![图4：禁用合成时的不透明度转换示例跟踪。](img/d5480b40e6c0ac8b3e0de4b260318b88.png)'
- en: 'Figure 4: Example trace of an opacity transition with compositing disabled.'
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：禁用合成时的不透明度转换示例跟踪。
- en: 'While visual effect animations in our browser are now efficient and *composited*,
    they are not *threaded* in the sense of [Chapter 12](scheduling.html#threaded-scrolling):
    the animation still ticks on the main thread, and if there is some slow JavaScript
    or other task clogging the task queue, animations will stutter. This is a significant
    problem for real browsers, so almost all of them support threaded opacity, transform,
    and filter animations; some support certain kinds of clip animations as well.
    Adding threaded animations to our browser is left as Execise 13-3.'
  id: totrans-2731
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们浏览器中的视觉效果动画现在既高效又*合成*，但它们在[第12章](scheduling.html#threaded-scrolling)的意义上并不是*线程化*的：动画仍然在主线程上运行，如果有慢速JavaScript或其他任务阻塞了任务队列，动画将会卡顿。这对真正的浏览器来说是一个重大问题，因此几乎所有浏览器都支持线程化的透明度、变换和滤镜动画；一些浏览器还支持某些类型的剪辑动画。将线程化动画添加到我们的浏览器中留作练习13-3。
- en: Nevertheless, it’s common to hear people use “composited” and “threaded” as
    synonyms. That’s because in most browsers, compositing is a *prerequisite* for
    threading. The reason is that if you’re going to animate efficiently, you usually
    need to composite a texture anyway, and plumbing animations on GPU textures is
    much easier to express in a browser than an animation on “part of a display list”.
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，人们经常听到将“合成”和“线程化”用作同义词。这是因为在大多数浏览器中，合成是线程化的先决条件。原因是如果你打算高效地动画化，你通常需要合成纹理，而在GPU纹理上处理动画比在“显示列表的一部分”上处理动画更容易在浏览器中表达。
- en: That being said, it’s not impossible to animate display lists, and some browsers
    have attempted it. For example, one aim of the [WebRender](https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/)
    project at Mozilla is to get rid of cached composited layers entirely, and perform
    all animations by rastering and drawing at 60 Hz on the GPU directly from the
    display list. This is called a *direct render* approach. In practice this goal
    is hard to achieve with current GPU technology, because some GPUs are faster than
    others. So browsers are slowly evolving to a hybrid of direct rendering and compositing
    instead.
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，对显示列表进行动画化并非不可能，一些浏览器已经尝试过。例如，Mozilla的[WebRender](https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/)项目的一个目标就是完全消除缓存的合成层，并通过在GPU上直接从显示列表以60Hz进行光栅化和绘制来执行所有动画。这被称为*直接渲染*方法。实际上，由于一些GPU比其他GPU快，这个目标在当前的GPU技术下很难实现。因此，浏览器正逐渐演变成直接渲染和合成的混合体。
- en: While all modern browsers have threaded animations, it’s interesting to note
    that, as of the time of writing, Chromium and WebKit both perform the `compositing`
    step on the main thread, whereas our browser does it on the browser thread. In
    this area, our browser is actually ahead of real browsers! The reason compositing
    doesn’t (yet) happen on another thread in Chromium is that to get there took re-architecting
    the entire algorithm for compositing. This turned out to be extremely difficult,
    because the old architecture was deeply intertwined with nearly every aspect of
    the rendering engine. It was only [completed in 2021](https://developer.chrome.com/blog/renderingng/#compositeafterpaint),
    so perhaps sometime soon this work will be threaded in Chromium.
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有现代浏览器都有线程化的动画，但值得注意的是，截至写作之时，Chromium和WebKit都在主线程上执行合成步骤，而我们的浏览器在浏览器线程上执行。在这方面，我们的浏览器实际上比真正的浏览器更先进！合成尚未（目前）在Chromium的另一个线程上发生，原因是为了达到这个目标需要对整个合成算法进行重构。这证明是非常困难的，因为旧架构与渲染引擎的几乎所有方面都紧密相连。它直到2021年才完成[完成](https://developer.chrome.com/blog/renderingng/#compositeafterpaint)，所以也许不久这项工作将在Chromium中线程化。
- en: Optimizing Compositing
  id: totrans-2735
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化合成
- en: 'At this point, our browser successfully runs composited animations while avoiding
    needless layout and raster. But compared to a real browser, there are *way* too
    many composited layers—one per paint command! That is a big waste of GPU memory
    and time: each composited layer allocates a surface, and each of those allocates
    and holds on to GPU memory. GPU memory is limited, and we want to use less of
    it when possible.'
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的浏览器成功运行了合成的动画，同时避免了不必要的布局和光栅化。但是，与真正的浏览器相比，我们的浏览器有太多的合成层——每个绘制命令一个！这是一个巨大的GPU内存和时间浪费：每个合成层分配一个表面，并且每个表面都分配和保留GPU内存。GPU内存是有限的，我们希望在可能的情况下使用更少的内存。
- en: To that end, we’d like to use fewer composited layers. The simplest thing we
    can do is put paint commands into the same composited layer if they have the exact
    same set of ancestor visual effects in the display list.
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，我们希望使用更少的合成层。我们能做的最简单的事情是将具有显示列表中完全相同祖先视觉效果集合的绘图命令放入同一个合成层。
- en: 'Let’s implement that. We’ll need two new methods on composited layers: `add`
    and `can_merge`. The `add` method just adds a new display item to a composited
    layer:'
  id: totrans-2738
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这一点。我们需要在合成层上实现两个新方法：`add` 和 `can_merge`。`add` 方法只是将一个新的显示项添加到合成层：
- en: '[PRE662]'
  id: totrans-2739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: 'But we should only add compatible display items to the same composited layer,
    determined by the `can_merge` method. A display item can be merged if it has the
    same parents as existing ones in the composited layer:'
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们应该只将兼容的显示项添加到同一个合成层，这由 `can_merge` 方法确定。一个显示项可以合并，如果它具有与合成层中现有项相同的父项：
- en: '[PRE663]'
  id: totrans-2741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: Now we want to use these methods in `composite`. Basically, instead of making
    a new composited layer for every single paint command, walk backwardBackward,
    because we can’t draw things in the wrong order. Later items in the display list
    have to draw later. through the `composited_layers` trying to find a composited
    layer to merge the command into:If you’re not familiar with Python’s `for ...
    else` syntax, the `else` block executes only if the loop never executed `break`.
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想在 `composite` 中使用这些方法。基本上，不是为每个绘图命令创建一个新的合成层，而是向后遍历，因为我们不能以错误的顺序绘制东西。显示列表中的后续项必须晚些时候绘制。通过
    `composited_layers` 尝试找到一个合成层来合并命令：如果你不熟悉 Python 的 `for ... else` 语法，`else` 块只有在循环从未执行
    `break` 时才会执行。
- en: '[PRE664]'
  id: totrans-2743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: With this implementation, multiple paint commands will sometimes end up in the
    same composited layer, but if the ancestor effects don’t *exactly* match, they
    won’t.
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种实现，多个绘图命令有时会最终位于同一个合成层中，但如果祖先效果不完全匹配，则不会。
- en: We can do even better by placing entire display list *subtrees* that aren’t
    animating into the same composited layer. This will let us put non-animating visual
    effects in the raster phase, reducing the number of composited layers even more.
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将整个非动画显示列表 *子树* 放入同一个合成层来做得更好。这将使我们能够在光栅阶段放置非动画视觉效果，从而进一步减少合成层的数量。
- en: 'To implement this, add a new `needs_compositing` field, which is `True` when
    a visual effect should go in the draw display list and `False` when it should
    go into a composited layer. We’ll set it to `False` for most visual effects:'
  id: totrans-2746
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，添加一个新的 `needs_compositing` 字段，当视觉效果应该在绘制显示列表中时，它为 `True`，当它应该在合成层中时，它为
    `False`。我们将大多数视觉效果设置为 `False`：
- en: '[PRE665]'
  id: totrans-2747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: 'We should set it to `True` when compositing would help us animate something.
    There are all sorts of complex heuristics real browsers use, but to keep things
    simple let’s just set it to `True` for `Blend`s (when they actually do something,
    not for no-ops), regardless of whether they are animating:'
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
  zh: 当合成有助于我们动画化某些内容时，我们应该将其设置为 `True`。真实浏览器使用各种复杂的启发式方法，但为了保持简单，让我们只为 `Blend` 设置为
    `True`（当它们实际上做了一些事情，而不是什么也不做），无论它们是否在动画：
- en: '[PRE666]'
  id: totrans-2749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: 'We’ll *also* need to mark a visual effect as needing compositing if any of
    its descendants do. That’s because if one effect is in the draw phase, then the
    ones above it will have to be as well:'
  id: totrans-2750
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何后代需要合成，我们还需要将视觉效果标记为需要合成。这是因为如果一个效果处于绘制阶段，那么它上面的效果也必须处于绘制阶段：
- en: '[PRE667]'
  id: totrans-2751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: 'Now, instead of layers containing bare paint commands, they can contain subtrees
    of non-composited commands:'
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再是包含裸露的绘图命令的层，它们可以包含非合成命令的子树：
- en: '[PRE668]'
  id: totrans-2753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: The multiple `if` statements inside the list comprehension are `and`-ed together.
  id: totrans-2754
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式内部的多个 `if` 语句被 `and` 连接在一起。
- en: Our compositing algorithm now creates way fewer layers! It does a good job of
    grouping together non-animating content to reduce the number of composited layers
    (which saves GPU memory), and doing as much non-animation work as possible in
    raster rather than draw (which makes composited animations faster).
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的合成算法创建的层要少得多！它很好地将非动画内容分组在一起，以减少合成层的数量（这节省了 GPU 内存），并在光栅而不是绘制中尽可能多地完成非动画工作（这使得合成动画更快）。
- en: 'At this point, the compositing algorithm and its effect on content is getting
    pretty complicated. It will be very useful to you to add in more visual debugging
    to help understand what is going on. One good way to do this is to add a [flag](https://docs.python.org/3/library/argparse.html)I
    also recommend you add a mode to your browser that disables compositing (that
    is, setting `needs_compositing` to `False` for every `VisualEffect`), and disables
    use of the GPU (that is, going back to the old way of making Skia surfaces). Everything
    should still work (albeit more slowly) in all of the modes, and you can use these
    additional modes to debug your browser more fully and benchmark its performance.
    to our browser that draws a red border around `CompositedLayer` content. This
    is a very simple addition to `CompositedLayer.raster`:'
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，合成算法及其对内容的影响已经变得相当复杂。添加更多的视觉调试来帮助理解正在发生的事情将非常有用。一个很好的方法是为我们的浏览器添加一个[标志](https://docs.python.org/3/library/argparse.html)，我也推荐你添加一个禁用合成的模式（即，将每个`VisualEffect`的`needs_compositing`设置为`False`），并禁用GPU的使用（即，回到使用Skia表面的老方法）。在所有模式下，一切都应该仍然正常工作（尽管速度较慢），你可以使用这些额外的模式来更全面地调试你的浏览器并基准测试其性能。向我们的浏览器添加一个在`CompositedLayer`内容周围绘制红色边框的功能。这是对`CompositedLayer.raster`的一个非常简单的添加：
- en: '[PRE669]'
  id: totrans-2757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: The opacity transition [example](examples/example13-opacity-transition.html)’s
    composited layers should look like Figure 5 (notice how there are two layers).
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例](examples/example13-opacity-transition.html)中的不透明度转换的合成层应该看起来像图5（注意有两个层）。'
- en: '![Figure 5: Example of composited layers for an opacity transition.](img/2f10f29715939aaff2f396b948a7d6cd.png)'
  id: totrans-2759
  prefs: []
  type: TYPE_IMG
  zh: '![图5：不透明度转换的合成层示例。](img/2f10f29715939aaff2f396b948a7d6cd.png)'
- en: 'Figure 5: Example of composited layers for an opacity transition.'
  id: totrans-2760
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：不透明度转换的合成层示例。
- en: Mostly for simplicity, our browser composites `Blend` visual effects regardless
    of whether they are animating. But in fact, there are some good reasons to always
    composite certain visual effects.
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
  zh: 主要为了简化，我们的浏览器无论是否在动画中都会合成`Blend`视觉效果。但实际上，总有很好的理由始终合成某些视觉效果。
- en: First, we’ll be able to start the animation quicker, since raster won’t have
    to happen first. That’s because whenever compositing reasons change, the browser
    has to redo compositing and re-raster the new surfaces.
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将能够更快地开始动画，因为栅格化不需要先发生。这是因为每当合成原因改变时，浏览器都必须重新进行合成和重新栅格化新的表面。
- en: Second, compositing sometimes has visual side-effects. Ideally, composited textures
    would look exactly the same on the screen as non-composited ones. But due to the
    details of pixel-sensitive raster technologies like [sub-pixel rendering](https://en.wikipedia.org/wiki/Subpixel_rendering),
    image resize filter algorithms, blending and anti-aliasing, this isn’t always
    possible. For example, it’s common to observe subtle color differences in some
    pixels due to floating-point precision differences. “Pre-compositing” the content
    avoids visual jumps on the page when compositing starts.
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，合成有时会有视觉副作用。理想情况下，合成的纹理在屏幕上应该与非合成的纹理看起来完全一样。但由于像素敏感的栅格技术（如[子像素渲染](https://en.wikipedia.org/wiki/Subpixel_rendering)）、图像缩放滤波算法、混合和抗锯齿的细节，这并不总是可能的。例如，由于浮点精度差异，常见到某些像素存在微妙的颜色差异。“预合成”内容可以避免在合成开始时页面上的视觉跳跃。
- en: Real browsers support the [`will-change`](https://developer.mozilla.org/en-US/docs/Web/CSS/will-change)
    CSS property for the purpose of signaling pre-compositing.
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
  zh: 实际浏览器支持`will-change` CSS属性，用于表示预合成。
- en: Overlap and Transforms
  id: totrans-2765
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重叠和转换
- en: The compositing algorithm we implemented works great in many cases. Unfortunately,
    it doesn’t work correctly for display list commands that *overlap* each other.
    Let me explain why with an example.
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的合成算法在许多情况下都工作得很好。不幸的是，它对于相互重叠的显示列表命令并不正确。让我用一个例子来解释原因。
- en: Consider a light blue square overlapped by a light green one, with a white background
    behind them, as in Figure 6.
  id: totrans-2767
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个被浅绿色方块覆盖的浅蓝色方块，它们后面有一个白色背景，如图6所示。
- en: 'Figure 6: Example of overlap that can lead to compositing draw errors.'
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：可能导致合成绘制错误的重叠示例。
- en: Now suppose we want to animate opacity on the blue square, but not the green
    square. So the blue square goes in its own composited layer—but what about the
    green square? It has the same ancestor visual effects as the background. But we
    don’t want to put the green square in the same composited layer as the background,
    because the blue square has to be drawn *in between* the background and the green
    square.
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要在蓝色方块上动画化透明度，但不希望在绿色方块上动画化。所以蓝色方块放在它自己的合成层中——那么绿色方块怎么办？它有与背景相同的祖先视觉效果。但我们不希望将绿色方块放在与背景相同的合成层中，因为蓝色方块必须绘制在背景和绿色方块*之间*。
- en: Therefore, the green square has to go in its own composited layer. This is called
    an *overlap reason for compositing*, and is a major complication—and potential
    source of extra memory use and slowdown—faced by all real browsers.
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，绿色方块必须放在它自己的合成层中。这被称为*合成重叠原因*，是所有真实浏览器面临的一个主要复杂问题——以及额外内存使用和速度降低的潜在来源。
- en: 'Let’s modify our compositing algorithm to take overlap into account. Basically,
    when considering which composited layer a display item goes in, also check if
    it overlaps with an existing composited layer. If so, start a new `CompositedLayer`
    for this display item:'
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的合成算法，以考虑重叠。基本上，在考虑显示项应该放在哪个合成层时，也要检查它是否与现有的合成层重叠。如果是这样，为这个显示项启动一个新的`CompositedLayer`：
- en: '[PRE670]'
  id: totrans-2772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: It’s a bit hard to *test* this code, however, because our browser doesn’t yet
    support any ways to move or growBy grow, I mean that the pixel bounding rect of
    the visual effect when drawn to the screen is *larger* than the pixel bounding
    rect of a paint command like `DrawText` within it. After all, blending, compositing,
    and opacity all change the colors of pixels, but don’t expand the set of affected
    ones. And clips and masking decrease rather than increase the set of pixels, so
    they can’t cause additional overlap either (though they might cause *less* overlap).
    Certain [CSS filters](https://developer.mozilla.org/en-US/docs/Web/CSS/filter),
    such as blurs, can also expand pixel rects. an element as part of a visual effect,
    so nothing ever overlaps. Oops! In real browsers there are lots of visual effects
    that cause overlap, the most important (for animations) being *transforms*, which
    let you move the painted output of a DOM subtree around the screen.Technically,
    `transform` is not always just a visual effect. In real browsers, transformed
    element positions contribute to scrolling overflow. Real browsers mostly do this
    correctly, but sometimes cut corners to avoid slowing down transform animations.
    Plus, transforms can be executed efficiently on the GPU.
  id: totrans-2773
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这段代码有点困难，因为我们的浏览器还没有支持任何移动或通过增长的方式，我指的是当视觉效果绘制到屏幕上时，其像素边界矩形比内部`DrawText`等绘图命令的像素边界矩形要*大*。毕竟，混合、合成和透明度都会改变像素的颜色，但不会扩大受影响像素的集合。而裁剪和遮罩会减少像素集合，而不是增加，所以它们也不能引起额外的重叠（尽管它们可能会引起*更少*的重叠）。某些[CSS过滤器](https://developer.mozilla.org/en-US/docs/Web/CSS/filter)，例如模糊，也可以扩展像素矩形。将元素作为视觉效果的一部分，因此永远不会重叠。哎呀！在真实浏览器中，有很多视觉效果会导致重叠，其中最重要的是（对于动画而言）*变换*，它允许你将DOM子树的绘制输出移动到屏幕上的任何位置。技术上讲，`transform`并不总是仅仅是一个视觉效果。在真实浏览器中，变换元素的定位对滚动溢出有贡献。真实浏览器大多数情况下都做得正确，但有时会走捷径以避免减慢变换动画的速度。此外，变换可以在GPU上高效执行。
- en: The `transform` CSS property is quite powerful, and lets you apply [any linear
    transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform) in 3D space,
    but let’s stick to basic 2D translations. That’s enough to implement something
    similar to the example with the blue and green square:The green square has a `transform`
    property also so that paint order doesn’t change when you try the demo in a real
    browser. That’s because there are various rules for painting, and “positioned”
    elements (such as elements with a `transform`) are supposed to paint after regular
    (non-positioned) elements. (This particular rule is mostly a historical artifact.)
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform` CSS属性非常强大，允许你在3D空间中应用[任何线性变换](https://developer.mozilla.org/en-US/docs/Web/CSS/transform)，但让我们先专注于基本的2D平移。这足以实现类似于蓝色和绿色方块示例的功能：绿色方块也有一个`transform`属性，这样当你在一个真实浏览器中尝试这个演示时，绘制顺序不会改变。这是因为存在各种绘制规则，而“定位”元素（例如具有`transform`的元素）应该在常规（非定位）元素之后绘制。（这个特定的规则主要是历史遗留问题。）'
- en: '[PRE671]'
  id: totrans-2775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: Supporting these transforms is simple. First let’s parse the property values:The
    CSS transform syntax allows multiple transforms in a space-separated sequence;
    the end result involves applying each in sequence. I won’t implement that, just
    like I won’t implement many other parts of the standardized transform syntax.
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
  zh: 支持这些变换很简单。首先，让我们解析属性值：CSS 变换语法允许在空格分隔的序列中包含多个变换；最终结果涉及按顺序应用每个变换。我不会实现这一点，就像我不会实现标准化变换语法的许多其他部分。
- en: '[PRE672]'
  id: totrans-2777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: 'Then, add some code to `paint_visual_effects` to add new `Transform` visual
    effects:'
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，向 `paint_visual_effects` 添加一些代码以添加新的 `Transform` 视觉效果：
- en: '[PRE673]'
  id: totrans-2779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: 'These `Transform` display items just call the conveniently built-in Skia canvas
    `translate` method:'
  id: totrans-2780
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `Transform` 显示项只是调用了方便构建的 Skia 画布 `translate` 方法：
- en: '[PRE674]'
  id: totrans-2781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: We also need to fix the hit testing algorithm to take into account translations
    in `click`. Instead of just comparing the locations of layout objects with the
    click point, compute an *absolute* bound—in coordinates of what the user sees,
    including the translation offset—and compare against that. Let’s use two helper
    methods that compute such bounds. The first maps a rect through a translation,
    and the second walks up the node tree, mapping through each translation found.
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修复击中测试算法，使其在 `click` 中考虑平移。而不仅仅是比较布局对象的位置与点击点，计算一个 *绝对* 边界——在用户看到的坐标中，包括平移偏移量——并与它比较。让我们使用两个辅助方法来计算这样的边界。第一个通过平移映射一个矩形，第二个遍历节点树，映射每个找到的平移。
- en: '[PRE675]'
  id: totrans-2783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: 'And then use it in `click`:'
  id: totrans-2784
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `click` 中使用它：
- en: '[PRE676]'
  id: totrans-2785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: However, if you try to load the example above, you’ll find that it still looks
    wrong—the blue square is supposed to be *under* the green one, but it’s on top.Hit
    testing is correct, though, because the rendering problem is in compositing, not
    geometry of layout objects.
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试加载上面的示例，你会发现它仍然看起来不正确——蓝色正方形应该位于绿色正方形下面，但它却在上面。尽管击中测试是正确的，因为渲染问题在于合成，而不是布局对象的几何形状。
- en: 'That’s because when we test for overlap, we’re comparing the `composited_bounds`
    of the display item to the `composited_bounds` of the composited layer. That means
    we’re comparing the original location of the display item, not its shifted version.
    We need to compute the absolute bounds instead:'
  id: totrans-2787
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当我们测试重叠时，我们正在比较显示项的 `composited_bounds` 与合成层的 `composited_bounds`。这意味着我们正在比较显示项的原始位置，而不是其移动后的版本。我们需要计算绝对边界：
- en: '[PRE677]'
  id: totrans-2788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: 'The `absolute_bounds` method looks like this:'
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
  zh: '`absolute_bounds` 方法看起来像这样：'
- en: '[PRE678]'
  id: totrans-2790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: To implement `local_to_absolute`, we first need a new `map` method on `Transform`
    that takes a rect in the coordinate space of the “contents” of the transform and
    outputs a rect in post-transform space. For example, if the transform was `translate(20px,
    0px)` then the output of calling `map` on a rect would translate it by 20 pixels
    in the *x* direction.
  id: totrans-2791
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `local_to_absolute`，我们首先需要一个在 `Transform` 上的新 `map` 方法，它接受变换“内容”坐标空间中的矩形，并输出变换后的空间中的矩形。例如，如果变换是
    `translate(20px, 0px)`，那么在矩形上调用 `map` 的输出将沿 *x* 方向移动 20 像素。
- en: '[PRE679]'
  id: totrans-2792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: 'For `Blend`, it’s worth adding a special case for clipping:'
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Blend`，添加一个针对裁剪的特殊情况是值得的：
- en: '[PRE680]'
  id: totrans-2794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: 'Now we can compute the absolute bounds of a display item, mapping its composited
    bounds through all of the visual effects applied to it. This looks a lot like
    `absolute_bounds_for_obj`, except that it works on the display list and not the
    layout object tree:'
  id: totrans-2795
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以计算显示项的绝对边界，通过映射其合成边界到应用到的所有视觉效果。这看起来很像 `absolute_bounds_for_obj`，但是它作用于显示列表而不是布局对象树：
- en: '[PRE681]'
  id: totrans-2796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: The blue square should now be underneath the green square, so overlap testing
    is now complete. You should now be able to render [this example](examples/example13-transform-overlap.html)
    correctly.
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
  zh: 现在蓝色正方形应该在绿色正方形下面，因此重叠测试现在完成。你现在应该能够正确渲染 [这个示例](examples/example13-transform-overlap.html)。
- en: It should look like Figure 7.
  id: totrans-2798
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来像图 7。
- en: '![Figure 7: Example of transformed overlap, clipping and blending.](img/c3c177a48662c49f704018bd2e911cef.png)'
  id: totrans-2799
  prefs: []
  type: TYPE_IMG
  zh: '![图 7：变换重叠、裁剪和混合的示例](img/c3c177a48662c49f704018bd2e911cef.png)'
- en: 'Figure 7: Example of transformed overlap, clipping and blending.'
  id: totrans-2800
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7：变换重叠、裁剪和混合的示例。
- en: 'Notice how this example exhibits *two* interesting features we had to get right
    when implementing compositing:'
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个示例展示了我们在实现合成时必须做对的 *两个* 有趣的特性：
- en: Overlap testing (without it, the elements would paint in the wrong order); if
    this code were missing it would incorrectly render like Figure 8.
  id: totrans-2802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重叠测试（如果没有它，元素将以错误的顺序绘制）；如果这段代码缺失，它将像图 8 一样错误渲染。
- en: '![Figure 8: Wrong rendering because overlap testing is missing.](img/d66dc79015e402e3d2e4e148349befa3.png)'
  id: totrans-2803
  prefs: []
  type: TYPE_IMG
  zh: '![图 8：渲染错误，因为缺少重叠测试。](img/d66dc79015e402e3d2e4e148349befa3.png)'
- en: 'Figure 8: Wrong rendering because overlap testing is missing.'
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8：渲染错误，因为缺少重叠测试。
- en: Reusing cloned effects (without it, blending and clipping would be wrong); if
    this code were missing it would incorrectly render like Figure 9.
  id: totrans-2805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用克隆效果（如果没有它，混合和裁剪将会出错）；如果这段代码缺失，它将渲染成如图 9 所示的错误效果。
- en: '![Figure 9: Wrong rendering because of incorrect blending.](img/1a913e6da95f47078e156638917a013c.png)'
  id: totrans-2806
  prefs: []
  type: TYPE_IMG
  zh: '![图 9：渲染错误，因为混合不正确。](img/1a913e6da95f47078e156638917a013c.png)'
- en: 'Figure 9: Wrong rendering because of incorrect blending.'
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9：渲染错误，因为混合不正确。
- en: There’s one more situation worth thinking about, though. Suppose we have a huge
    composited layer, containing a lot of text, except that only a small part of that
    layer is shown on the screen, the rest being clipped out. Then the `absolute_bounds`
    consider the clip operations but the `composited_bounds` don’t, meaning that we’ll
    make a much larger composited layer than necessary and waste a lot of time rastering
    pixels that the user will never see.
  id: totrans-2808
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，还有一种情况值得思考。假设我们有一个包含大量文本的巨大合成层，但只有该层的一小部分显示在屏幕上，其余部分被裁剪掉。然后 `absolute_bounds`
    考虑了裁剪操作，但 `composited_bounds` 没有考虑，这意味着我们将创建一个比必要的更大的合成层，并且浪费了大量时间对用户永远不会看到的像素进行光栅化。
- en: 'Let’s fix that by also applying those clips to `composited_bounds`.This is
    very important, because otherwise some composited layers can end up huge despite
    not drawing much to the screen. A good example of this optimization making a big
    difference is loading the browser from [Chapter 15](https://browser.engineering/embeds.html)
    for the [browser.engineering](https://browser.engineering/) homepage, where otherwise
    we would end up with an enormous composited layer for an iframe. We’ll do it by
    first computing the absolute bounds for each item, then mapping them back to local
    space, which will have the effect of computing the “clipped local rect” for each
    display item:'
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过也将这些裁剪应用到 `composited_bounds` 上来解决这个问题。这非常重要，因为否则一些合成层可能会变得非常大，尽管它们在屏幕上绘制的内容不多。一个优化带来巨大差异的好例子是加载
    [第 15 章](https://browser.engineering/embeds.html) 到 [browser.engineering](https://browser.engineering/)
    的主页，否则我们可能会得到一个巨大的合成层用于 iframe。我们将通过首先计算每个项目的绝对边界，然后将它们映射回局部空间来实现这一点，这将产生为每个显示项计算“裁剪后的局部矩形”的效果：
- en: '[PRE682]'
  id: totrans-2810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: 'This requires implementing `absolute_to_local`:'
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
  zh: '这需要实现 `absolute_to_local`:'
- en: '[PRE683]'
  id: totrans-2812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: 'Which in turn relies on `unmap`. For `Blend` these should be no-ops, but for
    `Transform` it’s just the inverse translation:'
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
  zh: 这又依赖于 `unmap`。对于 `Blend`，这些操作应该是无操作的，但对于 `Transform`，它只是逆变换：
- en: '[PRE684]'
  id: totrans-2814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: And with that, we now have completed the story of a pretty high-performance
    implementation of composited animations.
  id: totrans-2815
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们现在已经完成了关于一个相当高性能的合成动画实现的叙述。
- en: Overlap reasons for compositing not only create complications in the code, but
    without care from the browser and web developer can lead to a huge amount of GPU
    memory usage, as well as page slowdown to manage all of the additional composited
    layers. One way this could happen is that an additional composited layer results
    from one element overlapping another, and then a third because it overlaps the
    second, and so on. This phenomenon is called *layer explosion*. Our browser’s
    algorithm avoids this problem most of the time because it is able to merge multiple
    display items together as long as they have compatible ancestor effects, but in
    practice there are complicated situations where it’s hard to make content merge
    efficiently.
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
  zh: 合成重叠的原因不仅使代码复杂化，而且如果没有浏览器和网页开发者的细心处理，可能会导致大量的 GPU 内存使用，以及页面速度的降低来管理所有额外的合成层。这种情况可能发生的一种方式是，一个额外的合成层由于一个元素与另一个元素重叠而产生，然后是第三个元素因为它与第二个元素重叠，以此类推。这种现象被称为
    *层爆炸*。我们的浏览器算法大多数时候能够避免这个问题，因为它能够将具有兼容祖先效果的多个显示项合并在一起，但在实践中，存在一些复杂的情况，其中很难有效地合并内容。
- en: In addition to overlap, there are other situations where compositing has undesired
    side-effects leading to performance problems. For example, suppose we wanted to
    *turn off* composited scrolling in certain situations, such as on a machine without
    a lot of memory, but still use compositing for visual effect animations. But what
    if the animation is on content underneath a scroller? In practice, it can be very
    difficulty to implement this situation correctly without just giving up and compositing
    the scroller.
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
  zh: 除了重叠之外，还有其他情况，合成可能会产生不期望的副作用，导致性能问题。例如，假设我们想在某些情况下关闭合成的滚动，比如在没有大量内存的机器上，但仍然使用合成进行视觉效果动画。但如果动画是在滚动器下方的内
    容上呢？实际上，如果不放弃并合成滚动器，正确实现这种情况可能非常困难。
- en: Summary
  id: totrans-2818
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter introduces animations. The key takeaways you should remember are:'
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了动画。你应该记住的关键要点是：
- en: Animations come in DOM-based, input-driven and video-like varieties;
  id: totrans-2820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画有基于DOM、输入驱动和类似视频的多种类型；
- en: GPU acceleration is necessary for smooth animations.
  id: totrans-2821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于平滑动画，GPU加速是必要的。
- en: Compositing is usually necessary for smooth and threaded visual effect animations.
  id: totrans-2822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合成通常对于平滑和线程化的视觉效果动画是必要的。
- en: It’s important to optimize the number of composited layers.
  id: totrans-2823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化合成层的数量非常重要。
- en: Overlap testing can cause additional GPU memory use and needs to be implemented
    with care.
  id: totrans-2824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重叠测试可能会增加GPU内存的使用，并且需要谨慎实现。
- en: Click [here](widgets/lab13-browser.html) to try this chapter’s browser.
  id: totrans-2825
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[这里](widgets/lab13-browser.html)尝试本章的浏览器。
- en: Outline
  id: totrans-2826
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should now
    look something like this:'
  id: totrans-2827
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整功能集、类和方法现在看起来可能像这样：
- en: '`COOKIE_JAR` `` class URL: `def __init__(url)` `def request(referrer, payload)`
    `def resolve(url)` `def origin()` `def __str__()` `` `` class Text: `def __init__(text,
    parent)` `def __repr__()` `` `` class Element: `def __init__(tag, attributes,
    parent)` `def __repr__()` `` `def print_tree(node, indent)` `def tree_to_list(tree,
    list)` `` class HTMLParser: `SELF_CLOSING_TAGS` `HEAD_TAGS` `def __init__(body)`
    `def parse()` `def get_attributes(text)` `def add_text(text)` `def add_tag(tag)`
    `def implicit_tags(tag)` `def finish()` `` `` class CSSParser: `def __init__(s)`
    `def whitespace()` `def literal(literal)` `def word()` `def ignore_until(chars)`
    `def pair(until)` `def selector()` `def body()` `def parse()` `def until_chars(chars)`
    `` `` class TagSelector: `def __init__(tag)` `def matches(node)` `` `` class DescendantSelector:
    `def __init__(ancestor, descendant)` `def matches(node)` `` `FONTS` `def get_font(size,
    weight, style)` `def linespace(font)` `NAMED_COLORS` `def parse_color(color)`
    `def parse_blend_mode(blend_mode_str)` `def parse_transition(value)` `def parse_transform(transform_str)`
    `REFRESH_RATE_SEC` `` class MeasureTime: `def __init__()` `def time(name)` `def
    stop(name)` `def finish()` `` `` class Task: `def __init__(task_code)` `def run()`
    `` `` class TaskRunner: `def __init__(tab)` `def schedule_task(task)` `def set_needs_quit()`
    `def clear_pending_tasks()` `def start_thread()` `def run()` `def handle_quit()`
    `` `DEFAULT_STYLE_SHEET` `INHERITED_PROPERTIES` `def style(node, rules, tab)`
    `def cascade_priority(rule)` `def diff_styles(old_style, new_style)` `` class
    NumericAnimation: `def __init__(old_value, new_value, num_frames)` `def animate()`
    `` `WIDTH, HEIGHT` `HSTEP, VSTEP` `INPUT_WIDTH_PX` `BLOCK_ELEMENTS` `` class DocumentLayout:
    `def __init__(node)` `def layout()` `def should_paint()` `def paint()` `def paint_effects(cmds)`
    `` `` class BlockLayout: `def __init__(node, parent, previous)` `def layout_mode()`
    `def layout()` `def recurse(node)` `def new_line()` `def word(node, word)` `def
    input(node)` `def self_rect()` `def should_paint()` `def paint()` `def paint_effects(cmds)`
    `` `` class LineLayout: `def __init__(node, parent, previous)` `def layout()`
    `def should_paint()` `def paint()` `def paint_effects(cmds)` `` `` class TextLayout:
    `def __init__(node, word, parent, previous)` `def layout()` `def should_paint()`
    `def paint()` `def paint_effects(cmds)` `` `` class InputLayout: `def __init__(node,
    parent, previous)` `def layout()` `def should_paint()` `def paint()` `def paint_effects(cmds)`
    `def self_rect()` `` `` class PaintCommand: `def __init__(rect)` `` `` class DrawText:
    `def __init__(x1, y1, text, font, color)` `def execute(canvas)` `` `` class DrawRect:
    `def __init__(rect, color)` `def execute(canvas)` `` `` class DrawRRect: `def
    __init__(rect, radius, color)` `def execute(canvas)` `` `` class DrawLine: `def
    __init__(x1, y1, x2, y2, color, thickness)` `def execute(canvas)` `` `` class
    DrawOutline: `def __init__(rect, color, thickness)` `def execute(canvas)` `` ``
    class DrawCompositedLayer: `def __init__(composited_layer)` `def execute(canvas)`
    `` `` class VisualEffect: `def __init__(rect, children, node)` `` `` class Blend:
    `def __init__(opacity, blend_mode, node, children)` `def execute(canvas)` `def
    map(rect)` `def unmap(rect)` `def clone(child)` `` `` class Transform: `def __init__(translation,
    rect, node, children)` `def execute(canvas)` `def map(rect)` `def unmap(rect)`
    `def clone(child)` `` `def local_to_absolute(display_item, rect)` `def absolute_bounds_for_obj(obj)`
    `def absolute_to_local(display_item, rect)` `def map_translation(rect, translation,
    reversed)` `def paint_tree(layout_object, display_list)` `def paint_visual_effects(node,
    cmds, rect)` `def add_parent_pointers(nodes, parent)` `` class CompositedLayer:
    `def __init__(skia_context, display_item)` `def can_merge(display_item)` `def
    add(display_item)` `def composited_bounds()` `def absolute_bounds()` `def raster()`
    `` `EVENT_DISPATCH_JS` `SETTIMEOUT_JS` `XHR_ONLOAD_JS` `RUNTIME_JS` `` class JSContext:
    `def __init__(tab)` `def run(script, code)` `def dispatch_event(type, elt)` `def
    dispatch_settimeout(handle)` `def dispatch_xhr_onload(out, handle)` `def get_handle(elt)`
    `def querySelectorAll(selector_text)` `def getAttribute(handle, attr)` `def innerHTML_set(handle,
    s)` `def style_set(handle, s)` `def XMLHttpRequest_send(...)` `def setTimeout(handle,
    time)` `def requestAnimationFrame()` `` `SCROLL_STEP` `` class Tab: `def __init__(browser,
    tab_height)` `def load(url, payload)` `def run_animation_frame(scroll)` `def render()`
    `def allowed_request(url)` `def raster(canvas)` `def clamp_scroll(scroll)` `def
    set_needs_render()` `def set_needs_layout()` `def set_needs_paint()` `def scrolldown()`
    `def click(x, y)` `def go_back()` `def submit_form(elt)` `def keypress(char)`
    `` `` class Chrome: `def __init__(browser)` `def tab_rect(i)` `def paint()` `def
    click(x, y)` `def keypress(char)` `def enter()` `def blur()` `` `` class CommitData:
    `def __init__(...)` `` `` class Browser: `def __init__()` `def schedule_animation_frame()`
    `def commit(tab, data)` `def render()` `def composite_raster_and_draw()` `def
    composite()` `def get_latest(effect)` `def paint_draw_list()` `def raster_tab()`
    `def raster_chrome()` `def draw()` `def set_needs_animation_frame(tab)` `def set_needs_raster_and_draw()`
    `def set_needs_raster()` `def set_needs_composite()` `def set_needs_draw()` `def
    clear_data()` `def new_tab(url)` `def new_tab_internal(url)` `def set_active_tab(tab)`
    `def schedule_load(url, body)` `def clamp_scroll(scroll)` `def handle_down()`
    `def handle_click(e)` `def handle_key(char)` `def handle_enter()` `def handle_quit()`
    `` `def mainloop(browser)`'
  id: totrans-2828
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-2829
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 13-1 *`background-color`*. Implement animations of the `background-color` CSS
    property. You’ll have to define a new kind of interpolation that applies to all
    the color channels.
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
  zh: 13-1 *`background-color`*。实现`background-color` CSS属性的动画。您需要定义一种适用于所有颜色通道的新插值类型。
- en: 13-2 *Easing functions*. Our browser only implements a linear interpolation
    between start and end values, but there are many other [easing functions](https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function)
    (in fact, the default one in real browsers is `cubic-bezier(0.25, 0.1, 0.25, 1.0)`,
    not linear). Implement this easing function, and one or two others.
  id: totrans-2831
  prefs: []
  type: TYPE_NORMAL
  zh: 13-2 *缓动函数*。我们的浏览器只实现了起始值和结束值之间的线性插值，但还有许多其他的[缓动函数](https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function)（实际上，真实浏览器中的默认值是`cubic-bezier(0.25,
    0.1, 0.25, 1.0)`，而不是线性）。实现这个缓动函数，以及一两个其他的。
- en: '13-3 *Composited and threaded animations*. Our browser supports transfoms and
    scrolling, but they are not fully composited and threaded, and transform transition
    animations are not supported. Implement these. (Hint: for transforms, it just
    requires following the same pattern as for `opacity`; for scrolling, it requires
    setting fewer dirty bits in `handle_down`.) [A simultaneous transform and opacity
    animation](examples/example13-transform-transition.html) should now work, without
    any raster, and scrolling on that page should not raster either.'
  id: totrans-2832
  prefs: []
  type: TYPE_NORMAL
  zh: 13-3 *合成和线程动画*。我们的浏览器支持变换和滚动，但它们并未完全合成和线程化，变换过渡动画也不受支持。实现这些功能。（提示：对于变换，只需遵循与`opacity`相同的模式即可；对于滚动，需要在`handle_down`中设置更少的脏位。）[一个同时变换和透明度动画的示例](examples/example13-transform-transition.html)现在应该可以工作，无需任何光栅化，并且该页面的滚动也不应进行光栅化。
- en: 13-4 *Width/height animations*. (You’ll need to have done Exercise 6-2 first.)
    Make `width` and `height` animatable; you’ll need a variant of `NumericAnimation`
    that parses and produces pixel values (the “px” suffix in the string). Since `width`
    and `height` are layout-inducing, make sure that animating them sets `needs_layout`.
    Check that animating width in your browser changes line breaks. [A width transition
    example](examples/example13-width-transition.html) should work once you’ve implemented
    width animations.Width animations can’t be composited because width affects the
    layout tree, not just different display lists, which in turn means that draw commands,
    not just visual effects, change. Such animations are called *layout-inducing*,
    and they are therefore slower and typically not a good idea. [Chapter 16](invalidation.html)
    will look at one way to speed them up somewhat.
  id: totrans-2833
  prefs: []
  type: TYPE_NORMAL
  zh: 13-4 *宽度和高度动画*。（您需要先完成练习6-2。）使`width`和`height`可动画化；您需要一个可以解析和生成像素值（字符串中的“px”后缀）的`NumericAnimation`变体。由于`width`和`height`会引发布局变化，请确保动画化它们时设置`needs_layout`。检查在您的浏览器中动画化宽度是否会改变换行。一旦实现了宽度动画，[宽度过渡示例](examples/example13-width-transition.html)应该可以工作。[A
    width transition example](examples/example13-width-transition.html)应该工作一次您实现了宽度动画。宽度动画不能进行合成，因为宽度会影响布局树，而不仅仅是不同的显示列表，这意味着不仅仅是视觉效果，绘制命令也会改变。这种动画被称为*布局引发*，因此它们通常较慢，通常不是一个好主意。[第16章](invalidation.html)将探讨一种加快它们速度的方法。
- en: One exception is resizing the browser window with your mouse. That’s layout-inducing,
    but it’s very useful for the user to see the new layout as the window size changes.
    Modern browsers are fast enough to do this, but it used to be that they’d only
    redraw the screen every couple of frames, leaving a visual *gutter* between content
    and the edge of the window.
  id: totrans-2834
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例外是使用鼠标调整浏览器窗口的大小。这会引发布局变化，但对于用户来说，在窗口大小变化时看到新的布局非常有用。现代浏览器足够快，可以做到这一点，但过去它们每隔几帧才重绘屏幕，导致内容与窗口边缘之间出现视觉上的*空白*。
- en: 13-5 *CSS animations*. Implement the basics of the [CSS animations](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations)
    API, in particular enough of the `animation` CSS property and parsing of `@keyframe`
    to implement [two](examples/example13-opacity-animation.html) [demos](examples/example13-width-animation.html)
    on the `browser.engineering` website.
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
  zh: 13-5 *CSS动画*。实现[CSS动画](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations)
    API的基本功能，特别是足够的`animation` CSS属性和`@keyframe`的解析，以在`browser.engineering`网站上实现[两个](examples/example13-opacity-animation.html)
    [演示](examples/example13-width-animation.html)。
- en: 13-6 *Overlap testing with transform animations*. (You’ll need to have already
    done Exercise 13-3.) Our browser currently does not overlap test correctly in
    the presence of transform animations that cause overlap to come and go. First
    create a demo that exhibits the bug, and then fix it. One way to fix it is to
    enter “assume overlap mode” whenever an animated transform display item is encountered.
    This means that every subsequent display item is assumed to overlap the animating
    one (even if it doesn’t at the moment), and therefore can’t merge into any `CompositedLayer`
    earlier in the list than the animating one. Another way is to run overlap testing
    on every animation frame in the browser thread, and if the results differ from
    the prior frame, redo compositing and raster. And if you’ve done Exercise 13-5,
    and a transform animation is defined in terms of a CSS animation, you can analytically
    determine the bounding box of the animation, and use that for overlap instead.
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
  zh: 13-6 *与变换动画的重叠测试*。（您需要已经完成了练习13-3。）我们的浏览器目前在存在导致重叠出现和消失的变换动画时，无法正确进行重叠测试。首先创建一个演示该错误的示例，然后修复它。修复的一种方法是在遇到动画变换显示项时进入“假设重叠模式”。这意味着每个后续显示项都被假定为与动画项重叠（即使目前没有重叠），因此不能合并到列表中比动画项更早的任何`CompositedLayer`。另一种方法是，在浏览器线程的每一帧动画中运行重叠测试，如果结果与前一帧不同，则重新进行合成和位图化。如果您已经完成了练习13-5，并且变换动画是用CSS动画定义的，您可以通过分析确定动画的边界框，并使用它来进行重叠测试。
- en: 13-7 *Avoiding sparse composited layers*. Our browser’s algorithm currently
    always merges paint chunks that have compatible ancestor effects. But this can
    lead to inefficient situations, such as where two paint chunks that are visually
    very far away on the web page (e.g. one at the very top and one thousands of pixels
    lower down) end up in the same `CompositedLayer`. That can be very bad, because
    it results in a huge `skia.Surface` that is mostly wasted GPU memory. One way
    to reduce that problem is to stop merging paint chunks that would make the total
    area of the `skia.Surface` larger than some fixed value. Implement that.Another
    way is via surface tiling.
  id: totrans-2837
  prefs: []
  type: TYPE_NORMAL
  zh: 13-7 *避免稀疏合成层*。我们浏览器的算法目前总是合并具有兼容祖先效果的绘制块。但这可能导致效率低下的情况，例如，两个在网页上视觉上非常远的绘制块（例如，一个在顶部，另一个在数千像素以下）最终出现在同一个`CompositedLayer`中。这可能会非常糟糕，因为它导致了一个巨大的`skia.Surface`，大部分是浪费的GPU内存。减少这种问题的一种方法是不合并会使`skia.Surface`总面积超过某个固定值的绘制块。实现这一点。另一种方法是通过表面平铺。
- en: 13-8 *Short display lists*. it’s relatively common in real browsers to encounter
    `CompositedLayer`s that are only a single solid color, or only a few simple paint
    commands.A real browser would use among its criteria whether the time to raster
    the provided display items is low enough to not justify a GPU texture. This will
    be true for solid colors, but probably not for complex shapes or text. Implement
    an optimization that skips storing a `skia.Surface` on a `CompositedLayer` with
    less than a fixed number (three, say) of paint commands, and instead execute them
    directly. In other words, `raster` on these `CompositedLayer`s will be a no-op
    and `draw` will execute the paint commands instead.
  id: totrans-2838
  prefs: []
  type: TYPE_NORMAL
  zh: 13-8 *简短显示列表*。在实际浏览器中遇到只包含单一纯色或只有几个简单绘制命令的`CompositedLayer`相对常见。一个真正的浏览器会将其标准之一设定为，提供显示项的位图化时间是否足够低，以至于不需要使用GPU纹理。这对于纯色来说是真的，但对于复杂形状或文本可能就不是了。实现一个优化，跳过在`CompositedLayer`上存储少于固定数量（比如三个）的绘制命令的`skia.Surface`，而是直接执行它们。换句话说，这些`CompositedLayer`上的`raster`操作将是一个空操作，而`draw`将执行绘制命令。
- en: 13-9 *Hit testing*. Right now, when handling clicks, we convert each layout
    object’s bounds to absolute coordinates (via `absolute_bounds_for_obj`) to compare
    to the click location. But we could instead convert the click location to local
    coordinates as we traverse the layout tree. Implement that instead. It’ll probably
    be convenient to define a `hit_test` method on each layout object which takes
    in a click location, adjusts it for transforms, and recursively calls child `hit_test`
    methods.In real browsers hit testing is used for more than just clicking. The
    name comes from thinking whether an arrow shot at that location would “hit” the
    object.
  id: totrans-2839
  prefs: []
  type: TYPE_NORMAL
  zh: 13-9 *点击测试*。目前，在处理点击时，我们将每个布局对象的边界转换为绝对坐标（通过`absolute_bounds_for_obj`）以与点击位置进行比较。但我们可以改为在遍历布局树时将点击位置转换为局部坐标。实现这一点。定义每个布局对象的`hit_test`方法可能很方便，该方法接受一个点击位置，调整它以适应变换，并递归调用子`hit_test`方法。在实际浏览器中，点击测试不仅用于点击。这个名字来源于思考如果在这个位置射出一支箭，它是否会“击中”该对象。
- en: '13-10 *`z-index`*. Right now, elements later in the HTML document are drawn
    “on top” of earlier ones. The `z-index` CSS property changes that order: an element
    with a larger `z-index` draws on top (with ties broken by the current order, and
    with the default `z-index` being 0). For `z-index` to have any effect, the element’s
    `position` property must be set to something other than `static` (the default).
    Add support for `z-index`. For an extra challenge, add support for [nested elements](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)
    with `z-index` properties.'
  id: totrans-2840
  prefs: []
  type: TYPE_NORMAL
  zh: 13-10 *`z-index`*。目前，HTML文档中较后的元素被绘制在较早元素“之上”。`z-index` CSS属性改变了这种顺序：具有较大`z-index`的元素绘制在顶部（如果有冲突，则按当前顺序解决，默认`z-index`为0）。为了使`z-index`产生任何效果，元素的`position`属性必须设置为除`static`（默认值）之外的其他值。添加对`z-index`的支持。作为一个额外的挑战，添加对具有`z-index`属性的[嵌套元素](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)的支持。
- en: 13-11 *Animated scrolling*. Real browsers have many kinds of animations during
    scroll. For example, pressing the down key or the down-arrow in a scrollbar causes
    a pleasant animated scroll, rather than the immediate scroll our browser current
    implements. Or on mobile, a touch interaction often causes a “fling” scroll according
    to a physics-based model of scroll momentum with friction. Implement the [`scroll-behavior`](https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior)
    CSS property on the `<body>` element, and use it to trigger animated scroll in
    `handle_down`, by delegating scroll to a main thread animation.This will result
    in your browser losing threaded scrolling. If you’ve implemented Exercise 13-3,
    you could build on that code to animate scroll on the browser thread. You’ll need
    to implement a new `ScrollAnimation` class and some logic in `run_animation_frame`.
    Scrolling in the [transform transition](examples/example13-transform-transition.html)
    example should now be smooth, as that example uses `scroll-behavior`.These days,
    many websites implement a number of *scroll-linked* animation effects, such as
    *parallax*. In real life, parallax is the phenomenon that objects further away
    appear to move slower than closer-in objects (due to the angle of light changing
    less quickly). This can be achieved with the [`perspective`](https://developer.mozilla.org/en-US/docs/Web/CSS/perspective)
    CSS property. [This article](https://developer.chrome.com/blog/performant-parallaxing/)
    explains how, and [this one](https://css-tricks.com/how-css-perspective-works/)
    gives a much deeper dive into perspective in CSS generally.
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
  zh: 13-11 *动画滚动*。真实浏览器在滚动过程中有很多种动画。例如，按下向下键或滚动条中的向下箭头会导致令人愉悦的动画滚动，而不是我们浏览器当前实现的即时滚动。或者在移动设备上，触摸交互通常会根据基于滚动动量与摩擦的物理模型引起“滑动”滚动。在`<body>`元素上实现`[`scroll-behavior](https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior)`
    CSS属性，并在`handle_down`中通过委托滚动到主线程动画来触发动画滚动。这将导致您的浏览器失去线程滚动功能。如果您已经实现了练习13-3，您可以在该代码的基础上构建浏览器线程上的动画滚动。您需要实现一个新的`ScrollAnimation`类和在`run_animation_frame`中的某些逻辑。在[transform
    transition](examples/example13-transform-transition.html)示例中的滚动现在应该是平滑的，因为该示例使用了`scroll-behavior`。如今，许多网站实现了一些*滚动链接*动画效果，例如*视差效果*。在现实生活中，视差是远离物体的现象，它们看起来比靠近物体的物体移动得慢（由于光线角度变化较慢）。这可以通过使用`[`perspective](https://developer.mozilla.org/en-US/docs/Web/CSS/perspective)`
    CSS属性来实现。[这篇文章](https://developer.chrome.com/blog/performant-parallaxing/)解释了如何实现，[这篇文章](https://css-tricks.com/how-css-perspective-works/)则更深入地探讨了CSS中的视差。
- en: There are also animations that are [tied to scroll offset](https://drafts.csswg.org/scroll-animations-1/)
    but are not, strictly speaking, part of the scroll. An example is a rotation or
    opacity fade on an element that advances as the user scrolls down the page (and
    reverses as they scroll back up). Or there are *scroll-triggered* animations that
    start once an element has scrolled to a certain point on the screen, or when scroll
    changes direction.
  id: totrans-2842
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些动画是与[滚动偏移](https://drafts.csswg.org/scroll-animations-1/)相关的，但严格来说，它们不是滚动的一部分。一个例子是元素上的旋转或不透明度淡入淡出，当用户向下滚动页面时（当用户向上滚动时反转）。或者有*滚动触发*的动画，一旦元素滚动到屏幕上的某个位置，或者当滚动方向改变时，动画就会开始。
- en: '13-12 *Opacity plus draw*. If a `DrawCompositedLayer` command occurs inside
    a `Blend(alpha=0.5)` then right now there might be two surface copies: first copying
    the composited layer’s raster buffer into a temporary buffer, then applying opacity
    to it and copying it into the root surface. This is not necessary, and in fact
    Skia’s [`draw`](https://kyamagu.github.io/skia-python/reference/skia.Surface.html#skia.Surface.draw)
    API on a `Surface` allows opacity to be applied. Optimize the browser to combine
    these into one `draw` command when this situation happens. (This is an important
    optimization in real browsers.)'
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
  zh: 13-12 *不透明度加绘制*。如果一个`DrawCompositedLayer`命令在`Blend(alpha=0.5)`内部发生，那么现在可能会有两个表面副本：首先将合成层的位图缓冲区复制到一个临时缓冲区，然后对其应用不透明度，并将其复制到根表面。这是不必要的，实际上Skia的`Surface`上的`draw`（https://kyamagu.github.io/skia-python/reference/skia.Surface.html#skia.Surface.draw）API允许应用不透明度。当这种情况发生时，优化浏览器以将它们合并为一个`draw`命令。（这是真实浏览器中的一个重要优化。）
- en: Making Content Accessible
  id: totrans-2844
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使内容无障碍
- en: Chapter 14 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-2845
  prefs: []
  type: TYPE_NORMAL
  zh: '[Web浏览器工程](./index.html "目录")的第14章。'
- en: '[What is Accessibility?](#what-is-accessibility)'
  id: totrans-2846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[什么是无障碍性？](#what-is-accessibility)'
- en: '[Zoom](#zoom)'
  id: totrans-2847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[缩放](#zoom)'
- en: '[Dark Mode](#dark-mode)'
  id: totrans-2848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[暗黑模式](#dark-mode)'
- en: '[Customizing Dark Mode](#customizing-dark-mode)'
  id: totrans-2849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自定义暗黑模式](#customizing-dark-mode)'
- en: '[Keyboard Navigation](#keyboard-navigation)'
  id: totrans-2850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[键盘导航](#keyboard-navigation)'
- en: '[Indicating Focus](#indicating-focus)'
  id: totrans-2851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[指示焦点](#indicating-focus)'
- en: '[The Accessibility Tree](#the-accessibility-tree)'
  id: totrans-2852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[无障碍性树](#the-accessibility-tree)'
- en: '[Screen Readers](#screen-readers)'
  id: totrans-2853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[屏幕阅读器](#screen-readers)'
- en: '[Accessible Alerts](#accessible-alerts)'
  id: totrans-2854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[无障碍性警报](#accessible-alerts)'
- en: '[Voice and Visual Interaction](#voice-and-visual-interaction)'
  id: totrans-2855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[语音和视觉交互](#voice-and-visual-interaction)'
- en: '[Summary](#summary)'
  id: totrans-2856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summary)'
- en: '[Outline](#outline)'
  id: totrans-2857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大纲](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-2858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: So far, we’ve focused on making the browser an effective platform for developing
    web applications. But ultimately, the browser is a [*user* agent](intro.html#the-role-of-the-browser).
    That means it should assist the user in whatever way it can to access and use
    web applications. Browsers therefore offer a range of [*accessibility*](https://developer.mozilla.org/en-US/docs/Learn/Accessibility/What_is_accessibility)
    features that take advantage of [declarative](intro.html#browser-code-concepts)
    UI and the flexibility of HTML and CSS to make it possible to interact with web
    pages by touch, keyboard, or voice.
  id: totrans-2859
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于使浏览器成为开发网络应用的有效平台。但最终，浏览器是一个[*用户代理*](intro.html#the-role-of-the-browser)。这意味着它应该以任何可能的方式协助用户访问和使用网络应用。因此，浏览器提供了一系列[*无障碍性*](https://developer.mozilla.org/en-US/docs/Learn/Accessibility/What_is_accessibility)功能，利用[声明性](intro.html#browser-code-concepts)UI和HTML和CSS的灵活性，使得可以通过触摸、键盘或语音与网页进行交互。
- en: What is Accessibility?
  id: totrans-2860
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是无障碍性？
- en: Accessibility means that the user can change or customize how they interact
    with a web page in order to make it easier to use.This definition takes the browser’s
    point of view. Accessibility can also be defined from the developer’s point of
    view, [in which case](https://developer.mozilla.org/en-US/docs/Learn/Accessibility/What_is_accessibility)
    it’s about ways to make your web pages easy to use for as many people as possible.
    The web’s uniquely flexible core technologies mean that browsers offer a lot of
    accessibility featuresToo often, people take “accessibility” to mean “screen reader
    support”, but this is just one way a user may want to interact with a web page.
    that allow a user to customize the rendering of a web page, as well as interact
    with a web page with their keyboard, by voice, or using some kind of helper software.
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
  zh: '无障碍性意味着用户可以更改或自定义他们与网页的交互方式，以便更容易使用。这个定义采用了浏览器的视角。从开发者的角度来看，无障碍性也可以定义为，[在这种情况下](https://developer.mozilla.org/en-US/docs/Learn/Accessibility/What_is_accessibility)，它关乎使尽可能多的人能够轻松使用你的网页的方法。网络的独特灵活的核心技术意味着浏览器提供了大量的无障碍性功能。人们常常将“无障碍性”理解为“屏幕阅读器支持”，但这只是用户可能想要与网页交互的一种方式。这些功能允许用户自定义网页的渲染，以及通过键盘、语音或使用某种类型的辅助软件与网页进行交互。 '
- en: The reasons for customizing, of course, are as diverse as the customizations
    themselves. The World Health Organization [found](https://www.who.int/publications/i/item/9789241564182)
    that as much as 15% of the world population have some form of disability, and
    many of them are severe or permanent. Nearly all of them can benefit greatly from
    the accessibility features described in this chapter. The more severe the disability
    for a particular person, the more critically important these features become for
    them.
  id: totrans-2862
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，定制化的原因和定制化本身一样多样化。世界卫生组织[发现](https://www.who.int/publications/i/item/9789241564182)全球有高达15%的人口存在某种形式的残疾，其中许多人残疾严重或永久。他们中的几乎所有人都能够从本章描述的辅助功能中受益良多。对于特定个人的残疾越严重，这些功能对他们来说就越至关重要。
- en: Some needs for accessibility come and go over time. For example, when my son
    was born,This is Pavel speaking. my wife and I alternated time taking care of
    the baby and I ended up spending a lot of time working at night. To maximize precious
    sleep, I wanted the screen to be less bright, and was thankful that many websites
    offer a dark mode. Later, I found that taking notes by voice was convenient when
    my hands were busy holding the baby. And when I was trying to put the baby to
    sleep, muting the TV and reading the closed captions turned out to be the best
    way of watching movies.
  id: totrans-2863
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，一些辅助需求会出现和消失。例如，当我的儿子出生时，这是帕夫尔在说话。我和妻子轮流照顾宝宝，我最终花了很多时间在夜间工作。为了最大限度地利用宝贵的睡眠时间，我希望屏幕亮度更低，为此我感谢许多网站提供了暗黑模式。后来，我发现当我的手忙于抱宝宝时，通过语音记笔记很方便。而且，当我试图哄宝宝睡觉时，关闭电视和阅读字幕竟然是观看电影的最佳方式。
- en: The underlying reasons for using these accessibility tools were temporary; but
    other uses may last longer, or be permanent. I’m ever-grateful, for example, for
    [curb cuts](https://en.wikipedia.org/wiki/Curb_cut), which make it much more convenient
    to go on walks with a stroller.And even though my son has now started walking
    on his own, he’s still small enough that walking up a curb without a curb cut
    is difficult for him. And there’s a good chance that, like many of my relatives,
    my eyesight will worsen as I age and I’ll need to set my computer to a permanently
    larger text size. For more severe and permanent disabilities, there are advanced
    tools like [screen readers](https://www.afb.org/blindness-and-low-vision/using-technology/assistive-technology-products/screen-readers).Perhaps
    software assistants will become more widespread as technology improves, mediating
    between the user and web pages, and will one day no longer primarily be a screen
    reader accessibility technology. Password managers and form autofill agents are
    already somewhat like this, and in many cases use the same browser APIs as screen
    readers. These take time to learn and use effectively, but are transformative
    for those who need them.
  id: totrans-2864
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些辅助工具的潜在原因是暂时的；但其他用途可能持续时间更长，或成为永久性需求。例如，我非常感激[路边斜坡](https://en.wikipedia.org/wiki/Curb_cut)，它使得推婴儿车散步变得更加方便。尽管我的儿子现在已经开始自己走路，但他仍然很小，没有路边斜坡的话，对他来说上斜坡是困难的。而且，有很大可能性，就像我的许多亲戚一样，随着年龄的增长，我的视力会变差，我需要将电脑的字体大小永久性地设置得更大。对于更严重和永久性的残疾，有像[屏幕阅读器](https://www.afb.org/blindness-and-low-vision/using-technology/assistive-technology-products/screen-readers)这样的高级工具。也许随着技术的进步，软件助手将会变得更加普遍，它们将在用户和网页之间进行调解，并有一天不再主要是屏幕阅读器辅助技术。密码管理器和表单自动填充代理已经有些类似，并且在许多情况下使用与屏幕阅读器相同的浏览器API。这些工具需要时间来学习和有效使用，但对于需要它们的人来说，它们是变革性的。
- en: Accessibility covers the whole spectrum, from minor accommodations to advanced
    accessibility tools.We have an ethical responsibility to help all users. Plus,
    there is the practical matter that if you’re making a web page, you want as many
    people as possible to benefit from it. But a key lesson of all kinds of accessibility
    work, physical and digital, is that once an accessibility tool is built, creative
    people find that it helps in all kinds of situations unforeseen by the tool’s
    designers. Dark mode helps you tell your work and personal email apart; web page
    zoom helps you print the whole web page on a single sheet of paper; and keyboard
    shortcuts let you leverage muscle memory to submit many similar orders to a web
    application that doesn’t have a batch mode.
  id: totrans-2865
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性涵盖了整个范围，从轻微的便利设施到高级的可访问性工具。我们有道德责任帮助所有用户。此外，还有一个实际问题，那就是如果你正在制作一个网页，你希望尽可能多的人从中受益。但是，所有类型的可访问性工作，无论是物理的还是数字的，一个关键教训是，一旦可访问性工具被构建，创意人士会发现它在各种设计师未曾预见到的情况下都有帮助。暗黑模式帮助你区分工作和个人电子邮件；网页缩放功能帮助你将整个网页打印在一张纸上；而键盘快捷键让你可以利用肌肉记忆向没有批量模式的网络应用程序提交许多类似的订单。
- en: 'Moreover, accessibility derives from the same [principles](intro.html) that
    birthed the web: user control, multimodal content, and interoperability. These
    principles allowed the web to be accessible to all types of browsers and operating
    systems, and *these same principles* likewise make the web accessible to people
    of all types and abilities.'
  id: totrans-2866
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可访问性源于孕育网络的相同[原则](intro.html)：用户控制、多模式内容和互操作性。这些原则使得网络对所有类型的浏览器和操作系统都变得可访问，而且同样的原则同样使得网络对所有类型和能力的人变得可访问。
- en: In the United States, the United Kingdom, the European Union, and many other
    countries, website accessibility is in many cases legally required. For example,
    United States Government websites are required to be accessible under [Section
    508](https://www.access-board.gov/law/ra.html#section-508-federal-electronic-and-information-technology)
    of the [Rehabilitation Act Amendments of 1973 (with amendments added later)](https://www.access-board.gov/law/ra.html),
    and associated [regulations](https://www.access-board.gov/ict/). Non-government
    websites are also required to be accessible under the [Americans with Disabilities
    Act](https://www.ada.gov/ada_intro.htm), though it’s [not yet clear](https://www.americanbar.org/groups/law_practice/publications/law_practice_magazine/2022/jf22/vu-launey-egan/)
    exactly what that legal requirement means in practice, since it’s mostly being
    decided through the courts. In the UK, the [Equality Act 2010](https://www.siteimprove.com/glossary/uk-accessibility-laws/)
    established similar rules for websites, with stricter rules for government websites
    added in 2018\. A similar law in the European Union is the [European Accessibility
    Act](https://ec.europa.eu/social/main.jsp?catId=1202).
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国、英国、欧盟和其他许多国家，网站的可访问性在很多情况下是法律要求的。例如，美国政府的网站必须根据1973年[康复法案修正案](https://www.access-board.gov/law/ra.html#section-508-federal-electronic-and-information-technology)的第508节（后来增加了修正案）[相关法规](https://www.access-board.gov/ict/)实现可访问性。非政府网站也必须根据[美国残疾人法案](https://www.ada.gov/ada_intro.htm)实现可访问性，尽管在实践中这个法律要求的确切含义尚不清楚，因为它主要是由法院决定的。在英国，2010年的[平等法案](https://www.siteimprove.com/glossary/uk-accessibility-laws/)为网站制定了类似的规则，2018年增加了对政府网站更严格的规则。欧盟类似的法律是[欧洲可访问性法案](https://ec.europa.eu/social/main.jsp?catId=1202)。
- en: Zoom
  id: totrans-2868
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩放
- en: 'Let’s start with the simplest accessibility problem: text on the screen that
    is too small to read. It’s a problem many of us will face sooner or later, and
    is possibly the most common user disability issue. The simplest and most effective
    way to address this is by increasing font and element sizes. This approach is
    called *zoom*,The word zoom evokes an analogy to a camera zooming in, but it is
    not the same, because zoom causes layout. *Pinch zoom*, on the other hand, is
    just like a camera and does not cause layout. which means to lay out the page
    as if all of the CSS sizes were increased or decreased by a specified factor.'
  id: totrans-2869
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的可访问性问题开始：屏幕上太小而无法阅读的文本。这是我们中的许多人迟早会遇到的问题，可能是最常见的用户残疾问题。解决这个问题的最简单、最有效的方法是通过增加字体和元素大小。这种方法被称为*缩放*，缩放这个词让人联想到相机变焦的类比，但它并不相同，因为缩放会导致布局。另一方面，*捏合缩放*就像相机一样，不会导致布局。这意味着将页面布局得好像所有的CSS大小都按指定因素增加或减少。
- en: To implement it, we first need a way to trigger zooming. On most browsers, that’s
    done with the `Ctrl-+`, `Ctrl--`, and `Ctrl-0` keys; using the `Ctrl` modifier
    key means you can type a `+`, `-`, or `0` into a text entry without triggering
    the zoom function.
  id: totrans-2870
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现它，我们首先需要一个触发缩放的方法。在大多数浏览器中，这是通过`Ctrl-+`、`Ctrl--`和`Ctrl-0`键来完成的；使用`Ctrl`修饰键意味着你可以在文本输入中输入`+`、`-`或`0`而不会触发缩放功能。
- en: 'To handle modifier keys, we’ll need to listen to both “key down” and “key up”
    events in the event loop, and store whether the `Ctrl` key is pressed:'
  id: totrans-2871
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理修饰键，我们需要在事件循环中监听“键按下”和“键释放”事件，并存储`Ctrl`键是否被按下：
- en: '[PRE685]'
  id: totrans-2872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: 'Now we can have a case in the key handling code for “key down” events while
    the `Ctrl` key is held:'
  id: totrans-2873
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在按键处理代码中为“键按下”事件添加一个情况，当`Ctrl`键被按下时：
- en: '[PRE686]'
  id: totrans-2874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: Here, the argument to `increment_zoom` is whether we should increment (`True`)
    or decrement (`False`).
  id: totrans-2875
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`increment_zoom`的参数是是否应该增加（`True`）或减少（`False`）。
- en: 'The `Browser` code just delegates to the `Tab`, via a main thread task:'
  id: totrans-2876
  prefs: []
  type: TYPE_NORMAL
  zh: '`Browser`代码只是通过主线程任务委托给`Tab`：'
- en: '[PRE687]'
  id: totrans-2877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: Finally, the `Tab` responds to these commands by adjusting a new `zoom` property,
    which starts at `1` and acts as a multiplier for all “CSS sizes” on the web page:Zoom
    typically does not change the size of elements of the browser chrome. Browsers
    *can* do that too, but it’s usually triggered by a global OS setting.
  id: totrans-2878
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Tab`通过调整一个新的`zoom`属性来响应这些命令，该属性从`1`开始，作为网页上所有“CSS大小”的乘数：通常，缩放不会改变浏览器chrome中元素的大小。浏览器*也可以*这样做，但通常是由全局操作系统设置触发的。
- en: '[PRE688]'
  id: totrans-2879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: 'Note that we need to set the `needs_render` flag when we zoom to redraw the
    screen after zooming is complete. Also note that when we zoom the page we also
    need to adjust the scroll position,In a real browser, adjusting the scroll position
    when zooming is more complex than just multiplying. That’s because zoom not only
    changes the heights of individual lines of text, but also changes line breaking,
    meaning more or fewer lines of text. This means there’s no easy correspondence
    between old and new scroll positions. Most real browsers implement a much more
    general algorithm called [scroll anchoring](https://drafts.csswg.org/css-scroll-anchoring-1/)
    that handles all kinds of changes beyond just zoom. and reset the zoom level when
    we navigate to a new page:'
  id: totrans-2880
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们缩放时，需要设置`needs_render`标志以在缩放完成后重新绘制屏幕。另外，注意当我们缩放页面时，我们还需要调整滚动位置，在真实浏览器中，缩放时调整滚动位置比简单的乘法要复杂。这是因为缩放不仅改变了文本行的长度，还改变了换行，意味着文本行数会增多或减少。这意味着旧滚动位置和新滚动位置之间没有简单的对应关系。大多数真实浏览器实现了一个更通用的算法，称为[滚动锚点](https://drafts.csswg.org/css-scroll-anchoring-1/)，它处理了除缩放之外的所有类型的更改，并在我们导航到新页面时重置缩放级别：
- en: '[PRE689]'
  id: totrans-2881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: 'The `zoom` factor is supposed to multiply all CSS sizes, so we’ll need access
    to it during layout. There are a few ways to do this, but one easy way is just
    to pass it as a parameter to `layout` for `DocumentLayout`:'
  id: totrans-2882
  prefs: []
  type: TYPE_NORMAL
  zh: '`zoom`因子应该乘以所有CSS大小，因此我们将在布局期间需要访问它。有几种方法可以做到这一点，但一种简单的方法就是将`zoom`作为参数传递给`layout`的`DocumentLayout`：'
- en: '[PRE690]'
  id: totrans-2883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: '[PRE691]'
  id: totrans-2884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: 'Every other layout object can also have a `zoom` field, copied from its parent
    in `layout`. Here’s `BlockLayout`; the other layout classes should do the same:'
  id: totrans-2885
  prefs: []
  type: TYPE_NORMAL
  zh: 每个其他布局对象也可以有一个`zoom`字段，从其父级`layout`中复制。这是`BlockLayout`；其他布局类应该做同样的事情：
- en: '[PRE692]'
  id: totrans-2886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: Various methods now need to scale their font sizes to account for `zoom`. Since
    scaling by `zoom` is a common operation, let’s wrap it in a helper method, `dpx`:Normally,
    `dpx` would be a terrible function name, being short and cryptic. But we’ll be
    calling this function a lot, mixed in with mathematical operations, and it’ll
    be convenient for it not to take up too much space.
  id: totrans-2887
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要各种方法调整字体大小以考虑`zoom`。由于缩放是一个常见的操作，让我们将其包装在一个辅助方法`dpx`中：通常，`dpx`会是一个糟糕的函数名，因为它简短且晦涩。但我们将频繁调用此函数，与数学运算混合使用，并且它将方便地不占用太多空间。
- en: '[PRE693]'
  id: totrans-2888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: Think of `dpx` not as a simple helper method, but as a unit conversion from
    a *CSS pixel* (the units specified in a CSS declaration) to a *device pixel* (what’s
    actually drawn on the screen). In a real browser, this method could also account
    for differences like high-DPI displays.
  id: totrans-2889
  prefs: []
  type: TYPE_NORMAL
  zh: 将`dpx`不仅仅视为一个简单的辅助方法，而视为从*CSS像素*（CSS声明中指定的单位）到*设备像素*（实际绘制在屏幕上的内容）的单位转换。在真实浏览器中，此方法还可以考虑高DPI显示等差异。
- en: 'We’ll do this conversion to adjust the font sizes in the `text` and `input`
    methods for `BlockLayout`, and in `InputLayout`:'
  id: totrans-2890
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行这种转换以调整`BlockLayout`的`text`和`input`方法以及`InputLayout`中的字体大小：
- en: '[PRE694]'
  id: totrans-2891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: '[PRE695]'
  id: totrans-2892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: As well as the font size in `TextLayout`:Browsers also usually have a *minimum*
    font size feature, but it’s a lot trickier to use correctly. Since a minimum font
    size only affects *some* of the text on the page, and doesn’t affect other CSS
    lengths, it can cause overflowing fonts and broken layouts. Because of these problems,
    browsers often restrict the feature to situations where the site seems to be using
    [relative font sizes](https://developer.mozilla.org/en-US/docs/Web/CSS/font-size).
  id: totrans-2893
  prefs: []
  type: TYPE_NORMAL
  zh: 以及在`TextLayout`中的字体大小：浏览器通常也有一个*最小*字体大小功能，但正确使用它要复杂得多。由于最小字体大小只影响页面上的*一些*文本，并且不影响其他CSS长度，它可能导致字体溢出和布局损坏。由于这些问题，浏览器通常将此功能限制在网站似乎使用[相对字体大小](https://developer.mozilla.org/en-US/docs/Web/CSS/font-size)的情况下。
- en: '[PRE696]'
  id: totrans-2894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: 'And the fixed `INPUT_WIDTH_PX` for text boxes:'
  id: totrans-2895
  prefs: []
  type: TYPE_NORMAL
  zh: 以及文本框的固定`INPUT_WIDTH_PX`宽度：
- en: '[PRE697]'
  id: totrans-2896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: 'Finally, one tricky place we need to adjust for zoom is inside `DocumentLayout`.
    Here there are two sets of lengths: the overall `WIDTH`, and the `HSTEP`/`VSTEP`
    padding around the edges of the page. The `WIDTH` comes from the size of the application
    window itself, so that’s measured in device pixels and doesn’t need to be converted.
    But the `HSTEP`/`VSTEP` is part of the page’s layout, so it’s in CSS pixels and
    *does* need to be converted:'
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要调整缩放的一个棘手地方是在`DocumentLayout`内部。这里有两组长度：整体的`WIDTH`和围绕页面边缘的`HSTEP`/`VSTEP`填充。`WIDTH`来自应用程序窗口本身的大小，因此它以设备像素为单位进行测量，不需要转换。但`HSTEP`/`VSTEP`是页面布局的一部分，所以它以CSS像素为单位，*确实*需要转换：
- en: '[PRE698]'
  id: totrans-2898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: Now try it out. All of the fonts should get about 10% bigger each time you press
    `Ctrl-+`, and shrink by 10% when you press `Ctrl--`. The bigger text should still
    wrap appropriately at the edge of the screen, and CSS lengths should be scaled
    just like the text is. This is great for reading text more easily.
  id: totrans-2899
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下。每次按`Ctrl-+`时，所有字体都应该大约增加10%，而按`Ctrl--`时则缩小10%。较大的文本应该在屏幕边缘适当地换行，CSS长度应该像文本一样缩放。这对于更容易阅读文本来说非常好。
- en: '[Here is an example](examples/example14-line-breaking.html) of some text before
    zoom.No book on the web would be complete without some good old [Lorem ipsum](https://en.wikipedia.org/wiki/Lorem_ipsum)!'
  id: totrans-2900
  prefs: []
  type: TYPE_NORMAL
  zh: '[这是一个缩放前文本的示例](examples/example14-line-breaking.html)。没有一本网络书籍会缺少一些传统的[Lorem
    ipsum](https://en.wikipedia.org/wiki/Lorem_ipsum)！'
- en: This should render as shown in Figure 1, while Figure 2 shows how it should
    look after a 2× zoom. Note how not only are the words twice as big, but the lines
    wrap at different words, just as desired.
  id: totrans-2901
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该如图1所示渲染，而图2显示了2倍缩放后的样子。注意，不仅单词的大小增加了一倍，而且换行发生在不同的单词上，正如预期的那样。
- en: '![Figure 1: Example of line breaking before zoom.](img/54900a19f04b62d8a9cb554014d50f4a.png)'
  id: totrans-2902
  prefs: []
  type: TYPE_IMG
  zh: '![图1：缩放前的换行示例](img/54900a19f04b62d8a9cb554014d50f4a.png)'
- en: 'Figure 1: Example of line breaking before zoom.'
  id: totrans-2903
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：缩放前的换行示例。
- en: '![Figure 2: Example of line breaking after zoom.](img/470b8f0d00632f821e43417cd6dfb299.png)'
  id: totrans-2904
  prefs: []
  type: TYPE_IMG
  zh: '![图2：缩放后的换行示例](img/470b8f0d00632f821e43417cd6dfb299.png)'
- en: 'Figure 2: Example of line breaking after zoom.'
  id: totrans-2905
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：缩放后的换行示例。
- en: 'On high-resolution screens, CSS pixels are scaled by both zoom and a [`devicePixelRatio`](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio)
    factor.Strictly speaking, the JavaScript variable called `devicePixelRatio` is
    the product of the device-specific and zoom-based scaling factors. This factor
    scales device pixels so that there are approximately 96 CSS [pixels per inch](https://en.wikipedia.org/wiki/Dots_per_inch)
    (which a lot of old-school desktop displays had). For example, the original iPhone
    had 163 pixels per inch; the browser on that device used a `devicePixelRatio`
    of 2, so that 96 CSS pixels corresponds to 192 device pixels or about 1.17 inches.Typically
    the `devicePixelRatio` is rounded to an integer because that tends to make text
    and layout look crisper, but this isn’t required, and as pixel densities increase
    it becomes less and less important. For example, the Pixelbook Go I’m using to
    write this book, with a resolution of 166 pixels per inch, has a ratio of 1.25\.
    The choice of ratio for a given screen is somewhat arbitrary. This scaling is
    especially tricky when a device is connected to multiple displays: a window may
    switch from a low-resolution to a high-resolution display (thus changing `devicePixelRatio`)
    or even be split across two displays with different resolutions.'
  id: totrans-2906
  prefs: []
  type: TYPE_NORMAL
  zh: 在高分辨率屏幕上，CSS 像素由缩放和 `devicePixelRatio` 因子共同缩放。严格来说，名为 `devicePixelRatio` 的 JavaScript
    变量是设备特定缩放因子和基于缩放的缩放因子的乘积。这个因子将设备像素缩放，使得大约有 96 CSS [每英寸像素](https://en.wikipedia.org/wiki/Dots_per_inch)（许多老式桌面显示器就是这样）。例如，原始的
    iPhone 每英寸有 163 个像素；该设备上的浏览器使用了 `devicePixelRatio` 为 2，因此 96 CSS 像素对应 192 个设备像素或大约
    1.17 英寸。通常 `devicePixelRatio` 被四舍五入到整数，因为这往往会使文本和布局看起来更清晰，但这不是必需的，并且随着像素密度的增加，它变得越来越不重要。例如，我用来写这本书的
    Pixelbook Go，分辨率为每英寸 166 个像素，其比例为 1.25。对于给定屏幕的比率选择在一定程度上是任意的。当设备连接到多个显示器时，这种缩放特别棘手：窗口可能从低分辨率切换到高分辨率显示器（从而改变
    `devicePixelRatio`），甚至可能被分割到两个具有不同分辨率的显示器上。
- en: Dark Mode
  id: totrans-2907
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暗黑模式
- en: Another useful visual change is using darker colors to help users who are extra
    sensitive to light, use their device at night, or who just prefer a darker color
    scheme. This browser *dark mode* feature should switch both the browser chrome
    and the web page itself to use white text on a black background, and otherwise
    adjust background colors to be darker.These days, dark mode has hit the mainstream.
    It’s supported by pretty much all operating systems, browsers, and popular apps,
    and many people enable it as a personal preference. But it was an accessibility
    feature, often called high contrast or color filtering mode, long before then.
    Many other technologies, including text-to-speech, optical character recognition,
    on-screen keyboards, and voice control were also pioneered by accessibility engineers
    before becoming widely used.
  id: totrans-2908
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的视觉变化是使用较深的颜色来帮助那些对光线特别敏感的用户，在夜间使用他们的设备，或者只是更喜欢较深的配色方案的用户。这个浏览器 *暗黑模式*
    功能应该将浏览器界面和网页本身都切换到使用黑色背景上的白色文本，并相应地调整背景颜色以变得更深。如今，暗黑模式已经进入主流。几乎所有操作系统、浏览器和流行应用都支持它，许多人出于个人喜好而启用它。但在此之前，它是一个可访问性功能，通常被称为高对比度或颜色过滤模式。许多其他技术，包括语音合成、光学字符识别、屏幕键盘和语音控制，也是在成为广泛使用之前由可访问性工程师开创的。
- en: 'We’ll trigger dark mode in the event loop with `Ctrl-d`:'
  id: totrans-2909
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在事件循环中通过 `Ctrl-d` 触发暗黑模式：
- en: '[PRE699]'
  id: totrans-2910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: 'When dark mode is active, we need to draw both the browser chrome and the web
    page contents differently. The browser chrome is a bit easier, so let’s start
    with that. We’ll start with a `dark_mode` field indicating whether dark mode is
    active:'
  id: totrans-2911
  prefs: []
  type: TYPE_NORMAL
  zh: 当暗黑模式激活时，我们需要以不同的方式绘制浏览器界面和网页内容。浏览器界面相对简单一些，所以我们先从它开始。我们将从表示暗黑模式是否激活的 `dark_mode`
    字段开始：
- en: '[PRE700]'
  id: totrans-2912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: 'Now we just need to flip all the colors in `raster_chrome` when `dark_mode`
    is set. Let’s store the foreground and background colors in variables we can reuse:'
  id: totrans-2913
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当 `dark_mode` 被设置时，我们只需要在 `raster_chrome` 中翻转所有颜色。让我们将前景色和背景色存储在可以重复使用的变量中：
- en: '[PRE701]'
  id: totrans-2914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: 'Similarly, in `paint` on `Chrome`, we need to use the right foreground color:'
  id: totrans-2915
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在 `Chrome` 的 `paint` 中，我们需要使用正确的前景色：
- en: '[PRE702]'
  id: totrans-2916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: Then we just need to use `color` instead of `black` everywhere. Make that change
    in `paint`.Of course, a full-featured browser’s chrome has many more buttons and
    colors to adjust than our browser’s. Most browsers support a theming system that
    stores all the relevant colors and images, and dark mode switches the browser
    from one theme to another.
  id: totrans-2917
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需在所有地方使用`color`而不是`black`。在`paint`中进行这个更改。当然，功能齐全的浏览器界面有更多按钮和颜色需要调整，比我们的浏览器多得多。大多数浏览器支持一个主题系统，它存储所有相关的颜色和图像，深色模式将浏览器从一种主题切换到另一种。
- en: 'Now, we want the web page content to change from light mode to dark mode as
    well. To start, let’s inform the `Tab` when the user requests dark mode:'
  id: totrans-2918
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望网页内容能够从浅色模式切换到深色模式。首先，让我们在用户请求深色模式时通知`Tab`：
- en: '[PRE703]'
  id: totrans-2919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: 'And in `Tab`:'
  id: totrans-2920
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Tab`中：
- en: '[PRE704]'
  id: totrans-2921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: 'Note that we need to re-render the page when the dark mode setting is flipped,
    so that the user actually sees the new colors. On that note, we also need to set
    dark mode when changing tabs, since all tabs should be either dark or light:'
  id: totrans-2922
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当深色模式设置翻转时，我们需要重新渲染页面，以便用户实际上能看到新的颜色。在这方面，我们还需要在切换标签时设置深色模式，因为所有标签都应该要么是深色要么是浅色：
- en: '[PRE705]'
  id: totrans-2923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: 'Now we need the page’s colors to somehow depend on dark mode. The easiest to
    change are the default text color and the background color of the document, which
    are set by the browser. The default text color, for example, comes from the `INHERITED_PROPERTIES`
    dictionary, which we can just modify based on the dark mode:'
  id: totrans-2924
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要页面的颜色以某种方式依赖于深色模式。最容易更改的是文档的默认文本颜色和背景颜色，这些颜色由浏览器设置。例如，默认文本颜色来自`INHERITED_PROPERTIES`字典，我们可以根据深色模式对其进行修改：
- en: '[PRE706]'
  id: totrans-2925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: 'And the background for the page is drawn by the `Browser` in the `draw` method,
    which we can make depend on dark mode:'
  id: totrans-2926
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的背景是通过`Browser`的`draw`方法绘制的，我们可以使其依赖于深色模式：
- en: '[PRE707]'
  id: totrans-2927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: Now if you open the browser and switch to dark mode, you should see white text
    on a black background, as in Figure 3.
  id: totrans-2928
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您打开浏览器并切换到深色模式，您应该看到白色文本在黑色背景上，如图3所示。
- en: '![Figure 3: Example of dark mode rendering of text.](img/2c232f0dabf981aae3d743c5d1ba0bdc.png)'
  id: totrans-2929
  prefs: []
  type: TYPE_IMG
  zh: '![图3：文本深色模式渲染示例。](img/2c232f0dabf981aae3d743c5d1ba0bdc.png)'
- en: 'Figure 3: Example of dark mode rendering of text.'
  id: totrans-2930
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：文本深色模式渲染示例。
- en: The browser really should not be changing colors on unsuspecting pages; that
    could have terrible readability outcomes if the page’s theme conflicted! Instead
    web pages [indicate support](https://blogs.windows.com/msedgedev/2021/06/16/dark-mode-html-form-controls/)
    for dark mode using the `color-scheme` [`meta` tag](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta/name)
    or [CSS property](https://developer.mozilla.org/en-US/docs/Web/CSS/color-scheme).
    Browsers use the presence of the meta tag to determine whether it’s safe to apply
    dark mode. Before `color-scheme` was standardized, web pages could in principle
    offer alternative color schemes using [alternative style sheets](https://developer.mozilla.org/en-US/docs/Web/CSS/Alternative_style_sheets),
    but few browsers supported it (of the major ones, only Firefox) and it wasn’t
    commonly used.
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器真的不应该在不经意间更改页面的颜色；如果页面的主题冲突，这可能会产生可怕的可读性后果！相反，网页应使用`color-scheme` `meta`标签或[CSS属性](https://developer.mozilla.org/en-US/docs/Web/CSS/color-scheme)来表明对深色模式的支持。浏览器使用元标签的存在来确定是否安全地应用深色模式。在`color-scheme`标准化之前，网页原则上可以使用[备用样式表](https://developer.mozilla.org/en-US/docs/Web/CSS/Alternative_style_sheets)提供替代颜色方案，但很少浏览器支持它（在主要浏览器中，只有Firefox）并且它并不常见。
- en: Customizing Dark Mode
  id: totrans-2932
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义深色模式
- en: Our simple dark mode implementation works well for pages with just text on a
    background. But for a good-looking dark mode, we also need to adjust all the other
    colors on the page. For example, buttons and input elements probably need a darker
    background color, as do any colors that the web developer used on the page.
  id: totrans-2933
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的深色模式实现对于只有文本在背景上的页面效果很好。但为了有一个好看的深色模式，我们还需要调整页面上的所有其他颜色。例如，按钮和输入元素可能需要更深的背景颜色，以及网页开发者在该页面上使用的任何颜色。
- en: 'To support this, CSS uses [media queries](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries).
    This is a special syntax that basically wraps some CSS rules in an `if` statement
    with some kind of condition; if the condition is true, those CSS rules are used,
    but if the condition is false, they are ignored. The `prefers-color-scheme` condition
    checks for dark mode. For example, this CSS will make `<div>`s have a white text
    on a black background only in dark mode:'
  id: totrans-2934
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一点，CSS 使用 [媒体查询](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)。这是一种特殊的语法，基本上是将一些
    CSS 规则包裹在一个带有某种条件的 `if` 语句中；如果条件为真，则使用这些 CSS 规则，如果条件为假，则忽略它们。`prefers-color-scheme`
    条件检查深色模式。例如，以下 CSS 代码将使 `<div>` 在深色模式下只有白色文本和黑色背景：
- en: '[PRE708]'
  id: totrans-2935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: 'Web developers can use `prefers-color-scheme` queries in their own style sheets,
    adjusting their own choice of colors to fit user requests, but we can also use
    a `prefers-color-scheme` media query in the browser default style sheet to adjust
    the default colors for links, buttons, and text entries:'
  id: totrans-2936
  prefs: []
  type: TYPE_NORMAL
  zh: 网络开发者可以在自己的样式表中使用 `prefers-color-scheme` 查询，调整自己的颜色选择以适应用户请求，但我们也可以在浏览器默认样式表中使用
    `prefers-color-scheme` 媒体查询来调整链接、按钮和文本输入的默认颜色：
- en: '[PRE709]'
  id: totrans-2937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: Here I chose very specific hexadecimal colors that preserve the general color
    scheme of blue and orange, but ensure maximum contrast with white foreground text
    so they are easy to read. It’s important to choose colors that ensure maximum
    contrast (an [“AAA”](https://accessibleweb.com/rating/aaa/) rating). [This tool](https://webaim.org/resources/contrastchecker/)
    is handy for checking the contrast of foreground and background colors.
  id: totrans-2938
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我选择了非常具体的十六进制颜色，以保留蓝色和橙色的总体配色方案，但确保与白色前景文本的最大对比度，以便易于阅读。选择确保最大对比度的颜色（[“AAA”](https://accessibleweb.com/rating/aaa/)
    评级）非常重要。这个 [工具](https://webaim.org/resources/contrastchecker/) 对于检查前景和背景颜色的对比度很有用。
- en: 'To implement media queries, we’ll have to start with parsing this syntax:'
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现媒体查询，我们必须从解析此语法开始：
- en: '[PRE710]'
  id: totrans-2940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: Then, in `parse`, we keep track of the current color scheme and adjust it every
    time we enter or exit an `@media` rule:For simplicity, this code doesn’t handle
    nested `@media` rules, because with just one type of media query there’s no point
    in nesting them. To handle nested `@media` queries the `media` variable would
    have to store a stack of conditions.
  id: totrans-2941
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `parse` 中，我们跟踪当前配色方案，并在每次进入或退出 `@media` 规则时调整它：为了简单起见，此代码不处理嵌套的 `@media`
    规则，因为只有一个类型的媒体查询，嵌套它们没有意义。要处理嵌套的 `@media` 查询，`media` 变量必须存储条件栈。
- en: '[PRE711]'
  id: totrans-2942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: 'Note that I’ve modified the list of rules to store not just the selector and
    the body, but also the color scheme for those rules—`None` if it applies regardless
    of color scheme, `dark` for dark mode only, and `light` for light mode only. This
    way, the `style` function can ignore rules that don’t apply:'
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经修改了规则列表，不仅存储选择器和主体，还存储这些规则的配色方案——如果它不受配色方案的影响，则为 `None`，仅深色模式为 `dark`，仅浅色模式为
    `light`。这样，`style` 函数可以忽略不适用的情况：
- en: '[PRE712]'
  id: totrans-2944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: Try your browser on this [web page](examples/example14-focus.html)I’ll use it
    throughout the chapter as the “focus example”. with lots of links, text entries,
    and buttons, and you should now see that in dark mode they also change color to
    have a darker background and lighter foreground. It should look like Figure 4
    in dark mode.
  id: totrans-2945
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在浏览器中打开这个 [网页](examples/example14-focus.html)，我将在整章中使用它作为“焦点示例”。它包含许多链接、文本输入和按钮，你现在应该看到在深色模式下，它们也会改变颜色，以拥有更深的背景和更浅的前景。在深色模式下，它应该看起来像图
    4。
- en: '![Figure 4: Example of dark mode with forms. See the browser.engineering website
    for full color.](img/b2be086855b5cbe99b77c906d555e339.png)'
  id: totrans-2946
  prefs: []
  type: TYPE_IMG
  zh: '![图 4：表单的深色模式示例。查看浏览器工程网站以获取全色效果](img/b2be086855b5cbe99b77c906d555e339.png)'
- en: 'Figure 4: Example of dark mode with forms. See the `browser.engineering` website
    for full color.'
  id: totrans-2947
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4：表单的深色模式示例。查看 `browser.engineering` 网站以获取全色效果。
- en: Besides `prefers-color-scheme`, web pages can use media queries to increase
    or decrease contrast when a user [`prefers-contrast`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-contrast)
    or disable unnecessary animations when a user [`prefers-reduced-motion`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion),
    both of which can help users with certain disabilities. Users can also force the
    use of a specific, limited palette of colors through their operating system; web
    pages can detect this with the [`forced-colors`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/forced-colors)
    media query or disable it for certain elements (use with care!) with [`forced-color-adjust`](https://developer.mozilla.org/en-US/docs/Web/CSS/forced-color-adjust).
  id: totrans-2948
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`prefers-color-scheme`，网页还可以使用媒体查询在用户`prefers-contrast`（[偏好对比度](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-contrast)）或`prefers-reduced-motion`（[偏好减少运动](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion)）时增加或减少对比度，或禁用不必要的动画，这两者都有助于有特定残疾的用户。用户还可以通过操作系统强制使用特定的、有限的调色板颜色；网页可以通过`forced-colors`（[强制颜色](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/forced-colors)）媒体查询来检测这一点，或者使用`forced-color-adjust`（[强制颜色调整](https://developer.mozilla.org/en-US/docs/Web/CSS/forced-color-adjust)）禁用某些元素（请谨慎使用！）。
- en: Keyboard Navigation
  id: totrans-2949
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘导航
- en: Right now, most of our browser’s features are triggered using the mouse,Except
    for scrolling, which is keyboard only. which is a problem for users with injuries
    or disabilities in their hand—and also a problem for power users that prefer their
    keyboards. So ideally every browser feature should be accessible via the keyboard
    as well as the mouse. That includes browser chrome interactions like back navigation,
    typing a URL, or quitting the browser, and also web page interactions such as
    submitting forms, typing in text areas, navigating links, and selecting items
    on the page.
  id: totrans-2950
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们浏览器的大多数功能都是通过鼠标触发的，除了滚动，滚动只能通过键盘进行。这对手部受伤或有残疾的用户来说是个问题——对那些更喜欢键盘的效率用户来说也是个问题。所以理想情况下，每个浏览器功能都应该可以通过键盘和鼠标访问。这包括浏览器chrome交互，如后退导航、输入URL或退出浏览器，以及网页交互，如提交表单、在文本区域中输入、导航链接和选择页面上的项目。
- en: 'Let’s start with the browser chrome, since it’s the easiest. Here, we need
    to allow the user to back-navigate, to type in the address bar, and to create
    and cycle through tabs, all with the keyboard. We’ll also add a keyboard shortcut
    for quitting the browser.Depending on the OS you might also need shortcuts for
    minimizing or maximizing the browser window. Those require calling specialized
    OS APIs, so I won’t implement them. Let’s make all these shortcuts in the event
    loop use the `Ctrl` modifier key so they don’t interfere with normal typing: `Ctrl-Left`
    to go back, `Ctrl-l` to type in the address bar, `Ctrl-t` to create a new tab,
    `Ctrl-Tab` to switch to the next tab, and `Ctrl-q` to exit the browser:'
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从浏览器chrome开始，因为它是最简单的。在这里，我们需要允许用户通过键盘进行后退导航、在地址栏中输入，以及创建和切换标签页。我们还会添加一个退出浏览器的键盘快捷键。根据操作系统，可能还需要缩放或最大化浏览器窗口的快捷键。这些需要调用专门的操作系统API，所以我不将实现它们。让我们在事件循环中使用`Ctrl`修改键来创建所有这些快捷键，这样它们就不会干扰正常的输入：`Ctrl-Left`后退，`Ctrl-l`在地址栏中输入，`Ctrl-t`创建新标签页，`Ctrl-Tab`切换到下一个标签页，以及`Ctrl-q`退出浏览器：
- en: '[PRE713]'
  id: totrans-2952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: 'Here, the `focus_addressbar` and `cycle_tabs` methods are new, but their contents
    are just copied from `handle_click`:'
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`focus_addressbar`和`cycle_tabs`方法是新的，但它们的实现内容只是从`handle_click`复制过来的：
- en: '[PRE714]'
  id: totrans-2954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: Now any clicks in the browser chrome can be replaced with keyboard actions.
    But what about clicks in the web page itself? This is trickier, because web pages
    can have any number of links. So the standard solution is letting the user `Tab`
    through all the clickable things on the page, and press `Enter` to actually click
    on them.Though it’s not the only solution. The old [Vimperator](http://vimperator.org/)
    browser extension for Firefox and its successors instead shows one- or two-letter
    codes next to each clickable element, and lets the user type those codes to activate
    that element.
  id: totrans-2955
  prefs: []
  type: TYPE_NORMAL
  zh: 现在浏览器chrome中的任何点击都可以用键盘操作来替代。但网页本身中的点击怎么办呢？这比较棘手，因为网页可以有任意数量的链接。所以标准的解决方案是让用户通过`Tab`键遍历页面上的所有可点击元素，然后按`Enter`键来实际点击它们。尽管这不是唯一的解决方案。旧版的Firefox浏览器扩展[Vimperator](http://vimperator.org/)及其继任者会在每个可点击元素旁边显示一或两个字母的代码，并允许用户输入这些代码来激活该元素。
- en: We’ll implement this by expanding our implementation of *focus*. We already
    have a `focus` property on each `Tab` indicating which `input` element is capturing
    keyboard input. Let’s allow buttons and links to be focused as well. Of course,
    they don’t capture keyboard input, but when the user presses `Enter` we’ll press
    the button or navigate to the link.
  id: totrans-2956
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过扩展 `focus` 的实现来实现这一点。我们已经在每个 `Tab` 上有一个 `focus` 属性，表示哪个 `input` 元素正在捕获键盘输入。让我们允许按钮和链接也可以获得焦点。当然，它们不捕获键盘输入，但用户按下
    `Enter` 时，我们将按下按钮或导航到链接。
- en: 'We’ll start by binding those keys in the event loop:'
  id: totrans-2957
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将这些键绑定到事件循环中：
- en: '[PRE715]'
  id: totrans-2958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: Note that these lines don’t go inside the `if ctrl_down` block, since we’re
    binding `Tab` and `Enter`, not `Ctrl-Tab` and `Ctrl-Enter`. In `Browser`, we just
    forward these keys to the active tab’s `enter` and `advance_tab` methods:Real
    browsers also support `Shift-Tab` to go backwards in focus order.
  id: totrans-2959
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些行不在 `if ctrl_down` 块内，因为我们绑定的是 `Tab` 和 `Enter`，而不是 `Ctrl-Tab` 和 `Ctrl-Enter`。在
    `Browser` 中，我们只是将这些键转发到活动标签的 `enter` 和 `advance_tab` 方法：真实浏览器也支持 `Shift-Tab` 以在焦点顺序中向后移动。
- en: '[PRE716]'
  id: totrans-2960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: 'Let’s start with the `advance_tab` method. Each time it’s called, the browser
    should advance focus to the next focusable thing. This will first require a definition
    of which elements are focusable:'
  id: totrans-2961
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `advance_tab` 方法开始。每次调用它时，浏览器都应该将焦点移动到下一个可聚焦元素。这首先需要定义哪些元素是可聚焦的：
- en: '[PRE717]'
  id: totrans-2962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: Next, in `advance_tab`, we need to find out where the currently focused element
    is in this list so we can move focus to the next one.
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `advance_tab` 中，我们需要找出当前聚焦的元素在这个列表中的位置，以便我们可以将焦点移动到下一个元素。
- en: '[PRE718]'
  id: totrans-2964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: 'Finally, we just need to focus on the chosen element. If we’ve reached the
    last focusable node (or if there weren’t any focusable nodes to begin with), we’ll
    unfocus the page and move focus to the address bar:'
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要将焦点放在选定的元素上。如果我们已经到达最后一个可聚焦节点（或者一开始就没有可聚焦节点），我们将取消页面焦点并移动焦点到地址栏：
- en: '[PRE719]'
  id: totrans-2966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: 'Now that an element is focused, the user should be able to interact with it
    by pressing `Enter`. Since the exact action they’re performing varies (navigating
    a link, pressing a button, clearing a text entry), we’ll call this “activating”
    the element:'
  id: totrans-2967
  prefs: []
  type: TYPE_NORMAL
  zh: 现在元素已经获得焦点，用户应该能够通过按下 `Enter` 来与之交互。由于他们执行的确切操作各不相同（导航链接、按下按钮、清除文本输入），我们将这称为“激活”元素：
- en: '[PRE720]'
  id: totrans-2968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: 'The `activate_element` method does different things for different kinds of
    elements:'
  id: totrans-2969
  prefs: []
  type: TYPE_NORMAL
  zh: '`activate_element` 方法对不同类型的元素执行不同的操作：'
- en: '[PRE721]'
  id: totrans-2970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: All of this activation code is copied from the `click` method on `Tab`s. Note
    that hitting `Enter` when focused on a text entry clears the text entry; in most
    browsers, it submits the containing form instead. That quirk is a workaround for
    our browser [not implementing](forms.html#interacting-with-widgets) the `Backspace`
    key (Section 8.3).
  id: totrans-2971
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些激活代码都是从 `Tab` 上的 `click` 方法复制的。注意，当焦点在文本输入框上时按下 `Enter` 会清除文本输入；在大多数浏览器中，它会提交包含的表单。这个特性是一个针对我们的浏览器[未实现](forms.html#interacting-with-widgets)
    `Backspace` 键（第8.3节）的解决方案。
- en: 'The `click` method can now be rewritten to call `activate_element` directly:'
  id: totrans-2972
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将 `click` 方法重写为直接调用 `activate_element`：
- en: '[PRE722]'
  id: totrans-2973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: 'Also, since now any element can be focused, we need `keypress` to check that
    an `input` element is focused before typing into it:'
  id: totrans-2974
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于现在任何元素都可以获得焦点，我们需要在输入之前检查 `input` 元素是否已获得焦点：
- en: '[PRE723]'
  id: totrans-2975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: I’ve called `activate_element` to create an empty `value` attribute.
  id: totrans-2976
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经调用 `activate_element` 来创建一个空的 `value` 属性。
- en: 'Similarly, `InputLayout` used to draw a cursor for any focused element. Now
    that `button` elements can be focused, it needs to be more careful:'
  id: totrans-2977
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`InputLayout` 以前用于为任何获得焦点的元素绘制光标。现在 `button` 元素也可以获得焦点，因此需要更加小心：
- en: '[PRE724]'
  id: totrans-2978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: 'Finally, note that sometimes activating an element submits a form or navigates
    to a new page, which means the element we were focused on no longer exists. We
    need to make sure to clear focus in this case:'
  id: totrans-2979
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，有时激活一个元素会提交表单或导航到新页面，这意味着我们之前聚焦的元素不再存在。在这种情况下，我们需要确保清除焦点：
- en: '[PRE725]'
  id: totrans-2980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: We now have the ability to focus on links, buttons, and text entries. But as
    with any browser feature, it’s worth asking whether web page authors should be
    able to customize it. With keyboard navigation, the author might want certain
    links not to be focusable (like “permalinks” to a section heading, which would
    just be noise to most users), or might want to change the order in which the user
    tabs through focusable items.
  id: totrans-2981
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了聚焦链接、按钮和文本输入的能力。但就像任何浏览器功能一样，值得问一下网页作者是否应该能够自定义它。在使用键盘导航时，作者可能希望某些链接不可聚焦（例如指向章节标题的“永久链接”，这对大多数用户来说只是噪音），或者可能希望改变用户通过标签键切换焦点项的顺序。
- en: 'Browsers support the `tabindex` HTML attribute to make this possible. The `tabindex`
    attribute is a number. An element isn’t focusable if its `tabindex` is negative,
    and elements with smaller `tabindex` values come before those with larger values
    and those without a `tabindex` at all. To implement that, we need to sort the
    focusable elements by tab index, so we need a function that returns the tab index:'
  id: totrans-2982
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器支持 `tabindex` HTML 属性来实现这一点。`tabindex` 属性是一个数字。如果一个元素的 `tabindex` 是负数，则该元素不可聚焦，具有较小
    `tabindex` 值的元素排在具有较大值的元素之前，以及没有任何 `tabindex` 的元素之前。为了实现这一点，我们需要按 tab 索引对可聚焦元素进行排序，因此我们需要一个返回
    tab 索引的函数：
- en: '[PRE726]'
  id: totrans-2983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: 'The default value, “9999999”, is a hack to make sure that elements without
    a `tabindex` attribute sort after ones with the attribute. Now we can sort by
    `get_tabindex` in `advance_tab`:'
  id: totrans-2984
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值，“9999999”，是一个技巧，以确保没有 `tabindex` 属性的元素在排序时排在有属性的元素之后。现在我们可以在 `advance_tab`
    中按 `get_tabindex` 排序：
- en: '[PRE727]'
  id: totrans-2985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: Since Python’s sort is “stable”, two elements with the same `tabindex` won’t
    change their relative position in `focusable_nodes`.
  id: totrans-2986
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 的排序是“稳定的”，具有相同 `tabindex` 的两个元素在 `focusable_nodes` 中的相对位置不会改变。
- en: 'Additionally, elements with non-negative `tabindex` are automatically focusable,
    even if they aren’t a link or a button or a text entry. That’s useful, because
    that element might listen to the `click` event. To support this let’s first extend
    `is_focusable` to consider `tabindex`:'
  id: totrans-2987
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，具有非负 `tabindex` 的元素自动可聚焦，即使它们不是链接、按钮或文本输入。这很有用，因为该元素可能监听 `click` 事件。为了支持这一点，我们首先扩展
    `is_focusable` 以考虑 `tabindex`：
- en: '[PRE728]'
  id: totrans-2988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: 'If you print out `focusable_nodes` for the [focus example](examples/example14-focus.html),
    you should get this:'
  id: totrans-2989
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印出 `[focus example](examples/example14-focus.html)` 的 `focusable_nodes`，你应该得到这个：
- en: '[PRE729]'
  id: totrans-2990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: We also need to make sure to send a `click` event when an element is activated.
    Note that just like clicking on an element, activating an element can be canceled
    from JavaScript using `preventDefault`.
  id: totrans-2991
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保在元素被激活时发送一个 `click` 事件。注意，就像点击一个元素一样，激活一个元素也可以通过 JavaScript 使用 `preventDefault`
    来取消。
- en: '[PRE730]'
  id: totrans-2992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: 'We now have configurable keyboard navigation for both the browser and the web
    page content. And it involved writing barely any new code, instead mostly moving
    code from existing methods into new standalone ones. The fact that keyboard navigation
    simplified, not complicated, our browser implementation is a common outcome: improving
    accessibility often involves generalizing and refining existing concepts, leading
    to more maintainable code overall.'
  id: totrans-2993
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在为浏览器和网页内容都提供了可配置的键盘导航。这涉及到编写几乎没有任何新代码，而是主要将现有方法中的代码移动到新的独立方法中。键盘导航简化而不是复杂化我们的浏览器实现是一个常见的成果：提高可访问性通常涉及泛化和细化现有概念，从而总体上使代码更易于维护。
- en: Why send the `click` event when an element is activated, instead of a special
    `activate` event? Internet Explorer [did use](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa742710(v=vs.85))
    a special `activate` event, and other browsers used to send a [DOMActivate](https://w3c.github.io/uievents/#event-type-DOMActivate)
    event, but modern standards require sending the `click` event even if the element
    was activated via keyboard, not via a click. This works better when the developers
    aren’t thinking much about accessibility and only register the `click` event listener.
  id: totrans-2994
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在元素被激活时发送 `click` 事件，而不是一个特殊的 `activate` 事件呢？Internet Explorer [曾经使用过](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa742710(v=vs.85))
    一个特殊的 `activate` 事件，而其他浏览器则发送一个 [DOMActivate](https://w3c.github.io/uievents/#event-type-DOMActivate)
    事件，但现代标准要求即使元素是通过键盘激活的，而不是通过点击，也要发送 `click` 事件。当开发者不太考虑可访问性时，这种方法效果更好，他们只会注册 `click`
    事件监听器。
- en: Indicating Focus
  id: totrans-2995
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指示聚焦
- en: Thanks to our keyboard shortcuts, users can now reach any link, button, or text
    entry from the keyboard. But if you try to use this to navigate a website, it’s
    a little hard to know which element is focused when. A visual indication—similar
    to the cursor we use on text inputs—would help sighted users know if they’ve reached
    the element they want or if they need to keep hitting `Tab`. In most browsers,
    this visual indication is a *focus ring* that outlines the focused element.
  id: totrans-2996
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢我们的键盘快捷键，用户现在可以通过键盘访问任何链接、按钮或文本输入。但如果你尝试使用它来导航网站，很难知道何时哪个元素被聚焦。一个视觉指示——类似于我们在文本输入中使用的光标——可以帮助视力正常的用户知道他们是否到达了他们想要的元素，或者他们是否需要继续按
    `Tab` 键。在大多数浏览器中，这种视觉指示是一个 *聚焦环*，它勾勒出聚焦的元素。
- en: 'To implement focus rings, we’ll use the same mechanism we use to draw text
    cursors. Recall that, right now, text cursors are added by drawing a vertical
    line in `InputLayout`’s `paint` method. We’ll add a call to `paint_outline` in
    that method, to draw a rectangle around the focused element:'
  id: totrans-2997
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现聚焦轮廓，我们将使用与绘制文本光标相同的机制。回想一下，目前文本光标是通过在 `InputLayout` 的 `paint` 方法中绘制一条垂直线来添加的。我们将在该方法中添加对
    `paint_outline` 的调用，以在聚焦元素周围绘制一个矩形：
- en: '[PRE731]'
  id: totrans-2998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: 'Set this `is_focused` flag in a new `focus_element` method that we’ll now use
    to change the `focus` field in a `Tab`:'
  id: totrans-2999
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 `focus_element` 方法中设置这个 `is_focused` 标志，我们现在将使用它来更改 `Tab` 中的 `focus` 字段：
- en: '[PRE732]'
  id: totrans-3000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: Outline painting should happen in `paint_effects`, because it paints on top
    of the subtree.
  id: totrans-3001
  prefs: []
  type: TYPE_NORMAL
  zh: 轮廓绘制应在 `paint_effects` 中发生，因为它在子树之上绘制。
- en: '[PRE733]'
  id: totrans-3002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: I also changed the cursor drawing to only happen if the node is focused *and*
    it’s an `input` element. Tabbing over to a `button` element should not draw a
    cursor!
  id: totrans-3003
  prefs: []
  type: TYPE_NORMAL
  zh: 我还更改了光标绘制，只有在节点聚焦且它是一个 `input` 元素时才会发生。切换到 `button` 元素时不应绘制光标！
- en: Unfortunately, handling links is a little more complicated. That’s because one
    `<a>` element corresponds to multiple `TextLayout` objects, so there’s not just
    one layout object where we can stick the code. Moreover, those `TextLayout`s could
    be split across several lines, so we might want to draw more than one focus ring.
    To work around this, let’s draw the focus ring in `LineLayout`. Each `LineLayout`
    finds all of its child `TextLayout`s that are focused, and draws a rectangle around
    them all.
  id: totrans-3004
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，处理链接要复杂一些。这是因为一个 `<a>` 元素对应多个 `TextLayout` 对象，所以我们不能只在一个布局对象中放置代码。此外，这些
    `TextLayout`s 可能分布在多行中，所以我们可能需要绘制多个聚焦轮廓。为了解决这个问题，让我们在 `LineLayout` 中绘制聚焦轮廓。每个
    `LineLayout` 找到所有聚焦的子 `TextLayout`s，并围绕它们绘制一个矩形。
- en: '[PRE734]'
  id: totrans-3005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: You should also add a `paint_outline` call to `BlockLayout`, since users can
    make any element focusable with `tabindex`.This code does not correctly handle
    the case of text inside an inline element inside another inline element, with
    the outside one focused. You could fix this by walking from the `child` to the
    `LineLayout`’s `node`, checking the `is_focused` field along the way. I’m skipping
    that in the interest of expediency.
  id: totrans-3006
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该在 `BlockLayout` 中添加一个 `paint_outline` 调用，因为用户可以使用 `tabindex` 使任何元素可聚焦。此代码没有正确处理嵌套在另一个内联元素内的内联元素中的文本的情况，外部元素处于聚焦状态。你可以通过从
    `child` 到 `LineLayout` 的 `node` 的方式来修复这个问题，沿途检查 `is_focused` 字段。我为了方便起见跳过了这一步。
- en: Now when you `Tab` through a page, you should see the focused element highlighted
    with a black outline. And if a link happens to cross multiple lines, you will
    see our browser use multiple focus rectangles to make crystal clear what is being
    focused on.
  id: totrans-3007
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你使用 `Tab` 遍历页面时，你应该看到聚焦元素以黑色轮廓突出显示。如果一个链接恰好跨越多行，你将看到我们的浏览器使用多个聚焦矩形来清楚地表明聚焦的是什么。
- en: 'Except for one problem: if the focused element is scrolled offscreen, there
    is still no way to tell what’s focused. To fix this we’ll need to automatically
    scroll it onto the screen when the user tabs to it.'
  id: totrans-3008
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一个问题：如果聚焦元素滚动到屏幕外，仍然没有方法可以知道什么被聚焦。为了修复这个问题，当用户切换到它时，我们需要自动将其滚动到屏幕上。
- en: 'Doing this is a bit tricky, because determining if the element is offscreen
    requires layout. So, instead of scrolling to it immediately, we’ll set a new `needs_focus_scroll`
    bit on `Tab`:'
  id: totrans-3009
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事有点棘手，因为确定元素是否在屏幕外需要布局。因此，我们不会立即滚动到它，而是在 `Tab` 上设置一个新的 `needs_focus_scroll`
    位：
- en: '[PRE735]'
  id: totrans-3010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: 'Then, `run_animation_frame` can scroll appropriately before resetting the flag:'
  id: totrans-3011
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`run_animation_frame` 在重置标志之前可以适当地滚动：
- en: '[PRE736]'
  id: totrans-3012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: 'To actually do the scrolling, we need to find the layout object corresponding
    to the focused node:'
  id: totrans-3013
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际进行滚动，我们需要找到对应于聚焦节点的布局对象：
- en: '[PRE737]'
  id: totrans-3014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: 'Then, we scroll to it:'
  id: totrans-3015
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将其滚动到：
- en: '[PRE738]'
  id: totrans-3016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: Here, I’m shifting the scroll position to ensure that the object is `SCROLL_STEP`
    pixels from the top of the screen, though a real browser will likely use different
    logic for scrolling up versus down.
  id: totrans-3017
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将滚动位置调整到确保对象距离屏幕顶部 `SCROLL_STEP` 像素，尽管真正的浏览器可能使用不同的逻辑来向上或向下滚动。
- en: Focus outlines now basically work, and will even scroll on-screen if you try
    it on the [focus example](examples/example14-focus.html). Figure 5 shows what
    it looks like after I pressed tab to focus the “this is a link” element.
  id: totrans-3018
  prefs: []
  type: TYPE_NORMAL
  zh: 聚焦轮廓现在基本上是有效的，如果你在 [聚焦示例](examples/example14-focus.html) 上尝试，它甚至会滚动。图 5 显示了我按下
    tab 键聚焦“这是一个链接”元素后的样子。
- en: '![Figure 5: Example of focus outline.](img/f4bd18e9647c6c74e63ba1a2aa6500aa.png)'
  id: totrans-3019
  prefs: []
  type: TYPE_IMG
  zh: '![图 5：聚焦轮廓示例。](img/f4bd18e9647c6c74e63ba1a2aa6500aa.png)'
- en: 'Figure 5: Example of focus outline.'
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5：聚焦轮廓示例。
- en: 'But ideally, the focus indicator should be customizable, so that the web page
    author can make sure the focused element stands out. In CSS, that’s done with
    the `:focus` [pseudo-class](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes).
    Basically, this means you can write a selector like this:'
  id: totrans-3021
  prefs: []
  type: TYPE_NORMAL
  zh: 但理想情况下，焦点指示器应该是可定制的，这样网页作者就可以确保焦点元素突出显示。在CSS中，这是通过使用`:focus` [伪类](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes)来实现的。基本上，这意味着你可以编写如下选择器：
- en: '[PRE739]'
  id: totrans-3022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: And then that selector applies only to `<div>` elements that are currently focused.It’s
    called a pseudo-class because the syntax is similar to [class](https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors)
    selectors, except there’s no actual `class` attribute on the matched elements.
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个选择器仅应用于当前聚焦的`<div>`元素。它被称为伪类，因为其语法与[class](https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors)选择器类似，只是匹配的元素上没有实际的`class`属性。
- en: 'To implement this, we need to parse this new kind of selector. Let’s change
    `selector` to call a new `simple_selector` subroutine to parse a tag name and
    a possible pseudo-class:'
  id: totrans-3024
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要解析这种新类型的选择器。让我们将`selector`改为调用一个新的`simple_selector`子例程来解析一个标签名和一个可能的伪类：
- en: '[PRE740]'
  id: totrans-3025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: 'In `simple_selector`, the parser first parses a tag name and then checks if
    that’s followed by a colon and a pseudo-class name:'
  id: totrans-3026
  prefs: []
  type: TYPE_NORMAL
  zh: 在`simple_selector`中，解析器首先解析一个标签名，然后检查是否跟有一个冒号和一个伪类名：
- en: '[PRE741]'
  id: totrans-3027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: 'A `PseudoclassSelector` wraps another selector:'
  id: totrans-3028
  prefs: []
  type: TYPE_NORMAL
  zh: '`PseudoclassSelector`包装另一个选择器：'
- en: '[PRE742]'
  id: totrans-3029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: 'Matching is straightforward:'
  id: totrans-3030
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配是直接的：
- en: '[PRE743]'
  id: totrans-3031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: Unknown pseudoclasses simply never match anything.
  id: totrans-3032
  prefs: []
  type: TYPE_NORMAL
  zh: 未知伪类简单地从不匹配任何内容。
- en: The focused element can now be styled. But ideally we’d also be able to customize
    the focus outline itself and not just the element. That can be done by adding
    support for the CSS [`outline` property](https://developer.mozilla.org/en-US/docs/Web/CSS/outline),
    which looks like this (for a 3-pixel-thick red outline):We’ll only implement this
    syntax, but `outline` can also take a few other forms.
  id: totrans-3033
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以样式化聚焦的元素。但理想情况下，我们也能自定义焦点轮廓本身，而不仅仅是元素。这可以通过添加对CSS [outline属性](https://developer.mozilla.org/en-US/docs/Web/CSS/outline)的支持来实现，其外观如下（3像素厚的红色轮廓）：我们只会实现这种语法，但`outline`还可以采取几种其他形式。
- en: '[PRE744]'
  id: totrans-3034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: 'We can parse that into a thickness and a color:'
  id: totrans-3035
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其解析为厚度和颜色：
- en: '[PRE745]'
  id: totrans-3036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: 'And then paint a parsed outline:'
  id: totrans-3037
  prefs: []
  type: TYPE_NORMAL
  zh: 然后绘制一个解析后的轮廓：
- en: '[PRE746]'
  id: totrans-3038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: 'Even better, we can move the default two-pixel black outline into the browser
    default style sheet, like this:'
  id: totrans-3039
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们可以将默认的2像素黑色轮廓移动到浏览器默认样式表中，如下所示：
- en: '[PRE747]'
  id: totrans-3040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: 'Moreover, we can now make the outline white when dark mode is triggered, which
    is important for it to stand out against the black background:'
  id: totrans-3041
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现在我们可以在触发暗黑模式时使轮廓变为白色，这对于它突出黑色背景非常重要：
- en: '[PRE748]'
  id: totrans-3042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: 'Finally, change all of our `paint` methods to use `parse_outline` instead of
    `is_focused` to draw the outline. Here is `LineLayout`:'
  id: totrans-3043
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将所有`paint`方法更改为使用`parse_outline`而不是`is_focused`来绘制轮廓。以下是`LineLayout`：
- en: '[PRE749]'
  id: totrans-3044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: For the [focus example](examples/example14-focus.html), the focus outline of
    an `<a>` element becomes thicker and red, as in Figure 6.
  id: totrans-3045
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[焦点示例](examples/example14-focus.html)，`<a>`元素的焦点轮廓变得更厚，变为红色，如图6所示。
- en: '![Figure 6: Example of a customized focus outline.](img/77eb49735d94f70b7f355e73cbe8f74b.png)'
  id: totrans-3046
  prefs: []
  type: TYPE_IMG
  zh: '![图6：自定义焦点轮廓的示例。](img/77eb49735d94f70b7f355e73cbe8f74b.png)'
- en: 'Figure 6: Example of a customized focus outline.'
  id: totrans-3047
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：自定义焦点轮廓的示例。
- en: As with dark mode, focus outlines are a case where adding an accessibility feature
    meant generalizing existing browser features to make them more powerful. And once
    they were generalized, this generalized form can be made accessible to web page
    authors, who can use it for anything they like.
  id: totrans-3048
  prefs: []
  type: TYPE_NORMAL
  zh: 就像暗黑模式一样，焦点轮廓是一个例子，添加一个可访问性功能意味着将现有的浏览器功能泛化，使其更强大。一旦它们被泛化，这种泛化形式就可以提供给网页作者，他们可以使用它来做任何他们喜欢的事情。
- en: It’s essential that the focus indicator have [good contrast](https://www.w3.org/TR/WCAG21/#contrast-minimum)
    against the underlying web page, so the user can clearly see what they’ve tabbed
    over to. This might [require some care](https://darekkay.com/blog/accessible-focus-indicator/)
    if the default focus indicator looks like the page or element background. For
    example, it might be best to draw [two outlines](https://blogs.windows.com/msedgedev/2019/10/15/form-controls-microsoft-edge-chromium/),
    white and black, to guarantee a visible focus indicator on both dark and light
    backgrounds. If you’re designing your own, the [Web Content Accessibility Guidelines](https://www.w3.org/WAI/standards-guidelines/wcag/)
    provides contrast guidance.
  id: totrans-3049
  prefs: []
  type: TYPE_NORMAL
  zh: 焦点指示器与底层网页的对比度必须很好，以便用户可以清楚地看到他们已经切换到的部分。这可能需要[一些注意](https://darekkay.com/blog/accessible-focus-indicator/)，如果默认焦点指示器看起来像页面或元素背景。例如，最好绘制[两个轮廓](https://blogs.windows.com/msedgedev/2019/10/15/form-controls-microsoft-edge-chromium/)，白色和黑色，以确保在深色和浅色背景上都有可见的焦点指示器。如果您正在设计自己的，[Web内容可访问性指南](https://www.w3.org/WAI/standards-guidelines/wcag/)提供了对比度指导。
- en: The Accessibility Tree
  id: totrans-3050
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可访问性树
- en: 'Zoom, dark mode, and focus indicators help users with difficulty seeing fine
    details, but if the user can’t see the screen at all,The original motivation for
    screen readers was for blind users, but it’s also sometimes useful for situations
    where the user shouldn’t be looking at the screen (such as driving), or for devices
    with no screen. they typically use a screen reader instead. The name kind of explains
    it all: the screen reader reads the text on the screen out loud, so that users
    know what it says without having to see it.'
  id: totrans-3051
  prefs: []
  type: TYPE_NORMAL
  zh: 放大、暗色模式和焦点指示器有助于有视觉困难的用户，但如果用户根本看不到屏幕，屏幕阅读器的原始动机是为盲人用户设计的，但它有时也适用于用户不应该看屏幕的情况（如驾驶），或者对于没有屏幕的设备，他们通常使用屏幕阅读器。这个名字基本上解释了一切：屏幕阅读器大声读出屏幕上的文本，这样用户就可以知道它说了什么，而无需看到它。
- en: 'So: what should a screen reader say? There are basically two big challenges
    we must overcome.'
  id: totrans-3052
  prefs: []
  type: TYPE_NORMAL
  zh: 那么：屏幕阅读器应该说什么呢？我们基本上必须克服两个大的挑战。
- en: First, web pages contain visual hints besides text that we need to reproduce
    for screen reader users. For example, when focus is on an `<input>` or `<button>`
    element, the screen reader needs to say so, since these users won’t see the light
    blue or orange background.
  id: totrans-3053
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，网页除了文本外还包含我们需要为屏幕阅读器用户复制的视觉提示。例如，当焦点在`<input>`或`<button>`元素上时，屏幕阅读器需要这样说，因为这些用户看不到浅蓝色或橙色的背景。
- en: And second, when listening to a screen reader, the user must be able to direct
    the browser to the part of the page that interests them.Though many people who
    rely on screen readers learn to listen to *much* faster speech, it’s still a less
    informationally dense medium than vision. For example, the user might want to
    skip headers and navigation menus, or even skip most of the page until they get
    to a paragraph of interest. But once they’ve reached the part of the page of interest
    to them, they may want it read to them, and if some sentence or phrase is particularly
    complex, they may want the screen reader to re-read it.
  id: totrans-3054
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，当用户在听屏幕阅读器时，用户必须能够将浏览器直接导航到他们感兴趣的页面部分。尽管许多依赖屏幕阅读器的人学会了以更快的速度听，但它仍然比视觉信息密度低。例如，用户可能想要跳过标题和导航菜单，甚至跳过页面的大部分内容，直到他们到达感兴趣的段落。但一旦他们到达感兴趣的页面部分，他们可能希望有人读给他们听，如果某些句子或短语特别复杂，他们可能希望屏幕阅读器重新阅读它。
- en: You can see an exampleI encourage you to test out your operating system’s built-in
    screen reader to get a feel for what screen reader navigation is like. On macOS,
    type Cmd-Fn-F5 to turn on Voice Over; on Windows, type Win-Ctrl-Enter or Win-Enter
    to start Narrator; on ChromeOS type Ctrl-Alt-z to start ChromeVox. All are largely
    used via keyboard shortcuts that you can look up. of screen reader navigation
    in the talk presented in the video shown in Figure 7, specifically the segment
    from 2:36–3:54.The whole talk is recommended; it has great examples of using accessibility
    technology.
  id: totrans-3055
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在视频展示的7号图中看到屏幕阅读器导航的示例。我鼓励您测试您操作系统的内置屏幕阅读器，以了解屏幕阅读器导航的感觉。在macOS上，按Cmd-Fn-F5打开Voice
    Over；在Windows上，按Win-Ctrl-Enter或Win-Enter启动Narrator；在ChromeOS上按Ctrl-Alt-z启动ChromeVox。所有这些都可以通过键盘快捷键来查找。视频中的7号图展示了从2:36到3:54的屏幕阅读器导航片段。整个演讲都值得推荐；它有使用可访问性技术的优秀示例。
- en: '[https://www.youtube-nocookie.com/embed/qi0tY60Hd6M?start=159](https://www.youtube-nocookie.com/embed/qi0tY60Hd6M?start=159)'
  id: totrans-3056
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.youtube-nocookie.com/embed/qi0tY60Hd6M?start=159](https://www.youtube-nocookie.com/embed/qi0tY60Hd6M?start=159)'
- en: 'Figure 7: Accessibility talk available [here].'
  id: totrans-3057
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：可访问性讨论在此[链接]中可用。
- en: To support all this, browsers structure the page as a tree and use that tree
    to interact with the screen reader. The higher levels of the tree represent items
    like paragraphs, headings, or navigation menus, while lower levels represent text,
    links, or buttons.Generally speaking, the OS APIs consume this tree like a data
    model, and the actual tree and data model exposed to the OS APIs is platform-specific.
  id: totrans-3058
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持所有这些功能，浏览器将页面结构化为树形，并使用该树与屏幕阅读器交互。树的较高层表示段落、标题或导航菜单等项，而较低层表示文本、链接或按钮。一般来说，操作系统API像数据模型一样消费这个树，实际暴露给操作系统API的树和数据模型是平台特定的。
- en: This probably sounds a lot like HTML—and it is quite similar! But, just as the
    HTML tree does not exactly match the layout tree, there’s not an exact match with
    this tree either. For example, some HTML elements (like `<div>`) group content
    for styling that is meaningless to screen reader users. Alternatively, some HTML
    elements may be invisible on the screen,For example, using `opacity:0`. There
    are several other ways in real browsers that elements can be made invisible, such
    as with the `visibility` or `display` CSS properties. but relevant to screen reader
    users. The browser therefore builds a separate [accessibility tree](https://developer.mozilla.org/en-US/docs/Glossary/Accessibility_tree)
    to support screen reader navigation.
  id: totrans-3059
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很像HTML——确实非常相似！但是，就像HTML树并不完全匹配布局树一样，这个树也没有完全匹配。例如，一些HTML元素（如`<div>`）用于对屏幕阅读器用户无意义的样式分组。或者，一些HTML元素可能在屏幕上不可见，例如使用`opacity:0`。在实际浏览器中，还有其他几种方式可以使元素变得不可见，例如使用`visibility`或`display`
    CSS属性。但对于屏幕阅读器用户来说，这些元素可能是相关的。因此，浏览器会构建一个单独的[可访问性树](https://developer.mozilla.org/en-US/docs/Glossary/Accessibility_tree)来支持屏幕阅读器导航。
- en: 'Let’s implement an accessibility tree in our browser. It’s built in a rendering
    phase just after layout:'
  id: totrans-3060
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中实现一个可访问性树。它是在布局阶段之后的一个渲染阶段构建的：
- en: '[PRE750]'
  id: totrans-3061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: 'The accessibility tree is built out of `AccessibilityNode`s:'
  id: totrans-3062
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性树是由`AccessibilityNode`构建的：
- en: '[PRE751]'
  id: totrans-3063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: 'The `build` method on `AccessibilityNode` recursively creates the accessibility
    tree. To do so, we traverse the HTML tree and, for each node, determine what “role”
    it plays in the accessibility tree. Some elements, like `<div>`, have no role,
    so don’t appear in the accessibility tree, while elements like `<input>`, `<a>`
    and `<button>` have default roles.Roles and default roles are specified in the
    [WAI-ARIA standard](https://www.w3.org/TR/wai-aria-1.2/#introroles). We can compute
    the role of a node based on its tag name, or from the special `role` attribute
    if that exists:'
  id: totrans-3064
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccessibilityNode`上的`build`方法递归地创建可访问性树。为此，我们遍历HTML树，并为每个节点确定它在可访问性树中扮演的“角色”。一些元素，如`<div>`，没有角色，因此不会出现在可访问性树中，而像`<input>`、`<a>`和`<button>`这样的元素有默认角色。角色和默认角色在[WAI-ARIA标准](https://www.w3.org/TR/wai-aria-1.2/#introroles)中指定。我们可以根据其标签名称或特殊`role`属性（如果存在）来计算节点的角色：'
- en: '[PRE752]'
  id: totrans-3065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: 'To build the accessibility tree, just recursively walk the HTML tree. Along
    the way, skip nodes with a `none` role, but still recurse into their children:'
  id: totrans-3066
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建可访问性树，只需递归遍历HTML树。在这个过程中，跳过具有`none`角色的节点，但仍然递归进入它们的子节点：
- en: '[PRE753]'
  id: totrans-3067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: 'Here is the accessibility tree for the [focus example](examples/example14-focus.html):'
  id: totrans-3068
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[焦点示例](examples/example14-focus.html)的可访问性树：
- en: '[PRE754]'
  id: totrans-3069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: The user can now direct the screen reader to walk up or down this accessibility
    tree and describe each node or trigger actions on it. Let’s implement that.
  id: totrans-3070
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以指导屏幕阅读器遍历这个可访问性树，并描述每个节点或在其上触发操作。让我们来实现这一点。
- en: In a multi-process browser ([like Chromium](https://www.chromium.org/developers/design-documents/multi-process-architecture/)),
    there is a browser process that interfaces with the OS, and render processes for
    loading web pages. Since screen reader APIs are synchronous, Chromium [stores
    two copies](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/accessibility/browser/how_a11y_works_2.md)
    of the accessibility tree, one in the browser and one in each renderer, and only
    sends changes between the two. An alternative design, used by pre-Chromium Microsoft
    Edge and some other browsers, connects each render process to accessibility API
    requests from the operating system. This removes the need to duplicate the accessibility
    tree, but exposing the operating system to individual tabs can lead to security
    issues.
  id: totrans-3071
  prefs: []
  type: TYPE_NORMAL
  zh: 在多进程浏览器（例如 [Chromium](https://www.chromium.org/developers/design-documents/multi-process-architecture/)）中，有一个与操作系统交互的浏览器进程，以及用于加载网页的渲染进程。由于屏幕阅读器
    API 是同步的，Chromium [存储了两份](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/accessibility/browser/how_a11y_works_2.md)无障碍树，一份在浏览器中，一份在每个渲染器中，并且只在两者之间发送更改。另一种设计，由预
    Chromium 的 Microsoft Edge 和一些其他浏览器使用，将每个渲染进程连接到来自操作系统的无障碍 API 请求。这消除了复制无障碍树的必要性，但将操作系统暴露给单个标签页可能导致安全问题。
- en: Screen Readers
  id: totrans-3072
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕阅读器
- en: Typically, the screen reader is a separate application from the browser;Screen
    readers need to help the user with operating system actions such as logging in,
    starting applications, and switching between them, so it makes sense for the screen
    reader to be outside any application and to integrate with them through the operating
    system. the browser communicates with it through OS-specific APIs. To keep this
    book platform-independent and demonstrate more clearly how screen readers interact
    with the accessibility tree, our discussion of screen reader support will instead
    include a minimal screen reader integrated directly into the browser.
  id: totrans-3073
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，屏幕阅读器是浏览器之外的一个独立应用程序；屏幕阅读器需要帮助用户执行操作系统操作，例如登录、启动应用程序和在这些应用程序之间切换，因此屏幕阅读器位于任何应用程序之外，并通过操作系统与它们集成是有意义的。浏览器通过操作系统特定的
    API 与其通信。为了使这本书平台无关，并更清楚地展示屏幕阅读器如何与无障碍树交互，我们关于屏幕阅读器支持的讨论将包括直接集成到浏览器中的最小屏幕阅读器。
- en: 'But should our built-in screen reader live in the `Browser` or each `Tab`?
    Modern browsers generally talk to screen readers from something like the `Browser`,
    so we’ll do that too.And therefore the browser thread in our multithreaded browser.
    So the very first thing we need to do is send the tab’s accessibility tree over
    to the browser thread. That’ll be a straightforward extension of the commit concept
    introduced in [Chapter 12](scheduling.html#committing-a-display-list). First,
    we’ll add the tree to `CommitData`:'
  id: totrans-3074
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的内置屏幕阅读器应该位于 `Browser` 还是每个 `Tab` 中？现代浏览器通常从类似 `Browser` 的东西与屏幕阅读器通信，所以我们也会这样做。因此，在多线程浏览器中，我们首先需要做的事情是将标签页的无障碍树发送到浏览器线程。这将是对第
    12 章中引入的提交概念的直接扩展。首先，我们将树添加到 `CommitData`：
- en: '[PRE755]'
  id: totrans-3075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: 'Then we send it across in `run_animation_frame`:'
  id: totrans-3076
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在 `run_animation_frame` 中发送它：
- en: '[PRE756]'
  id: totrans-3077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: Note that I clear the `accessibility_tree` field once it’s sent to the browser
    thread, much like with the display list, to avoid a data race.
  id: totrans-3078
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦将 `accessibility_tree` 字段发送到浏览器线程，我就像处理显示列表一样清除它，以避免数据竞争。
- en: 'Now that the tree is in the browser thread, let’s implement the screen reader.
    We’ll use two Python libraries to actually read text out loud: [`gtts`](https://pypi.org/project/gTTS/)
    (which wraps the Google [text-to-speech service](https://cloud.google.com/text-to-speech/docs/apis))
    and [`playsound`](https://pypi.org/project/playsound/). You can install them using
    `pip`:'
  id: totrans-3079
  prefs: []
  type: TYPE_NORMAL
  zh: 现在树已经位于浏览器线程中，让我们实现屏幕阅读器。我们将使用两个 Python 库来大声朗读文本：[`gtts`](https://pypi.org/project/gTTS/)（它封装了
    Google [文本到语音服务](https://cloud.google.com/text-to-speech/docs/apis)）和[`playsound`](https://pypi.org/project/playsound/)。您可以使用
    `pip` 安装它们：
- en: '[PRE757]'
  id: totrans-3080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: 'You can use these libraries to convert text to an audio file, and then play
    it:'
  id: totrans-3081
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些库将文本转换为音频文件，然后播放它：
- en: '[PRE758]'
  id: totrans-3082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: You may need to adjust the `SPEECH_FILE` path to fit your system better. If
    you have trouble importing any of the libraries, you may need to consult the [`gtts`](https://pypi.org/project/gTTS/)
    or [`playsound`](https://pypi.org/project/playsound/) documentation. If you can’t
    get these libraries working, just delete everything in `speak_text` except the
    `print` statement. You won’t hear things being spoken, but you can at least debug
    by watching the console output.
  id: totrans-3083
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要调整 `SPEECH_FILE` 路径以更好地适应你的系统。如果你在导入任何库时遇到麻烦，你可能需要查阅 `gtts` ([https://pypi.org/project/gTTS/](https://pypi.org/project/gTTS/))
    或 `playsound` ([https://pypi.org/project/playsound/](https://pypi.org/project/playsound/))
    的文档。如果你无法让这些库正常工作，只需删除 `speak_text` 中的所有内容，除了 `print` 语句。你将听不到任何被说出的话，但至少可以通过查看控制台输出进行调试。
- en: 'To start with, we’ll want a key binding that turns the screen reader on and
    off. While real operating systems typically use more obscure shortcuts, I’ll use
    `Ctrl-a` to turn on the screen reader in the event loop:'
  id: totrans-3084
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要一个键绑定来开启和关闭屏幕阅读器。虽然真实的操作系统通常使用更隐蔽的快捷键，但我会使用 `Ctrl-a` 在事件循环中开启屏幕阅读器：
- en: '[PRE759]'
  id: totrans-3085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: 'The `toggle_accessibility` method tells the `Tab` that accessibility is on:'
  id: totrans-3086
  prefs: []
  type: TYPE_NORMAL
  zh: '`toggle_accessibility` 方法告诉 `Tab` 访问性是开启的：'
- en: '[PRE760]'
  id: totrans-3087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE760]'
- en: 'When accessibility is on, the `Browser` should call a new `update_accessibility`
    method, which we’ll implement in a moment to actually produce sound:'
  id: totrans-3088
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问性开启时，`Browser` 应该调用一个新的 `update_accessibility` 方法，我们将在稍后实现它以实际产生声音：
- en: '[PRE761]'
  id: totrans-3089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: Now, what should the screen reader say? That’s not really up to the browser—the
    screen reader is a standalone application, often heavily configured by its user,
    and can decide on its own. But as a simple debugging aid, let’s write a screen
    reader that speaks the whole web page once it’s loaded; of course, a real screen
    reader is much more flexible than that.
  id: totrans-3090
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，屏幕阅读器应该说些什么？这实际上并不取决于浏览器——屏幕阅读器是一个独立的应用程序，通常由用户大量配置，并且可以自行决定。但作为一个简单的调试辅助工具，让我们编写一个屏幕阅读器，一旦页面加载完成就朗读整个网页；当然，真正的屏幕阅读器比这要灵活得多。
- en: To speak the whole document, we need to know how to speak each `AccessibilityNode`.
    This has to be decided back in the `Tab`, since the text will include DOM content
    that is not accessible to the browser thread. So let’s add a `text` field to `AccessibilityNode`
    and set it in `build` according to the node’s role and surrounding DOM context.
    For text nodes it’s just the text, and otherwise it describes the element tag,
    plus whether it’s focused.
  id: totrans-3091
  prefs: []
  type: TYPE_NORMAL
  zh: 要朗读整个文档，我们需要知道如何朗读每个 `AccessibilityNode`。这必须在 `Tab` 中决定，因为文本将包括浏览器线程无法访问的 DOM
    内容。所以让我们给 `AccessibilityNode` 添加一个 `text` 字段，并在 `build` 中根据节点角色和周围的 DOM 上下文设置它。对于文本节点，它只是文本，否则它描述了元素标签，以及它是否被聚焦。
- en: '[PRE762]'
  id: totrans-3092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE762]'
- en: 'This text construction logic is, of course, pretty naive, but it’s enough to
    demonstrate the idea. Here is how it works out for the [focus example](examples/example14-focus.html):'
  id: totrans-3093
  prefs: []
  type: TYPE_NORMAL
  zh: 这种文本构建逻辑当然是相当简单的，但足以演示这个想法。以下是它如何为 [焦点示例](examples/example14-focus.html) 工作的情况：
- en: '[PRE763]'
  id: totrans-3094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: The screen reader can then read the whole document by speaking the `text` field
    on each `AccessibilityNode`.
  id: totrans-3095
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕阅读器可以读取整个文档，通过在每个 `AccessibilityNode` 上说出 `text` 字段：
- en: '[PRE764]'
  id: totrans-3096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE764]'
- en: Speaking the whole document happens only once. But the user might need feedback
    as they browse the page. For example, when the user tabs from one element to another,
    they may want the new element spoken to them so they know what they’re interacting
    with.
  id: totrans-3097
  prefs: []
  type: TYPE_NORMAL
  zh: 整个文档的朗读只发生一次。但用户在浏览页面时可能需要反馈。例如，当用户从一个元素切换到另一个元素时，他们可能希望听到新元素的声音，以便知道他们正在与之交互。
- en: 'To do that, the browser thread is going to need to know which element is focused.
    Let’s add that to the `CommitData`:'
  id: totrans-3098
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，浏览器线程需要知道哪个元素是聚焦的。让我们将其添加到 `CommitData`：
- en: '[PRE765]'
  id: totrans-3099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: 'Make sure to pass this new argument in `run_animation_frame`. Then, in `Browser`,
    we’ll need to extract this field and save it to `tab_focus`:'
  id: totrans-3100
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 `run_animation_frame` 中传递这个新参数。然后，在 `Browser` 中，我们需要提取这个字段并将其保存到 `tab_focus`：
- en: '[PRE766]'
  id: totrans-3101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE766]'
- en: 'Now we need to know when focus changes. The simplest way is to store a `last_tab_focus`
    field on `Browser` with the last focused element we actually spoke out loud:'
  id: totrans-3102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要知道何时焦点发生变化。最简单的方法是在 `Browser` 上存储一个 `last_tab_focus` 字段，其中包含我们实际大声说出的最后一个聚焦元素：
- en: '[PRE767]'
  id: totrans-3103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: 'Then, if `tab_focus` isn’t equal to `last_tab_focus`, we know focus has moved
    and it’s time to speak the focused node. The change looks like this:'
  id: totrans-3104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果 `tab_focus` 不等于 `last_tab_focus`，我们知道焦点已经移动，是时候说出被聚焦的节点了。变化看起来是这样的：
- en: '[PRE768]'
  id: totrans-3105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: 'The `speak_node` method is similar to `speak_document` but it only speaks a
    single node:'
  id: totrans-3106
  prefs: []
  type: TYPE_NORMAL
  zh: '`speak_node` 方法与 `speak_document` 类似，但它只说出单个节点：'
- en: '[PRE769]'
  id: totrans-3107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE769]'
- en: 'There’s a lot more in a real screen reader: landmarks, navigating text at different
    granularities, repeating text when requested, and so on. Those features make various
    uses of the accessibility tree and the roles of the various nodes. But since the
    focus of this book is on the browser, not the screen reader itself, let’s focus
    for the rest of this chapter on additional browser features that support accessibility.'
  id: totrans-3108
  prefs: []
  type: TYPE_NORMAL
  zh: 真实屏幕阅读器中还有很多其他功能：地标、以不同粒度导航文本、在请求时重复文本等等。这些功能使得可访问性树和各个节点的角色有了各种用途。但由于本书的重点是浏览器，而不是屏幕阅读器本身，所以让我们在接下来的章节中关注支持可访问性的额外浏览器功能。
- en: The accessibility tree isn’t just for screen readers. For example, some users
    prefer touch output such as a [braille display](https://en.wikipedia.org/wiki/Refreshable_braille_display)
    instead of or in addition to speech output. While the output device is quite different,
    the accessibility tree would still contain all the information about what content
    is on the page, whether it can be interacted with, its state, and so on. Moreover,
    by using the same accessibility tree for all output devices, users who use more
    than one *assistive technology* (like a braille display and a screen reader) are
    sure to receive consistent information.
  id: totrans-3109
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性树不仅仅是为了屏幕阅读器。例如，一些用户更喜欢触摸输出，如[盲文显示器](https://en.wikipedia.org/wiki/Refreshable_braille_display)，而不是语音输出，或者两者兼而有之。虽然输出设备相当不同，但可访问性树仍然会包含有关页面上的内容、是否可以与之交互、其状态等信息。此外，通过为所有输出设备使用相同的可访问性树，使用多个辅助技术（如盲文显示器和屏幕阅读器）的用户肯定能接收到一致的信息。
- en: Accessible Alerts
  id: totrans-3110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可访问性警告
- en: Scripts do not interact directly with the accessibility tree, much like they
    do not interact directly with the display list. However, sometimes scripts need
    to inform the screen reader about *why* they’re making certain changes to the
    page to give screen reader users a better experience. The most common example
    is an alertAlso called a “toast”, because it pops up. telling you that some action
    you just did failed. A screen reader user needs the alert read to them immediately,
    no matter where in the document it’s inserted.
  id: totrans-3111
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本并不直接与可访问性树交互，就像它们不直接与显示列表交互一样。然而，有时脚本需要通知屏幕阅读器它们对页面进行某些更改的原因，以提供更好的用户体验。最常见的情况是弹出一个警告（也称为“吐司”，因为它会弹出）。告诉你你刚才执行的操作失败了。屏幕阅读器用户需要立即听到这个警告，无论它在文档中的位置在哪里。
- en: 'The `alert` role addresses this need. A screen reader will immediatelyThe alert
    is only triggered if the element is added to the document, has the `alert` role
    (or the equivalent `aria-live` value, `assertive`), and is visible in the layout
    tree (meaning it doesn’t have `display: none`), or if its contents change. In
    this chapter, I won’t handle all of these cases—I’ll just focus on new elements
    with an `alert` role, not changes to contents or CSS. read an element with that
    role, no matter where in the document the user currently is. Note that there aren’t
    any HTML elements whose default role is `alert`, so this requires the page author
    to explicitly set the `role` attribute.'
  id: totrans-3112
  prefs: []
  type: TYPE_NORMAL
  zh: '`alert`角色解决了这个需求。屏幕阅读器会立即读取具有该角色的元素，无论用户当前在文档中的位置在哪里。注意，没有HTML元素的默认角色是`alert`，因此这需要页面作者显式设置`role`属性。'
- en: 'On to implementation. We first need to make it possible for scripts to change
    the `role` attribute, by adding support for the `setAttribute` method. On the
    JavaScript side, this just calls a browser API:'
  id: totrans-3113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是实施。我们首先需要让脚本能够更改`role`属性，通过添加对`setAttribute`方法的支持。在JavaScript端，这仅仅调用了一个浏览器API：
- en: '[PRE770]'
  id: totrans-3114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE770]'
- en: 'The Python side is also quite simple:'
  id: totrans-3115
  prefs: []
  type: TYPE_NORMAL
  zh: Python端也相当简单：
- en: '[PRE771]'
  id: totrans-3116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE771]'
- en: 'Now we can implement the `alert` role. Search the accessibility tree for elements
    with that role:'
  id: totrans-3117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现`alert`角色。在可访问性树中搜索具有该角色的元素：
- en: '[PRE772]'
  id: totrans-3118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE772]'
- en: 'Now, we can’t just read out every `alert` at every frame; we need to keep track
    of what elements have already been read, so we don’t read them twice:'
  id: totrans-3119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不可能在每一帧都读出每一个`alert`；我们需要跟踪哪些元素已经被读取，以免重复读取：
- en: '[PRE773]'
  id: totrans-3120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE773]'
- en: 'Since `spoken_alerts` points into the accessibility tree, we need to update
    it any time the accessibility tree is rebuilt, to point into the new tree. Just
    like with compositing, use the `node` pointers in the accessibility tree to match
    accessibility nodes between the old and new accessibility tree. Note that, while
    this matching *could* be done inside `commit`, we want that method to be as fast
    as possible since that method blocks both the browser and main threads. So it’s
    best to do it in `update_accessibility`:'
  id: totrans-3121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`spoken_alerts`指向无障碍树，因此每次无障碍树重建时，都需要更新它，以便指向新的树。就像在合成中一样，使用无障碍树中的`node`指针来匹配旧的无障碍树和新无障碍树之间的无障碍节点。请注意，虽然这种匹配*可以在`commit`内部完成，但我们希望该方法尽可能快，因为该方法会阻塞浏览器和主线程。因此，最好在`update_accessibility`中完成它：
- en: '[PRE774]'
  id: totrans-3122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE774]'
- en: Note that if a node *loses* the `alert` role, we remove it from `spoken_alerts`,
    so that if it later gains the `alert` role back, it will be spoken again. This
    sounds like an edge case, but having a single element for all of your alerts (and
    just changing its class, say, from hidden to visible) is a common pattern.
  id: totrans-3123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果一个节点*丢失*了`alert`角色，我们会将其从`spoken_alerts`中移除，这样如果它后来重新获得了`alert`角色，它将再次被朗读。这听起来像是一个边缘情况，但为所有警报使用单个元素（例如，只更改其类，从隐藏到可见）是一种常见的模式。
- en: You should now be able to load up [this example](https://browser.engineering/examples/example14-alert-role.html)
    and hear alert text once the button is clicked.
  id: totrans-3124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够加载[这个示例](https://browser.engineering/examples/example14-alert-role.html)，并在点击按钮后听到警报文本。
- en: The `alert` role is an example of what ARIA calls a “live region”, a region
    of the page which can change as a result of user actions. There are other roles
    (like `status` or `alertdialog`), or live regions can be configured on a more
    granular level by setting their “politeness” via the `aria-live` attribute (assertive
    notifications interrupt the user, but polite ones don’t); what kinds of changes
    to announce, via `aria-atomic` and `aria-relevant`; and whether the live region
    is in a finished or intermediate state, via `aria-busy`. In addition, `aria-live`
    is all that’s necessary to create a live region; no role is necessary.
  id: totrans-3125
  prefs: []
  type: TYPE_NORMAL
  zh: '`alert`角色是ARIA所说的“实时区域”的一个例子，即页面上的一个区域，它可以因用户操作而改变。还有其他角色（如`status`或`alertdialog`），或者可以通过设置`aria-live`属性来在更细粒度级别配置实时区域，通过该属性设置其“礼貌性”（断言性通知会打断用户，但礼貌性通知不会）；通过`aria-atomic`和`aria-relevant`宣布哪些类型的更改；以及实时区域是否处于完成或中间状态，通过`aria-busy`。此外，`aria-live`是创建实时区域所必需的，不需要任何角色。'
- en: Voice and Visual Interaction
  id: totrans-3126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语音和视觉交互
- en: 'Thanks to our work in this chapter, our rendering pipeline now basically has
    two different outputs: a display list for visual interaction, and an accessibility
    tree for screen reader interaction. Many users will use just one or the other.
    However, it can also be valuable to use both together. For example, a user might
    have limited vision—able to make out the general items on a web page but unable
    to read the text. Such a user might use their mouse to navigate the page, but
    need the items under the mouse to be read to them by a screen reader.'
  id: totrans-3127
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢我们在本章中的工作，我们的渲染管线现在基本上有两个不同的输出：用于视觉交互的显示列表和用于屏幕阅读器交互的无障碍树。许多用户只会使用其中之一。然而，同时使用两者也可能非常有价值。例如，一个用户可能有视力受限——能够识别网页上的项目，但无法阅读文本。这样的用户可能会使用鼠标导航页面，但需要屏幕阅读器朗读鼠标下的项目。
- en: Let’s try that. Implementing this particular feature requires each accessibility
    node to know about its geometry on the page. The user could then instruct the
    screen reader to determine which object is under the mouse (via [hit testing](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/accessibility/browser/how_a11y_works_3.md#Hit-testing))
    and read it aloud.
  id: totrans-3128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个。实现这个特定功能需要每个无障碍节点知道它在页面上的几何形状。然后用户可以指示屏幕阅读器确定鼠标下的对象（通过[击中测试](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/accessibility/browser/how_a11y_works_3.md#Hit-testing))并大声朗读。
- en: Getting access to the geometry is tricky, because the accessibility tree is
    generated from the HTML tree, while the geometry is accessible in the layout tree.
    Let’s add a `layout_object` pointer to each `Element` object to help with that:If
    it has a layout object, that is. Some `Element`s might not, and their `layout_object`
    pointers will stay `None`.
  id: totrans-3129
  prefs: []
  type: TYPE_NORMAL
  zh: 获取几何形状是棘手的，因为无障碍树是从HTML树生成的，而几何形状在布局树中是可访问的。让我们为每个`Element`对象添加一个`layout_object`指针来帮助解决这个问题：如果它有一个布局对象，那就是。一些`Element`可能没有，它们的`layout_object`指针将保持为`None`。
- en: '[PRE775]'
  id: totrans-3130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE775]'
- en: 'Now, when we construct a layout object, we can fill in the `layout_object`
    field of its `Element`. In `BlockLayout`, it looks like this:'
  id: totrans-3131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们构建一个布局对象时，我们可以在其`Element`的`layout_object`字段中填写内容。在`BlockLayout`中，它看起来是这样的：
- en: '[PRE776]'
  id: totrans-3132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE776]'
- en: 'Make sure to add a similar line of code to the constructors for every other
    type of layout object. Each `AccessibilityNode` can then store the layout object’s
    bounds:'
  id: totrans-3133
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为其他类型的每个布局对象的构造函数添加类似的代码行。然后，每个`AccessibilityNode`都可以存储布局对象的边界：
- en: '[PRE777]'
  id: totrans-3134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE777]'
- en: Note that I’m using `absolute_bounds_for_obj` here, because the bounds we’re
    interested in are the absolute coordinates on the screen, after any transformations
    like `translate`.
  id: totrans-3135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我这里使用的是`absolute_bounds_for_obj`，因为我们感兴趣的边界是在任何变换（如`translate`）之后的屏幕上的绝对坐标。
- en: 'However, there is another complication: it may be that `node.layout_object`
    is not set; for example, text nodes do not have one.And that’s OK, because I chose
    not to set bounds at all for these nodes, as they are not focusable. Likewise,
    nodes with inline layout generally do not. So we need to walk up the tree to find
    the parent with a `BlockLayout` and union all text nodes in all `LineLayouts`
    that are children of the current `node`. And because there can be multiple `LineLayouts`
    and text nodes, the bounds need to be in an array of `skia.Rect` objects:'
  id: totrans-3136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个复杂的问题：可能是`node.layout_object`没有被设置；例如，文本节点就没有。这没关系，因为我选择不为这些节点设置任何边界，因为它们不是可聚焦的。同样，具有内联布局的节点通常也不是。因此，我们需要遍历树以找到具有`BlockLayout`的父节点，并将所有`LineLayouts`中的文本节点合并，这些`LineLayouts`是当前`node`的子节点。由于可能有多个`LineLayouts`和文本节点，边界需要在一个`skia.Rect`对象数组中：
- en: '[PRE778]'
  id: totrans-3137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE778]'
- en: 'So let’s implement the read-on-hover feature. First we need to listen for mouse
    move events in the event loop, which in SDL are called `MOUSEMOTION`:'
  id: totrans-3138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们实现悬停时读取的功能。首先，我们需要在事件循环中监听鼠标移动事件，在SDL中这些事件被称为`MOUSEMOTION`：
- en: '[PRE779]'
  id: totrans-3139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE779]'
- en: 'The browser should listen to the hovered position, determine if it’s over an
    accessibility node, and highlight that node. We don’t want to disturb the normal
    rendering cadence, so in `handle_hover` save the hover event and then in `composite_raster_and_draw`
    react to the hover:'
  id: totrans-3140
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器应该监听悬停位置，确定它是否在可访问节点上，并突出显示该节点。我们不希望打扰正常的渲染节奏，所以在`handle_hover`中保存悬停事件，然后在`composite_raster_and_draw`中对此做出反应：
- en: '[PRE780]'
  id: totrans-3141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE780]'
- en: 'When the user hovers over a node, we’ll do two things. First, draw its bounds
    on the screen; this helps users see what they’re hovering over, plus it’s also
    helpful for debugging. Do that in `paint_draw_list`; start by finding the accessibility
    node the user is hovering over (note the need to take scroll into account):'
  id: totrans-3142
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户悬停在节点上时，我们将做两件事。首先，在屏幕上绘制其边界；这有助于用户看到他们悬停的位置，同时也有助于调试。在`paint_draw_list`中这样做；首先找到用户悬停的访问节点（注意需要考虑滚动）：
- en: '[PRE781]'
  id: totrans-3143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE781]'
- en: 'By the way, the acronym `a11y` in `a11y_node`, with an “a”, the number 11,
    and a “y”, is a common shorthand for the word “accessibility”.The number “11”
    refers to the number of letters we’re eliding from “accessibility”. The `hit_test`
    function recurses over the accessibility tree:'
  id: totrans-3144
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`a11y_node`中的缩写`a11y`，由一个“a”，数字11和一个“y”组成，是“accessibility”这个词的常见缩写。数字“11”指的是我们从“accessibility”中省略的字母数量。《hit_test`函数在访问树中递归：
- en: '[PRE782]'
  id: totrans-3145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE782]'
- en: 'Once the hit test is done and the browser knows what node the user is hovering
    over, save this information on the `Browser`—so that the outline persists between
    frames—and draw an outline:'
  id: totrans-3146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成点击测试，并且浏览器知道用户悬停的节点是什么，就在`Browser`上保存此信息——这样轮廓就可以在帧之间持续存在——并绘制轮廓：
- en: '[PRE783]'
  id: totrans-3147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE783]'
- en: 'Finally, we can draw the outline at the end of `paint_draw_list`:'
  id: totrans-3148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在`paint_draw_list`的末尾绘制轮廓：
- en: '[PRE784]'
  id: totrans-3149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE784]'
- en: Note that the color of the outline depends on whether or not dark mode is on,
    to ensure high contrast.
  id: totrans-3150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，轮廓的颜色取决于是否开启了暗黑模式，以确保高对比度。
- en: 'So now we have an outline drawn. But we additionally want to speak what the
    user is hovering over. To do that we’ll need another flag, `needs_speak_hovered_node`,
    which we’ll set whenever hover moves from one element to another:'
  id: totrans-3151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经绘制了一个轮廓。但此外，我们还想说出用户悬停的内容。为此，我们需要另一个标志`needs_speak_hovered_node`，每当悬停从一个元素移动到另一个元素时，我们将设置此标志：
- en: '[PRE785]'
  id: totrans-3152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE785]'
- en: 'The ugly conditional is necessary to handle two cases: either hovering over
    an object when nothing was previously hovered, or moving the mouse from one object
    onto another. We set the flag in either case, and then use that flag in `update_accessibility`:'
  id: totrans-3153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个丑陋的条件语句是必要的，以处理两种情况：要么在没有任何先前悬停的情况下悬停在对象上，要么将鼠标从一个对象移动到另一个对象上。在两种情况下，我们都会设置此标志，然后在`update_accessibility`中使用该标志：
- en: '[PRE786]'
  id: totrans-3154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE786]'
- en: You should now be able to turn on accessibility mode and move your mouse over
    the page to get both visual and auditory feedback about what you’re hovering on!
  id: totrans-3155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够打开无障碍模式，并将鼠标移至页面以获取关于你悬停内容的视觉和听觉反馈！
- en: A common issue is web page authors making custom input elements and not thinking
    much about their accessibility. The reason for this is that built-in input elements
    are hard to style, so authors roll their own better-looking ones.
  id: totrans-3156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见问题是网页作者创建自定义输入元素，而没有充分考虑它们的无障碍性。原因是内置输入元素难以样式化，因此作者会创建看起来更好的自定义版本。
- en: Built-in input elements often involve several separate pieces, like the path
    and button in a `file` input, the check box in a `checkbox` element, or the pop-up
    menu in a `select` dropdown, and CSS isn’t (yet) good at styling such “compound”
    elements, though [pseudo-elements](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements)
    such as `::backdrop` or `::file-selector-button` help. Perhaps the best solution
    is [standards](https://open-ui.org/#proposals) for new [fully styleable](https://blogs.windows.com/msedgedev/2022/05/05/styling-select-elements-for-real/)
    input elements.
  id: totrans-3157
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的输入元素通常涉及多个独立的组件，例如`file`输入中的路径和按钮，`checkbox`元素中的复选框，或者`select`下拉菜单中的弹出菜单，尽管像`::backdrop`或`::file-selector-button`这样的[伪元素](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements)有所帮助，但CSS（目前）并不擅长样式化这样的“复合”元素。或许最好的解决方案是针对新[完全可样式化](https://blogs.windows.com/msedgedev/2022/05/05/styling-select-elements-for-real/)输入元素的[标准](https://open-ui.org/#proposals)。
- en: Summary
  id: totrans-3158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter introduces accessibility—features to ensure *all* users can access
    and interact with websites—and shows how to solve several of the most common accessibility
    problems in browsers. The key takeaways are:'
  id: totrans-3159
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了无障碍性——确保*所有*用户都能访问和与网站交互的特性，并展示了如何解决浏览器中最常见的几个无障碍性问题。关键要点包括：
- en: The semantic and declarative nature of HTML makes accessibility features natural
    extensions.
  id: totrans-3160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML的语义和声明性使得无障碍特性成为自然扩展。
- en: Accessibility features often serve multiple needs, and almost everyone benefits
    from these features in one way or another.
  id: totrans-3161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无障碍特性通常满足多种需求，几乎每个人都能以某种方式从中受益。
- en: The accessibility tree is similar to the display list and drives the browser’s
    interaction with screen readers and other assistive technologies.
  id: totrans-3162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无障碍树类似于显示列表，并驱动浏览器与屏幕阅读器和其他辅助技术的交互。
- en: New features like dark mode, keyboard navigation, and outlines need to be customizable
    by web page authors to be maximally usable.
  id: totrans-3163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新特性如深色模式、键盘导航和轮廓需要由网页作者自定义，以便最大限度地可用。
- en: Click [here](widgets/lab14-browser.html) to try this chapter’s browser.
  id: totrans-3164
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[这里](widgets/lab14-browser.html)尝试本章的浏览器。
- en: Outline
  id: totrans-3165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should now
    look something like this:'
  id: totrans-3166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整功能集、类和方法现在应该看起来像这样：
- en: '`COOKIE_JAR` `` class URL: `def __init__(url)` `def request(referrer, payload)`
    `def resolve(url)` `def origin()` `def __str__()` `` `` class Text: `def __init__(text,
    parent)` `def __repr__()` `` `` class Element: `def __init__(tag, attributes,
    parent)` `def __repr__()` `` `def print_tree(node, indent)` `def tree_to_list(tree,
    list)` `def is_focusable(node)` `def get_tabindex(node)` `` class HTMLParser:
    `SELF_CLOSING_TAGS` `HEAD_TAGS` `def __init__(body)` `def parse()` `def get_attributes(text)`
    `def add_text(text)` `def add_tag(tag)` `def implicit_tags(tag)` `def finish()`
    `` `` class CSSParser: `def __init__(s)` `def whitespace()` `def literal(literal)`
    `def word()` `def ignore_until(chars)` `def pair(until)` `def selector()` `def
    body()` `def parse()` `def until_chars(chars)` `def simple_selector()` `def media_query()`
    `` `` class TagSelector: `def __init__(tag)` `def matches(node)` `` `` class DescendantSelector:
    `def __init__(ancestor, descendant)` `def matches(node)` `` `` class PseudoclassSelector:
    `def __init__(pseudoclass, base)` `def matches(node)` `` `FONTS` `def get_font(size,
    weight, style)` `def linespace(font)` `NAMED_COLORS` `def parse_color(color)`
    `def parse_blend_mode(blend_mode_str)` `def parse_transition(value)` `def parse_transform(transform_str)`
    `def parse_outline(outline_str)` `REFRESH_RATE_SEC` `` class MeasureTime: `def
    __init__()` `def time(name)` `def stop(name)` `def finish()` `` `` class Task:
    `def __init__(task_code)` `def run()` `` `` class TaskRunner: `def __init__(tab)`
    `def schedule_task(task)` `def set_needs_quit()` `def clear_pending_tasks()` `def
    start_thread()` `def run()` `def handle_quit()` `` `DEFAULT_STYLE_SHEET` `INHERITED_PROPERTIES`
    `def style(node, rules, tab)` `def cascade_priority(rule)` `def diff_styles(old_style,
    new_style)` `` class NumericAnimation: `def __init__(old_value, new_value, num_frames)`
    `def animate()` `` `def dpx(css_px, zoom)` `WIDTH, HEIGHT` `HSTEP, VSTEP` `INPUT_WIDTH_PX`
    `BLOCK_ELEMENTS` `` class DocumentLayout: `def __init__(node)` `def layout(zoom)`
    `def should_paint()` `def paint()` `def paint_effects(cmds)` `` `` class BlockLayout:
    `def __init__(node, parent, previous)` `def layout_mode()` `def layout()` `def
    recurse(node)` `def new_line()` `def word(node, word)` `def input(node)` `def
    self_rect()` `def should_paint()` `def paint()` `def paint_effects(cmds)` `` ``
    class LineLayout: `def __init__(node, parent, previous)` `def layout()` `def should_paint()`
    `def paint()` `def paint_effects(cmds)` `` `` class TextLayout: `def __init__(node,
    word, parent, previous)` `def layout()` `def should_paint()` `def paint()` `def
    paint_effects(cmds)` `def self_rect()` `` `` class InputLayout: `def __init__(node,
    parent, previous)` `def layout()` `def should_paint()` `def paint()` `def paint_effects(cmds)`
    `def self_rect()` `` `` class PaintCommand: `def __init__(rect)` `` `` class DrawText:
    `def __init__(x1, y1, text, font, color)` `def execute(canvas)` `` `` class DrawRect:
    `def __init__(rect, color)` `def execute(canvas)` `` `` class DrawRRect: `def
    __init__(rect, radius, color)` `def execute(canvas)` `` `` class DrawLine: `def
    __init__(x1, y1, x2, y2, color, thickness)` `def execute(canvas)` `` `` class
    DrawOutline: `def __init__(rect, color, thickness)` `def execute(canvas)` `` ``
    class DrawCompositedLayer: `def __init__(composited_layer)` `def execute(canvas)`
    `` `` class VisualEffect: `def __init__(rect, children, node)` `` `` class Blend:
    `def __init__(opacity, blend_mode, node, children)` `def execute(canvas)` `def
    map(rect)` `def unmap(rect)` `def clone(child)` `` `` class Transform: `def __init__(translation,
    rect, node, children)` `def execute(canvas)` `def map(rect)` `def unmap(rect)`
    `def clone(child)` `` `def local_to_absolute(display_item, rect)` `def absolute_bounds_for_obj(obj)`
    `def absolute_to_local(display_item, rect)` `def map_translation(rect, translation,
    reversed)` `def paint_tree(layout_object, display_list)` `def paint_visual_effects(node,
    cmds, rect)` `def paint_outline(node, cmds, rect, zoom)` `def add_parent_pointers(nodes,
    parent)` `` class CompositedLayer: `def __init__(skia_context, display_item)`
    `def can_merge(display_item)` `def add(display_item)` `def composited_bounds()`
    `def absolute_bounds()` `def raster()` `` `SPEECH_FILE` `` class AccessibilityNode:
    `def __init__(node)` `def compute_bounds()` `def build()` `def build_internal(child_node)`
    `def contains_point(x, y)` `def hit_test(x, y)` `` `def speak_text(text)` `EVENT_DISPATCH_JS`
    `SETTIMEOUT_JS` `XHR_ONLOAD_JS` `RUNTIME_JS` `` class JSContext: `def __init__(tab)`
    `def run(script, code)` `def dispatch_event(type, elt)` `def dispatch_settimeout(handle)`
    `def dispatch_xhr_onload(out, handle)` `def get_handle(elt)` `def querySelectorAll(selector_text)`
    `def getAttribute(handle, attr)` `def setAttribute(handle, attr, value)` `def
    innerHTML_set(handle, s)` `def style_set(handle, s)` `def XMLHttpRequest_send(...)`
    `def setTimeout(handle, time)` `def requestAnimationFrame()` `` `SCROLL_STEP`
    `` class Tab: `def __init__(browser, tab_height)` `def load(url, payload)` `def
    run_animation_frame(scroll)` `def render()` `def allowed_request(url)` `def raster(canvas)`
    `def clamp_scroll(scroll)` `def set_needs_render()` `def set_needs_layout()` `def
    set_needs_paint()` `def scrolldown()` `def click(x, y)` `def go_back()` `def submit_form(elt)`
    `def keypress(char)` `def focus_element(node)` `def activate_element(elt)` `def
    scroll_to(elt)` `def enter()` `def advance_tab()` `def zoom_by(increment)` `def
    reset_zoom()` `def set_dark_mode(val)` `` `` class Chrome: `def __init__(browser)`
    `def tab_rect(i)` `def paint()` `def click(x, y)` `def keypress(char)` `def enter()`
    `def blur()` `def focus_addressbar()` `` `` class CommitData: `def __init__(...)`
    `` `` class Browser: `def __init__()` `def schedule_animation_frame()` `def commit(tab,
    data)` `def render()` `def composite_raster_and_draw()` `def composite()` `def
    get_latest(effect)` `def paint_draw_list()` `def raster_tab()` `def raster_chrome()`
    `def update_accessibility()` `def draw()` `def speak_node(node, text)` `def speak_document()`
    `def set_needs_accessibility()` `def set_needs_animation_frame(tab)` `def set_needs_raster_and_draw()`
    `def set_needs_raster()` `def set_needs_composite()` `def set_needs_draw()` `def
    clear_data()` `def new_tab(url)` `def new_tab_internal(url)` `def set_active_tab(tab)`
    `def schedule_load(url, body)` `def clamp_scroll(scroll)` `def handle_down()`
    `def handle_click(e)` `def handle_key(char)` `def handle_enter()` `def handle_tab()`
    `def handle_hover(event)` `def handle_quit()` `def toggle_dark_mode()` `def increment_zoom(increment)`
    `def reset_zoom()` `def focus_content()` `def focus_addressbar()` `def go_back()`
    `def cycle_tabs()` `def toggle_accessibility()` `` `def mainloop(browser)`'
  id: totrans-3167
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-3168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 14-1 *Focus ring with good contrast*. Improve the contrast of the focus indicator
    by using two outlines, a thicker white one and a thinner black one, to ensure
    that there is contrast between the focus ring and surrounding content.
  id: totrans-3169
  prefs: []
  type: TYPE_NORMAL
  zh: 14-1 *具有良好对比度的焦点环*. 通过使用两个轮廓，一个较粗的白色轮廓和一个较细的黑色轮廓，来提高焦点指示器的对比度，以确保焦点环与周围内容之间有对比度。
- en: '14-2 *Focus method and events*. Add support for the JavaScript [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus)
    method and the corresponding [`focus`](https://developer.mozilla.org/en-US/docs/Web/API/Element/focus_event)
    and [`blur`](https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event)
    events on DOM elements. Make sure that `focus()` only has an effect on focusable
    elements. Be careful: before reading an element’s position, make sure that layout
    is up to date.'
  id: totrans-3170
  prefs: []
  type: TYPE_NORMAL
  zh: 14-2 *焦点方法和事件*. 在DOM元素上添加对JavaScript `focus()` 方法的支持以及相应的 `focus` 和 `blur` 事件。确保`focus()`只对可聚焦元素有效。请注意：在读取元素的位置之前，请确保布局是最新的。
- en: 14-3 *Highlighting elements during read*. The method to read the document works,
    but it would be nice to also highlight the element being read as it happens, in
    a similar way to how we did it for mouse hover. Implement that. You may want to
    replace the `speak_document` method with an `advance_accessibility` method that
    moves the accessibility focus by one node and speaks it.
  id: totrans-3171
  prefs: []
  type: TYPE_NORMAL
  zh: 14-3 *在阅读过程中突出显示元素*. 阅读文档的方法是有效的，但如果在阅读过程中也能以类似鼠标悬停的方式突出显示正在读取的元素，那就更好了。实现这一点。你可能想用`advance_accessibility`方法替换`speak_document`方法，该方法通过移动一个节点来移动可访问性焦点并朗读它。
- en: 14-4 *Width media queries*. Zooming in or out causes the width of the page in
    CSS pixels to change. That means that sometimes elements that used to fit comfortably
    on the page no longer do, and if the page becomes narrow enough, a different layout
    may be more appropriate. The [`max-width` media query](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/width)
    allows the developer to style pages differently based on available width; it is
    active only if the width of the page, in CSS pixels, is less than or equal to
    a given length.As you’ve seen, many accessibility features also have non-accessibility
    uses. For example, the `max-width` media query is indeed a way to customize behavior
    on zoom, but most developers think of it instead as a way to customize their website
    for different devices, like desktops, tablets, and mobile devices. This is called
    [responsive design](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design),
    and can be viewed as a kind of accessibility. Implement this media query. Test
    that zooming in or out can trigger this media query.
  id: totrans-3172
  prefs: []
  type: TYPE_NORMAL
  zh: 14-4 *宽度媒体查询*. 缩放会导致CSS像素中页面宽度的变化。这意味着有时原本在页面上舒适显示的元素不再适用，如果页面足够窄，则可能需要不同的布局。`max-width`
    媒体查询允许开发者根据可用宽度对页面进行不同的样式设计；它仅在页面宽度（CSS像素）小于或等于给定长度时才有效。正如你所见，许多无障碍功能也有非无障碍用途。例如，`max-width`
    媒体查询确实是一种在缩放时自定义行为的方法，但大多数开发者更倾向于将其视为为不同设备（如桌面、平板电脑和移动设备）定制网站的方式。这被称为[响应式设计](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design)，可以将其视为一种无障碍性。实现此媒体查询。测试缩放或缩小是否可以触发此媒体查询。
- en: After completing the exercise, [this example](examples/example14-maxwidth-media.html)
    should have green text on narrow screens.
  id: totrans-3173
  prefs: []
  type: TYPE_NORMAL
  zh: 完成练习后，[此示例](examples/example14-maxwidth-media.html)在窄屏幕上应显示绿色文本。
- en: 14-5 *Mixed inlines*. Make the focus ring work correctly on nested inline elements.
    For example, in `<a>a <b>bold</b> link</a>`, the focus ring should cover all three
    words together when the user is focused on the link, and with multiple rectangles
    if the inline crosses lines. However, if the user focuses on a block-level element,
    such as in `<div tabindex=2>many<br>lines</div>`, there shouldn’t be a focus ring
    around each line, but instead the block as a whole.
  id: totrans-3174
  prefs: []
  type: TYPE_NORMAL
  zh: 14-5 *混合内联元素*. 确保焦点环在嵌套内联元素上正确工作。例如，在 `<a>a <b>bold</b> link</a>` 中，当用户聚焦在链接上时，焦点环应覆盖所有三个单词，如果内联元素跨越行，则使用多个矩形。然而，如果用户聚焦在块级元素上，例如在
    `<div tabindex=2>many<br>lines</div>` 中，则不应在每一行周围有焦点环，而应在整个块周围。
- en: 14-6 *Threaded accessibility*. The accessibility code currently speaks text
    on the browser thread, and blocks the browser thread while it speaks. That’s frustrating
    to use. Solve this by moving the speaking to a new accessibility thread.
  id: totrans-3175
  prefs: []
  type: TYPE_NORMAL
  zh: 14-6 *线程化可访问性*. 当前可访问性代码在浏览器线程上朗读文本，并在朗读时阻塞浏览器线程。这使用起来非常令人沮丧。通过将朗读移动到新的可访问性线程来解决这个问题。
- en: 14-7 *High-contrast mode*. Implement high-contrast [forced-colors](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/forced-colors)
    mode. This should replace all colors with one of a small set of [high-contrast](https://www.w3.org/TR/WCAG21/#contrast-minimum)
    colors.
  id: totrans-3176
  prefs: []
  type: TYPE_NORMAL
  zh: 14-7 *高对比度模式*. 实现高对比度[强制颜色](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/forced-colors)模式。这应该用一小组高对比度[颜色](https://www.w3.org/TR/WCAG21/#contrast-minimum)之一替换所有颜色。
- en: 14-8 *`focus-visible`*. When the user tabs to a link, we probably want to show
    a focus indicator, but if the user clicked on it, most browsers don’t—the user
    knows where the focused element is! And a redundant focus indicator could be ugly,
    or distracting. Implement a similar heuristic. Clicking on a button should focus
    it, but not show a focus indicator. (Test this on the [focus example](examples/example14-focus.html)
    with a button placed outside a form, so clicking the button doesn’t navigate to
    a new page.) But both clicking on and tabbing to an input element should show
    a focus ring. Also add support for the [`:focus-visible` pseudo-class](https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible).
    This applies only if the element is focused *and* the browser would have drawn
    a focus ring (the focus ring would have been *visible*, hence the name). This
    lets custom widgets change focus ring styling without losing the useful browser
    heuristics I mentioned above.
  id: totrans-3177
  prefs: []
  type: TYPE_NORMAL
  zh: 14-8 *`focus-visible`*. 当用户切换到链接时，我们可能希望显示一个焦点指示器，但如果用户点击了它，大多数浏览器不会——用户知道焦点元素在哪里！并且重复的焦点指示器可能很丑陋，或者分散注意力。实现一个类似的启发式方法。点击按钮应该使其获得焦点，但不显示焦点指示器。（在[焦点示例](examples/example14-focus.html)中测试此功能，按钮放置在表单外部，因此点击按钮不会导航到新页面。）但是，点击和切换到输入元素都应该显示焦点环。另外，添加对[`:focus-visible`伪类](https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible)的支持。这仅适用于元素获得焦点且浏览器会绘制焦点环的情况（焦点环将是可见的，因此得名）。这允许自定义小部件在不丢失我上面提到的有用浏览器启发式方法的情况下更改焦点环样式。
- en: 14-9 *OS integration*. Add the [`accessible_output`](https://pypi.org/project/accessible_output/)
    Python library and use it to integrate directly with your OS’s built-in screen
    reader. Try out some of the examples in this chapter and compare the behavior
    with a real browser.
  id: totrans-3178
  prefs: []
  type: TYPE_NORMAL
  zh: 14-9 *操作系统集成*. 添加`accessible_output` Python库，并使用它直接与操作系统内置的屏幕阅读器集成。尝试本章的一些示例，并比较与真实浏览器的行为。
- en: 14-10 *The `zoom` CSS property*. Add support for the [`zoom`](https://developer.mozilla.org/en-US/docs/Web/CSS/zoom)
    CSS property. This exposes the same functionality as the zoom accessibility feature
    to web developers, plus it allows applying it only to designated HTML subtrees.
  id: totrans-3179
  prefs: []
  type: TYPE_NORMAL
  zh: 14-10 *`zoom` CSS属性*. 添加对`zoom` CSS属性的支持。这向网络开发者提供了与缩放可访问性功能相同的功能，并且允许仅将其应用于指定的HTML子树。
- en: Supporting Embedded Content
  id: totrans-3180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持嵌入内容
- en: Chapter 15 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-3181
  prefs: []
  type: TYPE_NORMAL
  zh: '[Web浏览器工程](./index.html "目录")的第15章。'
- en: '[Images](#images)'
  id: totrans-3182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[图像](#images)'
- en: '[Embedded layout](#embedded-layout)'
  id: totrans-3183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[嵌入布局](#embedded-layout)'
- en: '[Modifying Image Sizes](#modifying-image-sizes)'
  id: totrans-3184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[修改图像大小](#modifying-image-sizes)'
- en: '[Interactive Widgets](#interactive-widgets)'
  id: totrans-3185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[交互式小部件](#interactive-widgets)'
- en: '[Iframe Rendering](#iframe-rendering)'
  id: totrans-3186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Iframe渲染](#iframe-rendering)'
- en: '[Iframe Input Events](#iframe-input-events)'
  id: totrans-3187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Iframe输入事件](#iframe-input-events)'
- en: '[Iframe Scripts](#iframe-scripts)'
  id: totrans-3188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Iframe脚本](#iframe-scripts)'
- en: '[Communicating Between Frames](#communicating-between-frames)'
  id: totrans-3189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[帧间通信](#communicating-between-frames)'
- en: '[Isolation and Timing](#isolation-and-timing)'
  id: totrans-3190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[隔离和定时](#isolation-and-timing)'
- en: '[Summary](#summary)'
  id: totrans-3191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summary)'
- en: '[Outline](#outline)'
  id: totrans-3192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大纲](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-3193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: While our browser can render complex styles, visual effects, and animations,
    all of those apply basically just to text. Yet web pages contain a variety of
    non-text *embedded content*, from images to other web pages. Support for embedded
    content has powerful implications for browser architecture, performance, security,
    and open information access, and has played a key role throughout the web’s history.
  id: totrans-3194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的浏览器可以渲染复杂的样式、视觉效果和动画，但所有这些基本上都只应用于文本。然而，网页包含各种非文本*嵌入内容*，从图像到其他网页。对嵌入内容的支持对浏览器架构、性能、安全性和开放信息访问具有强大的影响，并在整个网络历史中发挥了关键作用。
- en: Images
  id: totrans-3195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图片
- en: 'Images are certainly the most popular kind of embedded content on the web,So
    it’s a little ironic that images only make their appearance in Chapter 15 of this
    book! It’s because Tkinter doesn’t support many image formats or proper sizing
    and clipping, so I had to wait for the introduction of Skia. dating back to [early
    1993](http://1997.webhistory.org/www.lists/www-talk.1993q1/0182.html).This history
    is also [the reason behind](http://1997.webhistory.org/www.lists/www-talk.1993q1/0196.html)
    a lot of inconsistencies, like `src` versus `href` or `img` versus `image`. They’re
    included on web pages via the `<img>` tag, which looks like this:'
  id: totrans-3196
  prefs: []
  type: TYPE_NORMAL
  zh: 图片无疑是网络上最受欢迎的嵌入式内容类型，所以有点讽刺的是，图片只在本书的第15章中出现！这是因为Tkinter不支持许多图像格式或适当的尺寸和裁剪，所以我不得不等待Skia的引入，这可以追溯到[1993年早期](http://1997.webhistory.org/www.lists/www-talk.1993q1/0182.html)。这个历史也是[很多不一致性的原因](http://1997.webhistory.org/www.lists/www-talk.1993q1/0196.html)，比如`src`与`href`或`img`与`image`。它们通过`<img>`标签包含在网页中，其外观如下：
- en: '[PRE787]'
  id: totrans-3197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE787]'
- en: This particular example renders as shown in Figure 1.
  id: totrans-3198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的例子在图1中显示如下。
- en: '![Figure 1: A computer operator using the Hypertext Editing System in 1969\.
    (Gregory Lloyd from Wikipedia, CC BY-SA 4.0 International.)](img/2c74993962642fa5738c4f8060cb4fe3.png)'
  id: totrans-3199
  prefs: []
  type: TYPE_IMG
  zh: '![图1：1969年使用超文本编辑系统的计算机操作员。（来自维基百科，CC BY-SA 4.0国际。）](img/2c74993962642fa5738c4f8060cb4fe3.png)'
- en: 'Figure 1: A computer operator using the Hypertext Editing System in 1969\.
    (Gregory Lloyd from [Wikipedia](https://commons.wikimedia.org/wiki/File:HypertextEditingSystemConsoleBrownUniv1969.jpg),
    [CC BY-SA 4.0 International](https://creativecommons.org/licenses/by-sa/4.0/deed.en).)'
  id: totrans-3200
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：1969年使用超文本编辑系统的计算机操作员。（来自维基百科的Gregory Lloyd，[CC BY-SA 4.0国际](https://creativecommons.org/licenses/by-sa/4.0/deed.en)。）
- en: 'Luckily, implementing images isn’t too hard, so let’s just get started. There
    are four steps to displaying images in our browser:'
  id: totrans-3201
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，实现图片并不太难，所以我们开始吧。在我们的浏览器中显示图片有四个步骤：
- en: Download the image from a URL.
  id: totrans-3202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从URL下载图片。
- en: Decode the image into a buffer in memory.
  id: totrans-3203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图片解码到内存中的缓冲区。
- en: Lay the image out on the page.
  id: totrans-3204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面上布局图片。
- en: Paint the image in the display list.
  id: totrans-3205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在显示列表中绘制图片。
- en: Let’s start with downloading images from a URL. Naturally, that happens over
    HTTP, which we already have a `request` function for. However, while all of the
    content we’ve downloaded so far—HTML, CSS, and JavaScript—has been textual, images
    typically use binary data formats. We’ll need to extend `request` to support binary
    data.
  id: totrans-3206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从从URL下载图片开始。当然，这是通过HTTP完成的，我们已经有了一个`request`函数。然而，虽然我们迄今为止下载的所有内容——HTML、CSS和JavaScript——都是文本的，但图片通常使用二进制数据格式。我们需要扩展`request`以支持二进制数据。
- en: 'The change is pretty minimal: instead of passing the `"r"` flag to `makefile`,
    pass a `"b"` flag indicating binary mode:'
  id: totrans-3207
  prefs: []
  type: TYPE_NORMAL
  zh: 变化非常微小：不再将`"r"`标志传递给`makefile`，而是传递一个表示二进制模式的`"b"`标志：
- en: '[PRE788]'
  id: totrans-3208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE788]'
- en: 'Now every time we read from `response`, we will get `bytes` of binary data,
    not a `str` with textual data, so we’ll need to change some HTTP parser code to
    explicitly `decode` the data:'
  id: totrans-3209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们每次从`response`读取时，都会得到二进制数据的`bytes`，而不是包含文本数据的`str`，因此我们需要更改一些HTTP解析器代码以显式`decode`数据：
- en: '[PRE789]'
  id: totrans-3210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE789]'
- en: 'Note that I *didn’t* add a `decode` call when we read the body; that’s because
    the body might actually be binary data, and we want to return that binary data
    directly to the browser. Now, every existing call to `request`, which wants textual
    data, needs to `decode` the response. For example, in `load`, you’ll want to do
    something like this:'
  id: totrans-3211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们读取正文时，我没有添加`decode`调用；这是因为正文实际上可能是二进制数据，我们希望直接将二进制数据返回给浏览器。现在，每个现有的`request`调用，它想要文本数据，都需要对响应进行`decode`。例如，在`load`中，你可能想要这样做：
- en: '[PRE790]'
  id: totrans-3212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE790]'
- en: By passing `replace` as the second argument to `decode`, I tell Python to replace
    any invalid characters by a special � character instead of throwing an exception.
  id: totrans-3213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`replace`作为`decode`的第二个参数传递，我告诉Python用特殊字符�替换任何无效字符，而不是抛出异常。
- en: Make sure to make this change everywhere in your browser that you call `request`,
    including inside `XMLHttpRequest_send` and in several other places in `load`.
  id: totrans-3214
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在浏览器中的所有调用`request`的地方都进行此更改，包括`XMLHttpRequest_send`和`load`中的几个其他地方。
- en: When we download images, however, we *won’t* call `decode`; we’ll just use the
    binary data directly.
  id: totrans-3215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们下载图片时，我们*不会*调用`decode`；我们只需直接使用二进制数据即可。
- en: '[PRE791]'
  id: totrans-3216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE791]'
- en: 'Once we’ve downloaded the image, we need to turn it into a Skia `Image` object.
    That requires the following code:'
  id: totrans-3217
  prefs: []
  type: TYPE_NORMAL
  zh: 下载图片后，我们需要将其转换为Skia的`Image`对象。这需要以下代码：
- en: '[PRE792]'
  id: totrans-3218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE792]'
- en: 'There are two tricky steps here: the requested data is turned into a Skia `Data`
    object using the `MakeWithoutCopy` method, and then into an image with `MakeFromEncoded`.'
  id: totrans-3219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个棘手的步骤：使用`MakeWithoutCopy`方法将请求的数据转换为Skia的`Data`对象，然后使用`MakeFromEncoded`将其转换为图像。
- en: Because we used `MakeWithoutCopy`, the `Data` object just stores a reference
    to the existing `body` and doesn’t own that data. That’s essential, because encoded
    image data can be large—maybe megabytes—and copying that data wastes memory and
    time. But that also means that the `data` will become invalid if `body` is ever
    garbage-collected; that’s why I save the `body` in an `encoded_data` field.This
    is a bit of a hack. Perhaps a better solution would be to write the response directly
    into a Skia `Data` object using the `writable_data` API. That would require some
    refactoring of the rest of the browser which is why I’m choosing to avoid it.
  id: totrans-3220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了`MakeWithoutCopy`，`Data`对象仅存储对现有`body`的引用，并不拥有该数据。这是非常重要的，因为编码的图像数据可能很大——可能达到兆字节级别——复制这些数据会浪费内存和时间。但这也意味着如果`body`被垃圾回收，`data`将变得无效；这就是为什么我将`body`保存在`encoded_data`字段中的原因。这有点像是一种折衷方案。也许更好的解决方案是直接使用`writable_data`
    API将响应写入Skia的`Data`对象。这将需要对浏览器其余部分进行一些重构，这就是为什么我选择避免这样做的原因。
- en: 'These download and decode steps can both fail; if that happens we’ll load a
    “broken image” placeholder (I used [one from Wikipedia](https://commons.wikimedia.org/wiki/File:Broken_Image.png)):'
  id: totrans-3221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些下载和解码步骤都可能失败；如果发生这种情况，我们将加载一个“损坏的图像”占位符（我使用了[来自维基百科的一个](https://commons.wikimedia.org/wiki/File:Broken_Image.png)）：
- en: '[PRE793]'
  id: totrans-3222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE793]'
- en: 'Now that we’ve downloaded and saved the image, we need to use it. That just
    requires calling Skia’s `drawImageRect` function:'
  id: totrans-3223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经下载并保存了图像，我们需要使用它。这只需要调用Skia的`drawImageRect`函数：
- en: '[PRE794]'
  id: totrans-3224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE794]'
- en: The internals of `drawImageRect`, however, are a little complicated and worth
    expanding on. Recall that the `Image` object is created using a `MakeFromEncoded`
    method. That name reminds us that the image we’ve downloaded isn’t raw image bytes.
    In fact, all of the image formats you know—JPG, PNG, and the many more obscure
    ones—encode the image data using various sophisticated algorithms. The image therefore
    needs to be *decoded* before it can be used.And with much more complicated algorithms
    than just `utf8` conversion.
  id: totrans-3225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`drawImageRect`的内部实现稍微复杂一些，值得详细说明。回想一下，`Image`对象是使用`MakeFromEncoded`方法创建的。这个名字提醒我们，我们下载的图像不是原始图像字节。实际上，您所知道的全部图像格式——JPG、PNG以及许多更不为人知的格式——都使用各种复杂的算法对图像数据进行编码。因此，在可以使用之前，图像需要被*解码*。而且解码算法比简单的`utf8`转换要复杂得多。
- en: Skia applies a variety of clever optimizations to decoding, such as directly
    decoding the image to its eventual size and caching the decoded image as long
    as possible.There’s also an [HTML API](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decoding)
    to control decoding, so that the web page author can indicate when to pay that
    cost. That’s because raw image data can be quite large:Decoding costs both a lot
    of memory and also a lot of time, since just writing out all of those bytes can
    take a big chunk of our render budget. Optimizing image handling is essential
    to a performant browser. a pixel is usually stored as 4 bytes, so a 12 megapixel
    camera (as you can find on phones these days) produces 48 megabytes of raw data
    for a single image.
  id: totrans-3226
  prefs: []
  type: TYPE_NORMAL
  zh: Skia在解码方面应用了各种巧妙的优化，例如直接将图像解码到最终大小，并尽可能长时间地缓存解码后的图像。还有一个[HTML API](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decoding)用于控制解码，这样网页作者就可以指示何时承担这种成本。这是因为原始图像数据可能相当大：解码既消耗大量内存，也消耗大量时间，因为仅仅写出所有这些字节就可能占用我们渲染预算的一大块。优化图像处理对于性能良好的浏览器至关重要。一个像素通常存储为4字节，所以一个1200万像素的相机（如今在手机上可以找到）为一张单独的图像产生48兆字节的原始数据。
- en: Because image decoding can be so expensive, Skia also has several algorithms
    available for decoding, some of which are faster but result in a worse-looking
    image.Image formats like JPEG are also [*lossy*](https://en.wikipedia.org/wiki/Lossy_compression),
    meaning that they don’t faithfully represent all of the information in the original
    picture, so there’s a time/quality trade-off going on before the file is saved.
    Typically these formats try to drop “noisy details” that a human is unlikely to
    notice, just like different resizing algorithms might. For example, there’s the
    fast, simple “nearest neighbor” algorithm and the slower but higher-quality “bilinear”
    or even “[Lanczos](https://en.wikipedia.org/wiki/Lanczos_resampling)” algorithms.Specifically,
    these algorithms decide how to decode an image when the image size and the destination
    size are different and the image therefore needs to be resized. The faster algorithms
    tend to result in choppier, more jagged images.
  id: totrans-3227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图像解码可能非常昂贵，Skia 还提供了几种解码算法，其中一些更快但生成的图像外观较差。像 JPEG 这样的图像格式也是[*有损的*](https://en.wikipedia.org/wiki/Lossy_compression)，这意味着它们不能忠实地表示原始图片中的所有信息，因此在保存文件之前就存在时间/质量权衡。通常这些格式会尝试去除人类不太可能注意到的“噪声细节”，就像不同的缩放算法可能做的那样。例如，有快速的简单“最近邻”算法，以及较慢但质量更高的“双线性”甚至“[Lanczos](https://en.wikipedia.org/wiki/Lanczos_resampling)”算法。具体来说，这些算法决定在图像大小和目标大小不同且因此需要调整大小时如何解码图像。较快的算法往往会导致更粗糙、更锯齿状的图像。
- en: 'To give web page authors control over this performance bottleneck, there’s
    an [`image-rendering`](https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering)
    CSS property that indicates which algorithm to use. Let’s add that as an argument
    to `DrawImage`:'
  id: totrans-3228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让网页作者控制这个性能瓶颈，有一个名为 `image-rendering` 的 CSS 属性，它指示使用哪个算法。让我们将其作为 `DrawImage`
    的一个参数添加：
- en: '[PRE795]'
  id: totrans-3229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE795]'
- en: But to talk about where this argument comes from, or more generally to actually
    see downloaded images in our browser, we first need to add images into our browser’s
    layout tree.
  id: totrans-3230
  prefs: []
  type: TYPE_NORMAL
  zh: 但要谈论这个论点从何而来，或者更普遍地说，实际上在我们的浏览器中查看下载的图片，我们首先需要将图片添加到浏览器布局树中。
- en: 'The HTTP `Content-Type` header lets the web server tell the browser whether
    a document contains text or binary data. The header contains a value called a
    [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types),
    such as `text/html`, `text/css`, and `text/javascript` for HTML, CSS, and JavaScript;
    `image/png` and `image/jpeg` for PNG and JPEG images; and [many others](https://www.iana.org/assignments/media-types/media-types.xhtml)
    for various font, video, audio, and data formats.“MIME” stands for Multipurpose
    Internet Mail Extensions, and was originally intended for enumerating all of the
    acceptable data formats for email attachments. These days the loop has basically
    closed: most email clients are now “webmail” clients, accessed through your browser,
    and most emails are now HTML, encoded with the `text/html` MIME type, though typically
    there is still a plain-text option. Interestingly, we didn’t need to specify the
    image format in the code above. That’s because many image formats start with [“magic
    bytes”](https://www.netspi.com/blog/technical/web-application-penetration-testing/magic-bytes-identifying-common-file-formats-at-a-glance/);
    for example, PNG files always start with byte 137 followed by the letters “PNG”.
    These magic bytes are often more reliable than web-server-provided MIME types,
    so such “format sniffing” is common inside browsers and their supporting libraries.'
  id: totrans-3231
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP `Content-Type` 头部允许服务器告诉浏览器文档是否包含文本或二进制数据。该头部包含一个称为 [MIME 类型](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)
    的值，例如 `text/html`、`text/css` 和 `text/javascript` 用于 HTML、CSS 和 JavaScript；`image/png`
    和 `image/jpeg` 用于 PNG 和 JPEG 图像；以及 [许多其他类型](https://www.iana.org/assignments/media-types/media-types.xhtml)
    用于各种字体、视频、音频和数据格式。“MIME”代表多用途互联网邮件扩展，最初是为了列举所有电子邮件附件可接受的数据格式。如今，这个循环基本上已经闭合：大多数电子邮件客户端现在都是“网络邮件”客户端，通过您的浏览器访问，并且大多数电子邮件现在都是
    HTML 格式，使用 `text/html` MIME 类型编码，尽管通常仍然有一个纯文本选项。有趣的是，我们不需要在上面的代码中指定图像格式。这是因为许多图像格式以
    [“魔术字节”](https://www.netspi.com/blog/technical/web-application-penetration-testing/magic-bytes-identifying-common-file-formats-at-a-glance/)
    开头；例如，PNG 文件总是以字节 137 开头，后面跟着字母“PNG”。这些魔术字节通常比服务器提供的 MIME 类型更可靠，因此在浏览器及其支持库中这种“格式嗅探”是常见的。
- en: Embedded layout
  id: totrans-3232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内嵌布局
- en: Based on your experience with prior chapters, you can probably guess how to
    add images to our browser’s layout and paint process. We’ll need to create an
    `ImageLayout` class; add a new `image` case to `BlockLayout`’s `recurse` method;
    and generate a `DrawImage` command from `ImageLayout`’s `paint` method.
  id: totrans-3233
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你对前几章的经验，你可能能够猜出如何将图片添加到我们浏览器的布局和绘制过程中。我们需要创建一个`ImageLayout`类；在`BlockLayout`的`recurse`方法中添加一个新的`image`情况；并从`ImageLayout`的`paint`方法生成一个`DrawImage`命令。
- en: 'As we do this, you might recall doing something very similar for `<input>`
    elements. In fact, text areas and buttons are very similar to images: both are
    leaf nodes of the DOM, placed into lines, affected by text baselines, and painting
    custom content.Images aren’t quite like *text* because a text node is potentially
    an entire run of text, split across multiple lines, while an image is an [atomic
    inline](https://drafts.csswg.org/css-display-3/#atomic-inline). The other types
    of embedded content in this chapter are also atomic inlines. Since they are so
    similar, let’s try to reuse the same code for both.'
  id: totrans-3234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做的时候，你可能记得为`<input>`元素做过类似的事情。实际上，文本区域和按钮与图片非常相似：两者都是DOM的叶节点，放置在行中，受文本基线的影响，并绘制自定义内容。图片并不完全像*文本*，因为文本节点可能是一整行文本，跨越多行，而图片是一个[原子内联](https://drafts.csswg.org/css-display-3/#atomic-inline)。本章中其他类型的嵌入内容也是原子内联。由于它们非常相似，让我们尝试为两者重用相同的代码。
- en: Let’s split the existing `InputLayout` into a superclass called `EmbedLayout`,
    containing most of the existing code, and a new subclass with the input-specific
    code, `InputLayout`:In a real browser, input elements are usually called *widgets*
    because they have a lot of [special rendering rules](https://html.spec.whatwg.org/multipage/rendering.html#widgets)
    that sometimes involve CSS.
  id: totrans-3235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将现有的`InputLayout`拆分为一个名为`EmbedLayout`的超类，其中包含大部分现有代码，以及一个新的子类`InputLayout`，包含特定于输入的代码：在真实浏览器中，输入元素通常被称为*小部件*，因为它们有很多[特殊渲染规则](https://html.spec.whatwg.org/multipage/rendering.html#widgets)，有时会涉及CSS。
- en: '[PRE796]'
  id: totrans-3236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE796]'
- en: '[PRE797]'
  id: totrans-3237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE797]'
- en: 'The idea is that `EmbedLayout` should provide common layout code for all kinds
    of embedded content, while its subclasses like `InputLayout` should provide the
    custom code for that type of content. Different types of embedded content might
    have different widths and heights, so that should happen in each subclass, as
    should the definition of `paint`:'
  id: totrans-3238
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是`EmbedLayout`应该为所有类型的嵌入内容提供通用的布局代码，而其子类如`InputLayout`应该提供该类型内容的自定义代码。不同类型的嵌入内容可能有不同的宽度和高度，因此这些应该在每个子类中发生，同样，`paint`的定义也应该如此：
- en: '[PRE798]'
  id: totrans-3239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE798]'
- en: '`ImageLayout` can now inherit most of its behavior from `EmbedLayout`, but
    take its width and height from the image itself:'
  id: totrans-3240
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageLayout`现在可以继承其大部分行为来自`EmbedLayout`，但它的宽度和高度则来自图片本身：'
- en: '[PRE799]'
  id: totrans-3241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE799]'
- en: 'Notice that the height of the image depends on the font size of the element.
    Though odd, this is how image layout actually works: a line with a single, very
    small, image on it will still be tall enough to contain text.In fact, a page with
    only a single image and no text or CSS at all still has its layout affected by
    a font—the default font. This is a common source of confusion for web developers.
    In a real browser, it can be avoided by forcing an image into a block or other
    layout mode via the `display` CSS property. The underlying reason for this is
    because, as a type of inline layout, images are designed to flow along with related
    text, which means the bottom of the image should line up with the [text baseline](text.html#text-of-different-sizes).
    That’s also why we save `img_height` in the code above.'
  id: totrans-3242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，图片的高度取决于元素的字体大小。虽然有些奇怪，但这就是图片布局实际上是如何工作的：即使只有一行非常小的图片，其高度也足以容纳文本。实际上，一个只有单张图片而没有文本或CSS的页面，其布局仍然会受到字体的影响——默认字体。这是网页开发者常见的混淆来源。在真实浏览器中，可以通过通过`display`
    CSS属性强制图片进入块或其他布局模式来避免这种情况。其根本原因是因为，作为一种内联布局，图片被设计成与相关文本一起流动，这意味着图片的底部应该与[文本基线](text.html#text-of-different-sizes)对齐。这也是为什么我们在上面的代码中保存`img_height`的原因。
- en: 'Also, in the code above I introduced new `ascent` and `descent` fields on `EmbedLayout`
    subclasses. This is meant to be used in `LineLayout` layout in place of the existing
    layout code for ascent and descent. It also requires introducing those fields
    on `TextLayout`:'
  id: totrans-3243
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在上面的代码中，我在`EmbedLayout`子类中引入了新的`ascent`和`descent`字段。这是为了在`LineLayout`布局中替代现有的`ascent`和`descent`布局代码。这也需要引入`TextLayout`上的那些字段：
- en: '[PRE800]'
  id: totrans-3244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE800]'
- en: 'Painting an image is also straightforward:'
  id: totrans-3245
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制图片也是直截了当的：
- en: '[PRE801]'
  id: totrans-3246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE801]'
- en: Now we need to create `ImageLayout`s in `BlockLayout`. Input elements are created
    in an `input` method, so we create a largely similar `image` method. But `input`
    is itself largely a duplicate of `word`, so this would be a lot of duplication.
    The only part of these methods that differs is the part that computes the width
    of the new inline child; most of the rest of the logic is shared.
  id: totrans-3247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在 `BlockLayout` 中创建 `ImageLayout`。输入元素是在 `input` 方法中创建的，所以我们创建了一个大致相似的
    `image` 方法。但 `input` 本身基本上是 `word` 的重复，所以这将导致大量的重复。这些方法中唯一不同的部分是计算新内联子元素宽度的部分；其余的大部分逻辑是共享的。
- en: 'Let’s instead refactor the shared code into new methods which `text`, `image`,
    and `input` can call. First, all of these methods need a font to determine how
    much spaceYes, this is how real browsers do it too. to leave after the inline;
    let’s make a function for that:'
  id: totrans-3248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们而不是重构共享代码到新的方法，这些方法 `text`、`image` 和 `input` 可以调用。首先，所有这些方法都需要一个字体来确定内联后的空间大小；让我们为此创建一个函数：
- en: '[PRE802]'
  id: totrans-3249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE802]'
- en: 'There’s also shared code that handles line layout; let’s put that into a new
    `add_inline_child` method. We’ll need to pass in the HTML node, the element, and
    the layout class to instantiate (plus a `word` parameter that’s just for `TextLayout`s):'
  id: totrans-3250
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有处理行布局的共享代码；让我们将其放入一个新的 `add_inline_child` 方法中。我们需要传入 HTML 节点、元素和布局类以实例化（还有一个仅用于
    `TextLayout` 的 `word` 参数）：
- en: '[PRE803]'
  id: totrans-3251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE803]'
- en: 'We can redefine `word` and `input` in a satisfying way now:'
  id: totrans-3252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以以令人满意的方式重新定义 `word` 和 `input`：
- en: '[PRE804]'
  id: totrans-3253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE804]'
- en: 'Adding `image` is easy:'
  id: totrans-3254
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `image` 很简单：
- en: '[PRE805]'
  id: totrans-3255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE805]'
- en: 'And of course, images also get the same inline layout mode as input elements:'
  id: totrans-3256
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，图像也获得与输入元素相同的内联布局模式：
- en: '[PRE806]'
  id: totrans-3257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE806]'
- en: Now that we have `ImageLayout` nodes in our layout tree, we’ll be painting `DrawImage`
    commands to our display list and showing the image on the screen!
  id: totrans-3258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在布局树中有 `ImageLayout` 节点，我们将向显示列表中绘制 `DrawImage` 命令，并在屏幕上显示图像！
- en: 'But what about our second output modality, screen readers? That’s what the
    `alt` attribute is for. It works like this:'
  id: totrans-3259
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的第二个输出模式，屏幕阅读器怎么办？这就是 `alt` 属性的作用。它的工作方式是这样的：
- en: '[PRE807]'
  id: totrans-3260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE807]'
- en: 'Implementing this in `AccessibilityNode` is very easy:'
  id: totrans-3261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AccessibilityNode` 中实现这一点非常简单：
- en: '[PRE808]'
  id: totrans-3262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE808]'
- en: As we continue to implement new features for the web platform, we’ll always
    need to think about how to make features work in multiple modalities.
  id: totrans-3263
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续为网络平台实现新功能，我们始终需要考虑如何使功能在多种模式中工作。
- en: Videos are similar to images, but demand more bandwidth, time, and memory; they
    also have complications like [digital rights management (DRM)](https://en.wikipedia.org/wiki/Digital_rights_management).
    The `<video>` tag addresses some of that, with built-in support for advanced video
    [*codecs*](https://en.wikipedia.org/wiki/Video_codec),In video, it’s called a
    “codec”, but in images it’s called a “format”–go figure. DRM, and hardware acceleration.
    It also provides media controls like a play/pause button and volume controls.
  id: totrans-3264
  prefs: []
  type: TYPE_NORMAL
  zh: 视频与图像类似，但需要更多的带宽、时间和内存；它们还涉及诸如 [数字版权管理 (DRM)](https://en.wikipedia.org/wiki/Digital_rights_management)
    这样的复杂性。`<video>` 标签解决了这些问题，内置了对高级视频 [*编解码器*](https://en.wikipedia.org/wiki/Video_codec)
    的支持，在视频中被称作“编解码器”，但在图像中被称为“格式”——想想看。DRM 和硬件加速。它还提供了媒体控件，如播放/暂停按钮和音量控制。
- en: Modifying Image Sizes
  id: totrans-3265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改图像大小
- en: 'So far, an image’s size on the screen is its size in pixels, possibly zoomed.Note
    that zoom already may cause an image to render at a size different than its regular
    size, even before introducing the features in this section. But in fact it’s generally
    valuable for authors to control the size of embedded content. There are a number
    of ways to do this,For example, the `width` and `height` CSS properties (not to
    be confused with the `width` and `height` attributes!), which we met in Exercise
    6-2. but one way is the special `width` and `height` attributes.Images have these
    mostly for historical reasons: they were invented before CSS existed.'
  id: totrans-3266
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，屏幕上图像的大小是其像素大小，可能已经缩放。注意，缩放已经可能导致图像以不同于其常规大小的大小渲染，甚至在引入本节中的功能之前。但事实上，对于作者来说，控制嵌入内容的大小通常是有价值的。有几种方法可以做到这一点，例如，我们在练习
    6-2 中遇到的 `width` 和 `height` CSS 属性（不要与 `width` 和 `height` 属性混淆！）。
- en: 'If *both* those attributes are present, things are pretty easy: we just read
    from them when laying out the element, both in `image`:'
  id: totrans-3267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *两个* 这些属性都存在，事情就很简单了：我们在布局元素时从它们中读取，在 `image` 中也是如此：
- en: '[PRE809]'
  id: totrans-3268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE809]'
- en: 'And in `ImageLayout`:'
  id: totrans-3269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ImageLayout` 中：
- en: '[PRE810]'
  id: totrans-3270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE810]'
- en: 'This works great, but it has a major flaw: if the ratio of `width` to `height`
    isn’t the same as the underlying image size, the image ends up stretched in weird
    ways. Sometimes that’s on purpose but usually it’s a mistake. So browsers let
    authors specify *just one* of `width` and `height`, and compute the other using
    the image’s *aspect ratio*.Despite it being easy to implement, this feature of
    real web browsers only reached all of them in 2021\. Before that, developers resorted
    to things like the [`padding-top` hack](https://web.dev/aspect-ratio/#the-old-hack-maintaining-aspect-ratio-with-padding-top).
    Sometimes design oversights take a long time to fix.'
  id: totrans-3271
  prefs: []
  type: TYPE_NORMAL
  zh: 这效果很好，但它有一个主要的缺陷：如果`width`与`height`的比例与底层图像大小不同，图像最终会以奇怪的方式拉伸。有时这是故意的，但通常是一个错误。因此，浏览器允许作者指定`width`和`height`中的`just
    one`，并使用图像的宽高比来计算另一个。尽管实现起来很简单，但这个特性直到2021年才在所有实际浏览器中实现。在此之前，开发者们求助于像`padding-top`这样的[旧技巧](https://web.dev/aspect-ratio/#the-old-hack-maintaining-aspect-ratio-with-padding-top)。有时设计上的疏忽需要很长时间才能修复。
- en: 'Implementing this aspect ratio tweak is easy:'
  id: totrans-3272
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个宽高比调整很简单：
- en: '[PRE811]'
  id: totrans-3273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE811]'
- en: Your browser should now be able to render the following [example page](https://browser.engineering/examples/example15-img.html)
    correctly, as shown in Figure 2\. When it’s scrolled down a bit you should see
    what’s shown in Figure 3 (notice the different aspect ratios). And scrolling to
    the end will show what appears in Figure 4, including the “broken image” icon.
  id: totrans-3274
  prefs: []
  type: TYPE_NORMAL
  zh: 您的浏览器现在应该能够正确渲染以下[示例页面](https://browser.engineering/examples/example15-img.html)，如图2所示。当向下滚动一点时，您应该看到图3中显示的内容（注意不同的宽高比）。滚动到页面底部将显示图4中显示的内容，包括“损坏的图像”图标。
- en: '[PRE812]'
  id: totrans-3275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE812]'
- en: '![Figure 2: Rendering of an example with images.](img/d1c2c7d6f62531d3e02e0e6b2b1309a9.png)'
  id: totrans-3276
  prefs: []
  type: TYPE_IMG
  zh: '![图2：示例图像的渲染。](img/d1c2c7d6f62531d3e02e0e6b2b1309a9.png)'
- en: 'Figure 2: Rendering of an example with images.'
  id: totrans-3277
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：示例图像的渲染。
- en: '![Figure 3: Rendering of an example with images after scrolling to aspect-ratio
    differences.](img/2e7b9c4edf45c86073a6044827035a01.png)'
  id: totrans-3278
  prefs: []
  type: TYPE_IMG
  zh: '![图3：滚动到宽高比差异后的示例图像渲染。](img/2e7b9c4edf45c86073a6044827035a01.png)'
- en: 'Figure 3: Rendering of an example with images after scrolling to aspect-ratio
    differences.'
  id: totrans-3279
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：滚动到宽高比差异后的示例图像渲染。
- en: '![Figure 4: Rendering of an example with images after scrolling to a broken
    image icon.](img/336f47c9d5c057d4420a9971105b0875.png)'
  id: totrans-3280
  prefs: []
  type: TYPE_IMG
  zh: '![图4：滚动到损坏的图像图标后的示例图像渲染。](img/336f47c9d5c057d4420a9971105b0875.png)'
- en: 'Figure 4: Rendering of an example with images after scrolling to a broken image
    icon.'
  id: totrans-3281
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：滚动到损坏的图像图标后的示例图像渲染。
- en: Our browser computes an aspect ratio from the loaded image dimensions, but that’s
    not available before an image loads, which is a problem in real browsers where
    images are loaded asynchronously and where the image size can [respond to](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design)
    layout parameters. Not knowing the aspect ratio can cause the [layout to shift](https://web.dev/cls/)
    when the image loads, which can be frustrating for users. The [`aspect-ratio`
    property](https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio) is one
    way web pages can address this issue.
  id: totrans-3282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器从加载的图像尺寸计算出一个宽高比，但在图像加载之前，这个信息是不可用的，这在实际浏览器中是一个问题，因为在实际浏览器中图像是异步加载的，图像大小可能会[响应](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design)布局参数。不知道宽高比可能会导致图像加载时布局发生[偏移](https://web.dev/cls/)，这对用户来说可能很令人沮丧。`aspect-ratio`属性是网页解决这个问题的方法之一。
- en: Interactive Widgets
  id: totrans-3283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式小部件
- en: 'So far, our browser has two kinds of embedded content: images and input elements.
    While both are important and widely used,As are variations like the [`<canvas>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas)
    element. Instead of loading an image from the network, JavaScript can draw on
    a `<canvas>` element via an API. Unlike images, `<canvas>` elements don’t have
    intrinsic sizes, but besides that they are pretty similar in terms of layout.
    they don’t offer quite the customizabilityThere’s actually [ongoing work](https://open-ui.org/)
    aimed at allowing web pages to customize what input elements look like, and it
    builds on earlier work supporting [custom elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components)
    and [forms](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/attachInternals).
    This problem is quite challenging, interacting with platform independence, accessibility,
    scripting, and styling. and flexibility that complex embedded content use cases
    like maps, PDFs, ads, and social media controls require. So in modern browsers,
    these are handled by *embedding one web page within another* using the `<iframe>`
    element.Or via the `embed` and `object` tags, for cases like PDFs. I won’t discuss
    those here.'
  id: totrans-3284
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的浏览器有两种嵌入内容：图像和输入元素。虽然两者都很重要且广泛使用，但像`<canvas>`（https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas）元素这样的变体也是如此。JavaScript可以通过API在`<canvas>`元素上绘制，而不是从网络上加载图像。与图像不同，`<canvas>`元素没有固有的大小，但除此之外，它们在布局方面相当相似。它们不提供复杂嵌入内容用例（如地图、PDF、广告和社交媒体控件）所需的相当可定制性和灵活性。因此，在现代浏览器中，这些是通过使用`<iframe>`元素将一个网页嵌入另一个网页来处理的。或者通过`embed`和`object`标签，用于PDF等案例。这里不会讨论这些。
- en: 'Semantically, an `<iframe>` is similar to a `Tab` inside a `Tab`—it has its
    own HTML document, CSS, and scripts. And layout-wise, an `<iframe>` is a lot like
    the `<img>` tag, with `width` and `height` attributes. So implementing basic iframes
    just requires handling these three significant differences:'
  id: totrans-3285
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上讲，`<iframe>`类似于`Tab`内部的`Tab`——它有自己的HTML文档、CSS和脚本。从布局上讲，`<iframe>`与`<img>`标签非常相似，具有`width`和`height`属性。因此，实现基本iframe只需要处理这三个显著差异：
- en: Iframes have *no browser chrome*. So any page navigation has to happen from
    within the page (either through an `<a>` element or a script), or as a side effect
    of navigation on the web page that *contains* the `<iframe>` element. Clicking
    on a link in an iframe also navigates the iframe, not the top-level page.
  id: totrans-3286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Iframes没有*浏览器边框*。因此，任何页面导航都必须在页面内部发生（通过一个`<a>`元素或脚本），或者作为包含`<iframe>`元素的网页导航的副作用。在iframe中点击链接也会导航iframe，而不是顶层页面。
- en: Iframes can *share a rendering event loop*.For example, if an iframe has the
    same origin as the web page that embeds it, then scripts in the iframe can synchronously
    access the parent DOM. That means that it’d be basically impossible to put that
    iframe in a different thread or CPU process, and in practice it ends up in the
    same rendering event loop. In real browsers, [cross-origin](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)
    iframes are often “site isolated”, meaning that the iframe has its own CPU process
    for [security reasons](https://www.chromium.org/Home/chromium-security/site-isolation/).
    In our browser we’ll just make all iframes (even nested ones—yes, iframes can
    include iframes!) use the same rendering event loop.
  id: totrans-3287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Iframes可以*共享渲染事件循环*。例如，如果一个iframe与嵌入它的网页有相同的源，那么iframe中的脚本可以同步访问父DOM。这意味着基本上不可能将那个iframe放入不同的线程或CPU进程，实际上它最终会位于相同的渲染事件循环中。在真实浏览器中，[跨源](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)iframe通常被“站点隔离”，这意味着iframe有自己的CPU进程出于[安全原因](https://www.chromium.org/Home/chromium-security/site-isolation/)。在我们的浏览器中，我们将使所有iframe（即使是嵌套的——是的，iframe可以包含iframe！）使用相同的渲染事件循环。
- en: Cross-origin iframes are *script-isolated* from the containing page. That means
    that a script in the iframe [can’t access](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#cross-origin_script_api_access)
    the containing page’s variables or DOM, nor can scripts in the containing page
    access the iframe’s variables or DOM. Same-origin iframes, however, can.
  id: totrans-3288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨源iframe与包含页面*脚本隔离*。这意味着iframe中的脚本[无法访问](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#cross-origin_script_api_access)包含页面的变量或DOM，包含页面的脚本也无法访问iframe的变量或DOM。然而，同源iframe可以。
- en: 'We’ll get to these differences, but for now, let’s start working on the idea
    of a `Tab` within a `Tab`. What we’re going to do is split the `Tab` class into
    two pieces: `Tab` will own the event loop and script environments, `Frame`s will
    do the rest.'
  id: totrans-3289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会讨论这些差异，但现在，让我们开始工作于`Tab`中的`Tab`的想法。我们要做的是将`Tab`类分成两部分：`Tab`将拥有事件循环和脚本环境，`Frame`将做其余的工作。
- en: 'It’s good to plan out complicated refactors like this in some detail. A `Tab`
    will:'
  id: totrans-3290
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些细节上规划出像这样的复杂重构是很好的。一个`Tab`将：
- en: interface between the `Browser` and the `Frame`s to handle events;
  id: totrans-3291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Browser`和`Frame`之间提供接口以处理事件；
- en: proxy communication between frames;
  id: totrans-3292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理帧之间的通信；
- en: kick off animation frames and rendering;
  id: totrans-3293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动动画帧和渲染；
- en: paint and own the display list for all frames in the tab;
  id: totrans-3294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为标签页中的所有帧绘制并拥有显示列表。
- en: construct and own the accessibility tree;
  id: totrans-3295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建并拥有可访问性树；
- en: commit to the browser thread.
  id: totrans-3296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交到浏览器线程。
- en: 'And the new `Frame` class will:'
  id: totrans-3297
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`Frame`类将：
- en: own the DOM, layout trees, and scroll offset for its HTML document;
  id: totrans-3298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有其HTML文档的DOM、布局树和滚动偏移量；
- en: run style and layout on the its DOM and layout tree;
  id: totrans-3299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其DOM和布局树上运行样式和布局；
- en: implement loading and event handling (focus, hit testing, etc) for its HTML
    document.
  id: totrans-3300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现其HTML文档的加载和事件处理（焦点、点击测试等）。
- en: Create these two classes and split the methods between them accordingly.
  id: totrans-3301
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这两个类，并相应地分配方法。
- en: 'Naturally, every `Frame` will need a reference to its `Tab`; it’s also convenient
    to have access to the parent frame and the corresponding `<iframe>` element:'
  id: totrans-3302
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，每个`Frame`都需要对其`Tab`的引用；同时访问父帧和相应的`<iframe>`元素也很方便：
- en: '[PRE813]'
  id: totrans-3303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE813]'
- en: 'Now let’s look at how `Frame`s are created. The first place is in `Tab`’s `load`
    method, which needs to create the *root frame*:'
  id: totrans-3304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`Frame`是如何创建的。第一个地方是在`Tab`的`load`方法中，它需要创建*根帧*：
- en: '[PRE814]'
  id: totrans-3305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE814]'
- en: 'Note that the guts of `load` now live in the `Frame`, because the `Frame` owns
    the HTML tree. The `Frame` can *also* construct child `Frame`s, for `<iframe>`
    elements:'
  id: totrans-3306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`load`方法的内部实现现在位于`Frame`中，因为`Frame`拥有HTML树。`Frame`还可以为`<iframe>`元素构建和拥有子`Frame`：
- en: '[PRE815]'
  id: totrans-3307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE815]'
- en: 'Since iframes can have subresources (and subframes!) and therefore be slow
    to load, we should load them asynchronously, just like scripts:'
  id: totrans-3308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于iframe可以有子资源（和子帧！）并且因此加载较慢，我们应该像脚本一样异步加载它们：
- en: '[PRE816]'
  id: totrans-3309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE816]'
- en: 'And since they are asynchronous, we need to record whether they have loaded
    yet, to avoid trying to render an unloaded iframe:'
  id: totrans-3310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是异步的，我们需要记录它们是否已经加载，以避免尝试渲染未加载的iframe：
- en: '[PRE817]'
  id: totrans-3311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE817]'
- en: 'So we’ve now got a tree of frames inside a single tab. But because we will
    sometimes need direct access to an arbitrary frame, let’s also give each frame
    an identifier, which I’m calling a *window ID*:'
  id: totrans-3312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在在单个`Tab`中有一个帧的树。但由于我们有时需要直接访问任意帧，让我们也给每个帧一个标识符，我称之为*窗口ID*：
- en: '[PRE818]'
  id: totrans-3313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE818]'
- en: '[PRE819]'
  id: totrans-3314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE819]'
- en: Now that we have frames being created, let’s work on rendering those frames
    to the screen.
  id: totrans-3315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了正在创建的帧，让我们开始将这些帧渲染到屏幕上。
- en: 'For quite a while, browsers also supported embedded content in the form of
    *plugins* like [Java applets](https://en.wikipedia.org/wiki/Java_applet) or [Flash](https://en.wikipedia.org/wiki/Adobe_Flash).
    But there were [performance, security, and accessibility problems](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Other_embedding_technologies#the_embed_and_object_elements)
    because plugins typically implemented their own rendering, sandboxing, and UI
    primitives. Over time, new APIs have closed the gap between web-native content
    and “non-web” plugins,For example, in the last decade the `<canvas>` element has
    gained support for hardware-accelerated 3D content, while [WebAssembly](https://en.wikipedia.org/wiki/WebAssembly)
    can run at near-native speed. and plugins have therefore become less common. Personally,
    I think that’s a good thing: the web is about making information accessible to
    everyone, and that requires open standards, including for embedded content.'
  id: totrans-3316
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间内，浏览器也支持以 *插件* 的形式嵌入内容，例如 [Java 小程序](https://en.wikipedia.org/wiki/Java_applet)
    或 [Flash](https://en.wikipedia.org/wiki/Adobe_Flash)。但由于插件通常实现了自己的渲染、沙盒化和 UI 原语，因此存在
    [性能、安全和可访问性问题](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Other_embedding_technologies#the_embed_and_object_elements)。随着时间的推移，新的
    API 已经缩小了原生 Web 内容和“非 Web”插件之间的差距。例如，在过去的十年中，`<canvas>` 元素已经支持了硬件加速的 3D 内容，而 [WebAssembly](https://en.wikipedia.org/wiki/WebAssembly)
    可以以接近原生的速度运行。因此，插件已经变得不那么常见了。我个人认为这是好事：Web 是关于让信息对每个人可访问的，而这需要开放的标准，包括嵌入内容的标准。
- en: Iframe Rendering
  id: totrans-3317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Iframe 渲染
- en: 'Rendering is split between the `Tab` and its `Frame`s: the `Frame` does style
    and layout, while the `Tab` does accessibility and paint.Why split the rendering
    pipeline this way? Because the accessibility tree and display list are ultimately
    transferred from the main thread to the browser thread, so they get combined anyway.
    DOM, style, and layout trees, meanwhile, don’t get passed between threads so don’t
    intermingle. We’ll need to implement that split, and also add code to trigger
    each `Frame`’s rendering from the `Tab`.'
  id: totrans-3318
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染被分割在 `Tab` 和其 `Frame`s 之间：`Frame` 负责样式和布局，而 `Tab` 负责可访问性和绘制。为什么以这种方式分割渲染管道？因为可访问性树和显示列表最终是从主线程传输到浏览器线程的，所以它们无论如何都会合并。同时，DOM、样式和布局树不会在线程之间传递，因此不会混合。我们需要实现这种分割，并添加代码从
    `Tab` 触发每个 `Frame` 的渲染。
- en: 'Let’s start with splitting the rendering pipeline. The main methods here are
    still the `Tab`’s `run_animation_frame` and `render`, which iterate over all loaded
    iframes:'
  id: totrans-3319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从分割渲染管道开始。这里的主要方法仍然是 `Tab` 的 `run_animation_frame` 和 `render`，它们遍历所有已加载的
    iframes：
- en: '[PRE820]'
  id: totrans-3320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE820]'
- en: 'In this code I used a new `dispatch_RAF` method:'
  id: totrans-3321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我使用了新的 `dispatch_RAF` 方法：
- en: '[PRE821]'
  id: totrans-3322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE821]'
- en: 'Note that the `needs_accessibility`, `pending_hover`, and other flags are all
    still on the `Tab`, because they relate to the `Tab`’s part of rendering. Meanwhile,
    style and layout happen in the `Frame` now:'
  id: totrans-3323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`needs_accessibility`、`pending_hover` 和其他标志仍然在 `Tab` 上，因为它们与 `Tab` 的渲染部分相关。同时，样式和布局现在发生在
    `Frame` 中：
- en: '[PRE822]'
  id: totrans-3324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE822]'
- en: Again, these dirty bits move to the `Frame` because they relate to the frame’s
    part of rendering.
  id: totrans-3325
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这些脏位移动到 `Frame` 上，因为它们与帧的渲染部分相关。
- en: 'Unlike images, iframes have *no [intrinsic size](https://developer.mozilla.org/en-US/docs/Glossary/Intrinsic_Size)*:
    the layout size of an `<iframe>` element does not depend on its content.There
    was an attempt to provide iframes with intrinsic sizing in the past, but it was
    [removed](https://github.com/whatwg/html/issues/331) from the HTML specification
    when no browser implemented it. This may change [in the future](https://github.com/w3c/csswg-drafts/issues/1771),
    as there are good use cases for a “seamless” iframe whose layout is coordinated
    with its parent frame. That means there’s a crucial extra bit of communication
    that needs to happen between the parent and child frames: how wide and tall should
    a frame be laid out? This is defined by the attributes and CSS of the `iframe`
    element:'
  id: totrans-3326
  prefs: []
  type: TYPE_NORMAL
  zh: 与图像不同，iframes 没有明确的 [尺寸](https://developer.mozilla.org/en-US/docs/Glossary/Intrinsic_Size)：`<iframe>`
    元素的布局大小不依赖于其内容。过去曾尝试为 iframes 提供内建尺寸，但它在没有浏览器实现的情况下被从 HTML 规范中 [移除](https://github.com/whatwg/html/issues/331)。这可能在
    [未来](https://github.com/w3c/csswg-drafts/issues/1771) 发生变化，因为对于布局与其父帧协调的“无缝”iframe
    有很好的用例。这意味着在父帧和子帧之间需要发生关键额外的通信：帧应该布局多宽多高？这由 `iframe` 元素的属性和 CSS 定义：
- en: '[PRE823]'
  id: totrans-3327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE823]'
- en: 'The `IframeLayout` layout code is similar, inheriting from `EmbedLayout`, but
    without the aspect ratio code:'
  id: totrans-3328
  prefs: []
  type: TYPE_NORMAL
  zh: '`IframeLayout` 布局代码类似，继承自 `EmbedLayout`，但没有宽高比代码：'
- en: '[PRE824]'
  id: totrans-3329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE824]'
- en: The extra two pixels provide room for a border, one pixel on each side, later
    on.
  id: totrans-3330
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的两个像素为边框提供了空间，每边一个像素，稍后使用。
- en: 'Note that if its `width` isn’t specified, an iframe uses a [default value](https://www.w3.org/TR/CSS2/visudet.html#inline-replaced-width),
    chosen a long time ago based on the average screen sizes of the day:'
  id: totrans-3331
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果其 `width` 没有指定，iframe 将使用一个 [默认值](https://www.w3.org/TR/CSS2/visudet.html#inline-replaced-width)，这个值是基于很久以前平均屏幕尺寸选择的：
- en: '[PRE825]'
  id: totrans-3332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE825]'
- en: 'Now, this code is run in the *parent* frame. We need to get this width and
    height over to the *child* frame, so that it can know its width and height during
    layout. So let’s add a field for that in the child frame:'
  id: totrans-3333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这段代码在 *父* 框架中运行。我们需要将这个宽度和高度传递到 *子* 框架，以便它在布局时知道自己的宽度和高度。因此，让我们在子框架中添加一个字段：
- en: '[PRE826]'
  id: totrans-3334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE826]'
- en: 'And we can set those when the parent frame is laid out:'
  id: totrans-3335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在父框架布局时设置这些值：
- en: '[PRE827]'
  id: totrans-3336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE827]'
- en: The conditional is only there to handle the (unusual) case of an iframe blocked
    by CSP.
  id: totrans-3337
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句仅用于处理（不常见）的 iframe 被CSP阻止的情况。
- en: 'You might be surprised that I’m not calling `set_needs_render` on the child
    frame here. That’s a shortcut: the `width` and `height` attributes can only change
    through `setAttribute`, while `zoom` can only change in `zoom_by` and `reset_zoom`.
    All of those handlers, however, need to invalidate all frames, via a new method
    to do so, instead of the old `set_needs_render` on `Tab` which is now gone. Update
    all of these call sites to call it (plus changes to dark mode, which affects style
    for all frames):'
  id: totrans-3338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶，我没有在这里调用 `set_needs_render`。这是一个快捷方式：`width` 和 `height` 属性只能通过 `setAttribute`
    更改，而 `zoom` 只能在 `zoom_by` 和 `reset_zoom` 中更改。然而，所有这些处理程序都需要通过一个新的方法来使所有框架无效，而不是现在已删除的
    `Tab` 上的旧 `set_needs_render`。更新所有这些调用点以调用它（以及影响所有框架样式的深色模式更改）：
- en: '[PRE828]'
  id: totrans-3339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE828]'
- en: 'The root frame, of course, fills the whole window:'
  id: totrans-3340
  prefs: []
  type: TYPE_NORMAL
  zh: 根框架当然填充整个窗口：
- en: '[PRE829]'
  id: totrans-3341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE829]'
- en: Note that there’s a tricky dependency order here. We need the parent frame to
    do layout before the child frame, so the child frame has an up-to-date width and
    height when it does layout. That order is guaranteed for us by Python (3.7 or
    later), where dictionaries are sorted by insertion order, but if you’re following
    along in another language, you might need to sort frames before rendering them.
  id: totrans-3342
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的依赖关系顺序很复杂。我们需要在子框架布局之前让父框架进行布局，以便子框架在布局时具有最新的宽度和高度。Python（3.7或更高版本）保证了这个顺序，其中字典按插入顺序排序，但如果你在另一种语言中跟随，你可能需要在渲染之前对框架进行排序。
- en: 'We’ve now got frames styled and laid out, and just need to paint them. Unlike
    layout and style, all the frames in a tab produce a single, unified display list,
    so we’re going to need to work recursively. We’ll have the `Tab` paint the root
    `Frame`:'
  id: totrans-3343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经对框架进行了样式化和布局，只需要绘制它们。与布局和样式不同，一个标签页中的所有框架产生一个单一的、统一的显示列表，因此我们需要递归地工作。我们将让
    `Tab` 绘制根 `Frame`：
- en: '[PRE830]'
  id: totrans-3344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE830]'
- en: 'Most of the layout tree’s `paint` methods don’t need to change, but to paint
    an `IframeLayout`, we’ll need to paint the child frame in `paint_tree`:'
  id: totrans-3345
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数布局树的 `paint` 方法不需要更改，但为了绘制 `IframeLayout`，我们需要在 `paint_tree` 中绘制子框架：
- en: '[PRE831]'
  id: totrans-3346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE831]'
- en: 'Before putting those commands in the display list, though, we need to add a
    border, clip iframe content that exceeds the visual area available, and transform
    the coordinate system:'
  id: totrans-3347
  prefs: []
  type: TYPE_NORMAL
  zh: 在将这些命令放入显示列表之前，我们需要添加一个边框，裁剪超出可视区域的 iframe 内容，并转换坐标系：
- en: '[PRE832]'
  id: totrans-3348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE832]'
- en: 'The `Transform` shifts over the child frame contents so that its top-left corner
    starts in the right place,This book doesn’t go into the details of the [CSS box
    model](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model),
    but the `width` and `height` attributes of an iframe refer to the *content box*,
    and adding the border width yields the *border box*. As a result, what we’ve implemented
    is somewhat incorrect. `ClipRRect` clips the contents of the iframe to the inside
    of the border, and `paint_outline` adds the border. To trigger the outline, just
    add this to the browser CSS file:'
  id: totrans-3349
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transform` 将子框架内容移动，使其左上角开始于正确的位置。这本书没有深入介绍 [CSS 盒模型](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model)，但
    iframe 的 `width` 和 `height` 属性指的是 *内容框*，加上边框宽度得到 *边框框*。因此，我们实现的是不完全正确的。`ClipRRect`
    将 iframe 内容裁剪到边框内部，而 `paint_outline` 添加边框。要触发轮廓，只需将以下内容添加到浏览器 CSS 文件中：'
- en: '[PRE833]'
  id: totrans-3350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE833]'
- en: 'Finally, let’s also add iframes to the accessibility tree. Like the display
    list, the accessibility tree is global across all frames. We can have iframes
    create `iframe` nodes:'
  id: totrans-3351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们也将 iframe 添加到可访问性树中。与显示列表一样，可访问性树在所有框架中都是全局的。我们可以让 iframe 创建 `iframe`
    节点：
- en: '[PRE834]'
  id: totrans-3352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE834]'
- en: 'To `build` such a node, we just recurse into the frame:'
  id: totrans-3353
  prefs: []
  type: TYPE_NORMAL
  zh: 要 `构建` 这样的节点，我们只需递归到框架中：
- en: '[PRE835]'
  id: totrans-3354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE835]'
- en: So we’ve now got iframes showing up on the screen. The next step is interacting
    with them.
  id: totrans-3355
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在在屏幕上看到了 iframe。下一步是与它们进行交互。
- en: Before iframes, there were the [`<frameset>` and `<frame>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frameset)
    elements. A `<frameset>` replaces the `<body>` tag and splits the browser window
    among multiple `<frame>`s; this was an early alternative layout system to the
    one presented in this book. Frames had confusing navigation and accessibility,
    and lacked the flexibility of `<iframe>`s, so aren’t used much these days. The
    name “iframe” references these elements in a way—it’s short for “inline frame”.
  id: totrans-3356
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iframe 之前，有 `<frameset>` 和 `<frame>` [元素](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frameset)。`<frameset>`
    替换了 `<body>` 标签，并将浏览器窗口分割成多个 `<frame>`；这是本书中介绍的早期布局系统的替代方案。框架具有令人困惑的导航和可访问性，并且缺乏
    `<iframe>` 的灵活性，因此现在很少使用。名称“iframe”以某种方式引用了这些元素——它是“inline frame”的缩写。
- en: Iframe Input Events
  id: totrans-3357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Iframe 输入事件
- en: Now that we’ve got iframes rendering to the screen, let’s close the loop with
    user input. We want to add support for clicking on things inside an iframe, and
    also for tabbing around or scrolling inside one.
  id: totrans-3358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 iframe 渲染到屏幕上，让我们通过用户输入来闭合循环。我们希望添加对在 iframe 内部点击、在标签页间切换或在其内部滚动等功能的支持。
- en: 'At a high level, event handlers just delegate to the root frame:'
  id: totrans-3359
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，事件处理器只是委托给根框架：
- en: '[PRE836]'
  id: totrans-3360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE836]'
- en: 'When an iframe is clicked, it passes the click through to the child frame,
    and immediately returns afterward, because iframes capture click events. Note
    how I subtracted the absolute *x* and *y* offsets of the iframe from the (absolute)
    *x* and *y* click positions when recursing into the child frame:'
  id: totrans-3361
  prefs: []
  type: TYPE_NORMAL
  zh: 当 iframe 被点击时，它会将点击事件传递给子框架，并在之后立即返回，因为 iframe 会捕获点击事件。注意我在递归到子框架时如何从（绝对）*x*
    和 *y* 点击位置中减去 iframe 的绝对 *x* 和 *y* 偏移量：
- en: '[PRE837]'
  id: totrans-3362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE837]'
- en: Now, clicking on `<a>` elements will work, which means that you can now cause
    a frame to navigate to a new page. And because a `Frame` has all the loading and
    navigation logic that `Tab` used to have, it just works without any more changes!
  id: totrans-3363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击 `<a>` 元素将生效，这意味着你现在可以导致一个框架导航到新页面。由于 `Frame` 具有与 `Tab` 之前所用的所有加载和导航逻辑，它无需任何更多更改即可正常工作！
- en: You should now be able to load [an iframe example](examples/example15-iframe.html).
    It should look like the image shown in Figure 5.
  id: totrans-3364
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够加载 [一个 iframe 示例](examples/example15-iframe.html)。它应该看起来像图 5 中所示。
- en: '![Figure 5: Rendering of an iframe.](img/17976f1be39bc62d5ddd94e97eb80644.png)'
  id: totrans-3365
  prefs: []
  type: TYPE_IMG
  zh: '![图 5：iframe 的渲染。](img/17976f1be39bc62d5ddd94e97eb80644.png)'
- en: 'Figure 5: Rendering of an iframe.'
  id: totrans-3366
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5：iframe 的渲染。
- en: Repeatedly clicking on the link on that page will add another recursive iframe.
    After clicking twice it should look like Figure 6.
  id: totrans-3367
  prefs: []
  type: TYPE_NORMAL
  zh: 重复点击该页面上的链接将添加另一个递归 iframe。点击两次后，它应该看起来像图 6。
- en: '![Figure 6: Rendering of nested iframes.](img/9682198ee6105fa7dec3b59ee55f0e17.png)'
  id: totrans-3368
  prefs: []
  type: TYPE_IMG
  zh: '![图 6：嵌套 iframe 的渲染。](img/9682198ee6105fa7dec3b59ee55f0e17.png)'
- en: 'Figure 6: Rendering of nested iframes.'
  id: totrans-3369
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6：嵌套 iframe 的渲染。
- en: 'Let’s get the other interactions working as well, starting with focusing an
    element. You can focus on *only one element per tab*, so we will still store the
    `focus` on the `Tab`, but we’ll need to store the iframe the focused element is
    on too:'
  id: totrans-3370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让其他交互也正常工作，从聚焦一个元素开始。你可以在每个标签页上聚焦于 *仅一个元素*，因此我们仍然会在 `Tab` 上存储 `focus`，但我们需要存储聚焦元素所在的
    iframe：
- en: '[PRE838]'
  id: totrans-3371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE838]'
- en: 'When an iframe tries to focus on an element, it sets itself as the focused
    iframe, but before it does that, it needs to un-focus the previously focused iframe:'
  id: totrans-3372
  prefs: []
  type: TYPE_NORMAL
  zh: 当 iframe 尝试聚焦到一个元素时，它会将自己设置为聚焦的 iframe，但在这样做之前，它需要取消之前聚焦的 iframe 的焦点：
- en: '[PRE839]'
  id: totrans-3373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE839]'
- en: We need to re-render the previously focused iframe so that it stops drawing
    the focus outline.
  id: totrans-3374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重新渲染之前聚焦的 iframe，以便停止绘制焦点轮廓。
- en: Another interaction is pressing `Tab` to cycle through focusable elements in
    the current frame. Let’s move the `advance_tab` logic into `Frame` and just dispatch
    to it from the `Tab`:This is not a particularly user-friendly implementation of
    tab cycling when multiple frames are involved; see Exercise 15-9 for a better
    version.
  id: totrans-3375
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种交互是通过按 `Tab` 在当前框架中循环遍历可聚焦元素。让我们将 `advance_tab` 逻辑移动到 `Frame` 中，并从 `Tab`
    中派发到它：这不是一个特别用户友好的多框架涉及时的标签页循环实现；请参阅练习 15-9 以获得更好的版本。
- en: '[PRE840]'
  id: totrans-3376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE840]'
- en: Do the same thing for `keypress` and `enter`, which are used for interacting
    with text inputs and buttons.
  id: totrans-3377
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `keypress` 和 `enter` 也做同样的事情，它们用于与文本输入和按钮交互。
- en: 'Another big interaction we need to support is scrolling. We’ll store the scroll
    offset in each `Frame`:'
  id: totrans-3378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要支持另一个大型的交互功能，即滚动。我们将在每个 `Frame` 中存储滚动偏移量：
- en: '[PRE841]'
  id: totrans-3379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE841]'
- en: 'Now, as you might recall from [Chapter 13](animations.html), scrolling happens
    both inside `Browser` and inside `Tab`, to improve responsiveness. That was already
    quite complicated, so to keep things simple we’ll only support threaded scrolling
    on the root frame. We’ll need a new commit parameter so the browser thread knows
    whether the root frame is focused:'
  id: totrans-3380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如您从 [第 13 章](animations.html) 中回忆的那样，滚动发生在 `Browser` 和 `Tab` 内部，以提高响应性。这已经相当复杂了，所以为了保持简单，我们只支持根框架的线程化滚动。我们需要一个新的提交参数，以便浏览器线程知道根框架是否被聚焦：
- en: '[PRE842]'
  id: totrans-3381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE842]'
- en: 'The `Browser` thread will save this information in `commit` and use it when
    the user requests a scroll:'
  id: totrans-3382
  prefs: []
  type: TYPE_NORMAL
  zh: '`Browser` 线程会将此信息保存在 `commit` 中，并在用户请求滚动时使用它：'
- en: '[PRE843]'
  id: totrans-3383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE843]'
- en: 'When a tab is asked to scroll, it then scrolls the focused frame:'
  id: totrans-3384
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个标签页被要求滚动时，它就会滚动聚焦的框架：
- en: '[PRE844]'
  id: totrans-3385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE844]'
- en: 'If a frame other than the root frame is scrolled, we’ll just set `needs_composite`
    so the browser has to re-raster from scratch:'
  id: totrans-3386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果除了根框架之外的框架被滚动，我们只需设置 `needs_composite`，这样浏览器就必须从头开始重新光栅化：
- en: '[PRE845]'
  id: totrans-3387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE845]'
- en: 'There’s one more subtlety to scrolling. After we scroll, we want to *clamp*
    the scroll position, to prevent the user scrolling past the last thing on the
    page. Right now `clamp_scroll` uses the window height to determine the maximum
    scroll amount; let’s move that function inside `Frame` so it can use the current
    frame’s height:'
  id: totrans-3388
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动还有一个细微之处。在滚动之后，我们希望将滚动位置 *clamp*，以防止用户滚动到页面上的最后一项。目前 `clamp_scroll` 使用窗口高度来确定最大滚动量；让我们将这个函数移动到
    `Frame` 内部，以便它可以使用当前框架的高度：
- en: '[PRE846]'
  id: totrans-3389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE846]'
- en: 'Make sure to use the `clamp_scroll` method everywhere. For example, in `scroll_to`:'
  id: totrans-3390
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在所有地方都使用 `clamp_scroll` 方法。例如，在 `scroll_to` 中：
- en: '[PRE847]'
  id: totrans-3391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE847]'
- en: 'There are also a number of accessibility hover interactions that we need to
    support. This is hard, because the accessibility interactions happen in the browser
    thread, which has limited information:'
  id: totrans-3392
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多需要支持的辅助功能悬停交互。这很困难，因为辅助功能交互发生在浏览器线程中，该线程信息有限：
- en: The accessibility tree doesn’t know where the iframe is, so it doesn’t know
    how to transform the hover coordinates when it goes into a frame.
  id: totrans-3393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助功能树不知道 iframe 的位置，所以它不知道如何在进入框架时转换悬停坐标。
- en: It also doesn’t know how big the iframe is, so it doesn’t ignore things that
    are clipped outside an iframe’s bounds.Observe that frame-based `click` already
    works correctly, because we don’t recurse into iframes unless the click intersects
    the `iframe` element’s bounds. And before iframes, we didn’t need to do that,
    because the SDL window system already did it for us.
  id: totrans-3394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它也不知道 iframe 的大小，所以它不会忽略超出 iframe 边界之外的内容。注意，基于框架的 `click` 已经正确工作，因为我们只有在点击与
    `iframe` 元素的边界相交时才会递归到 iframe 中。在 iframe 之前，我们不需要这样做，因为 SDL 窗口系统已经为我们做了这件事。
- en: It also doesn’t know how far a frame has scrolled, so it doesn’t adjust for
    scrolled frames.
  id: totrans-3395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它也不知道一个框架滚动了多少，所以它不会调整已滚动的框架。
- en: 'We’ll make a subclass of `AccessibilityNode` to store this information:'
  id: totrans-3396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `AccessibilityNode` 的子类来存储这些信息：
- en: '[PRE848]'
  id: totrans-3397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE848]'
- en: 'We’ll create one of those below each `iframe` node:'
  id: totrans-3398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每个 `iframe` 节点下方创建一个这样的实例：
- en: '[PRE849]'
  id: totrans-3399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE849]'
- en: 'Hit testing `FrameAccessibilityNodes` will use the frame’s bounds to ignore
    clicks outside the frame bounds, and adjust clicks against the frame’s coordinates
    (note how we subtract off the zoomed border of the frame):'
  id: totrans-3400
  prefs: []
  type: TYPE_NORMAL
  zh: 点击测试 `FrameAccessibilityNodes` 将使用框架的边界来忽略框架边界之外的点击，并调整与框架坐标的点击（注意我们是如何减去框架缩放边界的）：
- en: '[PRE850]'
  id: totrans-3401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE850]'
- en: 'Hit testing should now work, but the bounds of the hovered node when drawn
    to the screen are still wrong. For that, we’ll need a method that returns the
    absolute screen rect of an `AccessibilityNode`. And that method in turn needs
    parent pointers to walk up the accessibility tree, so let’s add that first:'
  id: totrans-3402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该可以正常进行点击测试，但悬停节点在屏幕上绘制时的边界仍然不正确。为此，我们需要一个返回 `AccessibilityNode` 的绝对屏幕矩形的函数。而这个函数又需要父指针来遍历辅助功能树，所以让我们先添加这个功能：
- en: '[PRE851]'
  id: totrans-3403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE851]'
- en: And now we’re ready for the method to map to absolute coordinates. This loops
    over all bounds `Rect`s and maps them up to the root. Note that there is a special
    case for `FrameAccessibilityNode`, because its self-bounds are in the coordinate
    space of the frame containing the iframe.
  id: totrans-3404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好将方法映射到绝对坐标。这个循环遍历所有的边界 `Rect`s 并将它们映射到根节点。注意，对于 `FrameAccessibilityNode`
    有一个特殊情况，因为它的自边界位于包含 iframe 的框架的坐标空间中。
- en: '[PRE852]'
  id: totrans-3405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE852]'
- en: 'This method calls `map_to_parent` to adjust the bounds. For most accessibility
    nodes we don’t need to do anything, because they are in the same coordinate space
    as their parent:'
  id: totrans-3406
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法调用 `map_to_parent` 来调整边界。对于大多数无障碍节点，我们不需要做任何事情，因为它们与其父节点位于相同的坐标系中：
- en: '[PRE853]'
  id: totrans-3407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE853]'
- en: 'A `FrameAccessibilityNode`, on the other hand, adjusts for the iframe’s postion
    and clipping:'
  id: totrans-3408
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`FrameAccessibilityNode` 调整iframe的位置和裁剪：
- en: '[PRE854]'
  id: totrans-3409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE854]'
- en: You should now be able to hover on nodes and have them read out by our accessibility
    subsystem.
  id: totrans-3410
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够悬停在节点上，让我们的无障碍子系统读取它们。
- en: Alright, we’ve now got all of our browser’s forms of user interaction properly
    recursing through the frame tree. It’s time to add more capabilities to iframes.
  id: totrans-3411
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在已经让浏览器中所有用户交互的形式都正确地通过框架树进行递归。现在是时候给iframe添加更多功能了。
- en: 'Our browser can only scroll the root frame on the browser thread, but real
    browsers have put in [a lot of work](https://developer.chrome.com/articles/renderingng/#threaded-scrolling-animations-and-decode)
    to make scrolling happen on the browser thread as much as possible, including
    for iframes. The hard part is handling the many obscure combinations of containing
    blocks, [stacking orders](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context),
    [scroll bars](https://developer.mozilla.org/en-US/docs/Web/CSS/overflow), transforms,
    and iframes: with scrolling on the browser thread, all of these complex interactions
    have to be communicated from the main thread to the browser thread, and correctly
    interpreted by both sides.'
  id: totrans-3412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器只能在浏览器线程上滚动根框架，但真实浏览器已经投入了[大量工作](https://developer.chrome.com/articles/renderingng/#threaded-scrolling-animations-and-decode)来尽可能在浏览器线程上实现滚动，包括iframe。难点在于处理包含块、[堆叠顺序](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)、[滚动条](https://developer.mozilla.org/en-US/docs/Web/CSS/overflow)、变换和iframe的许多晦涩组合：在浏览器线程上进行滚动时，所有这些复杂交互都必须从主线程传递到浏览器线程，并且由双方正确解释。
- en: Iframe Scripts
  id: totrans-3413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Iframe脚本
- en: We’ve now got users interacting with iframes—but what about scripts interacting
    with them? Of course, each frame can *already* run scripts—but right now, each
    `Frame` has its own `JSContext`, so these scripts can’t really interact with each
    other. Instead *same-origin* iframes should run in the same JavaScript context
    and should be able to access each other’s globals, call each other’s functions,
    and modify each other’s DOMs, as shown in Figure 7\. Let’s implement that.
  id: totrans-3414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经让用户与iframe进行交互——但是脚本如何与它们交互呢？当然，每个框架已经可以运行脚本——但现在，每个 `Frame` 都有自己的 `JSContext`，所以这些脚本实际上无法相互交互。相反，*同源*
    iframe应该在同一个JavaScript上下文中运行，并且应该能够访问彼此的全局变量，调用彼此的函数，并修改彼此的DOM，如图7所示。让我们来实现这一点。
- en: '![Figure 7: Multiple frames within the same tab can share a single JSContext.](img/22f0ccedb06d30d83e4c4d6c77d5725c.png)'
  id: totrans-3415
  prefs: []
  type: TYPE_IMG
  zh: '![图7：同一标签页内的多个框架可以共享单个JSContext。](img/22f0ccedb06d30d83e4c4d6c77d5725c.png)'
- en: 'Figure 7: Multiple frames within the same tab can share a single `JSContext`.'
  id: totrans-3416
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：同一标签页内的多个框架可以共享单个 `JSContext`。
- en: 'For two frames’ JavaScript environments to interact, we’ll need to put them
    in the same `JSContext`. So, instead of each `Frame` having a `JSContext` of its
    own, we’ll want to store `JSContext`s on the `Tab`, in a dictionary that maps
    origins to JavaScript contexts:'
  id: totrans-3417
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让两个框架的JavaScript环境交互，我们需要将它们放在同一个 `JSContext` 中。因此，而不是每个 `Frame` 都有自己的 `JSContext`，我们希望在
    `Tab` 上存储 `JSContext`s，在一个将源映射到JavaScript上下文的字典中：
- en: '[PRE855]'
  id: totrans-3418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE855]'
- en: 'Each `Frame` will then ask the `Tab` for its JavaScript context:'
  id: totrans-3419
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个 `Frame` 将向 `Tab` 请求其JavaScript上下文：
- en: '[PRE856]'
  id: totrans-3420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE856]'
- en: 'So we’ve got multiple pages’ scripts using one JavaScript context. But now
    we’ve got to keep their variables in their own namespaces somehow. The key is
    going to be the `window` global, of type `Window`. In the browser, this refers
    to the [global object](https://developer.mozilla.org/en-US/docs/Glossary/Global_object),
    and instead of writing a global variable like `a`, you can always write `window.a`
    instead.There are [various proposals](https://github.com/tc39/proposal-shadowrealm)
    to expose multiple global namespaces as a JavaScript API. It would definitely
    be convenient to have that capability in this chapter, to avoid having to write
    `window` everywhere! To keep our implementation simple, in our browser, scripts
    will always need to reference variable and functions via `window`.This also means
    that all global variables in a script need to do the same, even if they are not
    browser APIs. We’ll need to do the same in our runtime:'
  id: totrans-3421
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了多个页面的脚本使用一个JavaScript上下文。但现在我们必须以某种方式保持它们的变量在自己的命名空间中。关键将是`window`全局变量，其类型为`Window`。在浏览器中，这指的是[全局对象](https://developer.mozilla.org/en-US/docs/Glossary/Global_object)，你可以用`window.a`代替写一个全局变量`a`。有[各种提议](https://github.com/tc39/proposal-shadowrealm)将多个全局命名空间作为JavaScript
    API暴露出来。如果在这一章中拥有这种能力，将非常方便，可以避免在各个地方都写`window`。为了使我们的实现简单，在我们的浏览器中，脚本将始终需要通过`window`来引用变量和函数。这也意味着脚本中的所有全局变量都需要这样做，即使它们不是浏览器API。在我们的运行时中，我们也需要这样做：
- en: '[PRE857]'
  id: totrans-3422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE857]'
- en: 'Do the same for every function or variable in the `runtime.js` file. If you
    miss one, you’ll get errors like this:'
  id: totrans-3423
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`runtime.js`文件中的每个函数或变量，都要这样做。如果你遗漏了一个，你会得到这样的错误：
- en: '[PRE858]'
  id: totrans-3424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE858]'
- en: 'If you see this error, it means you need to find where you need to write `window.Node`
    instead of `Node`. You’ll also need to modify `EVENT_DISPATCH_JS` to prefix classes
    with `window`:'
  id: totrans-3425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这个错误，这意味着你需要找到你需要将`window.Node`而不是`Node`写入的地方。你还需要修改`EVENT_DISPATCH_JS`以在类名前加上`window`：
- en: '[PRE859]'
  id: totrans-3426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE859]'
- en: Demos from previous chapters will need to be similarly fixed up before they
    work. For example, `setTimeout` might need to change to `window.setTimeout`.
  id: totrans-3427
  prefs: []
  type: TYPE_NORMAL
  zh: 之前章节中的示例在运行之前也需要进行类似的修复。例如，`setTimeout`可能需要更改为`window.setTimeout`。
- en: 'To get multiple frames’ scripts to play nice inside one JavaScript context,
    we’ll create multiple `Window` objects: `window_1`, `window_2`, and so on. Before
    running a frame’s scripts, we’ll set `window` to that frame’s `Window` object,
    so that the script uses the correct `Window`.Some JavaScript engines support an
    API for changing the global object, but the DukPy library that we’re using isn’t
    one of them. There *is* a standard JavaScript operator called `with` which sort
    of does this, but the rules are complicated and not quite what we need here. It’s
    also not recommended these days.'
  id: totrans-3428
  prefs: []
  type: TYPE_NORMAL
  zh: 要在单个JavaScript上下文中让多个帧的脚本协同工作，我们将创建多个`Window`对象：`window_1`、`window_2`等等。在运行一个帧的脚本之前，我们将`window`设置为该帧的`Window`对象，这样脚本就能使用正确的`Window`。一些JavaScript引擎支持用于更改全局对象的API，但我们所使用的DukPy库并不支持。确实存在一个名为`with`的标准JavaScript运算符，它某种程度上可以做到这一点，但其规则很复杂，并不完全符合我们的需求。现在也不推荐使用它。
- en: 'So to begin with, let’s define the `Window` class when we create a `JSContext`:'
  id: totrans-3429
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在创建`JSContext`时定义`Window`类：
- en: '[PRE860]'
  id: totrans-3430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE860]'
- en: 'Now, when a frame is created and wants to use a `JSContext`, it needs to ask
    for a `window` object to be created first:'
  id: totrans-3431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当一个帧被创建并想要使用`JSContext`时，它需要首先请求创建一个`window`对象：
- en: '[PRE861]'
  id: totrans-3432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE861]'
- en: 'Before running any JavaScript, we’ll want to change which window the `window`
    global refers to:'
  id: totrans-3433
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行任何JavaScript之前，我们希望更改`window`全局变量所指向的窗口：
- en: '[PRE862]'
  id: totrans-3434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE862]'
- en: 'We can use this to, for example, set up the initial runtime environment for
    each `Frame`:'
  id: totrans-3435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个来，例如，为每个`Frame`设置初始的运行时环境：
- en: '[PRE863]'
  id: totrans-3436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE863]'
- en: 'We’ll need to call `wrap` any time we use `evaljs`, which also means we’ll
    need to add a window ID argument to a lot of methods. For example, in `run` we’ll
    add a `window_id` parameter:'
  id: totrans-3437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在使用`evaljs`时调用`wrap`，这也意味着我们需要将窗口ID参数添加到许多方法中。例如，在`run`中，我们将添加一个`window_id`参数：
- en: '[PRE864]'
  id: totrans-3438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE864]'
- en: 'And we’ll pass that argument from the `load` method:'
  id: totrans-3439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`load`方法传递这个参数：
- en: '[PRE865]'
  id: totrans-3440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE865]'
- en: 'The same holds for various dispatching APIs. For example, to dispatch an event,
    we’ll need the `window_id`:'
  id: totrans-3441
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于各种分发API。例如，要分发一个事件，我们需要`window_id`：
- en: '[PRE866]'
  id: totrans-3442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE866]'
- en: 'Likewise, we’ll need to pass a window ID argument in `click`, `submit_form`,
    and `keypress`; I’ve omitted those code fragments. Note that you should have modified
    your `runtime.js` file to store the `LISTENERS` on the `window` object, meaning
    each `Frame` will have its own set of event listeners to dispatch to:'
  id: totrans-3443
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们还需要在 `click`、`submit_form` 和 `keypress` 中传递窗口 ID 参数；我已经省略了那些代码片段。请注意，您应该已经修改了
    `runtime.js` 文件，以便在 `window` 对象上存储 `LISTENERS`，这意味着每个 `Frame` 都将有一组自己的事件监听器来分发：
- en: '[PRE867]'
  id: totrans-3444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE867]'
- en: Do the same for `requestAnimationFrame`, passing around a window ID and wrapping
    the code so that it correctly references `window`.
  id: totrans-3445
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `requestAnimationFrame`，也要这样做，传递窗口 ID 并将代码包装起来，以便它正确地引用 `window`。
- en: 'For calls *from* JavaScript into the browser, we’ll need JavaScript to pass
    in the window ID it’s calling from:'
  id: totrans-3446
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从 JavaScript 到浏览器的调用，我们需要 JavaScript 传递它调用的窗口 ID：
- en: '[PRE868]'
  id: totrans-3447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE868]'
- en: 'Then on the browser side we can use that window ID to get the `Frame` object:'
  id: totrans-3448
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在浏览器端，我们可以使用那个窗口 ID 来获取 `Frame` 对象：
- en: '[PRE869]'
  id: totrans-3449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE869]'
- en: We’ll need something similar in `innerHTML` and `style` because we need to call
    `set_needs_render` on the relevant `Frame`.
  id: totrans-3450
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `innerHTML` 和 `style` 中，我们还需要类似的东西，因为我们需要在相关的 `Frame` 上调用 `set_needs_render`。
- en: Finally, for `setTimeout` and `XMLHttpRequest`, which involve a call from JavaScript
    into the browser and later a call from the browser into JavaScript, we’ll likewise
    need to pass in a window ID from JavaScript, and use that window ID when calling
    back into JavaScript. I’ve omitted many of the code changes in this section because
    they are quite repetitive. You can find all of the needed locations by searching
    your codebase for `evaljs`.
  id: totrans-3451
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于 `setTimeout` 和 `XMLHttpRequest`，它们涉及到从 JavaScript 调用浏览器，然后从浏览器调用 JavaScript，我们同样需要从
    JavaScript 传递一个窗口 ID，并在回调到 JavaScript 时使用该窗口 ID。我在这一节中省略了许多代码更改，因为它们相当重复。您可以通过在代码库中搜索
    `evaljs` 来找到所有需要的位置。
- en: So now we’ve isolated different frames. Next, let’s let them interact.
  id: totrans-3452
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经隔离了不同的帧。接下来，让我们让它们进行交互。
- en: 'Same-origin iframes can access each other’s state, but cross-origin ones can’t.
    But the obscure [`domain`](https://developer.mozilla.org/en-US/docs/Web/API/Document/domain)
    property lets an iframe change its origin, moving itself in or out of same-origin
    status in some cases. I personally think it’s a misfeature: it’s hard to implement
    securely, and interferes with various sandboxing techniques; I hope it is eventually
    removed from the web. Instead, there are [various headers](https://html.spec.whatwg.org/multipage/browsers.html#origin-isolation)
    where an iframe can opt into less sharing in order to get better security and
    performance.'
  id: totrans-3453
  prefs: []
  type: TYPE_NORMAL
  zh: 同源 iframe 可以访问彼此的状态，但跨源 iframe 则不能。但是神秘的 `domain` [属性](https://developer.mozilla.org/en-US/docs/Web/API/Document/domain)
    允许 iframe 改变其源，在某些情况下将其移动到或从同源状态中。我个人认为这是一个错误特性：它很难安全实现，并且会干扰各种沙箱技术；我希望它最终会被从网络中移除。相反，有一些
    [各种头信息](https://html.spec.whatwg.org/multipage/browsers.html#origin-isolation)，iframe
    可以选择进行更少的共享以获得更好的安全性和性能。
- en: Communicating Between Frames
  id: totrans-3454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 之间的帧通信
- en: We’ve now managed to run multiple `Frame`s’ worth of JavaScript in a single
    `JSContext`, and isolated them somewhat so that they don’t mess with each others’
    state. But the whole point of this exercise is to allow *some* interaction between
    same-origin frames. Let’s do that now.
  id: totrans-3455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经成功地在单个 `JSContext` 中运行了多个 `Frame` 的 JavaScript，并在一定程度上隔离了它们，以便它们不会相互干扰状态。但这个练习的全部目的是允许同源帧之间进行某些交互。现在让我们这样做。
- en: 'The simplest way two frames can interact is that they can get access to each
    other’s state via the `parent` attribute on the `Window` object. If the two frames
    have the same origin, that lets one frame call methods, access variables, and
    modify browser state for the other frame. Because we’ve had these same-origin
    frames share a `JSContext`, this isn’t too hard to implement. Basically, we’ll
    need a way to go from a window ID to its parent frame’s window ID:'
  id: totrans-3456
  prefs: []
  type: TYPE_NORMAL
  zh: 两个帧之间最简单的方式是它们可以通过 `Window` 对象上的 `parent` 属性访问彼此的状态。如果两个帧有相同的源，这允许一个帧调用方法、访问变量并修改另一个帧的浏览器状态。因为我们让这些同源帧共享一个
    `JSContext`，所以这并不难实现。基本上，我们需要一种从窗口 ID 到其父帧窗口 ID 的转换方式：
- en: '[PRE870]'
  id: totrans-3457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE870]'
- en: 'On the JavaScript side, we now need to look up the `Window` object given its
    window ID. There are lots of ways you could do this, but the easiest is to have
    a global map:'
  id: totrans-3458
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 端，我们现在需要根据窗口 ID 查找 `Window` 对象。您有很多方法可以做到这一点，但最简单的方法是使用全局映射：
- en: '[PRE871]'
  id: totrans-3459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE871]'
- en: 'We’ll add each window to the global map as it’s created:'
  id: totrans-3460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在创建每个窗口时将其添加到全局映射中：
- en: '[PRE872]'
  id: totrans-3461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE872]'
- en: 'Now `window.parent` can look up the correct `Window` object in this global
    map:'
  id: totrans-3462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `window.parent` 可以在这个全局映射中查找正确的 `Window` 对象：
- en: '[PRE873]'
  id: totrans-3463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE873]'
- en: 'Note that it’s possible for the lookup in `WINDOWS` to fail, if the parent
    frame is not in the same origin as the current one and therefore isn’t running
    in the same `JSContext`. In that case, this code returns a fresh `Window` object
    with that id. But iframes are not allowed to access each others’ documents across
    origins (or call various other APIs that are unsafe), so add a method that checks
    for this situation and raises an exception:'
  id: totrans-3464
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果父框架不在与当前窗口相同的源中，那么在 `WINDOWS` 中的查找可能会失败，因此它不会在同一个 `JSContext` 中运行。在这种情况下，此代码将返回一个具有该
    id 的新 `Window` 对象。但是，iframe 不允许跨源访问彼此的文档（或调用其他不安全的 API），因此添加一个检查这种情况并引发异常的方法：
- en: '[PRE874]'
  id: totrans-3465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE874]'
- en: Then use this method in all `JSContext` methods that access documents:Note that
    in a real browser this is woefully inadequate security. A real browser would need
    to very carefully lock down the entire `runtime.js` code and audit every single
    JavaScript API with a fine-toothed comb.
  id: totrans-3466
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在所有访问文档的 `JSContext` 方法中使用此方法：请注意，在实际浏览器中，这显然是不够安全的。一个真正的浏览器需要非常仔细地锁定整个 `runtime.js`
    代码，并仔细检查每个 JavaScript API。
- en: '[PRE875]'
  id: totrans-3467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE875]'
- en: So same-origin iframes can communicate via `parent`. But what about cross-origin
    iframes? It would be insecure to let them access each other’s variables or call
    each other’s methods, so instead browsers allow a form of [*message passing*](https://en.wikipedia.org/wiki/Message_passing),
    a technique for structured communication between two different event loops that
    doesn’t require any shared state or locks.
  id: totrans-3468
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，同源 iframes 可以通过 `parent` 进行通信。但跨源 iframes 呢？允许它们访问彼此的变量或调用彼此的方法将是不安全的，因此浏览器允许一种形式的
    [*消息传递*](https://en.wikipedia.org/wiki/Message_passing)，这是一种在两个不同事件循环之间进行结构化通信的技术，不需要任何共享状态或锁。
- en: 'Message-passing in JavaScript works like this: you call the [`postMessage`
    API](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) on the
    `Window` object you’d like to talk to, with the message itself as the first parameter
    and `*` as the second:The second parameter has to do with origin restrictions;
    see Exercise 15-8.'
  id: totrans-3469
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的消息传递工作方式如下：你会在你想要与之通信的 `Window` 对象上调用 `postMessage` API，消息本身作为第一个参数，`*`
    作为第二个参数：第二个参数与源限制有关；参见练习 15-8。
- en: '[PRE876]'
  id: totrans-3470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE876]'
- en: 'This will send the first argumentIn a real browser, you can also pass data
    that is not a string, such as numbers and objects. This works via a *serialization*
    algorithm called [structured cloning](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm),
    which converts most JavaScript objects (though not, for example, DOM nodes) to
    a sequence of bytes that the receiver frame can convert back into a JavaScript
    object. DukPy doesn’t support structured cloning natively for objects, so our
    browser won’t support this either. to the parent frame, which can receive the
    message by handling the `message` event on its `Window` object:'
  id: totrans-3471
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发送第一个参数到父框架，父框架可以通过在其 `Window` 对象上处理 `message` 事件来接收消息：
- en: '[PRE877]'
  id: totrans-3472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE877]'
- en: Note that in this second code snippet, `window` is the receiving `Window`, a
    different `Window` from the `window` in the first snippet.
  id: totrans-3473
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个第二个代码片段中，`window` 是接收 `Window`，与第一个片段中的 `window` 不同。
- en: 'Let’s implement `postMessage`, starting on the *receiver* side. Since this
    event happens on the `Window`, not on a `Node`, we’ll need a new `WINDOW_LISTENERS`
    array:'
  id: totrans-3474
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 *接收方* 开始实现 `postMessage`。由于此事件发生在 `Window` 上，而不是 `Node` 上，我们需要一个新的 `WINDOW_LISTENERS`
    数组：
- en: '[PRE878]'
  id: totrans-3475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE878]'
- en: 'Each listener will be called with a `MessageEvent` object:'
  id: totrans-3476
  prefs: []
  type: TYPE_NORMAL
  zh: 每个监听器都会使用 `MessageEvent` 对象被调用：
- en: '[PRE879]'
  id: totrans-3477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE879]'
- en: 'The event listener and dispatching code is the same as for `Node`, except it’s
    on `Window` and uses `WINDOW_LISTENERS`. You can just duplicate those methods:'
  id: totrans-3478
  prefs: []
  type: TYPE_NORMAL
  zh: 事件监听器和分发代码与 `Node` 相同，只是它是在 `Window` 上，并使用 `WINDOW_LISTENERS`。你可以直接复制这些方法：
- en: '[PRE880]'
  id: totrans-3479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE880]'
- en: 'That’s everything on the receiver side; now let’s do the sender side. First,
    let’s implement the `postMessage` API itself. Note that `this` is the receiver
    or target window:'
  id: totrans-3480
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是接收方的一切；现在让我们来做发送方。首先，让我们实现 `postMessage` API 本身。注意，`this` 是接收器或目标窗口：
- en: '[PRE881]'
  id: totrans-3481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE881]'
- en: 'In the browser, `postMessage` schedules a task on the `Tab`:'
  id: totrans-3482
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，`postMessage` 方法会在 `Tab` 上安排一个任务：
- en: '[PRE882]'
  id: totrans-3483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE882]'
- en: Scheduling the task is necessary because `postMessage` is an asynchronous API;
    sending a synchronous message might involve synchronizing multiple `JSContext`s
    or even multiple processes, which would add a lot of overhead and probably result
    in deadlocks.
  id: totrans-3484
  prefs: []
  type: TYPE_NORMAL
  zh: 调度任务是有必要的，因为`postMessage`是一个异步API；发送同步消息可能需要同步多个`JSContext`，甚至多个进程，这会增加很多开销，并可能导致死锁。
- en: 'The task finds the target frame and calls a dispatch method:'
  id: totrans-3485
  prefs: []
  type: TYPE_NORMAL
  zh: 该任务找到目标框架并调用一个调度方法：
- en: '[PRE883]'
  id: totrans-3486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE883]'
- en: 'Which then calls into the JavaScript `dispatchEvent` method we just wrote:'
  id: totrans-3487
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用我们刚刚编写的JavaScript `dispatchEvent`方法：
- en: '[PRE884]'
  id: totrans-3488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE884]'
- en: 'You should now be able to use `postMessage` to send messages between frames,In
    [the iframe demo](https://browser.engineering/examples/example15-iframe.html),
    for example, you should see “Message received from iframe: This is the contents
    of postMessage.” printed to the console. (This particular example uses a same-origin
    `postMessage`. You can test cross-origin locally by starting two local HTTP servers
    on different ports, then changing the URL of the `example15-img.html` iframe document
    to point to the second port.) including cross-origin frames running in different
    `JSContext`s, in a secure way.'
  id: totrans-3489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够使用`postMessage`在框架之间发送消息，例如，在[iframe演示](https://browser.engineering/examples/example15-iframe.html)中，你应该看到“从iframe接收到的消息：这是postMessage的内容。”打印到控制台。（这个特定的例子使用的是同源的`postMessage`。你可以通过在不同的端口上启动两个本地HTTP服务器来测试跨源，然后更改`example15-img.html`
    iframe文档的URL，指向第二个端口。）包括在不同的`JSContext`中运行的跨源框架，以安全的方式进行。
- en: Ads are commonly served with iframes and are big users of the web’s sandboxing,
    embedding, and animation primitives. This means they are a challenging source
    of performance and [user experience](https://en.wikipedia.org/wiki/User_experience)
    problems. For example, ad [analytics](https://en.wikipedia.org/wiki/Web_analytics)
    are important to the ad economy, but involve running a lot of code and measuring
    lots of data. Some web APIs, such as [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API),
    basically exist to make analytics computations more efficient. And, of course,
    ad blockers are probably the most popular [browser extensions](https://en.wikipedia.org/wiki/Browser_extension).
  id: totrans-3490
  prefs: []
  type: TYPE_NORMAL
  zh: 广告通常使用iframe提供，并且是网络沙箱、嵌入和动画原语的大用户。这意味着它们是性能和[用户体验](https://en.wikipedia.org/wiki/User_experience)问题的挑战性来源。例如，广告[分析](https://en.wikipedia.org/wiki/Web_analytics)对于广告经济很重要，但涉及运行大量代码和测量大量数据。一些Web
    API，如[Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)，基本上是为了使分析计算更高效而存在的。当然，广告拦截器可能是最受欢迎的[浏览器扩展](https://en.wikipedia.org/wiki/Browser_extension)。
- en: Isolation and Timing
  id: totrans-3491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离和定时
- en: Iframes add a whole new layer of security challenges atop what we discussed
    in [Chapter 10](security.html). The power to embed one web page into another creates
    a commensurate security risk when the two pages don’t trust each other—both in
    the case of embedding an untrusted page into your own page, and the reverse, where
    an attacker embeds your page into their own, malicious one. In both cases, we
    want to protect your page from any security or privacy risks caused by the other
    frame.Websites can protect themselves from being iframed via the `X-Frame-Options`
    header.
  id: totrans-3492
  prefs: []
  type: TYPE_NORMAL
  zh: Iframe在[第10章](security.html)中讨论的基础上增加了全新的安全挑战。将一个网页嵌入到另一个网页中的能力，当两个页面不信任对方时，就会产生相应的安全风险——无论是将不受信任的页面嵌入到自己的页面中，还是相反，攻击者将你的页面嵌入到他们的恶意页面中。在这两种情况下，我们都希望保护你的页面免受其他框架造成的任何安全或隐私风险。网站可以通过`X-Frame-Options`头防止被iframe。
- en: The starting point is that cross-origin iframes can’t access each other directly
    through JavaScript. That’s good—but what if a bug in the JavaScript engine, like
    a [buffer overrun](https://en.wikipedia.org/wiki/Buffer_overflow), lets an iframe
    circumvent those protections? Unfortunately, bugs like this are common enough
    that browsers have to defend against them. For example, browsers these days run
    frames from different origins in [different operating system processes](https://www.chromium.org/Home/chromium-security/site-isolation/),
    and use operating system features to limit how much access those processes have.
  id: totrans-3493
  prefs: []
  type: TYPE_NORMAL
  zh: 起始点是跨源iframe不能通过JavaScript直接访问彼此。这是好的——但如果JavaScript引擎中的错误，比如一个[缓冲区溢出](https://en.wikipedia.org/wiki/Buffer_overflow)，让iframe绕过这些保护呢？不幸的是，这样的错误很常见，以至于浏览器必须防御它们。例如，现在的浏览器在不同的操作系统进程中运行来自不同源的内容[不同的操作系统进程](https://www.chromium.org/Home/chromium-security/site-isolation/)，并使用操作系统功能来限制这些进程的访问权限。
- en: Other parts of the browser mix content from multiple frames, like our browser’s
    `Tab`-wide display list. That means that a bug in the rasterizer could allow one
    frame to take over the rasterizer and then read data that ultimately came from
    another frame. This might seem like a rather complex attack, but it has happened
    before, so modern browsers use [sandboxing](https://chromium.googlesource.com/chromium/src/+/main/docs/linux/sandboxing.md)
    techniques to prevent it. For example, Chromium can place the rasterizer in its
    own process and use a Linux feature called `seccomp` to limit what system calls
    that process can make. Even if a bug compromised the rasterizer, that rasterizer
    wouldn’t be able to exfiltrate data over the network, preventing private data
    from leaking.
  id: totrans-3494
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的其他部分会混合来自多个框架的内容，例如我们浏览器的`Tab`全屏显示列表。这意味着，如果光栅化器中存在漏洞，一个框架可能会接管光栅化器，然后读取最终来自另一个框架的数据。这听起来可能是一个相当复杂的攻击，但这种情况已经发生过，因此现代浏览器使用[沙箱技术](https://chromium.googlesource.com/chromium/src/+/main/docs/linux/sandboxing.md)来防止此类攻击。例如，Chromium可以将光栅化器放置在其自己的进程中，并使用Linux的一个名为`seccomp`的功能来限制该进程可以做出的系统调用。即使漏洞影响了光栅化器，该光栅化器也无法通过网络泄露数据，从而防止私人数据泄露。
- en: These isolation and sandboxing features may seem “straightforward”, in the same
    sense that the browser thread we added in [Chapter 12](scheduling.html) is “straightforward”.
    In practice, the many browser APIs mean the implementation is full of subtleties
    and ends up being extremely complex. Chromium, for example, took many years to
    ship the first implementation of [*site isolation*](https://www.chromium.org/Home/chromium-security/site-isolation/).
  id: totrans-3495
  prefs: []
  type: TYPE_NORMAL
  zh: 这些隔离和沙箱功能可能看起来“简单”，就像我们在[第12章](scheduling.html)中添加的浏览器线程“简单”一样。实际上，众多的浏览器API意味着实现充满了微妙之处，最终变得极其复杂。例如，Chromium花费了多年时间才发布了[*网站隔离*](https://www.chromium.org/Home/chromium-security/site-isolation/)的第一个实现。
- en: Site isolation has become much more important in recent years, due to the CPU
    cache timing attacks called [*spectre* and *meltdown*](https://meltdownattack.com/).
    In short, these attacks allow an attacker to read arbitrary locations in memory—including
    another frame’s data, if the two frames are in the same process—by measuring the
    time certain CPU operations take. Placing sensitive content in different CPU processes
    (which come with their own memory address spaces) is a good protection against
    these attacks.
  id: totrans-3496
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CPU缓存时间攻击被称为[*spectre*和*meltdown*](https://meltdownattack.com/)，近年来，网站隔离变得尤为重要。简而言之，这些攻击允许攻击者通过测量某些CPU操作所需的时间来读取内存中的任意位置——包括另一个框架的数据，如果两个框架位于同一进程中。将敏感内容放置在不同的CPU进程中（每个进程都有自己的内存地址空间）是防范这些攻击的良好保护措施。
- en: That said, these kinds of *timing attacks* can be subtle, and there are doubtless
    more that haven’t been discovered yet. To try to dull this threat, browsers currently
    prevent access to *high-precision timers* that can provide the accurate timing
    data typically required for timing attacks. For example, browsers reduce the accuracy
    of APIs like `Date.now` or `setTimeout`.
  id: totrans-3497
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，这类*时间攻击*可能很微妙，而且无疑还有更多尚未被发现。为了减轻这种威胁，浏览器目前阻止了对*高精度计时器*的访问，这些计时器可以提供通常用于时间攻击的精确时间数据。例如，浏览器降低了`Date.now`或`setTimeout`等API的精度。
- en: Worse yet, there are browser APIs that don’t seem like timers but can be used
    as such.For example, the [SharedArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)
    API lets two JavaScript threads run concurrently and share memory, which can be
    used to [construct a clock](https://security.stackexchange.com/questions/177033/how-can-sharedarraybuffer-be-used-for-timing-attacks).
    These APIs are useful, so browsers don’t quite want to remove them, but there
    is also no way to make them “less accurate”, since they are not a clock to begin
    with. Browsers now require [certain optional HTTP headers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer#security_requirements)
    to be present in the parent *and* child frames’ HTTP responses in order to allow
    use of `SharedArrayBuffer` in particular, though this is not a perfect solution.
  id: totrans-3498
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，有些浏览器API看起来不像计时器，但可以用作计时器。例如，[SharedArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)
    API 允许两个JavaScript线程并发运行并共享内存，这可以用来[构建时钟](https://security.stackexchange.com/questions/177033/how-can-sharedarraybuffer-be-used-for-timing-attacks)。这些API很有用，所以浏览器并不想完全移除它们，但也没有办法使它们“更不准确”，因为它们本来就不是时钟。现在，浏览器要求在父框架和子框架的HTTP响应中存在[某些可选的HTTP头](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer#security_requirements)，以便允许特别使用`SharedArrayBuffer`，尽管这不是一个完美的解决方案。
- en: The `SharedArrayBuffer` issue caused problems when I [added JavaScript support](https://browserbook.substack.com/p/javascript-in-javascript)
    to the embedded browser widgets on [the book’s website](https://browser.engineering).
    I was using `SharedArrayBuffer` to allow synchronous calls from a `JSContext`
    to the browser, and that required APIs that browsers restrict for security reasons.
    Setting the security headers wouldn’t work, because Chapter 14 embeds a Youtube
    video, and as I’m writing this YouTube doesn’t send those headers. In the end,
    I worked around the issue by not embedding the browser widget and [asking the
    reader](http://browser.engineering/scripts.html#outline) to open a new browser
    window.
  id: totrans-3499
  prefs: []
  type: TYPE_NORMAL
  zh: 当我为[书籍网站](https://browser.engineering)上的嵌入浏览器小部件添加[JavaScript支持](https://browserbook.substack.com/p/javascript-in-javascript)时，`SharedArrayBuffer`问题引起了问题。我正在使用`SharedArrayBuffer`来允许从`JSContext`到浏览器的同步调用，而这需要浏览器出于安全原因限制的API。设置安全头不会起作用，因为第14章嵌入了一个YouTube视频，而当我写这篇文章时，YouTube没有发送这些头。最后，我通过不嵌入浏览器小部件并[要求读者](http://browser.engineering/scripts.html#outline)打开新浏览器窗口来解决这个问题。
- en: Summary
  id: totrans-3500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter introduced how the browser handles embedded content use cases
    like images and iframes. Reiterating the main points:'
  id: totrans-3501
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了浏览器如何处理嵌入内容用例，如图片和iframe。重申主要观点：
- en: Non-HTML *embedded content*—images, video, canvas, iframes, input elements,
    and plugins—can be embedded in a web page.
  id: totrans-3502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非HTML *嵌入内容*——图片、视频、画布、iframe、输入元素和插件——可以嵌入到网页中。
- en: Embedded content comes with its own performance concerns—like image decoding
    time—and necessitates custom optimizations.
  id: totrans-3503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入内容带来了自己的性能问题——如图像解码时间——并需要定制优化。
- en: Iframes are a particularly important kind of embedded content, having over time
    replaced browser plugins as the standard way to easily embed complex content into
    a web page.
  id: totrans-3504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Iframes 是一种特别重要的嵌入内容，随着时间的推移，已经取代了浏览器插件，成为将复杂内容轻松嵌入网页的标准方式。
- en: Iframes introduce all the complexities of the web—rendering, event handling,
    navigation, security—into the browser’s handling of embedded content. However,
    this complexity is justified, because they enable important cross-origin use cases
    like ads, videos, and social media buttons.
  id: totrans-3505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Iframes 将网络的所有复杂性——渲染、事件处理、导航、安全——引入浏览器对嵌入内容的处理中。然而，这种复杂性是合理的，因为它们使得像广告、视频和社交媒体按钮这样的跨源用例成为可能。
- en: And, as we hope you saw in this chapter, none of these features are too difficult
    to implement, though—as you’ll see in the exercises—implementing them well requires
    a lot of attention to detail.
  id: totrans-3506
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，正如我们希望你在本章中看到的，这些功能并不难实现，尽管——正如你将在练习中看到的——实现它们需要很多细节上的关注。
- en: Click [here](widgets/lab15-browser.html) to try this chapter’s browser.
  id: totrans-3507
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[这里](widgets/lab15-browser.html)尝试本章的浏览器。
- en: Outline
  id: totrans-3508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should now
    look something like this:'
  id: totrans-3509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整函数、类和方法集现在应该看起来像这样：
- en: '`COOKIE_JAR` `` class URL: `def __init__(url)` `def request(referrer, payload)`
    `def resolve(url)` `def origin()` `def __str__()` `` `` class Text: `def __init__(text,
    parent)` `def __repr__()` `` `` class Element: `def __init__(tag, attributes,
    parent)` `def __repr__()` `` `def print_tree(node, indent)` `def tree_to_list(tree,
    list)` `def is_focusable(node)` `def get_tabindex(node)` `` class HTMLParser:
    `SELF_CLOSING_TAGS` `HEAD_TAGS` `def __init__(body)` `def parse()` `def get_attributes(text)`
    `def add_text(text)` `def add_tag(tag)` `def implicit_tags(tag)` `def finish()`
    `` `` class CSSParser: `def __init__(s)` `def whitespace()` `def literal(literal)`
    `def word()` `def ignore_until(chars)` `def pair(until)` `def selector()` `def
    body()` `def parse()` `def until_chars(chars)` `def simple_selector()` `def media_query()`
    `` `` class TagSelector: `def __init__(tag)` `def matches(node)` `` `` class DescendantSelector:
    `def __init__(ancestor, descendant)` `def matches(node)` `` `` class PseudoclassSelector:
    `def __init__(pseudoclass, base)` `def matches(node)` `` `FONTS` `def get_font(size,
    weight, style)` `def font(style, zoom)` `def linespace(font)` `NAMED_COLORS` `def
    parse_color(color)` `def parse_blend_mode(blend_mode_str)` `def parse_transition(value)`
    `def parse_transform(transform_str)` `def parse_outline(outline_str)` `def parse_image_rendering(quality)`
    `REFRESH_RATE_SEC` `` class MeasureTime: `def __init__()` `def time(name)` `def
    stop(name)` `def finish()` `` `` class Task: `def __init__(task_code)` `def run()`
    `` `` class TaskRunner: `def __init__(tab)` `def schedule_task(task)` `def set_needs_quit()`
    `def clear_pending_tasks()` `def start_thread()` `def run()` `def handle_quit()`
    `` `DEFAULT_STYLE_SHEET` `INHERITED_PROPERTIES` `def style(node, rules, frame)`
    `def cascade_priority(rule)` `def diff_styles(old_style, new_style)` `` class
    NumericAnimation: `def __init__(old_value, new_value, num_frames)` `def animate()`
    `` `def dpx(css_px, zoom)` `WIDTH, HEIGHT` `HSTEP, VSTEP` `INPUT_WIDTH_PX` `IFRAME_WIDTH_PX,
    IFRAME_HEIGHT_PX` `BLOCK_ELEMENTS` `` class DocumentLayout: `def __init__(node,
    frame)` `def layout(width, zoom)` `def should_paint()` `def paint()` `def paint_effects(cmds)`
    `` `` class BlockLayout: `def __init__(node, parent, previous, frame)` `def layout_mode()`
    `def layout()` `def recurse(node)` `def add_inline_child(node, w, child_class,
    frame, word)` `def new_line()` `def word(node, word)` `def input(node)` `def image(node)`
    `def iframe(node)` `def self_rect()` `def should_paint()` `def paint()` `def paint_effects(cmds)`
    `` `` class LineLayout: `def __init__(node, parent, previous)` `def layout()`
    `def should_paint()` `def paint()` `def paint_effects(cmds)` `` `` class TextLayout:
    `def __init__(node, word, parent, previous)` `def layout()` `def should_paint()`
    `def paint()` `def paint_effects(cmds)` `def self_rect()` `` `` class EmbedLayout:
    `def __init__(node, parent, previous, frame)` `def layout()` `def should_paint()`
    `` `` class InputLayout: `def __init__(node, parent, previous, frame)` `def layout()`
    `def paint()` `def paint_effects(cmds)` `def self_rect()` `` `` class ImageLayout:
    `def __init__(node, parent, previous, frame)` `def layout()` `def paint()` `def
    paint_effects(cmds)` `` `` class IframeLayout: `def __init__(node, parent, previous,
    parent_frame)` `def layout()` `def paint()` `def paint_effects(cmds)` `` `BROKEN_IMAGE`
    `` class PaintCommand: `def __init__(rect)` `` `` class DrawText: `def __init__(x1,
    y1, text, font, color)` `def execute(canvas)` `` `` class DrawRect: `def __init__(rect,
    color)` `def execute(canvas)` `` `` class DrawRRect: `def __init__(rect, radius,
    color)` `def execute(canvas)` `` `` class DrawLine: `def __init__(x1, y1, x2,
    y2, color, thickness)` `def execute(canvas)` `` `` class DrawOutline: `def __init__(rect,
    color, thickness)` `def execute(canvas)` `` `` class DrawCompositedLayer: `def
    __init__(composited_layer)` `def execute(canvas)` `` `` class DrawImage: `def
    __init__(image, rect, quality)` `def execute(canvas)` `` `` class VisualEffect:
    `def __init__(rect, children, node)` `` `` class Blend: `def __init__(opacity,
    blend_mode, node, children)` `def execute(canvas)` `def map(rect)` `def unmap(rect)`
    `def clone(child)` `` `` class Transform: `def __init__(translation, rect, node,
    children)` `def execute(canvas)` `def map(rect)` `def unmap(rect)` `def clone(child)`
    `` `def local_to_absolute(display_item, rect)` `def absolute_bounds_for_obj(obj)`
    `def absolute_to_local(display_item, rect)` `def map_translation(rect, translation,
    reversed)` `def paint_tree(layout_object, display_list)` `def paint_visual_effects(node,
    cmds, rect)` `def paint_outline(node, cmds, rect, zoom)` `def add_parent_pointers(nodes,
    parent)` `` class CompositedLayer: `def __init__(skia_context, display_item)`
    `def can_merge(display_item)` `def add(display_item)` `def composited_bounds()`
    `def absolute_bounds()` `def raster()` `` `SPEECH_FILE` `` class AccessibilityNode:
    `def __init__(node, parent)` `def compute_bounds()` `def build()` `def build_internal(child_node)`
    `def contains_point(x, y)` `def hit_test(x, y)` `def map_to_parent(rect)` `def
    absolute_bounds()` `` `` class FrameAccessibilityNode: `def __init__(node, parent)`
    `def build()` `def hit_test(x, y)` `def map_to_parent(rect)` `` `def speak_text(text)`
    `EVENT_DISPATCH_JS` `SETTIMEOUT_JS` `XHR_ONLOAD_JS` `POST_MESSAGE_DISPATCH_JS`
    `RUNTIME_JS` `` class JSContext: `def __init__(tab, url_origin)` `def run(script,
    code, window_id)` `def add_window(frame)` `def wrap(script, window_id)` `def dispatch_event(type,
    elt, window_id)` `def dispatch_post_message(message, window_id)` `def dispatch_settimeout(handle,
    window_id)` `def dispatch_xhr_onload(out, handle, window_id)` `def dispatch_RAF(window_id)`
    `def throw_if_cross_origin(frame)` `def get_handle(elt)` `def querySelectorAll(selector_text,
    window_id)` `def getAttribute(handle, attr)` `def setAttribute(handle, attr, value,
    window_id)` `def innerHTML_set(handle, s, window_id)` `def style_set(handle, s,
    window_id)` `def XMLHttpRequest_send(...)` `def setTimeout(handle, time, window_id)`
    `def requestAnimationFrame()` `def parent(window_id)` `def postMessage(target_window_id,
    message, origin)` `` `SCROLL_STEP` `` class Frame: `def __init__(tab, parent_frame,
    frame_element)` `def allowed_request(url)` `def load(url, payload)` `def render()`
    `def clamp_scroll(scroll)` `def set_needs_render()` `def set_needs_layout()` `def
    advance_tab()` `def focus_element(node)` `def activate_element(elt)` `def submit_form(elt)`
    `def keypress(char)` `def scrolldown()` `def scroll_to(elt)` `def click(x, y)`
    `` `` class Tab: `def __init__(browser, tab_height)` `def load(url, payload)`
    `def run_animation_frame(scroll)` `def render()` `def get_js(url)` `def allowed_request(url)`
    `def raster(canvas)` `def clamp_scroll(scroll)` `def set_needs_render()` `def
    set_needs_layout()` `def set_needs_paint()` `def set_needs_render_all_frames()`
    `def set_needs_accessibility()` `def scrolldown()` `def click(x, y)` `def go_back()`
    `def submit_form(elt)` `def keypress(char)` `def focus_element(node)` `def activate_element(elt)`
    `def scroll_to(elt)` `def enter()` `def advance_tab()` `def zoom_by(increment)`
    `def reset_zoom()` `def set_dark_mode(val)` `def post_message(message, target_window_id)`
    `` `` class Chrome: `def __init__(browser)` `def tab_rect(i)` `def paint()` `def
    click(x, y)` `def keypress(char)` `def enter()` `def blur()` `def focus_addressbar()`
    `` `` class CommitData: `def __init__(...)` `` `` class Browser: `def __init__()`
    `def schedule_animation_frame()` `def commit(tab, data)` `def render()` `def composite_raster_and_draw()`
    `def composite()` `def get_latest(effect)` `def paint_draw_list()` `def raster_tab()`
    `def raster_chrome()` `def update_accessibility()` `def draw()` `def speak_node(node,
    text)` `def speak_document()` `def set_needs_accessibility()` `def set_needs_animation_frame(tab)`
    `def set_needs_raster_and_draw()` `def set_needs_raster()` `def set_needs_composite()`
    `def set_needs_draw()` `def clear_data()` `def new_tab(url)` `def new_tab_internal(url)`
    `def set_active_tab(tab)` `def schedule_load(url, body)` `def clamp_scroll(scroll)`
    `def handle_down()` `def handle_click(e)` `def handle_key(char)` `def handle_enter()`
    `def handle_tab()` `def handle_hover(event)` `def handle_quit()` `def toggle_dark_mode()`
    `def increment_zoom(increment)` `def reset_zoom()` `def focus_content()` `def
    focus_addressbar()` `def go_back()` `def cycle_tabs()` `def toggle_accessibility()`
    `` `def mainloop(browser)`'
  id: totrans-3510
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-3511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 15-1 *Canvas element*. Implement the [`<canvas>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas)
    element, the 2D aspect of the [`getContext`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext)
    API, and some of the drawing commands on [`CanvasRenderingContext2D`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D).
    Canvas layout is just like an iframe, including its default width and height.
    You should allocate a Skia surface of an appropriate size when `getContext("2d")`
    is called, and implement some of the APIs that draw to the canvas.Note that the
    Canvas APIs raster each drawing command immediately, instead of waiting until
    the rest of the page is rastered. This is called *immediate mode* rendering—as
    opposed to the [*retained mode*](https://en.wikipedia.org/wiki/Retained_mode)
    used by HTML. Immediate mode means the web developer decides when to incur the
    rasterization time. It should be straightforward to translate most API methods
    to their Skia equivalent.
  id: totrans-3512
  prefs: []
  type: TYPE_NORMAL
  zh: 15-1 *画布元素*. 实现了 `<canvas>` 元素，这是 `getContext` API 的 2D 部分，以及 `CanvasRenderingContext2D`
    上的某些绘图命令。Canvas 布局就像一个 iframe，包括其默认的宽度和高度。当调用 `getContext("2d")` 时，你应该分配一个适当大小的
    Skia 表面，并实现一些绘制到画布上的 API。请注意，Canvas API 会立即将每个绘图命令转换为位图，而不是等待整个页面被转换为位图。这被称为 *即时模式*
    渲染——与 HTML 使用的 [*保留模式*](https://en.wikipedia.org/wiki/Retained_mode) 相反。即时模式意味着网络开发者决定何时产生位图化时间。将大多数
    API 方法翻译成 Skia 相当应的方法应该是直截了当的。
- en: '15-2 *Background images*. Elements can have a [`background-image`](https://developer.mozilla.org/en-US/docs/Web/CSS/background-image).
    Implement the basics of this CSS property: a `url(...)` value for the `background-image`
    property. Avoid loading the image if the `background-image` property does not
    actually end up used on any element. For a bigger challenge, also allow the web
    page to set the size of the background image with the [`background-size`](https://developer.mozilla.org/en-US/docs/Web/CSS/background-size)
    CSS property.'
  id: totrans-3513
  prefs: []
  type: TYPE_NORMAL
  zh: 15-2 *背景图片*. 元素可以有 `background-image` 属性。实现这个 CSS 属性的基本功能：为 `background-image`
    属性提供一个 `url(...)` 值。如果 `background-image` 属性实际上没有在任何元素上使用，则避免加载图片。作为一个更大的挑战，还允许网页使用
    `background-size` CSS 属性设置背景图片的大小。
- en: 15-3 *`object-fit`*. Implement the [`object-fit`](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
    CSS property. It determines how the image within an `<img>` element is sized relative
    to its container element. This will require clipping images with a different aspect
    ratio.
  id: totrans-3514
  prefs: []
  type: TYPE_NORMAL
  zh: 15-3 *`object-fit`*. 实现了 `object-fit` CSS 属性。它决定了 `<img>` 元素内的图片相对于其容器元素的大小。这需要剪裁不同宽高比的图片。
- en: 15-4 *Lazy loading*. Downloading images can use quite a bit of data.In the early
    days of the web, computer networks were slow enough that browsers had a user setting
    to disable downloading of images until the user expressly asked for them. While
    browsers default to downloading all images on the page immediately, the [`loading`
    attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#loading)
    on `img` elements can instruct a browser to only download images if they are close
    to the visible area of the page. This kind of optimization is generally called
    [lazy loading](https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading).
    Implement `loading`. Make sure the page is laid out correctly both before and
    after the image finishes loading.
  id: totrans-3515
  prefs: []
  type: TYPE_NORMAL
  zh: 15-4 *懒加载*. 下载图片可能会使用相当多的数据。在互联网的早期，计算机网络足够慢，以至于浏览器有一个用户设置可以禁用图片的下载，直到用户明确请求它们。虽然浏览器默认立即下载页面上的所有图片，但
    `img` 元素上的 `loading` 属性可以指示浏览器仅在图片接近页面可见区域时才下载图片。这种优化通常被称为 [懒加载](https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading)。实现
    `loading`。确保在图片加载完成前后页面布局都是正确的。
- en: 15-5 *Iframe aspect ratio*. Implement the [`aspect-ratio`](https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio)
    CSS property and use it to provide an implicit sizing to iframes and images when
    only one of `width` or `height` is specified (or when the image is not yet loaded,
    if you do Exercise 15-4).
  id: totrans-3516
  prefs: []
  type: TYPE_NORMAL
  zh: 15-5 *Iframe 宽高比*. 实现了 `aspect-ratio` CSS 属性，并使用它为 iframe 和图片提供隐式大小，当只指定了 `width`
    或 `height` 之一时（或者当图片尚未加载，如果你做了 15-4 练习），或者当图片尚未加载时（如果你做了 15-4 练习）。
- en: 15-6 *Image placeholders*. Building on top of lazy loading, implement placeholder
    styling of images that haven’t loaded yet. This is done by setting a 0×0 sizing,
    unless `width` or `height` is specified. Also add support for hiding the “broken
    image” if the `alt` attribute is missing or empty.That’s because if `alt` text
    is provided, the browser can assume the image is important to the meaning of the
    website, and so it should tell the user that they are missing out on some of the
    content if it fails to load. But otherwise, the broken image icon is probably
    just ugly clutter.
  id: totrans-3517
  prefs: []
  type: TYPE_NORMAL
  zh: 15-6 *图像占位符*. 在懒加载的基础上，实现尚未加载的图像的占位符样式。这是通过设置0×0的大小来完成的，除非指定了`width`或`height`。另外，如果`alt`属性缺失或为空，还应添加隐藏“损坏的图像”的支持。这是因为如果提供了`alt`文本，浏览器可以假设图像对网站的意义很重要，因此如果图像加载失败，它应该告诉用户他们错过了一些内容。但否则，损坏的图像图标可能只是丑陋的杂乱。
- en: 15-7 *Media queries*. Implement the [`width`](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/width)
    media query. Make sure it works inside iframes. Also make sure it works even when
    the width of an iframe is changed by its parent frame.
  id: totrans-3518
  prefs: []
  type: TYPE_NORMAL
  zh: 15-7 *媒体查询*. 实现`width`媒体查询。确保它在iframe内部工作。还要确保即使iframe的宽度被其父框架更改，它也能正常工作。
- en: 15-8 *Target origin for `postMessage`*. Implement the `targetOrigin` parameter
    to [`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).
    This parameter is a string which indicates the frame origins that are allowed
    to receive the message.
  id: totrans-3519
  prefs: []
  type: TYPE_NORMAL
  zh: 15-8 *`postMessage`的目标源*. 实现对`postMessage`的`targetOrigin`参数，该参数是一个字符串，表示允许接收消息的框架源。
- en: 15-9 *Multi-frame focus*. In our browser, pressing `Tab` cycles through the
    elements in the focused frame. But this means it’s impossible to access focusable
    elements in other frames by keyboard alone. Fix it to move between frames after
    iterating through all focusable elements in one frame.
  id: totrans-3520
  prefs: []
  type: TYPE_NORMAL
  zh: 15-9 *多框架焦点*. 在我们的浏览器中，按下`Tab`会在当前焦点的框架中循环遍历元素。但这意味着仅通过键盘无法访问其他框架中的可聚焦元素。修复这个问题，以便在遍历完一个框架中所有可聚焦元素后，能够在框架之间切换。
- en: 15-10 *Iframe history*. Ensure that iframes affect browser history. For example,
    if you click on a link inside an iframe, and then hit the back button, it should
    go back inside the iframe. Make sure that this works even when the user clicks
    links in multiple frames in various orders.It’s debatable whether this is a good
    feature of iframes, as it causes a lot of confusion for web developers who embed
    iframes they don’t plan on navigating.
  id: totrans-3521
  prefs: []
  type: TYPE_NORMAL
  zh: 15-10 *Iframe历史记录*. 确保iframe影响浏览器历史记录。例如，如果你在iframe内部点击一个链接，然后点击后退按钮，它应该回到iframe内部。确保即使在用户以不同顺序点击多个框架中的链接时，这也应该正常工作。关于这是否是iframe的好特性，存在争议，因为它会给嵌入iframe但不打算导航的网页开发者带来很多困惑。
- en: '15-11 *Iframes added or removed by script*. The `innerHTML` API can cause iframes
    to be added or removed, but our browser doesn’t load or unload them when this
    happens. Fix this: new iframes should be loaded and old ones unloaded.'
  id: totrans-3522
  prefs: []
  type: TYPE_NORMAL
  zh: 15-11 *脚本添加或删除的iframe*. `innerHTML` API可能导致iframe的添加或删除，但在此发生时，我们的浏览器不会加载或卸载它们。修复这个问题：新的iframe应该被加载，旧的iframe应该被卸载。
- en: 15-12 *`X-Frame-Options`*. Implement [this header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options),
    which disallows a web page from appearing in an iframe.
  id: totrans-3523
  prefs: []
  type: TYPE_NORMAL
  zh: 15-12 *`X-Frame-Options`*. 实现[这个头部](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options)，它禁止网页在iframe中显示。
- en: Reusing Previous Computations
  id: totrans-3524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复使用之前的计算
- en: Chapter 16 of [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-3525
  prefs: []
  type: TYPE_NORMAL
  zh: '[Web浏览器工程](./index.html "目录")的第16章。'
- en: '[Editing Content](#editing-content)'
  id: totrans-3526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编辑内容](#editing-content)'
- en: '[Why Invalidation?](#why-invalidation)'
  id: totrans-3527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为什么需要失效？](#why-invalidation)'
- en: '[Idempotence](#idempotence)'
  id: totrans-3528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[幂等性](#idempotence)'
- en: '[Dependencies](#dependencies)'
  id: totrans-3529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[依赖项](#dependencies)'
- en: '[Protected Fields](#protected-fields)'
  id: totrans-3530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[受保护的字段](#protected-fields)'
- en: '[Recursive Invalidation](#recursive-invalidation)'
  id: totrans-3531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[递归失效](#recursive-invalidation)'
- en: '[Protecting Widths](#protecting-widths)'
  id: totrans-3532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[保护宽度](#protecting-widths)'
- en: '[Widths for Inline Elements](#widths-for-inline-elements)'
  id: totrans-3533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内联元素的宽度](#widths-for-inline-elements)'
- en: '[Invalidating Layout Fields](#invalidating-layout-fields)'
  id: totrans-3534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使布局字段失效](#invalidating-layout-fields)'
- en: '[Protecting Inline Layout](#protecting-inline-layout)'
  id: totrans-3535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[保护内联布局](#protecting-inline-layout)'
- en: '[Skipping No-op Updates](#skipping-no-op-updates)'
  id: totrans-3536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[跳过无操作更新](#skipping-no-op-updates)'
- en: '[Skipping Traversals](#skipping-traversals)'
  id: totrans-3537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[跳过遍历](#skipping-traversals)'
- en: '[Granular Style Invalidation](#granular-style-invalidation)'
  id: totrans-3538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[细粒度样式失效](#granular-style-invalidation)'
- en: '[Analyzing Dependencies](#analyzing-dependencies)'
  id: totrans-3539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[分析依赖项](#analyzing-dependencies)'
- en: '[Summary](#summary)'
  id: totrans-3540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](#summary)'
- en: '[Outline](#outline)'
  id: totrans-3541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大纲](#outline)'
- en: '[Exercises](#exercises)'
  id: totrans-3542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[练习](#exercises)'
- en: Compositing (see Chapter 13) makes animations smoother, but it doesn’t help
    with interactions that affect layout, like text editing or DOM modifications.
    Luckily, we can avoid redundant layout work by treating the layout tree as a kind
    of cache, and only recomputing the parts that change. This *invalidation* technique
    is traditionally complex and bug-prone, but we’ll use a principled approach and
    simple abstractions to make it manageable.
  id: totrans-3543
  prefs: []
  type: TYPE_NORMAL
  zh: 合成（见第13章）使动画更平滑，但它对影响布局的交互（如文本编辑或DOM修改）没有帮助。幸运的是，我们可以通过将布局树视为一种缓存来避免冗余的布局工作，并且只重新计算变化的部分。这种**无效化**技术传统上很复杂且容易出错，但我们将使用一种原则性的方法以及简单的抽象来使其可管理。
- en: Editing Content
  id: totrans-3544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑内容
- en: In Chapter 13, we used compositing to smoothly animate CSS properties like `transform`
    or `opacity`. But we couldn’t animate *layout-inducing* properties like `width`
    or `font-size` this way because they change not only the *display list* but also
    the *layout tree*. And while it’s best to avoid animating layout-inducing properties,
    many user interactions that change the layout tree need to be responsive.
  id: totrans-3545
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13章中，我们使用了合成来平滑地动画化CSS属性，如`transform`或`opacity`。但这种方式无法动画化**布局诱导**属性，如`width`或`font-size`，因为它们不仅改变**显示列表**，也改变**布局树**。虽然最好避免动画化布局诱导属性，但许多改变布局树的用户交互需要做出响应。
- en: One good example is editing text. People type pretty quickly, so even a few
    frames’ delay is distracting. But editing changes the HTML tree and therefore
    the layout tree. Rebuilding the layout tree from scratch, which our browser currently
    does, can be very slow on complex pages. Try, for example, loading [the web version
    of this chapter](https://browser.engineering/invalidation.html) in our browser
    and typing into the input box that appears after this paragraph … You’ll find
    that it is *much* too slow—1.7 seconds just in `render` (see Figure 1)!Trace [here](https://browser.engineering/examples/example16-input-no-optimizations.trace).
  id: totrans-3546
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是编辑文本。人们打字速度很快，所以即使只有几帧的延迟也会分散注意力。但编辑会改变HTML树，因此也会改变布局树。从头开始重建布局树，这是我们浏览器目前所做的那样，在复杂页面上可能会非常慢。例如，尝试在我们的浏览器中加载[本章的网页版本](https://browser.engineering/invalidation.html)，并在本段之后出现的输入框中输入文字……你会发现它非常慢——仅在`render`阶段就用了1.7秒！[在此追踪](https://browser.engineering/examples/example16-input-no-optimizations.trace)。
- en: '![Figure 1: Example of typing without any invalidation optimizations.](img/c651c51ce800919ffd2ab5173bcfe975.png)'
  id: totrans-3547
  prefs: []
  type: TYPE_IMG
  zh: '![图1：无任何无效化优化输入的示例](img/c651c51ce800919ffd2ab5173bcfe975.png)'
- en: 'Figure 1: Example of typing without any invalidation optimizations.'
  id: totrans-3548
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：无任何无效化优化输入的示例。
- en: 'Typing into `input` elements could be special-cased,The `input` element doesn’t
    change size as you type, and the text in the `input` element doesn’t get its own
    layout object, so typing into an `input` element doesn’t really have to induce
    layout, just paint. but there are other text editing APIs that can’t be. For example,
    the `contenteditable` attribute makes any element editable.The `contenteditable`
    attribute can turn any element on any page into a living document. It’s how we
    implemented the “typo” feature for this book: type `Ctrl-E` (or `Cmd-E` on a Mac)
    to turn it on. The source code is [on the website](https://browser.engineering/feedback.js);
    see the `typo_mode` function for the `contenteditable` attribute.'
  id: totrans-3549
  prefs: []
  type: TYPE_NORMAL
  zh: 在`input`元素中输入可以特殊处理，`input`元素在输入时不会改变大小，且`input`元素中的文本不会获得自己的布局对象，因此输入到`input`元素中实际上不需要引起布局，只需绘制即可。但还有其他文本编辑API不能这样做。例如，`contenteditable`属性可以使任何元素可编辑。`contenteditable`属性可以将任何页面上的任何元素变成一个活生生的文档。这就是我们实现这本书“错别字”功能的方式：输入`Ctrl-E`（或在Mac上为`Cmd-E`）来打开它。源代码在[网站上](https://browser.engineering/feedback.js)；查看`contenteditable`属性的`typo_mode`函数。
- en: Click on this *formatted* **text** to edit it, including rich text!
  id: totrans-3550
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此**格式化**的**文本**进行编辑，包括富文本！
- en: Let’s implement the most basic possible version of `contenteditable` in our
    browser—it’s a useful feature and also a good test of invalidation. To begin with,
    we need to make elements with a `contenteditable` property focusable:Actually,
    in real browsers, `contenteditable` can be set to `true` or `false`, and `false`
    is useful in case you want to have a non-editable element inside an editable one.
    But I’m not going to implement that in our browser.
  id: totrans-3551
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中实现最基本可能的`contenteditable`版本——这是一个有用的功能，也是对无效化的良好测试。首先，我们需要使具有`contenteditable`属性的元素可聚焦：实际上，在真实浏览器中，`contenteditable`可以设置为`true`或`false`，而`false`在您想在可编辑元素内部有一个不可编辑的元素时很有用。但我不打算在我们的浏览器中实现这一点。
- en: '[PRE885]'
  id: totrans-3552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE885]'
- en: 'Once we’re focused on an editable node, typing should edit it. A real browser
    would handle cursor movement and all kinds of complications, but I’ll keep it
    simple and just add each character to the last text node in the editable element.
    First we need to find that text node:'
  id: totrans-3553
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们聚焦到一个可编辑节点，键入应该会编辑它。一个真正的浏览器会处理光标移动和所有各种复杂情况，但我会保持简单，只将每个字符添加到可编辑元素中的最后一个文本节点。首先我们需要找到这个文本节点：
- en: '[PRE886]'
  id: totrans-3554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE886]'
- en: 'Note that if the editable element has no text children, we create a new one.
    Then we add the typed character to this element:'
  id: totrans-3555
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果可编辑元素没有文本子元素，我们创建一个新的。然后我们将键入的字符添加到这个元素：
- en: '[PRE887]'
  id: totrans-3556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE887]'
- en: 'This is enough to make editing work, but it’s convenient to also draw a cursor
    to confirm that the element is focused and show where edits will go. Let’s do
    that in `BlockLayout`:'
  id: totrans-3557
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以使编辑工作，但方便起见，也可以绘制一个光标以确认元素已聚焦并显示编辑将去哪里。让我们在`BlockLayout`中这样做：
- en: '[PRE888]'
  id: totrans-3558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE888]'
- en: 'Here, `DrawCursor` is just a wrapper around `DrawLine`:'
  id: totrans-3559
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`DrawCursor`只是`DrawLine`的一个包装器：
- en: '[PRE889]'
  id: totrans-3560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE889]'
- en: 'We might as well also use this wrapper in `InputLayout`:'
  id: totrans-3561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在`InputLayout`中使用这个包装器：
- en: '[PRE890]'
  id: totrans-3562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE890]'
- en: You can now edit the examples on [this chapter’s page](https://browser.engineering/invalidation.html)
    in your browser—but each key stroke will take more than a second, making for a
    frustrating editing experience. So let’s work on speeding that up.
  id: totrans-3563
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在浏览器中编辑[本章页面](https://browser.engineering/invalidation.html)上的示例——但是每个按键都会超过一秒，这使得编辑体验令人沮丧。所以让我们加快这个速度。
- en: Text editing is [exceptionally hard](https://lord.io/text-editing-hates-you-too/)
    if you include tricky concepts like caret affinity (which line the cursor is on,
    if a long line is wrapped in the middle of a word), Unicode handling, [bidirectional
    text](http://unicode.org/faq/bidi.html), and mixing text formatting with editing.
    So it’s a good thing browsers implement all this complexity and hide it behind
    `contenteditable`.
  id: totrans-3564
  prefs: []
  type: TYPE_NORMAL
  zh: 文本编辑如果包含像光标亲和力（如果一行在单词中间被换行，光标位于哪一行）这样的棘手概念，[异常困难](https://lord.io/text-editing-hates-you-too/)，还有Unicode处理、[双向文本](http://unicode.org/faq/bidi.html)以及将文本格式与编辑混合。因此，浏览器实现所有这些复杂性并隐藏在`contenteditable`后面是个好事。
- en: Why Invalidation?
  id: totrans-3565
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要无效化？
- en: 'Fundamentally, the reason editing this page is slow in our browser is that
    it’s pretty big. After all, it’s not handling the keypress that’s slow: appending
    a character to a `Text` node takes almost no time. What takes time is re-rendering
    the whole page afterward.'
  id: totrans-3566
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在我们浏览器中编辑这个页面慢的原因是它相当大。毕竟，处理按键按下并不慢：将一个字符追加到`Text`节点几乎不花时间。花时间的是之后的整个页面重绘。
- en: We want interactions to be fast, even on large, complex pages, so we want re-rendering
    the page to take time proportional to the *size of the change*, and not proportional
    to the *size of the page*. I call this the *principle of incremental performance*,
    and it’s crucial for handling large and complex web applications. Not only does
    it make text editing fast, it also means that developers can think about performance
    one change at a time, without considering the contents of the whole page. Incremental
    performance is therefore necessary for complex applications.
  id: totrans-3567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望交互快速，即使在大型、复杂的页面上也是如此，所以我们希望页面重绘的时间与*更改的大小*成比例，而不是与*页面的大小*成比例。我称之为*增量性能原则*，这对于处理大型和复杂的Web应用至关重要。这不仅使文本编辑变得快速，还意味着开发者可以一次考虑一次性能，而不必考虑整个页面的内容。因此，增量性能对于复杂应用是必要的。
- en: But the principle of incremental performance also really constrains our browser
    implementation. For example, even *traversing* the whole layout tree would take
    time proportional to the whole page, not the change being made, so we can’t even
    afford to do that.
  id: totrans-3568
  prefs: []
  type: TYPE_NORMAL
  zh: 但增量性能的原则也真正限制了我们的浏览器实现。例如，即使*遍历*整个布局树也需要与整个页面成比例的时间，而不是与所做的更改成比例，所以我们甚至负担不起这样做。
- en: 'To achieve incremental performance, we’re going to need to think of the initial
    render and later re-renders differently.While initial and later renders are in
    some ways conceptually different, they’ll use the same code path. Basically, the
    initial render will be one big change from no page to the initial page, while
    later re-renders will handle smaller changes. After all, a page could use `innerHTML`
    to replace the whole page; that would be a big change, and rendering it would
    take time proportional to the whole page, because the change is the size of the
    whole page! The point is: all of these will ultimately use the same code path.
    When the page is first loaded, rendering will take time proportional to the size
    of the page. But we’ll treat that initial render as a cache. Later renders will
    *invalidate* and recompute parts of that cache, taking time proportional to the
    size of the change, but won’t touch most of the page.I’m sure there are all sorts
    of performance improvements possible without implementing the invalidation techniques
    from this chapter, but invalidation is still essential for incremental performance,
    which is a kind of asymptotic guarantee that micro-optimization alone won’t achieve.
    In a real browser, every step of the rendering pipeline needs to be incremental,
    but this chapter focuses on layout.Why layout? Because layout is both important
    and complex enough to demonstrate most of the core challenges and techniques.'
  id: totrans-3569
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现增量性能，我们需要对初始渲染和后续的重新渲染进行不同的思考。虽然初始渲染和后续渲染在某些方面概念上不同，但它们将使用相同的代码路径。基本上，初始渲染将从无页面到初始页面的一个巨大变化，而后续的重新渲染将处理较小的变化。毕竟，一个页面可以使用`innerHTML`来替换整个页面；这将是一个很大的变化，渲染它将花费与整个页面成比例的时间，因为变化的大小就是整个页面的尺寸！关键是：所有这些最终都将使用相同的代码路径。当页面首次加载时，渲染将花费与页面大小成比例的时间。但我们将初始渲染视为缓存。后续的渲染将*失效*并重新计算缓存的部分，花费与变化大小成比例的时间，但不会触及页面的大部分内容。我相信，即使不实现本章中的失效技术，也可能有各种性能改进，但失效对于增量性能仍然是至关重要的，这是一种渐近保证，仅通过微优化是无法实现的。在真实浏览器中，渲染管道的每一步都需要是增量式的，但本章重点在于布局。为什么是布局？因为布局既重要又足够复杂，可以展示大多数核心挑战和技术。
- en: 'The key to this cache-and-invalidate approach will be tracking the effects
    of changes. When one part of the page, like a `style` attribute, changes, other
    things that depend on it, like that element’s size, change as well. So we’ll need
    to construct a detailed *dependency graph*, down to the level of each layout field,
    and use that graph to determine what to recompute. It will be similar to our `needs_style`
    and `needs_layout` flags, scaled way up. Most of this chapter is thus about tracking
    dependencies in the dependency graph, and building abstractions to help us do
    that. To use those abstractions, we’ll need to refactor our layout engine significantly.
    But incrementalizing layout will allow us to skip the two most expensive parts
    of layout: building the layout tree and traversing it to compute layout fields.
    When we’re done, re-layout will take under a millisecond for small changes like
    text editing.'
  id: totrans-3570
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缓存和失效方法的关键将是跟踪变化的影响。当页面的一部分，如`style`属性发生变化时，依赖于它的其他事物，如该元素的大小，也会发生变化。因此，我们需要构建一个详细的*依赖图*，直到每个布局字段的级别，并使用该图来确定需要重新计算的内容。它将类似于我们的`needs_style`和`needs_layout`标志，但规模要大得多。因此，本章的大部分内容都是关于在依赖图中跟踪依赖关系，并构建抽象来帮助我们做到这一点。为了使用这些抽象，我们需要对我们的布局引擎进行重大重构。但增量化布局将允许我们跳过布局的两个最昂贵的部分：构建布局树和遍历它来计算布局字段。当我们完成时，重新布局对于像文本编辑这样的小变化将只需不到一毫秒的时间。
- en: 'The principle of incremental performance is part of what makes browsers a good
    platform. Remember that the web is *declarative*: web pages only concern themselves
    with *describing* how the page looks, and it’s up to the browser to implement
    that description. To us browser engineers, that creates a whole bunch of complexity.
    But think about the web as a whole—it involves not just browser engineers, but
    web developers and users as well. Implementing complex invalidation algorithms
    in the browser lets web developers focus on making more interesting applications
    and gives users a better, more responsive experience. The declarative web makes
    it possible for the invalidation algorithms to be written once and then automatically
    benefit everyone.'
  id: totrans-3571
  prefs: []
  type: TYPE_NORMAL
  zh: 增量性能的原则是使浏览器成为一个良好平台的部分原因。记住，网络是*声明性的*：网页只关心*描述*页面的外观，而浏览器负责实现这种描述。对我们浏览器工程师来说，这创造了一大堆复杂性。但想想整个网络——它不仅涉及浏览器工程师，还涉及网页开发人员和用户。在浏览器中实现复杂的失效算法让网页开发人员能够专注于制作更有趣的应用程序，并为用户提供更好的、更响应式的体验。声明性网络使得失效算法一旦编写就可以自动惠及所有人。
- en: Idempotence
  id: totrans-3572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致性
- en: 'If we want to implement this caching-and-invalidation idea, the first roadblock
    is that our browser rebuilds the layout tree from scratch every time the layout
    phase runs:'
  id: totrans-3573
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要实现这个缓存和失效的想法，第一个障碍是每次布局阶段运行时，我们的浏览器都会从头开始重建布局树：
- en: '[PRE891]'
  id: totrans-3574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE891]'
- en: By starting over with a new `DocumentLayout`, we ignore all of the old layout
    information and start from scratch; we are essentially *invalidating* the whole
    tree. So our first optimization has to be avoiding that, reusing as many layout
    objects as possible. That both saves time allocating memory and makes the caching-and-invalidation
    approach possible by keeping around the old layout information.
  id: totrans-3575
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新开始一个新的`DocumentLayout`，我们忽略了所有的旧布局信息，从头开始；我们实际上是在*使整个树无效*。因此，我们的第一个优化必须避免这一点，尽可能重用布局对象。这样既可以节省分配内存的时间，又可以通过保留旧布局信息来实现缓存和失效的方法。
- en: 'But before jumping right to coding, let’s review how layout objects are created.
    Search your browser code for `Layout`, which all layout class names end with.
    You should see that layout objects are created in just a few places:'
  id: totrans-3576
  prefs: []
  type: TYPE_NORMAL
  zh: 但在直接进入编码之前，让我们回顾一下布局对象是如何创建的。在你的浏览器代码中搜索`Layout`，因为所有布局类名都以它结尾。你应该会看到布局对象只在几个地方被创建：
- en: '`DocumentLayout` objects are created by the `Frame` in `render`;'
  id: totrans-3577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DocumentLayout`对象是在`render`中由`Frame`创建的；'
- en: '`BlockLayout` objects are created by either:'
  id: totrans-3578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlockLayout`对象是由以下任一方式创建的：'
- en: a `DocumentLayout`, in `layout`, or
  id: totrans-3579
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`layout`中的`DocumentLayout`，
- en: a `BlockLayout`, in `layout`;
  id: totrans-3580
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`layout`中的`BlockLayout`；
- en: '`LineLayout` objects are created by `BlockLayout` in `new_line`;'
  id: totrans-3581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LineLayout`对象是在`BlockLayout`的`new_line`方法中创建的；'
- en: all others are created by `BlockLayout` in `add_inline_child`.
  id: totrans-3582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他所有对象都是由`BlockLayout`在`add_inline_child`中创建的。
- en: 'Let’s start with `DocumentLayout`. It’s created in `render`, and its two parameters,
    `nodes` and `self`, are the same every time. This means that identical `DocumentLayout`s
    are created each time.This wouldn’t be true if the `DocumentLayout` constructor
    had side-effects or read global state, but it doesn’t do that. That’s wasteful;
    let’s create the `DocumentLayout` just once, in `load`:'
  id: totrans-3583
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`DocumentLayout`开始。它是在`render`中创建的，并且它的两个参数`nodes`和`self`每次都是相同的。这意味着每次都会创建相同的`DocumentLayout`。如果`DocumentLayout`构造函数有副作用或读取全局状态，那就不会是这样了。但事实上它没有这样做。这是浪费的；让我们只在`load`中创建一次`DocumentLayout`：
- en: '[PRE892]'
  id: totrans-3584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE892]'
- en: 'Moving on, let’s look at where `DocumentLayout` constructs a `BlockLayout`:'
  id: totrans-3585
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`DocumentLayout`在哪里构建一个`BlockLayout`：
- en: '[PRE893]'
  id: totrans-3586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE893]'
- en: 'Once again, the constructor parameters cannot change, so again we can skip
    reconstructing this layout object, like so:'
  id: totrans-3587
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，构造函数参数不能改变，所以我们又可以跳过重建这个布局对象，如下所示：
- en: '[PRE894]'
  id: totrans-3588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE894]'
- en: 'But don’t run your browser with these changes just yet! By reusing layout objects,
    we end up running `layout` multiple times on the same object. That’s not how `layout`
    is intended to work, and it causes all sorts of weird behavior. For example, after
    the `DocumentLayout` creates its child `BlockLayout`, it *appends* it to the `children`
    array:'
  id: totrans-3589
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要立即运行带有这些更改的浏览器！通过重用布局对象，我们最终会在同一个对象上多次运行`layout`。这不是`layout`预期的工作方式，并且会导致各种奇怪的行为。例如，在`DocumentLayout`创建其子`BlockLayout`之后，它会*追加*它到`children`数组中：
- en: '[PRE895]'
  id: totrans-3590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE895]'
- en: But we don’t want to `append` the same child more than once!
  id: totrans-3591
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不想多次`append`同一个子对象！
- en: 'The issue here is called *idempotence*: repeated calls to `layout` shouldn’t
    repeatedly change state. More formally, a function is idempotent if calling it
    twice in a row with the same inputs and dependencies yields the same result. Assigning
    a field is idempotent: assigning the same value for a second time is a no-op.
    But methods like `append` aren’t idempotent.'
  id: totrans-3592
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题被称为*幂等性*：重复调用`layout`不应该重复改变状态。更正式地说，如果一个函数在连续两次使用相同的输入和依赖项调用时产生相同的结果，那么这个函数是幂等的。赋值字段是幂等的：第二次赋值相同的值是一个无操作。但是像`append`这样的方法不是幂等的。
- en: 'We’ll need to fix any non-idempotent method calls. In `DocumentLayout`, we
    can switch from `append` to assignment:'
  id: totrans-3593
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修复任何非幂等的方法调用。在`DocumentLayout`中，我们可以从`append`切换到赋值：
- en: '[PRE896]'
  id: totrans-3594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE896]'
- en: '`BlockLayout` also calls `append` on its `children` array. We can fix that
    by resetting the `children` array in `layout`. I’ll put separate reset code in
    the block and inline cases:'
  id: totrans-3595
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockLayout`也会在其`children`数组上调用`append`。我们可以通过在`layout`中重置`children`数组来修复这个问题。我将在块和内联情况下分别放置单独的重置代码：'
- en: '[PRE897]'
  id: totrans-3596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE897]'
- en: This makes the `BlockLayout`’s `layout` function idempotent because each call
    will start over from a new `children` array.
  id: totrans-3597
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`BlockLayout`的`layout`函数是幂等的，因为每次调用都会从一个新的`children`数组开始。
- en: Before we try running our browser, let’s read through all of the other `layout`
    methods, noting any subroutine calls that might not be idempotent. I found:If
    you’ve being doing exercises throughout this book, there might be more, in which
    case there might be more calls. In any case, the core idea is replacing non-idempotent
    calls with idempotent ones.
  id: totrans-3598
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试运行浏览器之前，让我们阅读所有其他的`layout`方法，注意任何可能不是幂等的子程序调用。我发现：如果你在这本书中一直在做练习，可能会有更多，在这种情况下可能会有更多的调用。无论如何，核心思想是将非幂等调用替换为幂等调用。
- en: In `new_line`, `BlockLayout` will append to its `children` array.
  id: totrans-3599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`new_line`中，`BlockLayout`将向其`children`数组中添加。
- en: In `add_inline_child`, `BlockLayout` will append to the `children` array of
    some `LineLayout` child.
  id: totrans-3600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`add_inline_child`中，`BlockLayout`将向某个`LineLayout`子对象的`children`数组中添加。
- en: In `add_inline_child`, `BlockLayout` will call `get_font`, as will the `TextLayout`
    and `InputLayout` methods.
  id: totrans-3601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`add_inline_child`中，`BlockLayout`会调用`get_font`，`TextLayout`和`InputLayout`方法也是如此。
- en: Basically every layout method calls `dpx`.
  id: totrans-3602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本上每个布局方法都会调用`dpx`。
- en: The `new_line` and `add_inline_child` methods are only called through `layout`,
    which resets the `children` array, so they don’t break idempotency. The `get_font`
    function acts as a cache, so multiple calls return the same font object, maintaining
    idempotency. And `dpx` just does math, so it always returns the same result given
    the same inputs. In other words all of our `layout` methods are now idempotent.
  id: totrans-3603
  prefs: []
  type: TYPE_NORMAL
  zh: '`new_line`和`add_inline_child`方法只通过`layout`调用，这会重置`children`数组，因此它们不会破坏幂等性。`get_font`函数充当缓存，因此多次调用返回相同的字体对象，保持幂等性。而`dpx`只是做数学运算，所以给定相同的输入总是返回相同的结果。换句话说，我们所有的`layout`方法现在都是幂等的。'
- en: It’s therefore safe to call `layout` multiple times on the same object—which
    is exactly what we’re now doing. More generally, since it doesn’t matter *how
    many* times an idempotent function is called, we can *skip redundant calls*! That
    makes idempotency the foundation for the rest of this chapter, which is all about
    skipping redundant work.
  id: totrans-3604
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在同一个对象上多次调用`layout`是安全的——这正是我们现在所做的事情。更普遍地说，由于幂等函数被调用的次数并不重要，我们可以*跳过冗余调用*！这使得幂等性成为本章其余部分的基础，本章全部关于跳过冗余工作。
- en: HTTP also features a [notion of idempotency](https://developer.mozilla.org/en-US/docs/Glossary/Idempotent),
    but that notion is subtly different from the one we’re discussing here because
    HTTP involves both a client and a server. In HTTP, idempotence only covers the
    effects of a request on the server state, not the response. So, for example, requesting
    the same page twice with `GET` might result in different responses (if the page
    has changed) but the request is still idempotent because it didn’t make any change
    to the server. And HTTP idempotence also only covers client-visible state, so
    for example it’s possible that the first `GET` request goes to cache while the
    second doesn’t, or it’s possible that each one adds a separate log entry.
  id: totrans-3605
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP也包含一个[幂等性的概念](https://developer.mozilla.org/en-US/docs/Glossary/Idempotent)，但这个概念与我们在讨论的略有不同，因为HTTP涉及客户端和服务器。在HTTP中，幂等性仅涵盖请求对服务器状态的影响，而不是响应。因此，例如，使用`GET`请求相同的页面两次可能会产生不同的响应（如果页面已更改），但请求仍然是幂等的，因为它没有对服务器造成任何改变。HTTP的幂等性也仅涵盖客户端可见状态，例如，第一个`GET`请求可能进入缓存，而第二个没有，或者每个请求都可能添加一个单独的日志条目。
- en: Dependencies
  id: totrans-3606
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖关系
- en: 'So far, we’re only reusing two layout objects: the `DocumentLayout`, and the
    root `BlockLayout`. Let’s look at the other `BlockLayout`s, created here:'
  id: totrans-3607
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只重用了两个布局对象：`DocumentLayout` 和根 `BlockLayout`。让我们看看这里创建的其他 `BlockLayout`s：
- en: '[PRE898]'
  id: totrans-3608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE898]'
- en: 'This code is a little more complicated than the code that creates the root
    `BlockLayout`: the `child` and `previous` arguments come from `node.children`,
    and that `children` array can change—as a result of `contenteditable` edits or
    `innerHTML` calls.Or any other exercises and extensions that you’ve implemented.
    Moreover, in order to even run this code, the node’s `layout_mode` has to be `block`,
    and `layout_mode` itself also reads the node’s `children`.It also looks at the
    node’s `tag` and the node’s children’s `tag`s, but `tag`s can’t change, so we
    don’t need to think about them as dependencies. In invalidation we care only about
    dependencies that can change. This makes it harder to know when we need to recreate
    the `BlockLayout`s.'
  id: totrans-3609
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比创建根 `BlockLayout` 的代码要复杂一些：`child` 和 `previous` 参数来自 `node.children`，而
    `children` 数组可能会改变——这是由于 `contenteditable` 编辑或 `innerHTML` 调用造成的。或者任何其他你已实现的练习和扩展。此外，为了运行此代码，节点的
    `layout_mode` 必须是 `block`，而 `layout_mode` 本身也读取节点的 `children`。它还检查节点的 `tag` 和节点子节点的
    `tag`s，但 `tag`s 不能改变，所以我们不需要将它们视为依赖项。在无效化过程中，我们只关心可能改变的依赖项。这使得知道何时需要重新创建 `BlockLayout`s
    更加困难。
- en: 'Recall that idempotency means that calling a function again *with the same
    inputs and dependencies* yields the same result. Here, the inputs can change,
    so we can only avoid redundant re-execution *if the node’s `children` field hasn’t
    changed*. So we need a way of knowing whether that `children` field has changed.
    We’re going to use a dirty flag:'
  id: totrans-3610
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，幂等性意味着 *使用相同的输入和依赖项* 再次调用函数会产生相同的结果。在这里，输入可以改变，所以我们只能避免重复执行，如果节点的 `children`
    字段没有改变。因此，我们需要一种方法来知道 `children` 字段是否已更改。我们将使用脏标志：
- en: '[PRE899]'
  id: totrans-3611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE899]'
- en: We’ve seen dirty flags before—like `needs_layout` and `needs_draw`—but layout
    is more complex and we’re going to need to think about dirty flags a bit more
    rigorously.
  id: totrans-3612
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经见过脏标志——比如 `needs_layout` 和 `needs_draw`——但布局更复杂，我们需要更严格地思考脏标志。
- en: 'Every dirty flag *protects* a certain field; this one protects a `BlockLayout`’s
    `children` field. A dirty flag has a certain life cycle: it can be set, checked,
    and reset. The dirty flag starts out `True`, and is set to `True` when an input
    or dependency of the field changes, marking the *protected field* as unusable.
    Then, before using the protected field, the dirty flag must be checked. The flag
    is reset to `False` only when the protected field is recomputed.'
  id: totrans-3613
  prefs: []
  type: TYPE_NORMAL
  zh: 每个脏标志 *保护* 着一个特定的字段；这个标志保护着 `BlockLayout` 的 `children` 字段。脏标志有一个特定的生命周期：它可以被设置、检查和重置。脏标志最初是
    `True`，当字段的输入或依赖项发生变化时，会将其设置为 `True`，标记 *受保护的字段* 为不可用。然后，在使用受保护的字段之前，必须检查脏标志。只有当受保护的字段被重新计算时，标志才会重置为
    `False`。
- en: 'So let’s analyze the `children_dirty` flag in this way. Dirty flags have to
    be set if any *dependencies* of the fields they protect change. In this case,
    the dirty flag protects the `children` field of a `BlockLayout`, which in turn
    depends on the `children` field of the associated `Element`. That means that any
    time an `Element`’s `children` field is modified, we need to set the dirty flag
    for the associated `BlockLayout`:'
  id: totrans-3614
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们这样分析 `children_dirty` 标志。如果它们所保护的字段的任何 *依赖项* 发生变化，则必须设置脏标志。在这种情况下，脏标志保护着
    `BlockLayout` 的 `children` 字段，而这个字段反过来又依赖于相关 `Element` 的 `children` 字段。这意味着每当
    `Element` 的 `children` 字段被修改时，我们都需要为相关的 `BlockLayout` 设置脏标志：
- en: '[PRE900]'
  id: totrans-3615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE900]'
- en: 'Likewise, we need to set the dirty flag any time we edit a `contenteditable`
    element, since that can also affect the `children` of a node:'
  id: totrans-3616
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，每次我们编辑 `contenteditable` 元素时，都需要设置脏标志，因为这也可能影响节点的 `children`：
- en: '[PRE901]'
  id: totrans-3617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE901]'
- en: It’s important that *all* dependencies of the protected field set the dirty
    bit. This can be challenging, since it requires being vigilant about which fields
    depend on which others. But if we do forget to set the dirty bit, we’ll sometimes
    fail to recompute the protected fields, which means we’ll display the page incorrectly.
    Typically these bugs look like unpredictable layout glitches, and they can be
    very hard to debug—so we need to be careful.
  id: totrans-3618
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，*所有* 受保护的字段的依赖项都必须设置脏位。这可能具有挑战性，因为它需要我们警惕哪些字段依赖于哪些其他字段。但如果我们忘记设置脏位，有时会失败地重新计算受保护的字段，这意味着我们将以错误的方式显示页面。通常这些错误看起来像不可预测的布局故障，并且它们可能非常难以调试——因此我们需要小心。
- en: 'Anyway, now that we’re setting the dirty flag, the next step is checking it
    before using the protected field. `BlockLayout` uses its `children` field in three
    places: to recursively call `layout` on all its children, to compute its `height`,
    and to `paint` itself. Let’s add a check in each place:'
  id: totrans-3619
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，现在我们已经设置了脏标志，下一步是在使用受保护的字段之前检查它。`BlockLayout`在其三个地方使用其`children`字段：递归调用所有子项的`layout`，计算其`height`，以及`paint`自身。让我们在每个地方添加一个检查：
- en: '[PRE902]'
  id: totrans-3620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE902]'
- en: It’s tempting to skip these assertions, since they should never be triggered,
    but coding defensively like this catches bugs earlier and makes them easier to
    debug. It’s very easy to invalidate fields in the wrong order, or skip a computation
    when it’s actually important, and you’d rather that trigger a crash rather than
    a subtly incorrect rendering—at least when debugging a toy browser!Real browsers
    prefer not to crash, however—better a slightly wrong page than a browser that
    is crashing all the time. So in release mode browsers turn off these assertions,
    or at least make them not crash the browser.
  id: totrans-3621
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过这些断言很有诱惑力，因为它们永远不会被触发，但像这样进行防御性编码可以更早地捕获错误，并使调试更容易。很容易以错误的顺序无效化字段，或者在实际很重要的时候跳过计算，你更希望它引发崩溃而不是微妙的错误渲染——至少在调试玩具浏览器时是这样！然而，真正的浏览器更喜欢不崩溃——与其崩溃的浏览器，不如有一点点错误的页面。因此，在发布模式下，浏览器关闭这些断言，或者至少让它们不会使浏览器崩溃。
- en: 'Finally, when the field is recomputed we need to reset the dirty flag. Here,
    we reset the flag when we’ve recomputed the `children` array:'
  id: totrans-3622
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当字段重新计算时，我们需要重置脏标志。在这里，我们在重新计算`children`数组时重置标志：
- en: '[PRE903]'
  id: totrans-3623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE903]'
- en: Now that we have all three parts of the dirty flag done, you should be able
    to run your browser and test it on [this chapter’s page](https://browser.engineering/invalidation.html).
    Even when you edit text or call `innerHTML`, you shouldn’t see any assertion failures.
    Work incrementally and test often—it makes debugging easier.
  id: totrans-3624
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了脏标志的所有三个部分，你应该能够运行你的浏览器并在[本章的页面](https://browser.engineering/invalidation.html)上测试它。即使当你编辑文本或调用`innerHTML`时，你也不应该看到任何断言失败。逐步工作并经常测试——这使调试更容易。
- en: 'Now that the `children_dirty` flag works correctly, we can rely on it to avoid
    redundant work. If `children` isn’t dirty, we don’t need to recreate the `BlockLayout`
    children:'
  id: totrans-3625
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由于`children_dirty`标志工作正确，我们可以依赖它来避免冗余工作。如果`children`没有脏，我们不需要重新创建`BlockLayout`子项：
- en: '[PRE904]'
  id: totrans-3626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE904]'
- en: 'If you add a `print` statement inside that inner-most `if`, you’ll see console
    output every time `BlockLayout` children are created. Try that out while editing
    text: it shouldn’t happen at all, and editing will be slightly smoother.'
  id: totrans-3627
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个最内层的`if`语句中添加一个`print`语句，每次创建`BlockLayout`子项时你都会看到控制台输出。在编辑文本时尝试一下：这根本不应该发生，编辑将会稍微平滑一些。
- en: If you’ve heard [Phil Karlton’s saying](https://www.karlton.org/2017/12/naming-things-hard/)
    that “the two hardest problems in computer science are cache invalidation and
    naming things”, you know that managing more and more dirty flags creates increasing
    complexity. Phil worked at Netscape at one point (officially as “[Principal Curmudgeon](https://www.karlton.org/karlton/)”)
    so I like to imagine him saying that quote while talking about layout invalidation.
  id: totrans-3628
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你听说过[Phil Karlton的名言](https://www.karlton.org/2017/12/naming-things-hard/)，即“计算机科学中最难的两个问题是缓存失效和命名事物”，你就知道管理越来越多的脏标志会带来不断增加的复杂性。Phil曾在某个时期在Netscape工作过（官方身份为“[Principal
    Curmudgeon](https://www.karlton.org/karlton/)”），所以我喜欢想象他在谈论布局失效时说出这句话。
- en: Protected Fields
  id: totrans-3629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受保护的字段
- en: Dirty flags like `children_dirty` are the traditional approach to layout invalidation,
    but they have downsides. Using them correctly means paying attention to the dependencies
    between fields and knowing when each field is read from and written to. And it’s
    easy to forget to check or set a dirty flag, which leads to hard-to-find bugs.
    In our simple browser it could probably be done, but a real browser’s layout system
    is much more complex, and mistakes become almost impossible to avoid.
  id: totrans-3630
  prefs: []
  type: TYPE_NORMAL
  zh: 脏标志，如`children_dirty`，是布局无效化的传统方法，但它们有缺点。正确使用它们意味着要注意字段之间的依赖关系，并知道每个字段何时被读取和写入。很容易忘记检查或设置脏标志，这会导致难以发现的错误。在我们的简单浏览器中，这可能可以做到，但真实浏览器的布局系统要复杂得多，错误几乎无法避免。
- en: 'A better approach exists. First of all, let’s try to combine the dirty flag
    and the field it protects into a single object:'
  id: totrans-3631
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一种更好的方法。首先，让我们尝试将脏标志和它所保护的字段合并成一个单一的对象：
- en: '[PRE905]'
  id: totrans-3632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE905]'
- en: 'That clarifies which dirty flag protects which field. Let’s replace our existing
    dirty flag with a `ProtectedField`:'
  id: totrans-3633
  prefs: []
  type: TYPE_NORMAL
  zh: 这澄清了哪个脏标志保护了哪个字段。让我们用`ProtectedField`替换我们现有的脏标志：
- en: '[PRE906]'
  id: totrans-3634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE906]'
- en: 'Next, let’s add methods for each step of the dirty flag life cycle. I’ll say
    that we `mark` a protected field to set its dirty flag:'
  id: totrans-3635
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为脏标志生命周期的每个步骤添加方法。我会说我们`mark`一个受保护的字段来设置其脏标志：
- en: '[PRE907]'
  id: totrans-3636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE907]'
- en: 'Note the early return: marking an already dirty field doesn’t do anything.
    That’ll become relevant later. Now call `mark` in `innerHTML_set` and `keypress`:'
  id: totrans-3637
  prefs: []
  type: TYPE_NORMAL
  zh: 注意早期返回：标记已经脏的字段不会做任何事情。这将在以后变得相关。现在在`innerHTML_set`和`keypress`中调用`mark`：
- en: '[PRE908]'
  id: totrans-3638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE908]'
- en: 'Before “`get`”-ting a `ProtectedField`’s value, let’s check the dirty flag:'
  id: totrans-3639
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取`ProtectedField`的值之前，让我们检查一下脏标志：
- en: '[PRE909]'
  id: totrans-3640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE909]'
- en: 'Now we can use `get` to read the `children` field in `layout` and in lots of
    other places besides:'
  id: totrans-3641
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`get`来读取`layout`中的`children`字段以及许多其他地方：
- en: '[PRE910]'
  id: totrans-3642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE910]'
- en: The nice thing about `get` is that it makes the dirty flag operations automatic,
    and therefore impossible to forget. It also makes the code a little nicer to read.
  id: totrans-3643
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`的好处是它使脏标志操作自动化，因此不可能忘记。它还使代码更容易阅读。'
- en: 'Finally, to reset the dirty flag, let’s make the caller pass in a new value
    when “`set`”-ting the field. This guarantees that the dirty flag and the value
    are updated together:'
  id: totrans-3644
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了重置脏标志，让我们在设置字段时让调用者传入一个新值。这保证了脏标志和值一起更新：
- en: '[PRE911]'
  id: totrans-3645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE911]'
- en: 'Unfortunately, using `set` will require a bit of refactoring. For example,
    in `BlockLayout`, we’ll need to build the children array in a local variable and
    then `set` the `children` field at the end:'
  id: totrans-3646
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用`set`将需要进行一些重构。例如，在`BlockLayout`中，我们需要在局部变量中构建子数组，然后在最后设置`children`字段：
- en: '[PRE912]'
  id: totrans-3647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE912]'
- en: But the benefit is that `set`, much like `get`, automates the dirty flag operations,
    making them hard to mess up. That makes it possible to think about more complex
    and ambitious invalidation algorithms in order to make layout faster.
  id: totrans-3648
  prefs: []
  type: TYPE_NORMAL
  zh: 但好处是`set`，就像`get`一样，自动化了脏标志操作，使得它们很难出错。这使得我们可以考虑更复杂和雄心勃勃的无效化算法，以加快布局速度。
- en: '[Under-invalidation](https://developer.chrome.com/docs/chromium/layoutng/#under-invalidation)
    is the technical name for forgetting to set the dirty flag on a field when you
    change a dependency. It often causes a bug where a particular change needs to
    happen multiple times to finally “take”. In other words, this kind of bug creates
    accidental non-idempotency! These bugs are [hard to find](https://developer.chrome.com/docs/chromium/layoutng/#correctness)
    because they typically only show up if you make a very specific sequence of changes.'
  id: totrans-3649
  prefs: []
  type: TYPE_NORMAL
  zh: '[无效化不足](https://developer.chrome.com/docs/chromium/layoutng/#under-invalidation)是忘记在更改依赖项时设置字段脏标志的技术名称。它通常会导致一个特定的更改需要多次发生才能最终“生效”。换句话说，这种类型的错误会创建意外的非幂等性！这些错误[很难找到](https://developer.chrome.com/docs/chromium/layoutng/#correctness)，因为它们通常只有在进行非常具体的更改序列时才会出现。'
- en: Recursive Invalidation
  id: totrans-3650
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归无效化
- en: 'Let’s leverage the `ProtectedField` class to avoid recreating all of the `LineLayout`s
    and their children every time inline layout happens. It all starts here:'
  id: totrans-3651
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用`ProtectedField`类来避免每次内联布局时都重新创建所有的`LineLayout`及其子元素。一切从这里开始：
- en: '[PRE913]'
  id: totrans-3652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE913]'
- en: 'The `new_line` and `recurse` methods, and the helpers they call like `word`,
    `input`, `iframe`, `image`, and `add_inline_child`, handle line wrapping: they
    check widths, create new lines, and so on. We’d like to skip all that if the `children`
    field isn’t dirty, but this will be a bit more challenging than for block layout
    mode: lots of different fields are read during line wrapping, and the `children`
    field depends on all of them.'
  id: totrans-3653
  prefs: []
  type: TYPE_NORMAL
  zh: '`new_line`和`recurse`方法，以及它们调用的辅助方法如`word`、`input`、`iframe`、`image`和`add_inline_child`处理换行：它们检查宽度、创建新行等等。如果我们想跳过所有这些操作，只要`children`字段不是脏的，但这会比块布局模式更具挑战性：在换行过程中会读取许多不同的字段，而`children`字段依赖于所有这些字段。'
- en: Converting all of those fields into `ProtectedField`s will be a challenging
    project. We’ll take it bit by bit, starting with `zoom`, which almost every method
    reads.
  id: totrans-3654
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些字段转换为`ProtectedField`将是一个具有挑战性的项目。我们将一点一点地完成，从几乎每个方法都读取的`zoom`开始。
- en: 'Zoom is initially set in `DocumentLayout`:'
  id: totrans-3655
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放最初在`DocumentLayout`中设置：
- en: '[PRE914]'
  id: totrans-3656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE914]'
- en: 'Each `BlockLayout` also has its own `zoom` field, which we can protect:'
  id: totrans-3657
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`BlockLayout`都有自己的`zoom`字段，我们可以对其进行保护：
- en: '[PRE915]'
  id: totrans-3658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE915]'
- en: 'However, in `BlockLayout`, the `zoom` value comes from its parent’s `zoom`
    field. We might be tempted to write something like this:'
  id: totrans-3659
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`BlockLayout`中，`zoom`值来自其父元素的`zoom`字段。我们可能会想写一些像这样的东西：
- en: '[PRE916]'
  id: totrans-3660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE916]'
- en: However, recall that with dirty flags we must always think about invalidating
    them (with `mark`), checking them (with `get`), and resetting them (with `set`).
    We’ve added `get` and `set`, but who *marks* the `zoom` dirty flag?Without marking
    them when they change, we will incorrectly skip too much layout work.
  id: totrans-3661
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，记住，在使用脏标志时，我们必须始终考虑使它们无效（使用`mark`），检查它们（使用`get`），以及重置它们（使用`set`）。我们已经添加了`get`和`set`，但谁*标记*`zoom`脏标志？如果没有在它们变化时标记它们，我们将错误地跳过太多的布局工作。
- en: 'We mark a field’s dirty flag when its dependency changes. For example, `innerHTML_set`
    and `keypress` change the HTML tree, which the layout tree’s `children` field
    depends on, so those handlers call `mark` on the `children` field. Since a child’s
    `zoom` field depends on its parents’ `zoom` field, we need to mark all the children
    when the `zoom` field changes. So in `DocumentLayout`, we have to do:'
  id: totrans-3662
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在字段的依赖关系发生变化时标记字段的脏标志。例如，`innerHTML_set`和`keypress`更改了HTML树，布局树的`children`字段依赖于它，因此这些处理程序在`children`字段上调用`mark`。由于子项的`zoom`字段依赖于其父项的`zoom`字段，因此当`zoom`字段发生变化时，我们需要标记所有子项。因此，在`DocumentLayout`中，我们必须做：
- en: '[PRE917]'
  id: totrans-3663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE917]'
- en: 'Similarly, in `BlockLayout`, which has multiple children, we must do:'
  id: totrans-3664
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在具有多个子项的`BlockLayout`中，我们必须做：
- en: '[PRE918]'
  id: totrans-3665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE918]'
- en: 'But now we’re back to manually calling methods and trying to make sure we don’t
    forget a call. What we need is something seamless: `set`-ting a field should automatically
    mark all the fields that depend on it.'
  id: totrans-3666
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们又回到了手动调用方法和试图确保我们不会忘记调用。我们需要的是无缝的：设置字段应该自动标记所有依赖于它的字段。
- en: 'To do that, each `ProtectedField` will need to track all fields that depend
    on it, called its `invalidations`:'
  id: totrans-3667
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，每个`ProtectedField`都需要跟踪所有依赖于它的字段，称为它的`invalidations`：
- en: '[PRE919]'
  id: totrans-3668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE919]'
- en: 'For example, we can add the child’s `zoom` field to its parent’s `zoom` field’s
    `invalidations`:'
  id: totrans-3669
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将子项的`zoom`字段添加到其父项的`zoom`字段的`invalidations`中：
- en: '[PRE920]'
  id: totrans-3670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE920]'
- en: 'Then, to automate the `mark` call, let’s add a `notify` method to mark each
    invalidation:'
  id: totrans-3671
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了自动化`mark`调用，让我们添加一个`notify`方法来标记每个无效化：
- en: '[PRE921]'
  id: totrans-3672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE921]'
- en: 'Then `set` can automatically call `notify`:'
  id: totrans-3673
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`set`可以自动调用`notify`：
- en: '[PRE922]'
  id: totrans-3674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE922]'
- en: 'That’s progress, but it’s still possible to forget to add the invalidation
    in the first place. We can automate it a little further. Think: why *does* the
    child’s `zoom` need to depend on its parent’s? It’s because we `get` the parent’s
    `zoom` when computing the child’s. So adding the invalidation can happen as part
    of `get`! Let’s make a variant of `get` called `read` with a `notify` parameter
    for the field to invalidate if the field being read changes:'
  id: totrans-3675
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有进展的，但仍然有可能忘记最初添加无效化。我们可以进一步自动化它。想想：为什么子项的`zoom`需要依赖于其父项的？这是因为我们在计算子项时获取了父项的`zoom`。因此，添加无效化可以作为`get`的一部分发生！让我们创建一个名为`read`的`get`的变体，它有一个`notify`参数，用于在读取的字段发生变化时使字段无效：
- en: '[PRE923]'
  id: totrans-3676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE923]'
- en: 'Now the `zoom` computation just needs to use `read`, and all of the marking
    and dependency logic will be handled automatically:'
  id: totrans-3677
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`zoom`计算只需要使用`read`，所有标记和依赖逻辑都将自动处理：
- en: '[PRE924]'
  id: totrans-3678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE924]'
- en: 'In fact, this pattern where we just copy our parent’s value is pretty common,
    so let’s add a shortcut for it:'
  id: totrans-3679
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这种我们只是复制父项值的情况相当常见，所以让我们为它添加一个快捷方式：
- en: '[PRE925]'
  id: totrans-3680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE925]'
- en: '`BlockLayout` also reads from the `zoom` field inside the `input`, `image`,
    `iframe`, `word`, and `add_inline_child` methods, which are all part of computing
    the `children` field. In those methods, we can use `read` to both get the zoom
    value and also invalidate the `children` field if the zoom value ever changes:'
  id: totrans-3681
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockLayout`还从`input`、`image`、`iframe`、`word`和`add_inline_child`方法中的`zoom`字段读取，这些都是计算`children`字段的一部分。在这些方法中，我们可以使用`read`来获取缩放值，并在缩放值发生变化时使`children`字段无效：'
- en: '[PRE926]'
  id: totrans-3682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE926]'
- en: Do the same in each of the other methods mentioned above. Also, go and protect
    the `zoom` field on every other layout object type (there are now quite a few!)
    using `copy` in place of writes and `read` in place of `get`s. Run your browser
    and make sure that nothing crashes, even when you increase or decrease the zoom
    level, to make sure you got it right.
  id: totrans-3683
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述提到的每种方法中都要做同样的事情。此外，还要去保护每个其他布局对象类型上的`zoom`字段（现在有很多！）使用`copy`代替写入，使用`read`代替`get`。运行你的浏览器并确保没有任何东西崩溃，即使在增加或减少缩放级别时也是如此，以确保你做对了。
- en: Now—protecting the `zoom` field did not speed our browser up. We’re still copying
    the zoom level around, plus we’re now doing some extra work checking dirty flags
    and updating invalidations. But protecting the `zoom` field means we can invalidate
    `children`, and other fields that depend on it, when the zoom level changes, which
    will help tell us when we have to rebuild `LineLayout` and `TextLayout` elements.
  id: totrans-3684
  prefs: []
  type: TYPE_NORMAL
  zh: 现在——保护`zoom`字段并没有加快我们的浏览器速度。我们仍在复制缩放级别，而且我们现在还要做一些额外的工作来检查脏标志和更新无效化。但是保护`zoom`字段意味着当缩放级别改变时，我们可以使`children`以及其他依赖于它的字段无效，这将帮助我们确定何时需要重建`LineLayout`和`TextLayout`元素。
- en: 'Real browsers don’t use automatic dependency-tracking like `ProtectedField`
    (for now at least). One reason is performance: `ProtectedField` adds lots of objects
    and method calls, and it’s easy to accidentally make performance worse by over-using
    it. It’s also possible to create cascading work by invalidating too many protected
    fields. Finally, most browser engine code bases have a lot of historical code,
    and it takes a lot of time to refactor them to use new approaches.'
  id: totrans-3685
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的浏览器现在不使用像`ProtectedField`这样的自动依赖跟踪（至少目前是这样）。一个原因是性能：`ProtectedField`添加了很多对象和方法调用，并且很容易通过过度使用它而无意中降低性能。也有可能通过使过多的受保护字段无效而创建级联工作。最后，大多数浏览器引擎代码库中有很多历史代码，将它们重构为使用新方法需要花费大量时间。
- en: Protecting Widths
  id: totrans-3686
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护宽度
- en: 'Another field that line wrapping depends on is `width`. Let’s convert that
    to a `ProtectedField`, using the new `read` method along the way. Like `zoom`,
    `width` is initially set in `DocumentLayout`:'
  id: totrans-3687
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个依赖于换行的字段是`width`。让我们将其转换为`ProtectedField`，在过程中使用新的`read`方法。像`zoom`一样，`width`最初在`DocumentLayout`中设置：
- en: '[PRE927]'
  id: totrans-3688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE927]'
- en: 'Then, `BlockLayout` copies it from the parent:'
  id: totrans-3689
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`BlockLayout`从父节点复制它：
- en: '[PRE928]'
  id: totrans-3690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE928]'
- en: 'The `width` field is read during line wrapping. For example, `add_inline_child`
    needs it to determine whether to add a new line. We’ll use `read` to set up that
    dependency:'
  id: totrans-3691
  prefs: []
  type: TYPE_NORMAL
  zh: 在换行时读取`width`字段。例如，`add_inline_child`需要它来确定是否添加新行。我们将使用`read`来设置这种依赖关系：
- en: '[PRE929]'
  id: totrans-3692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE929]'
- en: 'While we’re here, note that the decision for whether or not to add a new line
    also depends on `w`, which is an input to `add_inline_child`. If you look through
    `add_inline_child`’s callers, you’ll see that most of the time, this argument
    just depends on `zoom`, but in `word` it depends on a font object:'
  id: totrans-3693
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里时，请注意，是否添加新行的决定也取决于`w`，它是`add_inline_child`的输入。如果你查看`add_inline_child`的调用者，你会看到大多数情况下，这个参数只依赖于`zoom`，但在`word`中它依赖于一个字体对象：
- en: '[PRE930]'
  id: totrans-3694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE930]'
- en: 'Note that the font depends on the node’s `style`, which can change, for example
    via the `style_set` function. To handle this, we’ll need to protect `style`:'
  id: totrans-3695
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字体依赖于节点的`style`，它可能会改变，例如通过`style_set`函数。为了处理这种情况，我们需要保护`style`：
- en: '[PRE931]'
  id: totrans-3696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE931]'
- en: 'The `style` field is computed in the `style` method, which computes a new `style`
    dictionary over multiple phases. Let’s build that new dictionary in a local variable,
    and `set` it at the end:'
  id: totrans-3697
  prefs: []
  type: TYPE_NORMAL
  zh: '`style`字段在`style`方法中计算，该方法在多个阶段计算一个新的`style`字典。让我们在局部变量中构建这个新字典，并在最后`set`它：'
- en: '[PRE932]'
  id: totrans-3698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE932]'
- en: 'Inside `style`, one code path reads from the parent node’s style. We need to
    mark dependencies in these cases:'
  id: totrans-3699
  prefs: []
  type: TYPE_NORMAL
  zh: 在`style`内部，一个代码路径从父节点样式读取。在这些情况下，我们需要标记依赖关系：
- en: '[PRE933]'
  id: totrans-3700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE933]'
- en: Then `style_set` can mark the `style` field:We would ideally make the `style`
    attribute a protected field, and have the `style` field depend on it, but I’m
    taking a short-cut in the interest of simplicity.
  id: totrans-3701
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`style_set`可以标记`style`字段：我们理想上会制作一个受保护的`style`属性，并让`style`字段依赖于它，但我为了简化起见采取了捷径。
- en: '[PRE934]'
  id: totrans-3702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE934]'
- en: 'Finally, in `word` (and also in similar code in `add_inline_child`) we can
    depend on the `style` field:'
  id: totrans-3703
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`word`（以及`add_inline_child`中的类似代码）中，我们可以依赖于`style`字段：
- en: '[PRE935]'
  id: totrans-3704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE935]'
- en: Make sure all other uses of the `style` field use either `read` or `get`; it
    should be pretty clear which is which.
  id: totrans-3705
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有其他使用`style`字段的操作都使用`read`或`get`；应该很清楚哪个是哪个。
- en: 'We’ve now protected all of the fields read during line wrapping. That means
    the `children` field’s dirty flag now correctly tracks whether line-wrapping can
    be skipped. Let’s make use of that:'
  id: totrans-3706
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经保护了在换行过程中读取的所有字段。这意味着`children`字段的脏标志现在可以正确跟踪是否可以跳过换行。让我们利用这一点：
- en: '[PRE936]'
  id: totrans-3707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE936]'
- en: 'We also need to make sure we now only modify `children` via `set`. That’s a
    problem for `add_inline_child` and `new_line`, which currently `append` to the
    `children` field. There are a couple of possible fixes, but in the interests of
    expediency,Perhaps the nicest design would thread a local `children` variable
    through all of the methods involved in line layout, similar to `tree_to_list`.
    I’m going to use a second, unprotected field, `temp_children`, to build the list
    of children, and then `set` it as the new value of the `children` field at the
    end:'
  id: totrans-3708
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保我们现在只通过 `set` 方法来修改 `children`。这对 `add_inline_child` 和 `new_line` 来说是个问题，因为它们目前是通过
    `append` 方法向 `children` 字段添加内容的。有几个可能的解决方案，但为了方便起见，也许最好的设计是将一个本地的 `children` 变量贯穿于所有涉及行布局的方法中，类似于
    `tree_to_list`。我打算使用第二个不受保护的字段，`temp_children`，来构建子元素列表，然后在最后将其 `set` 为 `children`
    字段的新值：
- en: '[PRE937]'
  id: totrans-3709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE937]'
- en: 'Note that I reset `temp_children` once we’re done with it, to make sure that
    no other part of the code accidentally uses it. This way, `new_line` can modify
    `temp_children`, which will eventually become the value of `children`:'
  id: totrans-3710
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦我们完成了 `temp_children`，我就将其重置，以确保代码的其他部分不会意外地使用它。这样，`new_line` 就可以修改 `temp_children`，它最终将成为
    `children` 的值：
- en: '[PRE938]'
  id: totrans-3711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE938]'
- en: 'You’ll want to do something similar in `add_inline_child`:'
  id: totrans-3712
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 `add_inline_child` 中也想做类似的事情：
- en: '[PRE939]'
  id: totrans-3713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE939]'
- en: 'Thanks to these fixes, our browser now avoids rebuilding any part of the layout
    tree unless it changes, and that should make re-layout somewhat faster. If you’ve
    been going through and adding the appropriate `read` and `get` calls, your browser
    should be close to working. There’s one tricky case: `tree_to_list`, which might
    deal with both protected and unprotected `children` fields. I fixed this with
    a type test:'
  id: totrans-3714
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这些修复，我们的浏览器现在只有在布局树发生变化时才会重建任何部分，这应该会使重新布局变得更快。如果你已经添加了适当的 `read` 和 `get`
    调用，你的浏览器应该接近工作状态。有一个棘手的情况：`tree_to_list`，它可能处理受保护和不受保护的 `children` 字段。我用类型测试修复了这个问题：
- en: '[PRE940]'
  id: totrans-3715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE940]'
- en: With all of these changes made, your browser should work again, and it should
    now skip line layout for most elements.
  id: totrans-3716
  prefs: []
  type: TYPE_NORMAL
  zh: 做了所有这些更改后，你的浏览器应该又能正常工作，并且现在它应该会跳过大多数元素的行布局。
- en: Note that we have quite a few protected fields now, but we only skip recomputing
    `children` based on dirty flags. That’s because recomputing `children` is slow,
    but most other fields are really fast to compute. Checking dirty flags takes time
    and adds code clutter, so we only want to do it when it’s worth it.
  id: totrans-3717
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在有很多受保护的字段，但我们只根据脏标志跳过重新计算 `children`。这是因为重新计算 `children` 很慢，但大多数其他字段计算得非常快。检查脏标志需要时间，并增加了代码的混乱，所以我们只想在值得的时候做这件事。
- en: In real browsers, the layout phase is sometimes split in two, first constructing
    a layout tree and then a separate [fragment tree](https://developer.chrome.com/docs/chromium/renderingng-data-structures/#the_immutable_fragment_tree).This
    book doesn’t separate out the fragment tree because our layout algorithm is simple
    enough not to need it. In Chromium, the fragment tree is immutable, and invalidation
    is done by comparing the previous and new fragment trees instead of by using dirty
    flags, though the effect of that is pretty similar to what this book describes.
  id: totrans-3718
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实浏览器中，布局阶段有时会分成两个部分，首先构建布局树，然后是单独的 [片段树](https://developer.chrome.com/docs/chromium/renderingng-data-structures/#the_immutable_fragment_tree)。这本书没有分离出片段树，因为我们的布局算法足够简单，不需要它。在
    Chromium 中，片段树是不可变的，并且通过比较前一个和新的片段树来进行无效化，尽管这种效果与本书描述的非常相似。
- en: Widths for Inline Elements
  id: totrans-3719
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联元素的宽度
- en: 'At this point, `BlockLayout` has a protected `width` field, but other layout
    object types do not. Let’s fix that, because we’ll need it later. `LineLayout`
    is pretty easy:'
  id: totrans-3720
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`BlockLayout` 有一个受保护的 `width` 字段，但其他布局对象类型没有。让我们修复这个问题，因为我们稍后会需要它。`LineLayout`
    非常简单：
- en: '[PRE941]'
  id: totrans-3721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE941]'
- en: 'In `TextLayout`, we again need to handle `font` (and hence have `width` depend
    on `style`):'
  id: totrans-3722
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TextLayout` 中，我们再次需要处理 `font`（因此宽度依赖于 `style`）：
- en: '[PRE942]'
  id: totrans-3723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE942]'
- en: 'In `EmbedLayout`, we just need to protect the `width` field:'
  id: totrans-3724
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `EmbedLayout` 中，我们只需要保护 `width` 字段：
- en: '[PRE943]'
  id: totrans-3725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE943]'
- en: There’s also a reference to `width` in the `layout` method for computing `x`
    positions. For now you can just use `get` here.
  id: totrans-3726
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算 `x` 位置的 `layout` 方法中也有对 `width` 的引用。现在你在这里可以使用 `get`。
- en: 'Finally, there are the various types of replaced content. In `InputLayout`,
    the width only depends on the zoom level:'
  id: totrans-3727
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有各种替换内容的类型。在 `InputLayout` 中，宽度只取决于缩放级别：
- en: '[PRE944]'
  id: totrans-3728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE944]'
- en: '`IframeLayout` and `ImageLayout` are very similar, with the width depending
    on the zoom level and also the element’s `width` and `height` attributes. So,
    we’ll need to invalidate the `width` field if those attributes are changed from
    JavaScript:'
  id: totrans-3729
  prefs: []
  type: TYPE_NORMAL
  zh: '`IframeLayout`和`ImageLayout`非常相似，宽度取决于缩放级别以及元素的`width`和`height`属性。因此，如果这些属性从JavaScript中更改，我们需要使`width`字段无效：'
- en: '[PRE945]'
  id: totrans-3730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE945]'
- en: Otherwise, `IframeLayout` and `ImageLayout` are handled just like `InputLayout`.
    Search your code to make sure you’re always interacting with `width` via methods
    like `get` and `read`, and check that your browser works, including testing user
    interactions like `contenteditable`.
  id: totrans-3731
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，`IframeLayout`和`ImageLayout`的处理方式与`InputLayout`相同。搜索你的代码以确保你总是通过`get`和`read`等方法与`width`交互，并检查浏览器是否正常工作，包括测试用户交互如`contenteditable`。
- en: The `ProtectedField` class defined here is a type of [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)),
    a programming pattern used in programming languages like [Haskell](https://www.haskell.org/).
    In brief, monads describe ways of connecting steps in a computation, though the
    specifics are [famously confusing](https://wiki.haskell.org/Monad_tutorials_timeline).
    Luckily, in this chapter we don’t really need to think about monads in general,
    just `ProtectedField`.
  id: totrans-3732
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义的`ProtectedField`类是一种[monad](https://en.wikipedia.org/wiki/Monad_(functional_programming))，一种在像[Haskell](https://www.haskell.org/)这样的编程语言中使用的编程模式。简而言之，monads描述了连接计算步骤的方式，尽管具体细节[著名地令人困惑](https://wiki.haskell.org/Monad_tutorials_timeline)。幸运的是，在本章中，我们实际上并不需要考虑monads的一般概念，只需关注`ProtectedField`。
- en: Invalidating Layout Fields
  id: totrans-3733
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使布局字段无效
- en: While we’re here, let’s take a moment to protect all of the other layout fields,
    including `x`, `y`, and `height`. Once we’ve done that, we’ll be ready to talk
    about speeding up layout even further by skipping unnecessary traversals.
  id: totrans-3734
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里时，让我们花点时间保护所有其他布局字段，包括`x`、`y`和`height`。一旦我们完成这些，我们就可以讨论通过跳过不必要的遍历来进一步加快布局速度了。
- en: 'As with `width`, let’s start with `DocumentLayout` and `BlockLayout`. First,
    `x` and `y` positions. In `DocumentLayout`, just use `set`:'
  id: totrans-3735
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`width`一样，让我们从`DocumentLayout`和`BlockLayout`开始。首先，`x`和`y`位置。在`DocumentLayout`中，只需使用`set`：
- en: '[PRE946]'
  id: totrans-3736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE946]'
- en: 'A `BlockLayout`’s `x` position is just its parent’s `x` position, so we can
    just `copy` it over:'
  id: totrans-3737
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockLayout`的`x`位置只是其父元素的`x`位置，所以我们只需将其`copy`过来：'
- en: '[PRE947]'
  id: totrans-3738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE947]'
- en: 'However, the `y` position sometimes refers to the `previous` sibling:'
  id: totrans-3739
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`y`位置有时指的是`previous`兄弟元素：
- en: '[PRE948]'
  id: totrans-3740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE948]'
- en: 'Let’s also do `height`s. For `DocumentLayout`, we just read the child’s height:'
  id: totrans-3741
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也处理`height`。对于`DocumentLayout`，我们只需读取子元素的`height`：
- en: '[PRE949]'
  id: totrans-3742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE949]'
- en: '`BlockLayout` is similar, except it loops over multiple children:'
  id: totrans-3743
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockLayout`类似，但它会遍历多个子元素：'
- en: '[PRE950]'
  id: totrans-3744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE950]'
- en: Note that in this last code block, we first `read` the `children` field, then
    iterate over the list of children and `read` each of their `height` fields. The
    `height` field, unlike the previous layout fields, depends on the children’s fields,
    not the parent’s (see Figure 2).
  id: totrans-3745
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个最后的代码块中，我们首先`read`了`children`字段，然后遍历子元素列表并`read`每个子元素的`height`字段。与之前的布局字段不同，`height`字段依赖于子元素的字段，而不是父元素的字段（见图2）。
- en: '![Figure 2: The dependencies of widths and heights in the layout tree point
    in opposite directions.](img/b73f3133db9158450b51956feb36dbf4.png)'
  id: totrans-3746
  prefs: []
  type: TYPE_IMG
  zh: '![图2：布局树中宽度和高度的依赖关系指向相反方向。](img/b73f3133db9158450b51956feb36dbf4.png)'
- en: 'Figure 2: The dependencies of widths and heights in the layout tree point in
    opposite directions.'
  id: totrans-3747
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：布局树中宽度和高度的依赖关系指向相反方向。
- en: So that’s all the layout fields on `BlockLayout` and `DocumentLayout`. Do go
    through and fix up these layout types’ `paint` methods (and also the `DrawCursor`
    helper)—but note that the browser won’t quite run right now, because the `BlockLayout`
    assumes its children’s `height` fields are protected, but if those fields are
    `LineLayout`s they aren’t. Let’s get to that next.
  id: totrans-3748
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是`BlockLayout`和`DocumentLayout`上的所有布局字段。请仔细检查并修复这些布局类型的`paint`方法（以及`DrawCursor`辅助函数）——但请注意，浏览器现在还不能正常运行，因为`BlockLayout`假设其子元素的`height`字段是受保护的，但如果这些字段是`LineLayout`，则它们不是。让我们继续处理这个问题。
- en: Dirty flags aren’t the only way to achieve incremental performance; another
    option is to keep track of *delta*s. For example, in the [Adapton](http://adapton.org/)
    project, each computation that converts inputs to outputs can also convert input
    deltas to output deltas. [Operational Transform](https://en.wikipedia.org/wiki/Operational_transformation),
    the collaboration technology behind Google Docs, also works using this principle,
    as does [differential dataflow](https://www.microsoft.com/en-us/research/publication/differential-dataflow/)
    in databases. However, dirty flags can be implemented with much less memory overhead,
    which makes them a better fit in browsers.
  id: totrans-3749
  prefs: []
  type: TYPE_NORMAL
  zh: 脏标志不是实现增量性能的唯一方法；另一个选项是跟踪*delta*。例如，在[Adapton](http://adapton.org/)项目中，每个将输入转换为输出的计算也可以将输入delta转换为输出delta。[操作变换](https://en.wikipedia.org/wiki/Operational_transformation)，这是Google
    Docs背后的协作技术，也使用这个原则，数据库中的[微分数据流](https://www.microsoft.com/en-us/research/publication/differential-dataflow/)也是如此。然而，脏标志可以以更少的内存开销实现，这使得它们更适合在浏览器中使用。
- en: Protecting Inline Layout
  id: totrans-3750
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护内联布局
- en: We need to protect `LineLayout`s’, `TextLayout`s’, and `EmbedLayout`s’ fields
    too, and their `layout` methods work a little differently. Yes, each of these
    layout objects has `x`, `y`, and `height` fields, but they also compute `font`,
    `ascent`, and `descent` fields that are used by other layout objects. We’ll have
    to protect all of these. Since we now have quite a bit of `ProtectedField` experience,
    we’ll do all the fields in one go.
  id: totrans-3751
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要保护`LineLayout`、`TextLayout`和`EmbedLayout`的字段，以及它们的`layout`方法工作方式略有不同。是的，每个布局对象都有`x`、`y`和`height`字段，但它们还计算`font`、`ascent`和`descent`字段，这些字段被其他布局对象使用。我们必须保护所有这些。由于我们现在有相当多的`ProtectedField`经验，我们将一次处理所有字段。
- en: 'Let’s start with `TextLayout`:'
  id: totrans-3752
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`TextLayout`开始：
- en: '[PRE951]'
  id: totrans-3753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE951]'
- en: 'We’ll need to compute these fields in `layout`. All of the font-related ones
    are fairly straightforward:'
  id: totrans-3754
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`layout`中计算这些字段。所有与字体相关的字段都相当直接：
- en: '[PRE952]'
  id: totrans-3755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE952]'
- en: Note that I’ve changed `width` to read the `font` field instead of directly
    reading `zoom` and `style`. It *does* look a bit odd to compute `f` repeatedly,
    but remember that each of those `read` calls establishes a dependency for one
    layout field upon another. I like to think of each `f` as being scoped to its
    field’s computation.
  id: totrans-3756
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经将`width`改为读取`font`字段而不是直接读取`zoom`和`style`。重复计算`f`确实看起来有点奇怪，但请记住，每个`read`调用都会在布局字段之间建立依赖关系。我喜欢将每个`f`视为其字段计算的范畴。
- en: 'We also need to compute the *x* position of a `TextLayout`. That can use the
    previous sibling’s font, *x* position, and width:'
  id: totrans-3757
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要计算`TextLayout`的*x*位置。这可以使用前一个兄弟的字体、*x*位置和宽度：
- en: '[PRE953]'
  id: totrans-3758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE953]'
- en: '`EmbedLayout` is basically identical. As for its subclasses, here’s `InputLayout`:'
  id: totrans-3759
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmbedLayout`基本上是相同的。至于其子类，这里有一个`InputLayout`：'
- en: '[PRE954]'
  id: totrans-3760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE954]'
- en: 'And here’s `ImageLayout`; it has an `img_height` field, which I’m going to
    treat as an intermediate step in computing `height` and not protect:'
  id: totrans-3761
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`ImageLayout`；它有一个`img_height`字段，我将将其视为计算`height`的中间步骤，并且不进行保护：
- en: '[PRE955]'
  id: totrans-3762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE955]'
- en: 'Finally, here’s how `IframeLayout` computes its height, which is straightforward:'
  id: totrans-3763
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是`IframeLayout`计算其高度的方法，这是直截了当的：
- en: '[PRE956]'
  id: totrans-3764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE956]'
- en: 'We also need to invalidate the `height` field if the `height` attribute changes:'
  id: totrans-3765
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`height`属性更改时使`height`字段无效：
- en: '[PRE957]'
  id: totrans-3766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE957]'
- en: 'So that covers all of the inline layout objects. All that’s left is `LineLayout`.
    Here are `x` and `y`:'
  id: totrans-3767
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这涵盖了所有内联布局对象。剩下的是`LineLayout`。以下是`x`和`y`：
- en: '[PRE958]'
  id: totrans-3768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE958]'
- en: 'However, `height` is a bit complicated: it computes the maximum ascent and
    descent across all children and uses that to set the `height` and the children’s
    `y`. I think the simplest way to handle this code is to add `ascent` and `descent`
    fields to the `LineLayout` to store the maximum ascent and descent, and then have
    the `height` and the children’s `y` field depend on those.'
  id: totrans-3769
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`height`有点复杂：它计算所有子元素的最大上升和下降，并使用该值设置`height`和子元素的`y`。我认为处理这段代码的最简单方法是向`LineLayout`添加`ascent`和`descent`字段来存储最大上升和下降，然后让`height`和子元素的`y`字段依赖于这些值。
- en: 'Let’s do that, starting with declaring the protected fields:'
  id: totrans-3770
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样做，从声明受保护的字段开始：
- en: '[PRE959]'
  id: totrans-3771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE959]'
- en: 'Then, in `layout`, we’ll first handle the case of no children:'
  id: totrans-3772
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`layout`中，我们首先处理没有子元素的情况：
- en: '[PRE960]'
  id: totrans-3773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE960]'
- en: Note that we don’t need to `read` the `children` field because in `LineLayout`
    it isn’t protected; it’s filled in by `BlockLayout` when the `LineLayout` is created,
    and then never modified.
  id: totrans-3774
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要读取`children`字段，因为在`LineLayout`中它没有被保护；它在创建`LineLayout`时由`BlockLayout`填充，然后不再修改。
- en: 'Next, let’s compute the maximum ascent and descent:'
  id: totrans-3775
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们计算最大上升和下降：
- en: '[PRE961]'
  id: totrans-3776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE961]'
- en: 'Next, we can recompute the `y` position of each child:'
  id: totrans-3777
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以重新计算每个子元素的 `y` 位置：
- en: '[PRE962]'
  id: totrans-3778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE962]'
- en: 'Finally, we recompute the line’s height:'
  id: totrans-3779
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重新计算行的行高：
- en: '[PRE963]'
  id: totrans-3780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE963]'
- en: As a result of these changes, every layout object field is now protected. Just
    like before, make sure all uses of these fields use `read` and `get` and that
    your browser still runs, including during `contenteditable`. You will likely now
    need to fix a few uses of `height` and `y` inside `Frame` and `Tab`, like for
    clamping scroll offsets.
  id: totrans-3781
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些更改，现在每个布局对象字段都受到保护。就像之前一样，确保所有使用这些字段的地方都使用 `read` 和 `get`，并且你的浏览器仍然运行，包括在
    `contenteditable` 期间。你现在可能需要修复 `Frame` 和 `Tab` 内的 `height` 和 `y` 的几个使用，比如用于限制滚动偏移。
- en: Just before writing this section, IThis is Chris speaking. spent *weeks* weeding
    out some under-invalidation bugs in Chrome’s accessibility code. At first, the
    bugs would only occur on certain overloaded automated test machines! It turns
    out that on those machines, the HTML parser would yieldIn a real browser, HTML
    parsing doesn’t happen in one go, but often is broken up into multiple event loop
    tasks. This leads to better web page loading performance, and is the reason you’ll
    often see web pages render only part of the HTML at first when loading large web
    pages (including this book!). more often, triggering different and incorrect rendering
    paths. Deep bugs like this take untold hours to track down, which is why it’s
    so important to use robust abstractions to avoid them in the first place.
  id: totrans-3782
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本节之前，我Chris在说话。花了几周时间清理Chrome的可访问性代码中的某些未充分无效化错误。起初，这些错误只会出现在某些过载的自动化测试机器上！结果发现，在这些机器上，HTML解析器会更频繁地产生，触发不同的和不正确的渲染路径。这样的深层次错误需要难以计数的时问来追踪，这就是为什么从一开始就使用健壮的抽象来避免它们如此重要的原因。
- en: Skipping No-op Updates
  id: totrans-3783
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳过无操作更新
- en: 'We’ve got quite a number of layout fields now, so let’s see how much invalidation
    is actually going on. Add a `print` statement inside the `set` method on `ProtectedField`s
    to see which fields are getting recomputed:'
  id: totrans-3784
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有很多布局字段，让我们看看实际上有多少无效化正在进行。在 `ProtectedField`s 的 `set` 方法内添加一个 `print` 语句，以查看哪些字段正在被重新计算：
- en: '[PRE964]'
  id: totrans-3785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE964]'
- en: The `if` check avoids printing during initial page layout, so it will only show
    how well our invalidation optimizations are working. The fewer prints you see,
    the fewer fields change and the more work we should be able to skip.
  id: totrans-3786
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 检查避免了在初始页面布局期间打印，所以它只会显示我们的无效化优化工作得有多好。你看到的打印越少，字段变化越少，我们应该能够跳过的工怍就越多。'
- en: Try editing some text with `contenteditable` on a large web page (like this
    chapter)—you’ll see a *screenful* of output, thousands of lines of printed nonsense.
    It’s a little hard to understand why, so let’s add a nice printable form for `ProtectedField`s,
    plus a new `name` parameter for debugging purposes:Note that I print the node,
    not the layout object, because layout objects’ printable forms print layout field
    values, which might be dirty and unreadable.
  id: totrans-3787
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在一个大型网页（如本章）上编辑一些带有 `contenteditable` 的文本——你会看到一整屏的输出，数千行打印的无用信息。很难理解为什么会这样，所以让我们为
    `ProtectedField`s 添加一个漂亮的打印表单，以及一个用于调试目的的新 `name` 参数：请注意，我打印的是节点，而不是布局对象，因为布局对象的打印表单会打印布局字段值，这些值可能是不干净的且难以阅读的。
- en: '[PRE965]'
  id: totrans-3788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE965]'
- en: 'Name all of your `ProtectedField`s, like this:'
  id: totrans-3789
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有你的 `ProtectedField`s 命名，就像这样：
- en: '[PRE966]'
  id: totrans-3790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE966]'
- en: 'If you look at your output again, you should now see two phases. First, there’s
    a lot of `style` re-computation:'
  id: totrans-3791
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次查看你的输出，你现在应该看到两个阶段。首先，有很多 `style` 重新计算：
- en: '[PRE967]'
  id: totrans-3792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE967]'
- en: 'Then, we recompute four layout fields repeatedly:'
  id: totrans-3793
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们反复重新计算四个布局字段：
- en: '[PRE968]'
  id: totrans-3794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE968]'
- en: 'Let’s fix these. First, let’s tackle `style`. The reason `style` is being recomputed
    repeatedly is just that we recompute it even if it isn’t dirty. Let’s skip if
    it’s not:'
  id: totrans-3795
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修复这些问题。首先，让我们解决 `style` 的问题。`style` 之所以被反复重新计算，仅仅是因为即使它没有变脏，我们也会重新计算它。如果它没有变脏，就跳过它：
- en: '[PRE969]'
  id: totrans-3796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE969]'
- en: 'There should now be barely any style re-computation at all. But what about
    those layout field re-computations? Why are those happening? Well, the very first
    field being recomputed here is `zoom`, which itself traces back to `DocumentLayout`:'
  id: totrans-3797
  prefs: []
  type: TYPE_NORMAL
  zh: 现在几乎没有任何样式重新计算。但是，那些布局字段重新计算是怎么回事？为什么会发生？嗯，这里首先被重新计算的字段是 `zoom`，它本身追溯到 `DocumentLayout`：
- en: '[PRE970]'
  id: totrans-3798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE970]'
- en: Every time we lay out the page, we `set` the zoom parameter, and we have to
    do that because the user might have zoomed in or out. But every time we `set`
    a field, that notifies every dependant field. The combination of these two things
    means we are recomputing the `zoom` field, and everything that depends on `zoom`,
    on every frame.
  id: totrans-3799
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们布局页面时，我们都会设置`zoom`参数，我们必须这样做，因为用户可能已经放大或缩小。但是，每次我们设置一个字段时，都会通知每个依赖字段。这两者的结合意味着我们在每一帧都会重新计算`zoom`字段以及所有依赖于`zoom`的字段。
- en: 'What makes this all wasteful is that `zoom` usually doesn’t change. So we should
    notify dependants only if the value didn’t change:'
  id: totrans-3800
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切之所以显得浪费，是因为`zoom`通常不会改变。因此，只有在值没有改变的情况下，我们才应该通知依赖项：
- en: '[PRE971]'
  id: totrans-3801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE971]'
- en: 'This change is safe, because if the new value is the same as the old value,
    any downstream computations don’t actually need to change. This small tweak should
    reduce the number of field changes down to the minimum:'
  id: totrans-3802
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改是安全的，因为如果新值与旧值相同，任何下游的计算实际上并不需要改变。这个小调整应该将字段更改的数量减少到最小：
- en: '[PRE972]'
  id: totrans-3803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE972]'
- en: All that’s happening here is recreating the `contenteditable` element’s `children`
    (which we have to do, to incorporate the new text) and checking that its `height`
    didn’t change (necessary in case we wrapped onto more lines).
  id: totrans-3804
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的一切只是重新创建`contenteditable`元素的`children`（我们必须这样做，以包含新文本）并检查其`height`是否没有改变（如果换行是必要的）。
- en: Editing should also now feel snappier—about 0.6 seconds instead of the original
    1.7 (see Figure 3). Better, but still not good:Trace [here](http://browser.engineering/examples/example16-input-reuse-layout-tree.trace).
  id: totrans-3805
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑现在也应该感觉更加流畅——大约0.6秒而不是原来的1.7秒（见图3）。更好，但仍然不够好：[在此处跟踪](http://browser.engineering/examples/example16-input-reuse-layout-tree.trace)。
- en: '![Figure 3: Snappier rendering due to reusing the layout tree.](img/dcc4b88bbf8b1dc0f10a91483d534ae0.png)'
  id: totrans-3806
  prefs: []
  type: TYPE_IMG
  zh: '![图3：由于重用布局树，渲染更加流畅。](img/dcc4b88bbf8b1dc0f10a91483d534ae0.png)'
- en: 'Figure 3: Snappier rendering due to reusing the layout tree.'
  id: totrans-3807
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：由于重用布局树，渲染更加流畅。
- en: The caching and invalidation we’re doing in browser layout has analogs throughout
    computer science. For example, some databases use [incremental view maintenance](https://wiki.postgresql.org/wiki/Incremental_View_Maintenance)
    to cache and update the results of common queries as database entries are added
    or modified. Build systems like [Make](https://en.wikipedia.org/wiki/Make_(software))
    also attempt to recompile only changed objects, and [spreadsheets](https://lord.io/spreadsheets/)
    attempt to recompute only formulas that might have changed. The specific trade-offs
    browsers require may be unusual, but the problems and core algorithms are universal.
  id: totrans-3808
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在浏览器布局中进行的缓存和失效操作在计算机科学中也有类似之处。例如，一些数据库使用[增量视图维护](https://wiki.postgresql.org/wiki/Incremental_View_Maintenance)来缓存和更新数据库条目添加或修改后的常见查询结果。像[Make](https://en.wikipedia.org/wiki/Make_(software))这样的构建系统也试图仅重新编译已更改的对象，而[电子表格](https://lord.io/spreadsheets/)则试图仅重新计算可能已更改的公式。浏览器可能需要的特定权衡可能很特殊，但问题和核心算法是普遍的。
- en: Skipping Traversals
  id: totrans-3809
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳过遍历
- en: Now that all of the layout fields are protected, we can check if any of them
    need to be recomputed by checking their dirty bits. But to check all of those
    dirty bits, we’d need to *visit* every layout object, which can take a long time.
    Instead, we should use dirty bits to minimize the number of layout objects we
    need to visit.
  id: totrans-3810
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的布局字段都被保护起来，我们可以通过检查它们的脏位来确认是否需要重新计算它们。但是，为了检查所有的脏位，我们需要访问每一个布局对象，这可能会花费很长时间。相反，我们应该使用脏位来最小化需要访问的布局对象数量。
- en: 'The basic idea revolves around the question: do we even need to call `layout`
    on a given node? The `layout` method does three things: create child layout objects,
    compute layout properties, and recurse into more calls to `layout`. Those steps
    can be skipped if:'
  id: totrans-3811
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想围绕着这样一个问题：我们是否真的需要在给定的节点上调用`layout`？`layout`方法执行三个操作：创建子布局对象、计算布局属性，以及递归调用更多的`layout`。如果以下步骤可以跳过：
- en: we don’t need to create child layout objects, meaning the `children` field isn’t
    dirty;
  id: totrans-3812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要创建子布局对象，这意味着`children`字段不是脏的；
- en: we don’t need to recompute layout fields, because they aren’t dirty; and
  id: totrans-3813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要重新计算布局字段，因为它们不是脏的；并且
- en: we don’t need to recursively call `layout`.
  id: totrans-3814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要递归调用`layout`。
- en: There’s no dirty flag yet for the last condition, so let’s add one. I’ll call
    it `has_dirty_descendants` because it tracks whether any descendant has a dirty
    `ProtectedField`:In some code bases, you will see these called *ancestor* dirty
    flags instead. It’s the same thing, just following the flow of dirty bits instead
    of the flow of control.
  id: totrans-3815
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个条件，还没有设置脏标志，所以让我们添加一个。我将称之为`has_dirty_descendants`，因为它跟踪是否有任何子代具有脏的`ProtectedField`：在某些代码库中，你会看到这些被称为*祖先*脏标志。这是同一件事，只是遵循脏位流而不是控制流。
- en: '[PRE973]'
  id: totrans-3816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE973]'
- en: Add this to every other kind of layout object, too.
  id: totrans-3817
  prefs: []
  type: TYPE_NORMAL
  zh: 也为其他类型的布局对象添加这个。
- en: Now we need to set the `has_dirty_descendants` flag if any dirty flag is set.
    We can do that with an additional (and optionalIt’s optional because only `ProtectedField`s
    on layout objects need this feature.) `parent` parameter to a `ProtectedField`.
  id: totrans-3818
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要设置`has_dirty_descendants`标志，如果设置了任何脏标志。我们可以通过一个额外的（并且可选的）`parent`参数来实现，这个参数是针对`ProtectedField`的。
- en: '[PRE974]'
  id: totrans-3819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE974]'
- en: 'Make sure to pass this parameter for each `ProtectedField` in each layout object
    type. Here’s `BlockLayout`, for example:'
  id: totrans-3820
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为每个布局对象类型的每个`ProtectedField`传递这个参数。例如，这是`BlockLayout`：
- en: '[PRE975]'
  id: totrans-3821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE975]'
- en: 'Then, whenever `mark` or `notify` is called, we set the descendant bits by
    walking the `parent` chain:'
  id: totrans-3822
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每当调用`mark`或`notify`时，我们通过遍历`parent`链来设置子代位：
- en: '[PRE976]'
  id: totrans-3823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE976]'
- en: Note that the `while` loop exits early if the descendants bit is already set.
    That’s because whoever set *that* bit already set all the ancestors’ descendant
    dirty bits.This optimization is important in real browsers. Without it, repeatedly
    invalidating the same object would walk up the tree to the root repeatedly, violating
    the principle of incremental performance.
  id: totrans-3824
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果子代位已经设置，`while`循环会提前退出。这是因为设置*那个*位的人已经设置了所有祖先的子代脏位。这个优化在真实浏览器中非常重要。没有它，反复使同一对象无效会反复遍历树到根，违反了增量性能的原则。
- en: 'We’ll need to clear the descendant bits after `layout`:'
  id: totrans-3825
  prefs: []
  type: TYPE_NORMAL
  zh: 在`layout`之后，我们需要清除子代位：
- en: '[PRE977]'
  id: totrans-3826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE977]'
- en: 'Now that we have descendant dirty flags, let’s use them to skip `layout`, including
    recursive calls:'
  id: totrans-3827
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了子代脏标志，让我们使用它们来跳过`layout`，包括递归调用：
- en: '[PRE978]'
  id: totrans-3828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE978]'
- en: 'Here, the `layout_needed` method just checks all of the dirty bits:'
  id: totrans-3829
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`layout_needed`方法只是检查所有的脏位：
- en: '[PRE979]'
  id: totrans-3830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE979]'
- en: Do the same for every other type of layout object. In `DocumentLayout`, you
    do need to be a little careful, since it receives the frame width and zoom level
    as an argument; you have to `mark` those fields of `DocumentLayout` if the corresponding
    `Frame` variables change:We need to mark the root layout object’s `width` because
    the `frame_width` is passed into `DocumentLayout`’s `layout` method as the `width`
    parameter. We could have protected the `frame_width` field instead, and then this
    `mark` would happen automatically; I’m skipping that for expediency, but it would
    have been a bit safer.
  id: totrans-3831
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种类型的布局对象都做同样的事情。在`DocumentLayout`中，你需要稍微小心一点，因为它接收帧宽度和缩放级别作为参数；如果相应的`Frame`变量发生变化，你必须`mark``DocumentLayout`的这些字段：我们需要标记根布局对象的`width`，因为`frame_width`被传递到`DocumentLayout`的`layout`方法作为`width`参数。我们本来可以保护`frame_width`字段，然后这个`mark`就会自动发生；我跳过这个是为了方便，但这样会更安全一些。
- en: '[PRE980]'
  id: totrans-3832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE980]'
- en: 'The `zoom` level changes in `Tab`:'
  id: totrans-3833
  prefs: []
  type: TYPE_NORMAL
  zh: '`zoom`级别在`Tab`中改变：'
- en: '[PRE981]'
  id: totrans-3834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE981]'
- en: Skipping unneeded `layout` methods should provide a noticable speed bump, with
    small layouts now taking about 7 ms to update layout and editing now substantially
    smoother.It might also be pretty laggy on large pages due to the composite–raster–draw
    cycle being fairly slow, depending on which exercises you implemented in Chapter
    13.Trace [here](https://browser.engineering/examples/example16-input-skip-traverse.trace).
  id: totrans-3835
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过不必要的`layout`方法应该会提供一个明显的速度提升，现在小型布局现在大约需要7毫秒来更新布局，编辑现在也变得更加平滑。这也可能在大型页面上因为合成-光栅-绘制周期相当慢而显得有些卡顿，这取决于你在第13章中实现了哪些练习。[跟踪这里](https://browser.engineering/examples/example16-input-skip-traverse.trace)。
- en: '![Figure 4: Example after skipping layout traversal.](img/758c5b61c9bc9a091eea9f3855f90d14.png)'
  id: totrans-3836
  prefs: []
  type: TYPE_IMG
  zh: '![图4：跳过布局遍历后的示例。](img/758c5b61c9bc9a091eea9f3855f90d14.png)'
- en: 'Figure 4: Example after skipping layout traversal.'
  id: totrans-3837
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：跳过布局遍历后的示例。
- en: However, Figure 4 shows that `paint` is still slow, and `render` overall is
    still about 230 ms. Making a browser fast requires optimizing everything! I won’t
    implement it, but paint can be made a lot faster too—see Exercise 16-10.
  id: totrans-3838
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，图4显示`paint`仍然很慢，`render`整体仍然大约是230毫秒。使浏览器快速需要优化一切！我不会实现它，但`paint`也可以变得更快——参见练习16-10。
- en: '`ProtectedField` is similar to the [observer pattern](https://en.wikipedia.org/wiki/Observer_pattern),
    where one piece of code runs a callback when a piece of state changes. This pattern
    is [common in UI frameworks](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html).
    Usually these observers *eagerly* recompute dependent results, but our callbacks—`mark`
    and `notify`—simply set a dirty bit to be cleaned up later. That means our invalidation
    algorithm is a kind of [*lazy* observer](https://en.wikipedia.org/wiki/Lazy_evaluation).
    Laziness helps performance by batching updates.'
  id: totrans-3839
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProtectedField`类似于[观察者模式](https://en.wikipedia.org/wiki/Observer_pattern)，其中当某个状态发生变化时，一段代码会运行回调。这种模式在[UI框架](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html)中很常见。通常，这些观察者会**急切地**重新计算依赖的结果，但我们的回调——`mark`和`notify`——只是简单地设置一个脏位以稍后清理。这意味着我们的无效化算法是一种[*懒加载*观察者](https://en.wikipedia.org/wiki/Lazy_evaluation)。懒加载通过批量更新帮助提高性能。'
- en: Granular Style Invalidation
  id: totrans-3840
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 细粒度样式无效化
- en: 'Unfortunately, in the process of adding invalidation, we have inadvertently
    broken smooth animations. Here’s the basic issue: suppose an element’s `opacity`
    or `transform` property changes, for example through JavaScript. That property
    isn’t layout-inducing, so it *should* be animated entirely through compositing.
    However, changing any style property invalidates the `Element`’s `style` field,
    and that in turn invalidates the `children` field, causing the layout tree to
    be rebuilt. That’s no good.'
  id: totrans-3841
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在添加无效化的过程中，我们不慎破坏了平滑动画。基本问题是：假设一个元素的`opacity`或`transform`属性发生变化，例如通过JavaScript。该属性不是布局诱导的，所以它**应该**完全通过合成动画。然而，更改任何样式属性都会使`Element`的`style`字段无效，这反过来又使`children`字段无效，导致布局树被重建。这是不可取的。
- en: 'Ultimately the core problem here is *over*-invalidation caused by `ProtectedField`s
    that are too coarse-grained. The `children` field, for example, doesn’t depend
    on the whole `style` dictionary, just a few font-related fields in it. We need
    `style` to be a dictionary of `ProtectedField`s, not a `ProtectedField` of a dictionary:'
  id: totrans-3842
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这里的核心问题是由于过于粗粒度的`ProtectedField`导致的过度无效化。例如，`children`字段并不依赖于整个`style`字典，而只是其中的一些与字体相关的字段。我们需要`style`成为一个包含`ProtectedField`的字典，而不是一个字典的`ProtectedField`：
- en: '[PRE982]'
  id: totrans-3843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE982]'
- en: 'Make the same change in `Text`. The `CSS_PROPERTIES` dictionary contains each
    CSS property that we support, plus their default value:'
  id: totrans-3844
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Text`中也进行相同的更改。`CSS_PROPERTIES`字典包含我们支持的每个CSS属性及其默认值：
- en: '[PRE983]'
  id: totrans-3845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE983]'
- en: 'When setting the `style` property from JavaScript, I’ll invalidate all of the
    fields by calling a new `dirty_style` function:'
  id: totrans-3846
  prefs: []
  type: TYPE_NORMAL
  zh: 当从JavaScript设置`style`属性时，我将通过调用一个新的`dirty_style`函数来使所有字段无效：
- en: '[PRE984]'
  id: totrans-3847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE984]'
- en: But that’s not all. There is also other code that invalidates style, in particular
    code that can affect a pseudo-class such as `:focus`.
  id: totrans-3848
  prefs: []
  type: TYPE_NORMAL
  zh: 但不仅如此。还有其他代码也会使样式无效，特别是那些可能影响伪类如`:focus`的代码：
- en: '[PRE985]'
  id: totrans-3849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE985]'
- en: 'Similarly, in `style`, we will need to recompute a node’s style if *any* of
    their style properties are dirty:'
  id: totrans-3850
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在`style`中，如果它们的任何样式属性都是脏的，我们都需要重新计算节点的样式：
- en: '[PRE986]'
  id: totrans-3851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE986]'
- en: 'To match the existing code, I’ll make `old_style` and `new_style` just map
    properties to values:'
  id: totrans-3852
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与现有代码匹配，我将使`old_style`和`new_style`仅将属性映射到值：
- en: '[PRE987]'
  id: totrans-3853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE987]'
- en: 'Then, when we resolve inheritance, we specifically have one field of our style
    depend on one field of the parent’s style:'
  id: totrans-3854
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们解决继承问题时，我们特别有一个样式字段依赖于父样式的相应字段：
- en: '[PRE988]'
  id: totrans-3855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE988]'
- en: 'Likewise when resolving percentage font sizes:'
  id: totrans-3856
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在解析百分比字体大小时：
- en: '[PRE989]'
  id: totrans-3857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE989]'
- en: 'Then, once the `new_style` is all computed, we individually set every field
    of the node’s `style`:'
  id: totrans-3858
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦`new_style`全部计算完成，我们分别设置节点`style`的每个字段：
- en: '[PRE990]'
  id: totrans-3859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE990]'
- en: 'Now we just need to update the rest of the browser to use the granular style
    fields. Mostly, this means replacing `style.get()[property]` with `style[property].get()`:'
  id: totrans-3860
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要更新浏览器中的其余部分以使用细粒度的样式字段。大多数情况下，这意味着将`style.get()[property]`替换为`style[property].get()`：
- en: '[PRE991]'
  id: totrans-3861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE991]'
- en: 'However, the `font` method needs a little bit of work. Until now, we’ve read
    the node’s `style` and passed that to `font`:'
  id: totrans-3862
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`font`方法需要一点工作。到目前为止，我们读取了节点的`style`并将其传递给`font`：
- en: '[PRE992]'
  id: totrans-3863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE992]'
- en: 'That won’t work anymore, because now we need to read three different properties
    of `style`. To keep things compact, I’m going to rewrite `font` to pass in the
    field to invalidate as an argument:'
  id: totrans-3864
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不再有效，因为现在我们需要读取`style`的三个不同属性。为了保持紧凑，我将重写`font`以将无效化的字段作为参数传递：
- en: '[PRE993]'
  id: totrans-3865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE993]'
- en: 'Now we can simply pass `self.children` in for the `notify` parameter when requesting
    a font during line breaking:'
  id: totrans-3866
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当请求行中断时的字体时，我们可以简单地传递`self.children`作为`notify`参数：
- en: '[PRE994]'
  id: totrans-3867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE994]'
- en: 'Likewise, we pass in the `font` field if that’s what we’re computing:'
  id: totrans-3868
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们正在计算`font`字段，我们会传递该字段：
- en: '[PRE995]'
  id: totrans-3869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE995]'
- en: Make sure to update all other uses of the `font` method to this new interface.
    This “destination-passing style” is a common way to add invalidation to helper
    methods.
  id: totrans-3870
  prefs: []
  type: TYPE_NORMAL
  zh: 确保更新所有其他`font`方法的用法到这个新接口。这种“传递目的地风格”是向辅助方法添加失效的常见方式。
- en: 'Finally, now that we’ve added granular invalidation to `style`, we can invalidate
    just the animating property when handling animations:'
  id: totrans-3871
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在我们已经为`style`添加了细粒度的失效，因此当处理动画时，我们只需使动画属性失效：
- en: '[PRE996]'
  id: totrans-3872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE996]'
- en: When a property like `opacity` or `transform` is changed, it won’t invalidate
    any layout fields (because these properties don’t affect any layout fields) and
    so animations will once again skip layout entirely.
  id: totrans-3873
  prefs: []
  type: TYPE_NORMAL
  zh: 当像`opacity`或`transform`这样的属性发生变化时，它不会使任何布局字段失效（因为这些属性不会影响任何布局字段），因此动画将再次完全跳过布局。
- en: CSS styles depend on which elements a selector matches, and as the page changes,
    that may also need to be invalidated.Our browser supports so few CSS selectors
    and so few DOM APIs that it wouldn’t make sense to implement such an advanced
    invalidation technique, but for real browsers it is quite important. Browsers
    have clever algorithms to avoid redoing selector matching for every selector on
    the page. For example, Chromium constructs [*invalidation sets*](https://chromium.googlesource.com/chromium/src/+/HEAD/third_party/blink/renderer/core/css/style-invalidation.md?pli=1#)
    for each selector, which tell it which selector-element matches to recheck. New
    selectors such as `:has()` require [more complicated](https://blogs.igalia.com/blee/posts/2023/05/31/how-blink-invalidates-styles-when-has-in-use.html)
    invalidation strategies, but this complexity is necessary for fast re-styles.
  id: totrans-3874
  prefs: []
  type: TYPE_NORMAL
  zh: CSS样式依赖于选择器匹配的元素，当页面发生变化时，这也可能需要失效。我们的浏览器支持的CSS选择器和DOM API如此之少，以至于实现这种高级失效技术是没有意义的，但对于真实浏览器来说，它非常重要。浏览器有巧妙的算法来避免对页面上的每个选择器都重新进行选择器匹配。例如，Chromium为每个选择器构建了[*失效集*](https://chromium.googlesource.com/chromium/src/+/HEAD/third_party/blink/renderer/core/css/style-invalidation.md?pli=1#)，它告诉浏览器哪些选择器-元素匹配需要重新检查。新的选择器，如`:has()`，需要[更复杂的](https://blogs.igalia.com/blee/posts/2023/05/31/how-blink-invalidates-styles-when-has-in-use.html)失效策略，但这种复杂性对于快速重样式是必要的。
- en: Analyzing Dependencies
  id: totrans-3875
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析依赖项
- en: Layout is now pretty fast and correct thanks to the `ProtectedField` abstraction.
    However, because most of our dependencies are established implicitly, by `read`,
    it’s hard to tell which fields will ultimately get invalidated from any given
    operation. That makes it hard to understand which operations are fast and which
    are slow, especially as we add new style and layout features. This *auditability*
    concern happens in real browsers, too. After all, real browsers are millions,
    not thousands, of lines long, and support thousands of CSS properties. Their dependency
    graphs are dramatically more complex than our browser’s.
  id: totrans-3876
  prefs: []
  type: TYPE_NORMAL
  zh: 布局现在由于`ProtectedField`抽象变得相当快且正确。然而，由于我们的大部分依赖都是通过`read`隐式建立的，因此很难判断任何给定操作最终会使哪些字段失效。这使得理解哪些操作快，哪些操作慢变得困难，尤其是在我们添加新的样式和布局功能时。这种*可审计性*问题在真实浏览器中也会发生。毕竟，真实浏览器的代码行数以百万计，支持数千个CSS属性。它们的依赖图比我们的浏览器复杂得多。
- en: We’d therefore like to make it easier to see the dependency graph, though see
    Figure 5 for an idea of the scale of the task. And along the way we can centralize
    *invariants* about the shape of that graph. That will [harden](https://en.wikipedia.org/wiki/Hardening_(computing))
    our browser against accidental bugs in the future and also improve performance.
  id: totrans-3877
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们希望使查看依赖图更容易，尽管请参考图5以了解任务的规模。在这个过程中，我们可以集中处理该图形状的*不变性*。这将使我们的浏览器在未来对意外错误具有更强的抵抗力，并提高性能。
- en: '![Figure 5: A dependency diagram for the layout fields in our browser. Simplified
    though it is, the dependency diagram is already quite complex.](img/afd626487cbe9831c354b377f7180f16.png)'
  id: totrans-3878
  prefs: []
  type: TYPE_IMG
  zh: '![图5：我们浏览器中布局字段的依赖图。虽然简化了，但依赖图已经相当复杂。](img/afd626487cbe9831c354b377f7180f16.png)'
- en: 'Figure 5: A dependency diagram for the layout fields in our browser. Simplified
    though it is, the dependency diagram is already quite complex.'
  id: totrans-3879
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：我们浏览器中布局字段的依赖图。虽然简化了，但依赖图已经相当复杂。
- en: 'An easy first step is explicitly listing the dependencies of each `ProtectedField`.
    We can make this an optional constructor parameter:'
  id: totrans-3880
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的第一步是明确列出每个`ProtectedField`的依赖项。我们可以将其作为一个可选的构造函数参数：
- en: '[PRE997]'
  id: totrans-3881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE997]'
- en: 'Moreover, if the dependencies are passed in the constructor, we can “freeze”
    the `ProtectedField`, so that `read` no longer adds new dependencies, just checks
    that they were declared:'
  id: totrans-3882
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果依赖项在构造函数中传递，我们可以“冻结”`ProtectedField`，这样`read`就不再添加新的依赖项，而只是检查它们是否已声明：
- en: '[PRE998]'
  id: totrans-3883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE998]'
- en: For example, in `DocumentLayout`, we can now be explicit about the fact that
    its fields have no external dependencies, and thus have to be `mark`ed explicitly:I
    didn’t even notice that myself until I wrote this section!
  id: totrans-3884
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`DocumentLayout`中，我们现在可以明确指出其字段没有外部依赖项，因此必须显式地`mark`：
- en: '[PRE999]'
  id: totrans-3885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE999]'
- en: But note that `height` is missing the dependencies parameter. A `DocumentLayout`’s
    height depends on its child’s height, and that child doesn’t exist until `layout`
    is called. “Downward” dependencies like this mean we can’t freeze every `ProtectedField`
    when it’s constructed. But every protected field we freeze makes the dependency
    graph easier to audit.
  id: totrans-3886
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，`height`缺少依赖项参数。`DocumentLayout`的高度取决于其子元素的高度，而这个子元素直到`layout`被调用才存在。“向下”依赖项意味着我们无法在构造时冻结每个`ProtectedField`。但每个我们冻结的保护字段都会使依赖图更容易审计。
- en: 'We can also freeze the `zoom`, `width`, `x`, and `y` fields in `BlockLayout`.
    For `y`, the dependencies differ based on whether or not the layout object has
    a previous sibling:'
  id: totrans-3887
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`BlockLayout`中冻结`zoom`、`width`、`x`和`y`字段。对于`y`，依赖项取决于布局对象是否有前一个兄弟元素：
- en: '[PRE1000]'
  id: totrans-3888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1000]'
- en: We can’t freeze `height` for `BlockLayout`, for the same reason as `DocumentLayout`,
    in the constructor. But we *can* freeze it as soon as the `children` field is
    computed. Let’s add a `set_dependencies` method to do that:This is dynamic, just
    like calls to `read`, but at least we’re centralizing dependencies in one place.
    Plus, listing the dependencies explicitly and then checking them later is a kind
    of [defense in depth](https://en.wikipedia.org/wiki/Defense_in_depth_(computing))
    against invalidation bugs.
  id: totrans-3889
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在构造函数中冻结`BlockLayout`的`height`，原因与`DocumentLayout`相同。但我们可以一旦`children`字段被计算出来就立即冻结它。让我们添加一个`set_dependencies`方法来完成这个任务：这是动态的，就像对`read`的调用一样，但至少我们正在将依赖项集中在一个地方。此外，明确列出依赖项然后在之后检查它们是一种对无效化错误的[深度防御](https://en.wikipedia.org/wiki/Defense_in_depth_(computing))。
- en: '[PRE1001]'
  id: totrans-3890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1001]'
- en: 'Now we can freeze `height` in `DocumentLayout`:'
  id: totrans-3891
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`DocumentLayout`中冻结`height`：
- en: '[PRE1002]'
  id: totrans-3892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1002]'
- en: 'Similarly, in `BlockLayout`:'
  id: totrans-3893
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在`BlockLayout`中：
- en: '[PRE1003]'
  id: totrans-3894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1003]'
- en: 'The other layout objects can also freeze their fields. In `TextLayout`, `EmbedLayout`,
    and its subclasses we can freeze everything:'
  id: totrans-3895
  prefs: []
  type: TYPE_NORMAL
  zh: 其他布局对象也可以冻结它们的字段。在`TextLayout`、`EmbedLayout`及其子类中，我们可以冻结一切：
- en: '[PRE1004]'
  id: totrans-3896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1004]'
- en: 'In `LineLayout`, due to the somewhat complicated way a line is created and
    then laid out, we need to delay freezing `ascent` and `descent` until the first
    time `layout` is called:'
  id: totrans-3897
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LineLayout`中，由于创建和布局行的复杂方式，我们需要在第一次调用`layout`之前延迟冻结`ascent`和`descent`：
- en: '[PRE1005]'
  id: totrans-3898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1005]'
- en: 'The last layout class is `EmbedLayout`. The dependencies there are straightforward
    except for two things: first, just like for `TextLayout`, `x` depends on the previous
    `x` if present, and second, `height` depends on `width` because of aspect ratios:'
  id: totrans-3899
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个布局类是`EmbedLayout`。那里的依赖项很简单，除了两点：首先，就像`TextLayout`一样，如果存在，`x`依赖于前一个`x`，其次，`height`依赖于`width`，因为它们有宽高比：
- en: '[PRE1006]'
  id: totrans-3900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1006]'
- en: 'We can even freeze all of the style fields! The only complication is that `innerHTML`
    changes an element’s parent, so let’s create the style dictionary dynamically.
    Initialize it to `None` in the constructor:'
  id: totrans-3901
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以冻结所有的样式字段！唯一的复杂性在于`innerHTML`会改变元素的父母，所以让我们动态地创建样式字典。在构造函数中将其初始化为`None`：
- en: '[PRE1007]'
  id: totrans-3902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1007]'
- en: 'Then set it the first time `style` is called:'
  id: totrans-3903
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第一次调用`style`时设置它：
- en: '[PRE1008]'
  id: totrans-3904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1008]'
- en: 'Inside `init_style`, we need to freeze the dependencies of each style field.
    That’s easy: only inherited fields have any dependencies:'
  id: totrans-3905
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init_style`内部，我们需要冻结每个样式字段的依赖项。这很简单：只有继承的字段才有任何依赖项：
- en: '[PRE1009]'
  id: totrans-3906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1009]'
- en: By freezing every layout and style field, except `children`, we can get a good
    sense of our browser’s dependency graph just by looking at layout object type
    constructors. That’s nice, and helps us avoid cycles and long dependency chains
    as we add more style and layout features.
  id: totrans-3907
  prefs: []
  type: TYPE_NORMAL
  zh: 通过冻结每个布局和样式字段（除了`children`），我们可以仅通过查看布局对象类型构造函数就获得我们浏览器依赖图的良好感觉。这很好，有助于我们在添加更多样式和布局功能时避免循环和长的依赖链。
- en: But to obtain maximum performance, the kind you would need for a real browser,
    there’s an additional benefit. All these fancy `ProtectedFields` add a lot of
    overhead, mostly because they take up more memory and require more function calls.
    In fact, this chapter likely made your browser quite a bit slower on an *initial*
    page load.For me, it’s about twice as slow. Some of that can be improved by skipping
    `assert`s,If you run Python with the `-O` command-line flag, Python will automatically
    skip `assert`s. but it’s definitely not ideal.
  id: totrans-3908
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了获得最大性能，即真实浏览器所需的性能，还有一个额外的优势。所有这些花哨的`ProtectedField`增加了大量的开销，主要是因为它们占用更多的内存并需要更多的函数调用。实际上，这章可能使你的浏览器在*初始*页面加载时慢了很多。对我来说，它大约慢了两倍。其中一些可以通过跳过`assert`来改进，如果你以`-O`命令行标志运行Python，Python将自动跳过`assert`，但这绝对不是理想的。
- en: Luckily, techniques like compile-time code generation and macros can be used
    to turn `ProtectedField` objects into straight-line code behind the scenes. Setting
    a particular `ProtectedField` can set the dirty bits on statically known invalidations,
    the dirty bits can be inlined into the layout objects, and the `read` function
    can check that the dependency was declared at compile time.Real browsers pull
    tricks like that all the time, in order to be super fast but still maintainable
    and readable. For example, Chromium has a fancy way of [generating optimized code](https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/style/ComputedStyle.md)
    for all of the style properties. Such techniques are beyond the scope of this
    book, but I’ve left exploring it to an advanced exercise.
  id: totrans-3909
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，像编译时代码生成和宏这样的技术可以用来将`ProtectedField`对象转换为幕后直接的代码。设置特定的`ProtectedField`可以设置静态已知失效的脏位，脏位可以内联到布局对象中，而`read`函数可以检查依赖是否在编译时声明。实际浏览器一直在使用这样的技巧，以便超级快速但仍然可维护和可读。例如，Chromium有一种生成所有样式属性优化代码的[花哨方式](https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/style/ComputedStyle.md)。这些技术超出了本书的范围，但我将其留给了高级练习。
- en: Real browsers also use assertions to catch bugs, much like the `ProtectedField`
    abstraction in this chapter. But to avoid slowing down the browser for users,
    non-essential assertions are “compiled out” in the *release build*, which is what
    end-users run. The *debug build* is what browser engineers use when debugging
    or developing new features, and also in automated tests. Debug builds also compile
    in debugging features like [sanitizers](https://firefox-source-docs.mozilla.org/tools/sanitizer/index.html),
    while release builds instead use heavyweight optimizations [like *profile-guided
    optimization*](https://blog.chromium.org/2020/08/chrome-just-got-faster-with-profile.html).
  id: totrans-3910
  prefs: []
  type: TYPE_NORMAL
  zh: 实际浏览器也使用断言来捕获错误，这与本章中提到的`ProtectedField`抽象类似。但为了避免减慢用户的浏览器速度，非必要的断言在*发布构建*中被“编译出去”，这是最终用户运行的内容。*调试构建*是浏览器工程师在调试或开发新功能时使用的，也用于自动化测试。调试构建还会编译进调试功能，如[清理器](https://firefox-source-docs.mozilla.org/tools/sanitizer/index.html)，而发布构建则使用重量级优化[如*配置文件引导优化*](https://blog.chromium.org/2020/08/chrome-just-got-faster-with-profile.html)。
- en: Summary
  id: totrans-3911
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter introduces the concept of partial style and layout through optimized
    cache invalidation. The main takeaways are:'
  id: totrans-3912
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过优化的缓存失效介绍了部分样式和布局的概念。主要的收获是：
- en: Caching and invalidation is a powerful way to speed up key browser interactions,
    and is therefore an essential technique in real browsers.
  id: totrans-3913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存和失效是加快关键浏览器交互的强大方式，因此是真实浏览器中的一项基本技术。
- en: Making rendering idempotent allows us to skip redundant work while guaranteeing
    that the page will look the same.
  id: totrans-3914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使渲染具有幂等性允许我们在保证页面外观相同的同时跳过冗余工作。
- en: 'A good browser aims for the principle of incremental performance: the cost
    of a change should be proportional to the size of the change, not the size of
    the page as a whole.'
  id: totrans-3915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的浏览器追求增量性能的原则：变化的成本应该与变化的大小成比例，而不是整个页面的大小。
- en: Cache invalidation is difficult and error-prone, and justifies careful abstractions
    like `ProtectedField`.
  id: totrans-3916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存失效既困难又容易出错，这证明了像`ProtectedField`这样的谨慎抽象的必要性。
- en: Invalidation can be used to skip allocation, computation, and even traversals
    of objects.
  id: totrans-3917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失效可以用来跳过分配、计算，甚至对象的遍历。
- en: Click [here](widgets/lab16-browser.html) to try this chapter’s browser.
  id: totrans-3918
  prefs: []
  type: TYPE_NORMAL
  zh: 点击[这里](widgets/lab16-browser.html)尝试本章的浏览器。
- en: Outline
  id: totrans-3919
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'The complete set of functions, classes, and methods in our browser should now
    look something like this:'
  id: totrans-3920
  prefs: []
  type: TYPE_NORMAL
  zh: 我们浏览器中的完整函数、类和方法集现在看起来可能像这样：
- en: '`COOKIE_JAR` `` class URL: `def __init__(url)` `def request(referrer, payload)`
    `def resolve(url)` `def origin()` `def __str__()` `` `` class Text: `def __init__(text,
    parent)` `def __repr__()` `` `` class Element: `def __init__(tag, attributes,
    parent)` `def __repr__()` `` `def print_tree(node, indent)` `def tree_to_list(tree,
    list)` `def is_focusable(node)` `def get_tabindex(node)` `` class HTMLParser:
    `SELF_CLOSING_TAGS` `HEAD_TAGS` `def __init__(body)` `def parse()` `def get_attributes(text)`
    `def add_text(text)` `def add_tag(tag)` `def implicit_tags(tag)` `def finish()`
    `` `` class CSSParser: `def __init__(s)` `def whitespace()` `def literal(literal)`
    `def word()` `def ignore_until(chars)` `def pair(until)` `def selector()` `def
    body()` `def parse()` `def until_chars(chars)` `def simple_selector()` `def media_query()`
    `` `` class TagSelector: `def __init__(tag)` `def matches(node)` `` `` class DescendantSelector:
    `def __init__(ancestor, descendant)` `def matches(node)` `` `` class PseudoclassSelector:
    `def __init__(pseudoclass, base)` `def matches(node)` `` `FONTS` `def get_font(size,
    weight, style)` `def font(css_style, zoom, notify)` `def linespace(font)` `NAMED_COLORS`
    `def parse_color(color)` `def parse_blend_mode(blend_mode_str)` `def parse_transition(value)`
    `def parse_transform(transform_str)` `def parse_outline(outline_str)` `def parse_image_rendering(quality)`
    `REFRESH_RATE_SEC` `` class MeasureTime: `def __init__()` `def time(name)` `def
    stop(name)` `def finish()` `` `` class Task: `def __init__(task_code)` `def run()`
    `` `` class TaskRunner: `def __init__(tab)` `def schedule_task(task)` `def set_needs_quit()`
    `def clear_pending_tasks()` `def start_thread()` `def run()` `def handle_quit()`
    `` `DEFAULT_STYLE_SHEET` `CSS_PROPERTIES` `INHERITED_PROPERTIES` `def init_style(node)`
    `def style(node, rules, frame)` `def cascade_priority(rule)` `def diff_styles(old_style,
    new_style)` `` class NumericAnimation: `def __init__(old_value, new_value, num_frames)`
    `def animate()` `` `def dirty_style(node)` `` class ProtectedField: `def __init__(obj,
    name, parent, dependencies, invalidations)` `def set_dependencies(dependencies)`
    `def set_ancestor_dirty_bits()` `def mark()` `def notify()` `def set(value)` `def
    get()` `def read(notify)` `def copy(field)` `def __repr__()` `` `def dpx(css_px,
    zoom)` `WIDTH, HEIGHT` `HSTEP, VSTEP` `INPUT_WIDTH_PX` `IFRAME_WIDTH_PX, IFRAME_HEIGHT_PX`
    `BLOCK_ELEMENTS` `` class DocumentLayout: `def __init__(node, frame)` `def layout(width,
    zoom)` `def should_paint()` `def paint()` `def paint_effects(cmds)` `def layout_needed()`
    `` `` class BlockLayout: `def __init__(node, parent, previous, frame)` `def layout_mode()`
    `def layout()` `def recurse(node)` `def add_inline_child(node, w, child_class,
    frame, word)` `def new_line()` `def word(node, word)` `def input(node)` `def image(node)`
    `def iframe(node)` `def self_rect()` `def should_paint()` `def paint()` `def paint_effects(cmds)`
    `def layout_needed()` `` `` class LineLayout: `def __init__(node, parent, previous)`
    `def layout()` `def should_paint()` `def paint()` `def paint_effects(cmds)` `def
    layout_needed()` `` `` class TextLayout: `def __init__(node, word, parent, previous)`
    `def layout()` `def should_paint()` `def paint()` `def paint_effects(cmds)` `def
    self_rect()` `def layout_needed()` `` `` class EmbedLayout: `def __init__(node,
    parent, previous, frame)` `def layout()` `def should_paint()` `def layout_needed()`
    `` `` class InputLayout: `def __init__(node, parent, previous, frame)` `def layout()`
    `def paint()` `def paint_effects(cmds)` `def self_rect()` `` `` class ImageLayout:
    `def __init__(node, parent, previous, frame)` `def layout()` `def paint()` `def
    paint_effects(cmds)` `` `` class IframeLayout: `def __init__(node, parent, previous,
    parent_frame)` `def layout()` `def paint()` `def paint_effects(cmds)` `` `BROKEN_IMAGE`
    `` class PaintCommand: `def __init__(rect)` `` `` class DrawText: `def __init__(x1,
    y1, text, font, color)` `def execute(canvas)` `` `` class DrawRect: `def __init__(rect,
    color)` `def execute(canvas)` `` `` class DrawRRect: `def __init__(rect, radius,
    color)` `def execute(canvas)` `` `` class DrawLine: `def __init__(x1, y1, x2,
    y2, color, thickness)` `def execute(canvas)` `` `` class DrawOutline: `def __init__(rect,
    color, thickness)` `def execute(canvas)` `` `` class DrawCompositedLayer: `def
    __init__(composited_layer)` `def execute(canvas)` `` `` class DrawImage: `def
    __init__(image, rect, quality)` `def execute(canvas)` `` `def DrawCursor(elt,
    offset)` `` class VisualEffect: `def __init__(rect, children, node)` `` `` class
    Blend: `def __init__(opacity, blend_mode, node, children)` `def execute(canvas)`
    `def map(rect)` `def unmap(rect)` `def clone(child)` `` `` class Transform: `def
    __init__(translation, rect, node, children)` `def execute(canvas)` `def map(rect)`
    `def unmap(rect)` `def clone(child)` `` `def local_to_absolute(display_item, rect)`
    `def absolute_bounds_for_obj(obj)` `def absolute_to_local(display_item, rect)`
    `def map_translation(rect, translation, reversed)` `def paint_tree(layout_object,
    display_list)` `def paint_visual_effects(node, cmds, rect)` `def paint_outline(node,
    cmds, rect, zoom)` `def add_parent_pointers(nodes, parent)` `` class CompositedLayer:
    `def __init__(skia_context, display_item)` `def can_merge(display_item)` `def
    add(display_item)` `def composited_bounds()` `def absolute_bounds()` `def raster()`
    `` `SPEECH_FILE` `` class AccessibilityNode: `def __init__(node, parent)` `def
    compute_bounds()` `def build()` `def build_internal(child_node)` `def contains_point(x,
    y)` `def hit_test(x, y)` `def map_to_parent(rect)` `def absolute_bounds()` ``
    `` class FrameAccessibilityNode: `def __init__(node, parent)` `def build()` `def
    hit_test(x, y)` `def map_to_parent(rect)` `` `def speak_text(text)` `EVENT_DISPATCH_JS`
    `SETTIMEOUT_JS` `XHR_ONLOAD_JS` `POST_MESSAGE_DISPATCH_JS` `RUNTIME_JS` `` class
    JSContext: `def __init__(tab, url_origin)` `def run(script, code, window_id)`
    `def add_window(frame)` `def wrap(script, window_id)` `def dispatch_event(type,
    elt, window_id)` `def dispatch_post_message(message, window_id)` `def dispatch_settimeout(handle,
    window_id)` `def dispatch_xhr_onload(out, handle, window_id)` `def dispatch_RAF(window_id)`
    `def throw_if_cross_origin(frame)` `def get_handle(elt)` `def querySelectorAll(selector_text,
    window_id)` `def getAttribute(handle, attr)` `def setAttribute(handle, attr, value,
    window_id)` `def innerHTML_set(handle, s, window_id)` `def style_set(handle, s,
    window_id)` `def XMLHttpRequest_send(...)` `def setTimeout(handle, time, window_id)`
    `def requestAnimationFrame()` `def parent(window_id)` `def postMessage(target_window_id,
    message, origin)` `` `SCROLL_STEP` `` class Frame: `def __init__(tab, parent_frame,
    frame_element)` `def allowed_request(url)` `def load(url, payload)` `def render()`
    `def clamp_scroll(scroll)` `def set_needs_render()` `def set_needs_layout()` `def
    advance_tab()` `def focus_element(node)` `def activate_element(elt)` `def submit_form(elt)`
    `def keypress(char)` `def scrolldown()` `def scroll_to(elt)` `def click(x, y)`
    `` `` class Tab: `def __init__(browser, tab_height)` `def load(url, payload)`
    `def run_animation_frame(scroll)` `def render()` `def get_js(url)` `def allowed_request(url)`
    `def raster(canvas)` `def clamp_scroll(scroll)` `def set_needs_render()` `def
    set_needs_layout()` `def set_needs_paint()` `def set_needs_render_all_frames()`
    `def set_needs_accessibility()` `def scrolldown()` `def click(x, y)` `def go_back()`
    `def submit_form(elt)` `def keypress(char)` `def focus_element(node)` `def activate_element(elt)`
    `def scroll_to(elt)` `def enter()` `def advance_tab()` `def zoom_by(increment)`
    `def reset_zoom()` `def set_dark_mode(val)` `def post_message(message, target_window_id)`
    `` `` class Chrome: `def __init__(browser)` `def tab_rect(i)` `def paint()` `def
    click(x, y)` `def keypress(char)` `def enter()` `def blur()` `def focus_addressbar()`
    `` `` class CommitData: `def __init__(...)` `` `` class Browser: `def __init__()`
    `def schedule_animation_frame()` `def commit(tab, data)` `def render()` `def composite_raster_and_draw()`
    `def composite()` `def get_latest(effect)` `def paint_draw_list()` `def raster_tab()`
    `def raster_chrome()` `def update_accessibility()` `def draw()` `def speak_node(node,
    text)` `def speak_document()` `def set_needs_accessibility()` `def set_needs_animation_frame(tab)`
    `def set_needs_raster_and_draw()` `def set_needs_raster()` `def set_needs_composite()`
    `def set_needs_draw()` `def clear_data()` `def new_tab(url)` `def new_tab_internal(url)`
    `def set_active_tab(tab)` `def schedule_load(url, body)` `def clamp_scroll(scroll)`
    `def handle_down()` `def handle_click(e)` `def handle_key(char)` `def handle_enter()`
    `def handle_tab()` `def handle_hover(event)` `def handle_quit()` `def toggle_dark_mode()`
    `def increment_zoom(increment)` `def reset_zoom()` `def focus_content()` `def
    focus_addressbar()` `def go_back()` `def cycle_tabs()` `def toggle_accessibility()`
    `` `def mainloop(browser)`'
  id: totrans-3921
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-3922
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 16-1 *Emptying an element*. Implement the [`replaceChildren` DOM method](https://developer.mozilla.org/en-US/docs/Web/API/Element/replaceChildren)
    when called with no arguments. This method should delete all the children of a
    given element. Make sure to handle invalidation properly.
  id: totrans-3923
  prefs: []
  type: TYPE_NORMAL
  zh: 16-1 *清空元素*。当没有参数调用时，实现`replaceChildren` DOM方法（[链接](https://developer.mozilla.org/en-US/docs/Web/API/Element/replaceChildren)）。此方法应删除给定元素的所有子元素。确保正确处理无效化。
- en: '16-2 *Protecting layout phases*. Replace the `needs_style` and `needs_layout`
    dirty flags by making the `document` field on `Frame`s a `ProtectedField`. Make
    sure animations still work correctly: animations of `opacity` or `transform` shouldn’t
    trigger layout, while animations of other properties should.'
  id: totrans-3924
  prefs: []
  type: TYPE_NORMAL
  zh: 16-2 *保护布局阶段*。通过将`Frame`上的`document`字段替换为`ProtectedField`来替换`needs_style`和`needs_layout`脏标志。确保动画仍然正确工作：`opacity`或`transform`的动画不应触发布局，而其他属性的动画应该。
- en: 16-3 *Transferring children*. Implement the [`replaceChildren` DOM method](https://developer.mozilla.org/en-US/docs/Web/API/Element/replaceChildren)
    when called with multiple arguments. Here the arguments are elements from elsewhere
    in the document,Unless you’ve implemented Exercises 9-2 and 9-3, in which case
    they can also be “detached” elements. which are then removed from their current
    parent and then attached to this one. Make sure to handle invalidation properly.
  id: totrans-3925
  prefs: []
  type: TYPE_NORMAL
  zh: 16-3 *转移子元素*。当调用多个参数时，实现`replaceChildren` DOM方法（[链接](https://developer.mozilla.org/en-US/docs/Web/API/Element/replaceChildren)）。这里的参数是文档其他部分的元素，除非你已经实现了练习9-2和9-3，在这种情况下，它们也可以是“分离”的元素。这些元素随后从它们当前父元素中移除，然后附加到这个元素上。确保正确处理无效化。
- en: 16-4 *Descendant bits for style*. Add descendant dirty flags for `style` information,
    so that the `style` phase doesn’t need to traverse nodes whose styles are unchanged.
  id: totrans-3926
  prefs: []
  type: TYPE_NORMAL
  zh: 16-4 *样式后代位*。为`style`信息添加后代脏标志，这样`style`阶段就不需要遍历样式未更改的节点。
- en: '16-5 *Resizing the browser*. Perhaps, back in Exericse 2-3, you implemented
    support for resizing the browser. (And, most likely, you dropped support for it
    when we switched to SDL.) Reimplement support for resizing your browser; you’ll
    need to pass the `SDL_WINDOW_RESIZABLE` flag to `SDL_CreateWindow` and listen
    for `SDL_WINDOWEVENT_RESIZED` events. Make sure invalidation works: resizing the
    window should resize the page. How much does invalidation help make resizing fast?
    Test both vertical and horizontal resizing.'
  id: totrans-3927
  prefs: []
  type: TYPE_NORMAL
  zh: 16-5 *调整浏览器大小*。也许，在练习2-3中，你实现了对调整浏览器大小的支持。（而且，很可能是当我们切换到SDL时，你放弃了这种支持。）重新实现调整浏览器大小的支持；你需要将`SDL_WINDOW_RESIZABLE`标志传递给`SDL_CreateWindow`并监听`SDL_WINDOWEVENT_RESIZED`事件。确保无效化工作正常：调整窗口大小应该调整页面大小。无效化在使调整大小快速方面有多大帮助？测试垂直和水平调整大小。
- en: 16-6 *Matching children*. Add support for [the `appendChild` method](https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild)
    if you haven’t already in Exercise 9-2\. What’s interesting about `appendChild`
    is that, while it *does* change a layout object’s `children` field, it only does
    so by adding new children to the end. In this case, you can keep all of the existing
    layout object children. Apply this optimization, at least in the case of block-mode
    `BlockLayout`s.
  id: totrans-3928
  prefs: []
  type: TYPE_NORMAL
  zh: 16-6 *匹配子元素*。如果你在练习9-2中还没有实现，添加对[`appendChild`方法](https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild)的支持。关于`appendChild`有趣的是，尽管它*确实*改变了布局对象的`children`字段，但它只是通过向末尾添加新子元素来这样做。在这种情况下，你可以保留所有现有的布局对象子元素。至少在块模式`BlockLayout`s的情况下应用此优化。
- en: 16-7 *Invalidating `previous`*. Add support for [the `insertBefore` method](https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore)
    if you if you haven’t already in Exercise 9-2\. Like with `appendChild`, we want
    to skip rebuilding layout objects if we can. However, this method can also change
    the `previous` field of layout objects; protect that field on all block-mode `BlockLayout`s
    and then avoid rebuilding as much of the layout tree as possible.
  id: totrans-3929
  prefs: []
  type: TYPE_NORMAL
  zh: 16-7 *无效化`previous`*。如果你在练习9-2中还没有实现，添加对[`insertBefore`方法](https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore)的支持。与`appendChild`一样，如果我们能跳过重建布局对象，我们希望这样做。然而，此方法也可以改变布局对象的`previous`字段；在所有块模式`BlockLayout`s上保护该字段，然后尽可能避免重建布局树的大部分。
- en: 16-8 *`:hover` pseudo-class*. There is a `:hover` pseudo-class that identifies
    elements the mouse is [hovering over](https://developer.mozilla.org/en-US/docs/Web/CSS/:hover).
    Implement it by sending mouse hover events to the active `Tab` and hit testing
    to find out which element is being hovered over. Try to avoid [forcing a layout](https://browser.engineering/scheduling.html#threaded-style-and-layout)
    in this hit test; one way to do that is to store a `pending_hover` on the `Tab`
    and run the hit test after `layout` during `render`, and then perform *another*
    render to invalidate the hovered element’s style.
  id: totrans-3930
  prefs: []
  type: TYPE_NORMAL
  zh: 16-8 *`:hover` 伪类*. 存在一个 `:hover` 伪类，用于识别鼠标悬停的元素。[悬停](https://developer.mozilla.org/en-US/docs/Web/CSS/:hover)。通过将鼠标悬停事件发送到活动
    `Tab` 并进行碰撞测试以找出正在悬停的元素来实现它。尽量在这个碰撞测试中避免[强制布局](https://browser.engineering/scheduling.html#threaded-style-and-layout)；实现这一点的其中一种方法是在
    `Tab` 上存储一个 `pending_hover`，并在 `render` 期间的 `layout` 之后运行碰撞测试，然后进行 *另一个* 渲染以使悬停元素的样式无效。
- en: 16-9 *Optimizing away `ProtectedField`*. As mentioned in the last section of
    this chapter, creating all these `ProtectedField` objects is way too expensive
    for a real browser. See if you can find a way to avoid creating the objects entirely.
    Depending on the language you’re using to implement your browser, you might have
    compile-time macros available to help; in Python, this might require refactoring
    to change the API shape of `ProtectedField` to be functional rather than object-oriented.
  id: totrans-3931
  prefs: []
  type: TYPE_NORMAL
  zh: 16-9 *优化移除 `ProtectedField`*. 如本章最后一节所述，创建所有这些 `ProtectedField` 对象对于真实浏览器来说代价太高。看看你是否能找到一种方法来完全避免创建这些对象。根据你用来实现浏览器的语言，你可能有一些编译时宏可用以帮助；在
    Python 中，这可能需要重构以改变 `ProtectedField` 的 API 形状，使其成为函数式而非面向对象的。
- en: 16-10 *Optimizing paint*. Even after making layout fast for text input, paint
    is still painfully slow. Fix that by storing the display list between frames,
    adding dirty bits for whether paint is needed for each layout object, and mutating
    the display list rather than recreating it every time.
  id: totrans-3932
  prefs: []
  type: TYPE_NORMAL
  zh: 16-10 *优化绘制*. 即使在使文本输入布局变得快速之后，绘制仍然非常缓慢。通过在帧之间存储显示列表、为每个布局对象添加是否需要绘制的脏位，以及而不是每次都重新创建它来修复这个问题。
- en: What Wasn’t Covered
  id: totrans-3933
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未涵盖的内容
- en: The Conclusion to [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-3934
  prefs: []
  type: TYPE_NORMAL
  zh: '[《网络浏览器工程》的结论](./index.html "目录").'
- en: '[JavaScript Execution](#javascript-execution)'
  id: totrans-3935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JavaScript 执行](#javascript-execution)'
- en: '[Text & Graphics Rendering](#text-graphics-rendering)'
  id: totrans-3936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[文本与图形渲染](#text-graphics-rendering)'
- en: '[Connection Security & Privacy](#connection-security-privacy)'
  id: totrans-3937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[连接安全与隐私](#connection-security-privacy)'
- en: '[Network Caching and Media](#network-caching-and-media)'
  id: totrans-3938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[网络缓存和媒体](#network-caching-and-media)'
- en: '[Fancier Layout Modes](#fancier-layout-modes)'
  id: totrans-3939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[更复杂的布局模式](#fancier-layout-modes)'
- en: '[Browser UIs and Developer Tools](#browser-uis-and-developer-tools)'
  id: totrans-3940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[浏览器 UI 和开发者工具](#browser-uis-and-developer-tools)'
- en: '[Testing](#testing)'
  id: totrans-3941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[测试](#testing)'
- en: The last 16 chapters have, I hope, given you a solid understanding of all of
    the major components of a web browser, from the network requests it makes to the
    way it stores your data safely. With such a vast topic I had to leave a few things
    out. Here’s my list of the most important things not covered by this book, in
    no particular order.
  id: totrans-3942
  prefs: []
  type: TYPE_NORMAL
  zh: 希望前 16 章已经给了你一个关于网络浏览器所有主要组件的坚实基础理解，从它发出的网络请求到它安全存储你的数据的方式。对于这样一个庞大的主题，我不得不省略一些内容。以下是这本书没有涵盖的最重要事项列表，不分先后。
- en: JavaScript Execution
  id: totrans-3943
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 执行
- en: A large part of a modern web browser is a very-high-performance implementation
    of JavaScript. Today, every major browser not only runs JavaScript, but compiles
    it, in flight, to low-level machine code using runtime type analysis. Plus, techniques
    like hidden classes infer structure where JavaScript doesn’t provide any, lowering
    memory usage and garbage collection pressure. On top of all of that, modern browsers
    also execute WebAssembly, a hardware-independent bytecode format for many other
    programming languages to target, and which may one day be co-equal to JavaScript
    on the web.
  id: totrans-3944
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络浏览器的大部分是一个高性能的 JavaScript 实现。今天，每个主要的浏览器不仅运行 JavaScript，而且在飞行中将其编译成低级机器代码，使用运行时类型分析。此外，像隐藏类这样的技术可以在
    JavaScript 没有提供结构的地方推断结构，从而降低内存使用和垃圾收集压力。在此基础上，现代浏览器还执行 WebAssembly，这是一种针对许多其他编程语言的硬件无关的字节码格式，它可能有一天会在网络上与
    JavaScript 并驾齐驱。
- en: This book skips building the JavaScript engine, instead using DukPy. I made
    this choice because, while JavaScript execution is central to a modern browser,
    it uses techniques fairly similar to the execution of other languages like Python,
    Lua, or Java. The best way to learn about the insides of a modern JavaScript engine
    is a book on programming language implementation.
  id: totrans-3945
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书跳过了构建 JavaScript 引擎，而是使用了 DukPy。我做出这个选择是因为，虽然 JavaScript 执行是现代浏览器中的核心，但它使用的技术与
    Python、Lua 或 Java 等其他语言的执行相当相似。了解现代 JavaScript 引擎内部的最佳方式是阅读关于编程语言实现的书籍。
- en: Text & Graphics Rendering
  id: totrans-3946
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本与图形渲染
- en: Text rendering is much more complex than it may seem at the surface. Letters
    differ in widths and heights. Accents may need to be stacked atop characters.
    Characters may change shape when next to other characters, like for ligatures
    or for *shaping* (for cursive fonts). Sometimes languages are written right-to-left
    or top-to-bottom. Then there are typographic features, like kerning and variants.
    But the most complex of all is *hinting*, which is a little computer program embedded
    in a font that modifies it to better match the discrete pixel grid. Text rendering
    of course affects Skia, but it also affects layout, determining the size and position
    of content on the screen.
  id: totrans-3947
  prefs: []
  type: TYPE_NORMAL
  zh: 文本渲染比表面上看起来要复杂得多。字母在宽度和高度上有所不同。重音符号可能需要堆叠在字符上方。字符在与其他字符相邻时可能会改变形状，例如连字符或*形状*（用于手写字体）。有时语言是从右到左或从上到下书写的。然后还有排版特性，如字距调整和变体。但最复杂的是*提示*，它是一个嵌入在字体中的小计算机程序，用于修改它以更好地匹配离散的像素网格。文本渲染当然会影响
    Skia，但它也影响布局，确定屏幕上内容的尺寸和位置。
- en: And more broadly, graphics in general is pretty complex! Our browser uses Skia,
    which is the actual rasterization engine used by Chromium and some other browsers.
    But we didn’t really talk at all about how Skia actually works, and it turns out
    to be pretty complex. It not only renders text but applies all sorts of blends
    and effects quickly and with high quality on basically all CPUs and GPUs. In a
    real browser this becomes even more complex, with fancy compositing systems, graphics
    process security sandboxing, and various platform-specific font and OS compositing
    integrations. And there is a whole lot of additional effort to implement lower-level
    JavaScript-exposed APIs like [Canvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API),
    [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API), and [WebGPU](https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API).
  id: totrans-3948
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛地说，图形总体上相当复杂！我们的浏览器使用 Skia，这是 Chromium 和一些其他浏览器实际使用的光栅化引擎。但我们并没有真正谈论 Skia
    实际是如何工作的，而它实际上相当复杂。它不仅渲染文本，而且在基本上所有 CPU 和 GPU 上快速且高质量地应用各种混合和效果。在真正的浏览器中，这变得更加复杂，有复杂的合成系统、图形处理安全沙箱以及各种平台特定的字体和操作系统合成集成。还有大量额外的工作来实现底层的
    JavaScript 公开的 API，如 [Canvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API)、[WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API)
    和 [WebGPU](https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API)。
- en: I skipped this topic in the book because high-quality implementations are available
    in libraries like Skia (for graphics) and Harfbuzz (for text), as well as various
    system libraries, so are arguably not browser-specific. But there is a depth here
    best served by a book on these specific subjects.
  id: totrans-3949
  prefs: []
  type: TYPE_NORMAL
  zh: 我在书中跳过了这个主题，因为像 Skia（用于图形）和 Harfbuzz（用于文本）这样的库以及各种系统库中都有高质量的实现，所以可以说是与浏览器无关的。但这里有一个深度，最好通过这些特定主题的书籍来满足。
- en: Connection Security & Privacy
  id: totrans-3950
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接安全与隐私
- en: Web browsers now ship with a sophisticated suite of cryptographic protocols
    with bewildering names like AES-GCM, ChaCha20, and HMAC-SHA512\. These protocols
    protect against malicious actors with the ability to read or write network packets.
    At the broadest level, connection security is established via the TLS protocol
    (which cameos in [Chapter 1](http.html)) and is maintained by an ecosystem of
    cryptographers, certificate authorities, and open-source projects.
  id: totrans-3951
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的网页浏览器配备了复杂的加密协议套件，名称令人困惑，如 AES-GCM、ChaCha20 和 HMAC-SHA512。这些协议可以防止恶意行为者读取或写入网络数据包。在最广泛的意义上，连接安全是通过
    TLS 协议（在第 1 章[http.html]中亮相）建立的，并由一群密码学家、证书颁发机构和开源项目维护。
- en: I chose to skip an in-depth discussion of TLS because this book’s irreverent
    attitude toward completeness and validation is incompatible with real security
    engineering. A minimal and incomplete version of TLS is a broken and insecure
    version of it, contrary to the intended goal and pedagogically counterproductive.
    The best way to learn about modern cryptography and network security is a book
    on that topic.
  id: totrans-3952
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择跳过对TLS的深入讨论，因为这本书对完整性和验证的不敬态度与实际的安全工程不相容。TLS的一个最小化和不完整的版本是一个有缺陷和不安全的版本，与预期目标相悖，并且从教育角度来看也是反生产力的。了解现代密码学和网络安全最好的方式是阅读关于这个主题的书籍。
- en: '[Privacy on the web](https://developer.mozilla.org/en-US/docs/Web/Privacy)
    is another important topic that I skipped. In some ways security and privacy are
    related (and certainly complement one other), but they are not the same. And privacy
    on the web is in flux, such as debates around [third-party cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#third-party_cookies),
    [fingerprinting](https://developer.mozilla.org/en-US/docs/Glossary/Fingerprinting),
    and whether there should be APIs to help with advertising. I chose to skip this
    topic because many basic concepts remain unsettled: what the standards of privacy
    are and what role governments, browser developers, website authors, and users
    should play in them.'
  id: totrans-3953
  prefs: []
  type: TYPE_NORMAL
  zh: '[网络隐私](https://developer.mozilla.org/en-US/docs/Web/Privacy)是另一个我跳过的主题。在某种程度上，安全和隐私是相关的（并且当然相互补充），但它们并不相同。网络隐私处于不断变化之中，例如围绕[第三方cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#third-party_cookies)、[指纹识别](https://developer.mozilla.org/en-US/docs/Glossary/Fingerprinting)以及是否应该有API来帮助广告的辩论。我选择跳过这个主题，因为许多基本概念仍然没有定论：隐私的标准是什么，以及政府、浏览器开发者、网站作者和用户在其中的角色应该是什么。'
- en: Network Caching and Media
  id: totrans-3954
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络缓存和媒体
- en: Caching makes network requests faster by skipping most of them. What makes it
    more than a mere optimization, however, is the extent to which HTTP is designed
    to enable caching. Implementing a network cache deepens one’s understanding of
    HTTP significantly. That said, the networking portion of this book is long enough,
    and at no point in the book did the lack of a cache feel painful, so I decided
    to leave this topic out.
  id: totrans-3955
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存通过跳过大多数网络请求来使网络请求更快。然而，使其不仅仅是一个优化的是HTTP设计到何种程度来启用缓存。实现网络缓存可以显著加深对HTTP的理解。尽管如此，本书的网络部分已经足够长，而且在书中任何地方都没有感觉到缺少缓存会带来痛苦，所以我决定省略这个主题。
- en: And since the majority of network bandwidth and battery life is today eaten
    up by video playback and video conferencing, there is a whole world of complexity
    in real-time video encoding, decoding and rendering. Real browsers have large
    teams devoted to these services and APIs, and many researchers across the world
    work on video compression. Video codecs are fascinating, but again not very browser-specific,
    so this book skips them entirely, and I advise reading a dedicated book about
    them.
  id: totrans-3956
  prefs: []
  type: TYPE_NORMAL
  zh: 由于今天网络带宽和电池寿命的大部分都被视频播放和视频会议消耗，实时视频编码、解码和渲染中存在一个复杂的领域。实际浏览器有专门负责这些服务和API的大型团队，全世界有众多研究人员致力于视频压缩。视频编解码器非常有趣，但同样不是非常特定于浏览器，所以这本书完全跳过了它们，我建议阅读关于它们的专门书籍。
- en: Fancier Layout Modes
  id: totrans-3957
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更复杂的布局模式
- en: The layout algorithm used in real browsers is much more sophisticated than that
    covered in the book, with features like floating layout, positioned elements,
    flexible boxes, grids, tables, and more. Implementing these layout modes is complex
    and requires care and sophistication—especially if you want speed and incremental
    performance. Important techniques here include multi-phase layoutWe do a little
    bit of multi-phase layout in the book, with words in a line having their `x`,
    `width`, and `height` computed in the first phase and then their `y` computed
    in a separate phase based on the baseline. But we don’t talk much about it as
    an example of multi-phase layout, and real browsers have much more complex sets
    of layout phases. and measure-layout phases, with tricky caching strategies necessary
    to produce good performance.
  id: totrans-3958
  prefs: []
  type: TYPE_NORMAL
  zh: 实际浏览器中使用的布局算法比书中所涵盖的更为复杂，具有浮动布局、定位元素、弹性盒子、网格、表格等功能。实现这些布局模式是复杂的，需要细心和技巧——尤其是如果你想要速度和渐进式性能的话。这里的重要技术包括多阶段布局和测量布局阶段，以及为了产生良好性能所需的复杂缓存策略。我们在书中进行了一些多阶段布局的示例，一行中的文字在第一阶段计算其`x`、`width`和`height`，然后在基于基线的单独阶段计算其`y`。但我们并没有过多地讨论它作为一个多阶段布局的示例，而实际浏览器有更复杂的布局阶段集合。
- en: I chose to skip fancier layout in this book because even the simple layout algorithm
    described here is quite complex, and real-world layout algorithms involve a lot
    of accidental complexity caused by old standards and backwards compatibility,
    which I didn’t want to talk much about.
  id: totrans-3959
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择在这本书中跳过更复杂的布局，因为即使这里描述的简单布局算法也相当复杂，而现实世界的布局算法涉及许多由旧标准和向后兼容性引起的偶然复杂性，这些内容我不想过多讨论。
- en: Browser UIs and Developer Tools
  id: totrans-3960
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器用户界面和开发者工具
- en: A real browser has a *much* more complex and powerful “browser UI”—meaning the
    chrome around the web page, where you can enter URLs, see tabs, and so on—than
    our browser. In fact, a large fraction of a real browser team works just on this,
    and not on the “web platform” itself. The multi-process nature of a modern browser
    also makes it difficult to interact with synchronous OS APIs, as we saw with accessibility
    in [Chapter 14](accessibility.html#the-accessibility-tree). Plus, many browsers
    (desktop ones, at least) support powerful [extension APIs](https://en.wikipedia.org/wiki/Browser_extension)
    that enable developers to extend the browser UI. To help with that, browser UIs
    are often implemented in HTML and rendered by the browser itself.
  id: totrans-3961
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真正的浏览器拥有比我们的浏览器更复杂、更强大的“浏览器UI”——即围绕网页的浏览器界面，您可以在其中输入URL、查看标签等——比我们的浏览器。事实上，一个真正的浏览器团队的大部分工作就是在这方面，而不是在“Web平台”本身。现代浏览器的多进程特性也使得与同步OS
    API交互变得困难，正如我们在第14章中看到的可访问性那样。此外，许多浏览器（至少是桌面浏览器）支持强大的[扩展API](https://en.wikipedia.org/wiki/Browser_extension)，允许开发者扩展浏览器UI。为了帮助实现这一点，浏览器UI通常使用HTML实现并由浏览器本身渲染。
- en: Also, it’d be almost impossible to build complex web apps without some kind
    of debugging aid, so all real browsers have built-in debuggers. Believe it or
    not, for quite a long time web developers just did a lot of [`console.log` debugging](https://en.wikipedia.org/wiki/Debugging#printf_debugging)
    (or even `alert` debugging, before there was an easy way to see the console!).
    This changed in a big way with the innovative [Firebug](https://en.wikipedia.org/wiki/Firebug_(software))
    browser extension for Firefox, and eventually today’s integrated developer tools.
    These developer tools have deep integration with the browser engine itself to
    implement features like observing the styles of elements in real time or pausing
    and stepping through JavaScript execution.
  id: totrans-3962
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，没有某种调试辅助工具几乎不可能构建复杂的Web应用程序，因此所有真正的浏览器都内置了调试器。信不信由你，在相当长的一段时间里，Web开发者只是做了大量的[`console.log`调试](https://en.wikipedia.org/wiki/Debugging#printf_debugging)（甚至在有简单查看控制台的方法之前，甚至使用`alert`调试！）。这种状况随着Firefox的[Firebug](https://en.wikipedia.org/wiki/Firebug_(software))浏览器扩展的推出而发生了重大变化，并最终演变成了今天的集成开发者工具。这些开发者工具与浏览器引擎本身深度集成，以实现实时观察元素样式或暂停和逐步执行JavaScript等特性。
- en: 'I skipped this topic because many challenges in browser UI are the same as
    those of any other UI: design, usability, complexity, and so on. That would make
    for a tedious book. Even the debugger, conceptually quite interesting, is only
    useful if a substantial amount of UI work is done to make it usable. Unfortunately,
    I’m not aware of any book on developer tools, but many books will cover basic
    user interface development.'
  id: totrans-3963
  prefs: []
  type: TYPE_NORMAL
  zh: 我跳过了这个主题，因为浏览器UI中的许多挑战与其他任何UI的挑战相同：设计、可用性、复杂性等等。这会使书籍变得乏味。即使是概念上相当有趣的调试器，也只有在进行了大量的UI工作以使其可用时才有用。不幸的是，我并不了解任何关于开发者工具的书籍，但许多书籍都会涵盖基本的用户界面开发。
- en: Testing
  id: totrans-3964
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Real browsers have evolved an incredibly impressive array of testing techniques
    to ensure they maintain and improve quality over time. In total, they have batteries
    of hundreds of thousands of [unit](https://en.wikipedia.org/wiki/Unit_testing)
    and [integration](https://en.wikipedia.org/wiki/Integration_testing) tests. Recently,
    a lot of focus has been put on robust [cross-browser tests](https://wpt.fyi) that
    allow a single automated test to run on all browsers to verify that they all behave
    the same on the same input. And there are now yearly [interoperability](https://wpt.fyi/interop-2023)“Interop”,
    for short. benchmarks that measure how well browsers are doing against this goal
    for key features. Behind the scenes of testing is a whole world of code and infrastructure
    to efficiently run these tests continuously and provide extensive [frameworks](https://web-platform-tests.org/)
    to make testing easy.
  id: totrans-3965
  prefs: []
  type: TYPE_NORMAL
  zh: 真实浏览器已经发展出了一系列令人印象深刻的测试技术，以确保它们随着时间的推移保持并提高质量。总的来说，它们拥有成千上万的[单元测试](https://en.wikipedia.org/wiki/Unit_testing)和[集成测试](https://en.wikipedia.org/wiki/Integration_testing)。最近，很多关注都放在了强大的[跨浏览器测试](https://wpt.fyi)上，这使得单个自动化测试可以在所有浏览器上运行，以验证它们在相同输入下的行为是否一致。现在每年都有[互操作性](https://wpt.fyi/interop-2023)“Interop”，简称“互操作性”基准测试，用于衡量浏览器在关键特性上实现这一目标的情况。在测试的背后，是一个庞大的代码和基础设施的世界，以高效地持续运行这些测试并提供广泛的[框架](https://web-platform-tests.org/)，使测试变得简单。
- en: A Changing Landscape
  id: totrans-3966
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变化的景观
- en: The Post-script to [Web Browser Engineering](./index.html "Table of Contents").
  id: totrans-3967
  prefs: []
  type: TYPE_NORMAL
  zh: '[Web Browser Engineering](./index.html "目录")的附录。'
- en: The web is a dynamic, ever-changing place. The first web browser, in 1989, did
    not support colors, images, styling, or scripting. Three decades of market forces,
    implementation quirks, and the ever-expanding reach of the web then made browsers
    what they are today. Those forces are as strong as ever. Browsers continue to
    evolve!
  id: totrans-3968
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是一个动态、不断变化的地方。1989年的第一个网络浏览器不支持颜色、图像、样式或脚本。三十年的市场力量、实施怪癖以及网络不断扩大的范围，使得浏览器成为了今天的模样。这些力量依然强大。浏览器继续在进化！
- en: Sooner or later this book will be obsolete.In one sense, the sooner the better,
    because it means the web is continuing to thrive! Whether it is WebAssembly or
    WebGPU, hardware access or new CSS features, integrated payments or AI assistants,
    I do expect the browser of the future to play many new and different roles in
    computing and our lives.
  id: totrans-3969
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书迟早会过时。从某种意义上说，越快越好，因为这意味着网络正在继续繁荣！无论是WebAssembly还是WebGPU，硬件访问或新的CSS特性，集成支付或AI助手，我都期待未来的浏览器在计算和我们的生活中扮演许多新的不同角色。
- en: That said, many dedicated, talented engineers have devoted themselves to the
    web over its first three decades. The structure of the web embeds their ideas,
    inventions, and tastes. It embeds their values and hopes for computing. You and
    I, dear reader, walk in their footsteps and study their work. If, in a few years,
    this book is out-dated, I hope those values live on and those hopes are fulfilled.
  id: totrans-3970
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，许多有奉献精神、才华横溢的工程师在互联网的前三十年里致力于网络。网络的架构融入了他们的想法、发明和品味。它融入了他们的价值观和对计算的希望。亲爱的读者，您和我，都在他们的足迹中前行，研究他们的工作。如果几年后这本书过时了，我希望那些价值观能够延续，那些希望能够实现。
- en: © 2018–2023 [Pavel Panchekha](https://pavpanchekha.com) & [Chris Harrelson](https://twitter.com/chrishtr)
  id: totrans-3971
  prefs: []
  type: TYPE_NORMAL
  zh: © 2018–2023 [Pavel Panchekha](https://pavpanchekha.com) & [Chris Harrelson](https://twitter.com/chrishtr)
