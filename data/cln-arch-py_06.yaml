- en: Chapter 4 - Add a web application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 - 添加Web应用程序
- en: 原文：[https://www.thedigitalcatbooks.com/pycabook-chapter-04/](https://www.thedigitalcatbooks.com/pycabook-chapter-04/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://www.thedigitalcatbooks.com/pycabook-chapter-04/](https://www.thedigitalcatbooks.com/pycabook-chapter-04/)
- en: For your information, Hairdo, a major network is interested in me.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了您的信息，Hairdo，一个主要网络公司，对我感兴趣。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Groundhog Day, 1993
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 土拨鼠日，1993年
- en: In this chapter, I will go through the creation of an HTTP endpoint for the
    room list use case. An HTTP endpoint is a URL exposed by a Web server that runs
    a specific logic and returns values in a standard format.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍为房间列表用例创建HTTP端点的过程。HTTP端点是由运行特定逻辑并返回标准格式值的Web服务器公开的URL。
- en: I will follow the REST recommendation, so the endpoint will return a JSON payload.
    REST is however not part of the clean architecture, which means that you can choose
    to model your URLs and the format of returned data according to whatever scheme
    you prefer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我将遵循REST推荐，因此端点将返回JSON有效负载。然而，REST不是清洁架构的一部分，这意味着你可以选择根据你喜欢的任何方案来建模你的URL和返回数据的格式。
- en: To expose the HTTP endpoint we need a web server written in Python, and in this
    case, I chose Flask. Flask is a lightweight web server with a modular structure
    that provides just the parts that the user needs. In particular, we will not use
    any database/ORM, since we already implemented our own repository layer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了公开HTTP端点，我们需要一个用Python编写的Web服务器，在这种情况下，我选择了Flask。Flask是一个轻量级的Web服务器，具有模块化结构，仅提供用户所需的部分。特别是，我们不会使用任何数据库/ORM，因为我们已经实现了自己的存储库层。
- en: Flask setup
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask设置
- en: Let us start updating the requirements files. The file `requirements/prod.txt`
    shall mention Flask, as this package contains a script that runs a local webserver
    that we can use to expose the endpoint
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始更新需求文件。文件`requirements/prod.txt`应提及Flask，因为这个包包含一个运行本地Web服务器的脚本，我们可以用它来公开端点
- en: '`requirements/prod.txt`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements/prod.txt`'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The file `requirements/test.txt` will contain the pytest extension to work with
    Flask (more on this later)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`requirements/test.txt`将包含用于与Flask一起工作的pytest扩展（关于这一点稍后讨论）
- en: '`requirements/test.txt`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements/test.txt`'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Source code'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*源代码*'
- en: '[https://github.com/pycabook/rentomatic/tree/ed2-c04-s01](https://github.com/pycabook/rentomatic/tree/ed2-c04-s01)*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pycabook/rentomatic/tree/ed2-c04-s01](https://github.com/pycabook/rentomatic/tree/ed2-c04-s01)*'
- en: '*Remember to run `pip install -r requirements/dev.txt` again after those changes
    to install the new packages in your virtual environment.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，在这些更改之后再次运行`pip install -r requirements/dev.txt`以在虚拟环境中安装新包。*'
- en: '*The setup of a Flask application is not complex, but there are a lot of concepts
    involved, and since this is not a tutorial on Flask I will run quickly through
    these steps. I will provide links to the Flask documentation for every concept,
    though. If you want to dig a bit deeper in this matter you can read my series
    of posts [Flask Project Setup: TDD, Docker, Postgres and more](https://www.thedigitalcatonline.com/blog/2020/07/05/flask-project-setup-tdd-docker-postgres-and-more-part-1/).*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*Flask应用程序的设置并不复杂，但涉及许多概念，由于这不是Flask教程，我将快速浏览这些步骤。不过，我会为每个概念提供Flask文档的链接。如果你想对这个话题进行更深入的了解，你可以阅读我的系列文章[Flask项目设置：TDD、Docker、Postgres等](https://www.thedigitalcatonline.com/blog/2020/07/05/flask-project-setup-tdd-docker-postgres-and-more-part-1/)。*'
- en: '*The Flask application can be configured using a plain Python object ([documentation](http://flask.pocoo.org/docs/latest/api/#flask.Config.from_object)),
    so I created the file `application/config.py` that contains this code*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*Flask应用程序可以使用纯Python对象进行配置（[文档](http://flask.pocoo.org/docs/latest/api/#flask.Config.from_object)），因此我创建了包含此代码的文件`application/config.py`*'
- en: '*`application/config.py`*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*`application/config.py`*'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Read [this page](http://flask.pocoo.org/docs/latest/config/) to know more
    about Flask configuration parameters.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*阅读[这个页面](http://flask.pocoo.org/docs/latest/config/)了解更多关于Flask配置参数的信息。*'
- en: '*Now we need a function that initialises the Flask application ([documentation](http://flask.pocoo.org/docs/latest/patterns/appfactories/)),
    configures it, and registers the blueprints ([documentation](http://flask.pocoo.org/docs/latest/blueprints/)).
    The file `application/app.py` contains the following code, which is an app factory*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在我们需要一个初始化Flask应用程序（[文档](http://flask.pocoo.org/docs/latest/patterns/appfactories/)）、配置它并注册蓝图（[文档](http://flask.pocoo.org/docs/latest/blueprints/)）的函数。文件`application/app.py`包含以下代码，这是一个应用程序工厂*'
- en: '*`application/app.py`*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*`application/app.py`*'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Source code'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码**'
- en: '[https://github.com/pycabook/rentomatic/tree/ed2-c04-s02](https://github.com/pycabook/rentomatic/tree/ed2-c04-s02)**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pycabook/rentomatic/tree/ed2-c04-s02](https://github.com/pycabook/rentomatic/tree/ed2-c04-s02)'
- en: '**Test and create an HTTP endpoint**'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**测试并创建一个 HTTP 端点**'
- en: '**Before we create the proper setup of the webserver, we want to create the
    endpoint that will be exposed. Endpoints are ultimately functions that are run
    when a user sends a request to a certain URL, so we can still work with TDD, as
    the final goal is to have code that produces certain results.**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**在我们创建 web 服务器的正确设置之前，我们希望创建将要公开的端点。端点最终是当用户向特定 URL 发送请求时运行的函数，因此我们仍然可以使用
    TDD，因为最终目标是拥有产生特定结果的代码。**'
- en: '**The problem we have testing an endpoint is that we need the webserver to
    be up and running when we hit the test URLs. The webserver itself is an external
    system so we won''t test it, but the code that provides the endpoint is part of
    our application^([[1](#fd--3563573)]). It is actually a gateway, that is an interface
    that allows an HTTP framework to access the use cases.**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试端点时遇到的问题是，我们需要在点击测试 URL 时确保 web 服务器正在运行。web 服务器本身是一个外部系统，所以我们不会对其进行测试，但提供端点的代码是我们应用程序的一部分^([[1](#fd--3563573)]）。实际上，它是一个网关，即允许
    HTTP 框架访问用例的接口。**'
- en: '**The extension `pytest-flask` allows us to run Flask, simulate HTTP requests,
    and test the HTTP responses. This extension hides a lot of automation, so it might
    be considered a bit "magic" at a first glance. When you install it some fixtures
    like `client` are available automatically, so you don''t need to import them.
    Moreover, it tries to access another fixture named `app` that you have to define.
    This is thus the first thing to do.**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**`pytest-flask` 扩展允许我们运行 Flask、模拟 HTTP 请求并测试 HTTP 响应。这个扩展隐藏了很多自动化，所以乍一看可能有点“魔法”。当你安装它时，一些固定值如
    `client` 会自动可用，因此你不需要导入它们。此外，它试图访问另一个名为 `app` 的固定值，你必须定义它。因此，这是要做的第一件事。**'
- en: '**Fixtures can be defined directly in your test file, but if we want a fixture
    to be globally available the best place to define it is the file `conftest.py`
    which is automatically loaded by pytest. As you can see there is a great deal
    of automation, and if you are not aware of it you might be surprised by the results,
    or frustrated by the errors.**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**可以在测试文件中直接定义固定值，但如果希望固定值全局可用，最佳定义位置是文件 `conftest.py`，该文件由 pytest 自动加载。正如你所见，这里有很多自动化，如果你不了解它，可能会对结果感到惊讶，或者因错误而感到沮丧。**'
- en: '**`tests/conftest.py`**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**`tests/conftest.py`**'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**The function `app` runs the app factory to create a Flask app, using the
    configuration `testing`, which sets the flag `TESTING` to `True`. You can find
    the description of these flags in the [official documentation](http://flask.pocoo.org/docs/1.0/config/).**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数 `app` 运行应用程序工厂来创建一个 Flask 应用，使用配置 `testing`，该配置将标志 `TESTING` 设置为 `True`。你可以在[官方文档](http://flask.pocoo.org/docs/1.0/config/)中找到这些标志的描述。**'
- en: '**At this point, we can write the test for our endpoint.**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**在这个阶段，我们可以为我们的端点编写测试。**'
- en: '**`tests/rest/test_room.py`**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**`tests/rest/test_room.py`**'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Let''s comment it section by section.**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**让我们逐节进行注释。**'
- en: '**`tests/rest/test_room.py`**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**`tests/rest/test_room.py`**'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**The first part contains some imports and sets up a room from a dictionary.
    This way we can later directly compare the content of the initial dictionary with
    the result of the API endpoint. Remember that the API returns JSON content, and
    we can easily convert JSON data into simple Python structures, so starting from
    a dictionary will come in handy.**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一部分包含一些导入，并从字典中设置一个房间。这样我们就可以稍后直接比较初始字典的内容与 API 端点结果。记住，API 返回 JSON 内容，我们可以轻松地将
    JSON 数据转换为简单的 Python 结构，因此从字典开始会很有用。**'
- en: '**`tests/rest/test_room.py`**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**`tests/rest/test_room.py`**'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**This is the only test that we have for the time being. During the whole test,
    we mock the use case, as we are not interested in running it, as it has been already
    tested elsewhere. We are however interested in checking the arguments passed to
    the use case, and a mock can provide this information. The test receives the mock
    from the decorator `patch` and the fixture `client`, which is one of the fixtures
    provided by `pytest-flask`. The fixture automatically loads `app`, which we defined
    in `conftest.py`, and is an object that simulates an HTTP client that can access
    the API endpoints and store the responses of the server.**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**目前我们只有一个测试。在整个测试过程中，我们模拟了用例的使用，因为我们不感兴趣运行它，因为它已经在其他地方测试过了。然而，我们确实对检查传递给用例的参数感兴趣，而模拟可以提供这些信息。测试从装饰器`patch`和固定装置`client`接收模拟，这是`pytest-flask`提供的固定装置之一。固定装置自动加载`app`，我们在`conftest.py`中定义了它，它是一个模拟HTTP客户端的对象，可以访问API端点并存储服务器的响应。**'
- en: '**`tests/rest/test_room.py`**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**`tests/rest/test_room.py`**'
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**The first line initialises the mock use case, instructing it to return the
    fixed `rooms` variable that we created previously. The central part of the test
    is the line where we `get` the API endpoint, which sends an HTTP GET request and
    collects the server''s response.**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一行初始化了模拟用例，指示它返回我们之前创建的固定`rooms`变量。测试的核心部分是获取API端点的行，它发送一个HTTP GET请求并收集服务器的响应。**'
- en: '**After this, we check that the data contained in the response is a JSON that
    contains the data in the structure `room_dict`, that the method use_case has been
    called, that the HTTP response status code is 200, and last that the server sends
    the correct MIME type back.**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**之后，我们检查响应中包含的数据是否是包含`room_dict`结构数据的JSON，使用_case方法已被调用，HTTP响应状态码是200，最后服务器发送正确的MIME类型。**'
- en: '**It''s time to write the endpoint, where we will finally see all the pieces
    of the architecture working together, as they did in the little CLI program that
    we wrote previously. Let me show you a template for the minimal Flask endpoint
    we can create**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在是时候编写端点了，我们将最终看到所有架构的各个部分协同工作，就像我们在之前写的那个小CLI程序中所做的那样。让我向您展示我们可以创建的最小Flask端点的模板**'
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**As you can see the structure is really simple. Apart from setting the blueprint,
    which is the way Flask registers endpoints, we create a simple function that runs
    the endpoint, and we decorate it assigning the enpoint `/rooms` that serves `GET`
    requests. The function will run some logic and eventually return a `Response`
    that contains JSON data, the correct MIME type, and an HTTP status that represents
    the success or failure of the logic.**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**如您所见，结构非常简单。除了设置蓝图，这是Flask注册端点的方式，我们创建了一个简单的函数来运行端点，并给它装饰了`/rooms`端点，用于处理`GET`请求。该函数将运行一些逻辑，并最终返回一个包含JSON数据、正确的MIME类型和表示逻辑成功或失败的HTTP状态码的`Response`对象。**'
- en: '**The above template becomes the following code**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**上面的模板变成了以下代码**'
- en: '**`application/rest/room.py`**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**`application/rest/room.py`**'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***Source code'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '***源代码'
- en: '[https://github.com/pycabook/rentomatic/tree/ed2-c04-s03](https://github.com/pycabook/rentomatic/tree/ed2-c04-s03)***'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pycabook/rentomatic/tree/ed2-c04-s03](https://github.com/pycabook/rentomatic/tree/ed2-c04-s03)*'
- en: '***Please note that I initialised the memory storage with the same list used
    for the script `cli.py`. Again, the need of initialising the storage with data
    (even with an empty list) is due to the limitations of the storage `MemRepo`.
    The code that runs the use case is***'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '***请注意，我使用与脚本`cli.py`相同的列表初始化了内存存储。需要使用数据（即使是空列表）初始化存储的原因是由于存储`MemRepo`的限制。运行用例的代码是***'
- en: '***`application/rest/room.py`***'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '***`application/rest/room.py`***'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***which is exactly the same code that we used in the command-line interface.
    The last part of the code creates a proper HTTP response, serializing the result
    of the use case using `RoomJsonEncoder`, and setting the HTTP status to 200 (success)***'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '***这与我们在命令行界面中使用的代码完全相同。代码的最后部分创建了一个适当的HTTP响应，使用`RoomJsonEncoder`序列化用例的结果，并将HTTP状态设置为200（成功）***'
- en: '***`application/rest/room.py`***'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '***`application/rest/room.py`***'
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***This shows you the power of the clean architecture in a nutshell. Writing
    a CLI interface or a Web service is different only in the presentation layer,
    not in the logic, which is the same, as it is contained in the use case.***'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '***这简要展示了干净架构的力量。编写CLI界面或Web服务不同之处仅在于表示层，而不是逻辑，因为逻辑是相同的，它包含在用例中。***'
- en: '***Now that we defined the endpoint, we can finalise the configuration of the
    webserver, so that we can access the endpoint with a browser. This is not strictly
    part of the clean architecture, but as I did with the CLI interface I want you
    to see the final result, to get the whole picture and also to enjoy the effort
    you put in following the whole discussion up to this point.***'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '***现在我们已经定义了端点，我们可以最终确定网络服务器的配置，这样我们就可以用浏览器访问端点了。这虽然不是干净的架构的严格组成部分，但正如我在 CLI
    接口中所做的那样，我想让你看到最终结果，以获得完整的画面，并且享受你到目前为止所付出的努力。***'
- en: '***WSGI***'
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '***WSGI***'
- en: '***Python web applications expose a common interface called [Web Server Gateway
    Interface](https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface) or WSGI.
    So to run the Flask development web server, we have to define a `wsgi.py` file
    in the main folder of the project, i.e. in the same directory of the file `cli.py`***'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '***Python 网络应用暴露了一个称为 [Web 服务器网关接口](https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface)
    或 WSGI 的通用接口。因此，要运行 Flask 开发网络服务器，我们必须在项目的根目录中定义一个 `wsgi.py` 文件，即在 `cli.py` 文件所在的同一目录中。***'
- en: '***`wsgi.py`***'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '***`wsgi.py`***'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '****Source code'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '****源代码'
- en: '[https://github.com/pycabook/rentomatic/tree/ed2-c04-s04](https://github.com/pycabook/rentomatic/tree/ed2-c04-s04)****'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pycabook/rentomatic/tree/ed2-c04-s04](https://github.com/pycabook/rentomatic/tree/ed2-c04-s04)****'
- en: '***When you run the Flask Command Line Interface ([documentation](http://flask.pocoo.org/docs/1.0/cli/)),
    it automatically looks for a file named `wsgi.py` and loads it, expecting it to
    contain a variable named `app` that is an instance of the object `Flask`. As the
    function `create_app` is a factory we just need to execute it.***'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '***当你运行 Flask 命令行界面 ([文档](http://flask.pocoo.org/docs/1.0/cli/)) 时，它会自动查找一个名为
    `wsgi.py` 的文件并加载它，期望它包含一个名为 `app` 的变量，该变量是 `Flask` 对象的一个实例。由于 `create_app` 是一个工厂函数，我们只需要执行它。***'
- en: '***At this point, you can execute `FLASK_CONFIG="development" flask run` in
    the directory that contains this file and you should see a nice message like***'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '***此时，你可以在包含此文件的目录中执行 `FLASK_CONFIG="development" flask run`，你应该会看到一个类似的消息：***'
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***At this point, you can point your browser to [http://127.0.0.1:5000/rooms](http://127.0.0.1:5000/rooms)
    and enjoy the JSON data returned by the first endpoint of your web application.***'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '***此时，你可以将浏览器指向 [http://127.0.0.1:5000/rooms](http://127.0.0.1:5000/rooms)，并享受你的网络应用第一个端点返回的
    JSON 数据。***'
- en: '* * *'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '***I hope you can now appreciate the power of the layered architecture that
    we created. We definitely wrote a lot of code to "just" print out a list of models,
    but the code we wrote is a skeleton that can easily be extended and modified.
    It is also fully tested, which is a part of the implementation that many software
    projects struggle with.***'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '***我希望你现在可以欣赏我们所创建的分层架构的力量。我们确实编写了很多代码来“仅仅”打印出模型列表，但我们编写的代码是一个可以轻松扩展和修改的骨架。它也是完全经过测试的，这是许多软件项目在实施过程中都难以解决的问题。***'
- en: '***The use case I presented is purposely very simple. It doesn''t require any
    input and it cannot return error conditions, so the code we wrote completely ignored
    input validation and error management. These topics are however extremely important,
    so we need to discuss how a clean architecture can deal with them.***'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '***我展示的使用案例故意非常简单。它不需要任何输入，也不能返回错误条件，所以我们编写的代码完全忽略了输入验证和错误管理。然而，这些主题却极为重要，因此我们需要讨论一个干净的架构如何处理这些问题。***'
- en: '***[1](#fr--3563573)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '***[1](#fr--3563573)'
- en: We could, in theory, create a pure component that receives parameters and returns
    a JSON object, and then wrap this component into an endpoint. This way, the component
    would be strictly part of the internal system and the endpoint of the external
    one, but both would have to be created in the Gateway layer. This looks overkill,
    at least for the simple example we are discussing here, so I will keep them together
    and test them as a single component.***
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，我们可以创建一个纯组件，该组件接收参数并返回一个 JSON 对象，然后将其封装到端点中。这样，组件将严格属于内部系统的一部分，而端点属于外部系统，但两者都必须在网关层创建。这看起来有些过度设计，至少对于我们正在讨论的简单示例来说是这样，所以我会将它们放在一起，作为一个单一组件进行测试。***
